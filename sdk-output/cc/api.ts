/* tslint:disable */
/* eslint-disable */
/**
 * IdentityNow cc (private) APIs
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap  } from './base';

/**
 * 
 * @export
 * @interface CreateApplicationRequestCC
 */
export interface CreateApplicationRequestCC {
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequestCC
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequestCC
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateConnectorRequestCC
 */
export interface CreateConnectorRequestCC {
    /**
     * 
     * @type {string}
     * @memberof CreateConnectorRequestCC
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectorRequestCC
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectorRequestCC
     */
    'className'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateConnectorRequestCC
     */
    'directConnect'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectorRequestCC
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetApplication200ResponseCC
 */
export interface GetApplication200ResponseCC {
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'appId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'serviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'serviceAppId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'appCenterEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'provisionRequestEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'controlType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'mobile'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'privateApp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'scriptName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'icon'?: string;
    /**
     * 
     * @type {ListApplications200ResponseInnerHealthCC}
     * @memberof GetApplication200ResponseCC
     */
    'health'?: ListApplications200ResponseInnerHealthCC;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'enableSso'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'ssoMethod'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'hasLinks'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'hasAutomations'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetApplication200ResponseCC
     */
    'stepUpAuthData'?: object;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'stepUpAuthType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'usageAnalytics'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'usageCertRequired'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetApplication200ResponseCC
     */
    'usageCertText'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'launchpadEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'passwordManaged'?: boolean;
    /**
     * 
     * @type {ListApplications200ResponseInnerOwnerCC}
     * @memberof GetApplication200ResponseCC
     */
    'owner'?: ListApplications200ResponseInnerOwnerCC;
    /**
     * 
     * @type {number}
     * @memberof GetApplication200ResponseCC
     */
    'dateCreated'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetApplication200ResponseCC
     */
    'lastUpdated'?: number;
    /**
     * 
     * @type {object}
     * @memberof GetApplication200ResponseCC
     */
    'defaultAccessProfile'?: object;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'service'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'selectedSsoMethod'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetApplication200ResponseCC
     */
    'supportedSsoMethods'?: number;
    /**
     * 
     * @type {object}
     * @memberof GetApplication200ResponseCC
     */
    'offNetworkBlockedRoles'?: object;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'supportedOffNetwork'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetApplication200ResponseCC
     */
    'accountServiceId'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetApplication200ResponseCC
     */
    'launcherCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'accountServiceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'accountServiceExternalId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'accountServiceMatchAllAccounts'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'externalId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'accountServiceUseForPasswordManagement'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'accountServicePolicyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'accountServicePolicyName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200ResponseCC
     */
    'requireStrongAuthn'?: boolean;
    /**
     * 
     * @type {Array<ListApplications200ResponseInnerAccountServicePoliciesInnerCC>}
     * @memberof GetApplication200ResponseCC
     */
    'accountServicePolicies'?: Array<ListApplications200ResponseInnerAccountServicePoliciesInnerCC>;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200ResponseCC
     */
    'xsdVersion'?: string;
    /**
     * 
     * @type {Array<ListApplications200ResponseInnerAppProfilesInnerCC>}
     * @memberof GetApplication200ResponseCC
     */
    'appProfiles'?: Array<ListApplications200ResponseInnerAppProfilesInnerCC>;
    /**
     * 
     * @type {number}
     * @memberof GetApplication200ResponseCC
     */
    'passwordServiceId'?: number;
    /**
     * 
     * @type {object}
     * @memberof GetApplication200ResponseCC
     */
    'accessProfileIds'?: object;
}
/**
 * 
 * @export
 * @interface GetIdentity200ResponseAuthCC
 */
export interface GetIdentity200ResponseAuthCC {
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseAuthCC
     */
    'service'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseAuthCC
     */
    'encryption'?: string;
}
/**
 * 
 * @export
 * @interface GetIdentity200ResponseCC
 */
export interface GetIdentity200ResponseCC {
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseCC
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseCC
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseCC
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseCC
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseCC
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseCC
     */
    'uuid'?: string;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseCC
     */
    'encryptionKey'?: object;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseCC
     */
    'encryptionCheck'?: object;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseCC
     */
    'status'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseCC
     */
    'pending'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseCC
     */
    'passwordResetSinceLastLogin'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseCC
     */
    'usageCertAttested'?: object;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseCC
     */
    'userFlags'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseCC
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseCC
     */
    'altAuthVia'?: string;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseCC
     */
    'altAuthViaIntegrationData'?: object;
    /**
     * 
     * @type {number}
     * @memberof GetIdentity200ResponseCC
     */
    'kbaAnswers'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseCC
     */
    'disablePasswordReset'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseCC
     */
    'ptaSourceId'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseCC
     */
    'supportsPasswordPush'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseCC
     */
    'attributes'?: object;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseCC
     */
    'externalId'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof GetIdentity200ResponseCC
     */
    'role'?: Array<object>;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseCC
     */
    'phone'?: object;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseCC
     */
    'email'?: string;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseCC
     */
    'personalEmail'?: object;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseCC
     */
    'employeeNumber'?: object;
    /**
     * 
     * @type {number}
     * @memberof GetIdentity200ResponseCC
     */
    'riskScore'?: number;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseCC
     */
    'featureFlags'?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetIdentity200ResponseCC
     */
    'feature'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseCC
     */
    'orgEncryptionKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseCC
     */
    'orgEncryptionKeyId'?: string;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseCC
     */
    'meta'?: object;
    /**
     * 
     * @type {GetIdentity200ResponseOrgCC}
     * @memberof GetIdentity200ResponseCC
     */
    'org'?: GetIdentity200ResponseOrgCC;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseCC
     */
    'stepUpAuth'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseCC
     */
    'bxInstallPrompted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseCC
     */
    'federatedLogin'?: boolean;
    /**
     * 
     * @type {GetIdentity200ResponseAuthCC}
     * @memberof GetIdentity200ResponseCC
     */
    'auth'?: GetIdentity200ResponseAuthCC;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseCC
     */
    'onNetwork'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseCC
     */
    'onTrustedGeo'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseCC
     */
    'loginUrl'?: string;
}
/**
 * 
 * @export
 * @interface GetIdentity200ResponseOrgCC
 */
export interface GetIdentity200ResponseOrgCC {
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'scriptName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'mode'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'numQuestions'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'maxRegisteredUsers'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'pod'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'pwdResetPersonalPhone'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'pwdResetPersonalEmail'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'pwdResetKba'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'pwdResetEmail'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'pwdResetDuo'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'pwdResetPhoneMask'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'authErrorText'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'strongAuthKba'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'strongAuthPersonalPhone'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'strongAuthPersonalEmail'?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'integrations'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'productName'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'kbaReqForAuthn'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'kbaReqAnswers'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'lockoutAttemptThreshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'lockoutTimeMinutes'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'usageCertRequired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'adminStrongAuthRequired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'enableExternalPasswordChange'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'enablePasswordReplay'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'enableAutomaticPasswordReplay'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'notifyAuthenticationSettingChange'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'netmasks'?: object;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'countryCodes'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'whiteList'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'usernameEmptyText'?: object;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'usernameLabel'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'enableAutomationGeneration'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'emailTestMode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'emailTestAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'orgType'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'passwordReplayState'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'systemNotificationConfig'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'redirectPatterns'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'maxClusterDebugHours'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'brandName'?: string;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'logo'?: object;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'emailFromAddress'?: object;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'standardLogoUrl'?: object;
    /**
     * 
     * @type {object}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'narrowLogoUrl'?: object;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'actionButtonColor'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'activeLinkColor'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIdentity200ResponseOrgCC
     */
    'navigationColor'?: string;
}
/**
 * 
 * @export
 * @interface ImportConnectorConfigRequestCC
 */
export interface ImportConnectorConfigRequestCC {
    /**
     * This is the connector config zip bundle which gets uploaded.
     * @type {File}
     * @memberof ImportConnectorConfigRequestCC
     */
    'file'?: File;
}
/**
 * 
 * @export
 * @interface ListAccounts200ResponseInnerCC
 */
export interface ListAccounts200ResponseInnerCC {
    /**
     * 
     * @type {string}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'username'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'passwordRequired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'passwordProvided'?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'apps'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'ssoMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'idEncryption'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'passwordEncryption'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'lastPasswdChange'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'serviceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'dateDisabled'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'accountServiceId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'serviceId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'pendingPasswordRequestId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'passwordChangeStatus'?: string;
    /**
     * 
     * @type {ListAccounts200ResponseInnerPasswordChangeResultCC}
     * @memberof ListAccounts200ResponseInnerCC
     */
    'passwordChangeResult'?: ListAccounts200ResponseInnerPasswordChangeResultCC;
}
/**
 * 
 * @export
 * @interface ListAccounts200ResponseInnerPasswordChangeResultCC
 */
export interface ListAccounts200ResponseInnerPasswordChangeResultCC {
    /**
     * 
     * @type {string}
     * @memberof ListAccounts200ResponseInnerPasswordChangeResultCC
     */
    'completionStatus'?: string;
}
/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerAccountServicePoliciesInnerCC
 */
export interface ListApplications200ResponseInnerAccountServicePoliciesInnerCC {
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerAccountServicePoliciesInnerCC
     */
    'policyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerAccountServicePoliciesInnerCC
     */
    'policyName'?: string;
    /**
     * 
     * @type {object}
     * @memberof ListApplications200ResponseInnerAccountServicePoliciesInnerCC
     */
    'selectors'?: object;
}
/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerAppProfilesInnerCC
 */
export interface ListApplications200ResponseInnerAppProfilesInnerCC {
    /**
     * 
     * @type {number}
     * @memberof ListApplications200ResponseInnerAppProfilesInnerCC
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerAppProfilesInnerCC
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerAppProfilesInnerCC
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerAppProfilesInnerCC
     */
    'dateCreated'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerAppProfilesInnerCC
     */
    'xsdVersion'?: string;
}
/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerCC
 */
export interface ListApplications200ResponseInnerCC {
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'appId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'serviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'serviceAppId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'appCenterEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'provisionRequestEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'controlType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'mobile'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'privateApp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'scriptName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'icon'?: string;
    /**
     * 
     * @type {ListApplications200ResponseInnerHealthCC}
     * @memberof ListApplications200ResponseInnerCC
     */
    'health'?: ListApplications200ResponseInnerHealthCC;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'enableSso'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'ssoMethod'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'hasLinks'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'hasAutomations'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ListApplications200ResponseInnerCC
     */
    'stepUpAuthData'?: object;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'stepUpAuthType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'usageAnalytics'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'usageCertRequired'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ListApplications200ResponseInnerCC
     */
    'usageCertText'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'launchpadEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'passwordManaged'?: boolean;
    /**
     * 
     * @type {ListApplications200ResponseInnerOwnerCC}
     * @memberof ListApplications200ResponseInnerCC
     */
    'owner'?: ListApplications200ResponseInnerOwnerCC;
    /**
     * 
     * @type {number}
     * @memberof ListApplications200ResponseInnerCC
     */
    'dateCreated'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListApplications200ResponseInnerCC
     */
    'lastUpdated'?: number;
    /**
     * 
     * @type {object}
     * @memberof ListApplications200ResponseInnerCC
     */
    'defaultAccessProfile'?: object;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'service'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'selectedSsoMethod'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListApplications200ResponseInnerCC
     */
    'supportedSsoMethods'?: number;
    /**
     * 
     * @type {object}
     * @memberof ListApplications200ResponseInnerCC
     */
    'offNetworkBlockedRoles'?: object;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'supportedOffNetwork'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListApplications200ResponseInnerCC
     */
    'accountServiceId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListApplications200ResponseInnerCC
     */
    'launcherCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'accountServiceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'accountServiceExternalId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'accountServiceMatchAllAccounts'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'externalId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'accountServiceUseForPasswordManagement'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'accountServicePolicyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'accountServicePolicyName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCC
     */
    'requireStrongAuthn'?: boolean;
    /**
     * 
     * @type {Array<ListApplications200ResponseInnerAccountServicePoliciesInnerCC>}
     * @memberof ListApplications200ResponseInnerCC
     */
    'accountServicePolicies'?: Array<ListApplications200ResponseInnerAccountServicePoliciesInnerCC>;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCC
     */
    'xsdVersion'?: string;
    /**
     * 
     * @type {Array<ListApplications200ResponseInnerAppProfilesInnerCC>}
     * @memberof ListApplications200ResponseInnerCC
     */
    'appProfiles'?: Array<ListApplications200ResponseInnerAppProfilesInnerCC>;
    /**
     * 
     * @type {number}
     * @memberof ListApplications200ResponseInnerCC
     */
    'passwordServiceId'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListApplications200ResponseInnerCC
     */
    'accessProfileIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerHealthCC
 */
export interface ListApplications200ResponseInnerHealthCC {
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerHealthCC
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerHealthCC
     */
    'lastChanged'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListApplications200ResponseInnerHealthCC
     */
    'since'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerHealthCC
     */
    'healthy'?: boolean;
}
/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerOwnerCC
 */
export interface ListApplications200ResponseInnerOwnerCC {
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerOwnerCC
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerOwnerCC
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ListConnectors200ResponseCC
 */
export interface ListConnectors200ResponseCC {
    /**
     * 
     * @type {number}
     * @memberof ListConnectors200ResponseCC
     */
    'total'?: number;
    /**
     * 
     * @type {Array<ListConnectors200ResponseItemsInnerCC>}
     * @memberof ListConnectors200ResponseCC
     */
    'items'?: Array<ListConnectors200ResponseItemsInnerCC>;
}
/**
 * 
 * @export
 * @interface ListConnectors200ResponseItemsInnerCC
 */
export interface ListConnectors200ResponseItemsInnerCC {
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'applicationXml'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'className'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'connectorMetadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'correlationConfigXml'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'directConnect'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'fileUpload'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    's3Location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'scriptName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'sourceConfig'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'sourceConfigFrom'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'sourceConfigXml'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'status'?: string;
    /**
     * 
     * @type {object}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'translationProperties'?: object;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'type'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof ListConnectors200ResponseItemsInnerCC
     */
    'uploadedFiles'?: Array<object>;
}
/**
 * 
 * @export
 * @interface LoadAccountsRequestCC
 */
export interface LoadAccountsRequestCC {
    /**
     * 
     * @type {boolean}
     * @memberof LoadAccountsRequestCC
     */
    'disableOptimization'?: boolean;
    /**
     * 
     * @type {File}
     * @memberof LoadAccountsRequestCC
     */
    'file'?: File;
}
/**
 * 
 * @export
 * @interface LoadEntitlementsRequestCC
 */
export interface LoadEntitlementsRequestCC {
    /**
     * 
     * @type {File}
     * @memberof LoadEntitlementsRequestCC
     */
    'file'?: File;
}
/**
 * 
 * @export
 * @interface RefreshIdentitiesRequestCC
 */
export interface RefreshIdentitiesRequestCC {
    /**
     * Defines the identity or identities which this refresh applies to. The filter must use searchable identity attributes. If the filter cannot be understood or parsed, all identities will be refreshed. 
     * @type {string}
     * @memberof RefreshIdentitiesRequestCC
     */
    'filter'?: string;
    /**
     * 
     * @type {RefreshIdentitiesRequestRefreshArgsCC}
     * @memberof RefreshIdentitiesRequestCC
     */
    'refreshArgs'?: RefreshIdentitiesRequestRefreshArgsCC;
}
/**
 * 
 * @export
 * @interface RefreshIdentitiesRequestRefreshArgsCC
 */
export interface RefreshIdentitiesRequestRefreshArgsCC {
    /**
     * This will refresh entitlement, role, and access profile calculations.
     * @type {boolean}
     * @memberof RefreshIdentitiesRequestRefreshArgsCC
     */
    'correlateEntitlements'?: boolean;
    /**
     * This will calculate identity attributes.
     * @type {boolean}
     * @memberof RefreshIdentitiesRequestRefreshArgsCC
     */
    'promoteAttributes'?: boolean;
    /**
     * This recalculates manager correlation and manager status. Note: This is computationally expensive to run. 
     * @type {boolean}
     * @memberof RefreshIdentitiesRequestRefreshArgsCC
     */
    'refreshManagerStatus'?: boolean;
    /**
     * Enables attribute synchronization.
     * @type {boolean}
     * @memberof RefreshIdentitiesRequestRefreshArgsCC
     */
    'synchronizeAttributes'?: boolean;
    /**
     * Option that will enable deletion of an identity objects if there are no account objects. Note: This is not typically used in IdentityNow, except by guidance from SailPoint. 
     * @type {boolean}
     * @memberof RefreshIdentitiesRequestRefreshArgsCC
     */
    'pruneIdentities'?: boolean;
    /**
     * Enables provisioning of role assignments with entitlements that are not currently fulfilled.
     * @type {boolean}
     * @memberof RefreshIdentitiesRequestRefreshArgsCC
     */
    'provision'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateUserPermissionsRequestCC
 */
export interface UpdateUserPermissionsRequestCC {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPermissionsRequestCC
     */
    'ids'?: string;
    /**
     * Indicates if user should be an IDN Admin.  \"0\" for false, \"1\" for true.
     * @type {string}
     * @memberof UpdateUserPermissionsRequestCC
     */
    'isAdmin'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPermissionsRequestCC
     */
    'adminType'?: UpdateUserPermissionsRequestCCAdminTypeCC;
}

export const UpdateUserPermissionsRequestCCAdminTypeCC = {
    Admin: 'ADMIN',
    CertAdmin: 'CERT_ADMIN',
    Helpdesk: 'HELPDESK',
    ReportAdmin: 'REPORT_ADMIN',
    RoleAdmin: 'ROLE_ADMIN',
    RoleSubadmin: 'ROLE_SUBADMIN',
    SourceAdmin: 'SOURCE_ADMIN',
    SourceSubadmin: 'SOURCE_SUBADMIN'
} as const;

export type UpdateUserPermissionsRequestCCAdminTypeCC = typeof UpdateUserPermissionsRequestCCAdminTypeCC[keyof typeof UpdateUserPermissionsRequestCCAdminTypeCC];


/**
 * AccountsCCApi - axios parameter creator
 * @export
 */
export const AccountsCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Accounts
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/account/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Account
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        removeAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeAccount', 'id', id)
            const localVarPath = `/cc/api/account/remove/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsCCApi - functional programming interface
 * @export
 */
export const AccountsCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsCCApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Accounts
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListAccounts200ResponseInnerCC>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsCCApi.listAccounts']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Remove Account
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async removeAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAccount(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountsCCApi.removeAccount']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AccountsCCApi - factory interface
 * @export
 */
export const AccountsCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsCCApiFp(configuration)
    return {
        /**
         * 
         * @summary List Accounts
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listAccounts(options?: AxiosRequestConfig): AxiosPromise<Array<ListAccounts200ResponseInnerCC>> {
            return localVarFp.listAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Account
         * @param {AccountsCCApiRemoveAccountRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        removeAccount(requestParameters: AccountsCCApiRemoveAccountRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeAccount(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for removeAccount operation in AccountsCCApi.
 * @export
 * @interface AccountsCCApiRemoveAccountRequest
 */
export interface AccountsCCApiRemoveAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsCCApiRemoveAccount
     */
    readonly id: string
}

/**
 * AccountsCCApi - object-oriented interface
 * @export
 * @class AccountsCCApi
 * @extends {BaseAPI}
 */
export class AccountsCCApi extends BaseAPI {
    /**
     * 
     * @summary List Accounts
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsCCApi
     */
    public listAccounts(axiosOptions?: AxiosRequestConfig) {
        return AccountsCCApiFp(this.configuration).listAccounts(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Account
     * @param {AccountsCCApiRemoveAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsCCApi
     */
    public removeAccount(requestParameters: AccountsCCApiRemoveAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsCCApiFp(this.configuration).removeAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationsCCApi - axios parameter creator
 * @export
 */
export const ApplicationsCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Application
         * @param {CreateApplicationRequestCC} [createApplicationRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (createApplicationRequestCC?: CreateApplicationRequestCC, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/app/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationRequestCC, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Application
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApplication', 'id', id)
            const localVarPath = `/cc/api/app/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Application
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApplication', 'id', id)
            const localVarPath = `/cc/api/app/get/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Access Profiles for Application
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationAccessProfiles: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApplicationAccessProfiles', 'id', id)
            const localVarPath = `/cc/api/app/getAccessProfiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Applications
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/app/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Application
         * @param {string} id 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: async (id: string, requestBody?: { [key: string]: any; }, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateApplication', 'id', id)
            const localVarPath = `/cc/api/app/update/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsCCApi - functional programming interface
 * @export
 */
export const ApplicationsCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsCCApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Application
         * @param {CreateApplicationRequestCC} [createApplicationRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(createApplicationRequestCC?: CreateApplicationRequestCC, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(createApplicationRequestCC, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ApplicationsCCApi.createApplication']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Application
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ApplicationsCCApi.deleteApplication']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Application
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApplication200ResponseCC>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ApplicationsCCApi.getApplication']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Access Profiles for Application
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationAccessProfiles(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationAccessProfiles(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ApplicationsCCApi.getApplicationAccessProfiles']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List Applications
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListApplications200ResponseInnerCC>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ApplicationsCCApi.listApplications']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update Application
         * @param {string} id 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplication(id: string, requestBody?: { [key: string]: any; }, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(id, requestBody, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ApplicationsCCApi.updateApplication']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ApplicationsCCApi - factory interface
 * @export
 */
export const ApplicationsCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsCCApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Application
         * @param {ApplicationsCCApiCreateApplicationRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createApplication(requestParameters: ApplicationsCCApiCreateApplicationRequest = {}, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.createApplication(requestParameters.createApplicationRequestCC, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Application
         * @param {ApplicationsCCApiDeleteApplicationRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteApplication(requestParameters: ApplicationsCCApiDeleteApplicationRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApplication(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Application
         * @param {ApplicationsCCApiGetApplicationRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getApplication(requestParameters: ApplicationsCCApiGetApplicationRequest, options?: AxiosRequestConfig): AxiosPromise<GetApplication200ResponseCC> {
            return localVarFp.getApplication(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Access Profiles for Application
         * @param {ApplicationsCCApiGetApplicationAccessProfilesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getApplicationAccessProfiles(requestParameters: ApplicationsCCApiGetApplicationAccessProfilesRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getApplicationAccessProfiles(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Applications
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listApplications(options?: AxiosRequestConfig): AxiosPromise<Array<ListApplications200ResponseInnerCC>> {
            return localVarFp.listApplications(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Application
         * @param {ApplicationsCCApiUpdateApplicationRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateApplication(requestParameters: ApplicationsCCApiUpdateApplicationRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.updateApplication(requestParameters.id, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createApplication operation in ApplicationsCCApi.
 * @export
 * @interface ApplicationsCCApiCreateApplicationRequest
 */
export interface ApplicationsCCApiCreateApplicationRequest {
    /**
     * 
     * @type {CreateApplicationRequestCC}
     * @memberof ApplicationsCCApiCreateApplication
     */
    readonly createApplicationRequestCC?: CreateApplicationRequestCC
}

/**
 * Request parameters for deleteApplication operation in ApplicationsCCApi.
 * @export
 * @interface ApplicationsCCApiDeleteApplicationRequest
 */
export interface ApplicationsCCApiDeleteApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof ApplicationsCCApiDeleteApplication
     */
    readonly id: string
}

/**
 * Request parameters for getApplication operation in ApplicationsCCApi.
 * @export
 * @interface ApplicationsCCApiGetApplicationRequest
 */
export interface ApplicationsCCApiGetApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof ApplicationsCCApiGetApplication
     */
    readonly id: string
}

/**
 * Request parameters for getApplicationAccessProfiles operation in ApplicationsCCApi.
 * @export
 * @interface ApplicationsCCApiGetApplicationAccessProfilesRequest
 */
export interface ApplicationsCCApiGetApplicationAccessProfilesRequest {
    /**
     * 
     * @type {string}
     * @memberof ApplicationsCCApiGetApplicationAccessProfiles
     */
    readonly id: string
}

/**
 * Request parameters for updateApplication operation in ApplicationsCCApi.
 * @export
 * @interface ApplicationsCCApiUpdateApplicationRequest
 */
export interface ApplicationsCCApiUpdateApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof ApplicationsCCApiUpdateApplication
     */
    readonly id: string

    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ApplicationsCCApiUpdateApplication
     */
    readonly requestBody?: { [key: string]: any; }
}

/**
 * ApplicationsCCApi - object-oriented interface
 * @export
 * @class ApplicationsCCApi
 * @extends {BaseAPI}
 */
export class ApplicationsCCApi extends BaseAPI {
    /**
     * 
     * @summary Create Application
     * @param {ApplicationsCCApiCreateApplicationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsCCApi
     */
    public createApplication(requestParameters: ApplicationsCCApiCreateApplicationRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ApplicationsCCApiFp(this.configuration).createApplication(requestParameters.createApplicationRequestCC, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Application
     * @param {ApplicationsCCApiDeleteApplicationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsCCApi
     */
    public deleteApplication(requestParameters: ApplicationsCCApiDeleteApplicationRequest, axiosOptions?: AxiosRequestConfig) {
        return ApplicationsCCApiFp(this.configuration).deleteApplication(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Application
     * @param {ApplicationsCCApiGetApplicationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsCCApi
     */
    public getApplication(requestParameters: ApplicationsCCApiGetApplicationRequest, axiosOptions?: AxiosRequestConfig) {
        return ApplicationsCCApiFp(this.configuration).getApplication(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Access Profiles for Application
     * @param {ApplicationsCCApiGetApplicationAccessProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsCCApi
     */
    public getApplicationAccessProfiles(requestParameters: ApplicationsCCApiGetApplicationAccessProfilesRequest, axiosOptions?: AxiosRequestConfig) {
        return ApplicationsCCApiFp(this.configuration).getApplicationAccessProfiles(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Applications
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsCCApi
     */
    public listApplications(axiosOptions?: AxiosRequestConfig) {
        return ApplicationsCCApiFp(this.configuration).listApplications(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Application
     * @param {ApplicationsCCApiUpdateApplicationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsCCApi
     */
    public updateApplication(requestParameters: ApplicationsCCApiUpdateApplicationRequest, axiosOptions?: AxiosRequestConfig) {
        return ApplicationsCCApiFp(this.configuration).updateApplication(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConnectorsCCApi - axios parameter creator
 * @export
 */
export const ConnectorsCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Connector
         * @param {string} [contentType] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [className] 
         * @param {boolean} [directConnect] 
         * @param {string} [status] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createConnector: async (contentType?: string, name?: string, description?: string, className?: string, directConnect?: boolean, status?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/connector/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.set('description', description as any);
            }
    
            if (className !== undefined) { 
                localVarFormParams.set('className', className as any);
            }
    
            if (directConnect !== undefined) { 
                localVarFormParams.set('directConnect', directConnect as any);
            }
    
            if (status !== undefined) { 
                localVarFormParams.set('status', status as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Connector
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnector: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteConnector', 'id', id)
            const localVarPath = `/cc/api/connector/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export Connector Config
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportConnectorConfig: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportConnectorConfig', 'id', id)
            const localVarPath = `/cc/api/connector/export/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Connector Config
         * @param {string} id 
         * @param {File} [file] This is the connector config zip bundle which gets uploaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importConnectorConfig: async (id: string, file?: File, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importConnectorConfig', 'id', id)
            const localVarPath = `/cc/api/connector/import/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Connectors
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listConnectors: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/connector/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorsCCApi - functional programming interface
 * @export
 */
export const ConnectorsCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorsCCApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Connector
         * @param {string} [contentType] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [className] 
         * @param {boolean} [directConnect] 
         * @param {string} [status] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createConnector(contentType?: string, name?: string, description?: string, className?: string, directConnect?: boolean, status?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnector(contentType, name, description, className, directConnect, status, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectorsCCApi.createConnector']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Connector
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnector(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnector(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectorsCCApi.deleteConnector']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Export Connector Config
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportConnectorConfig(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportConnectorConfig(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectorsCCApi.exportConnectorConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Import Connector Config
         * @param {string} id 
         * @param {File} [file] This is the connector config zip bundle which gets uploaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importConnectorConfig(id: string, file?: File, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importConnectorConfig(id, file, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectorsCCApi.importConnectorConfig']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List Connectors
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectors(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListConnectors200ResponseCC>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectors(axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectorsCCApi.listConnectors']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ConnectorsCCApi - factory interface
 * @export
 */
export const ConnectorsCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorsCCApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Connector
         * @param {ConnectorsCCApiCreateConnectorRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        createConnector(requestParameters: ConnectorsCCApiCreateConnectorRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createConnector(requestParameters.contentType, requestParameters.name, requestParameters.description, requestParameters.className, requestParameters.directConnect, requestParameters.status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Connector
         * @param {ConnectorsCCApiDeleteConnectorRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        deleteConnector(requestParameters: ConnectorsCCApiDeleteConnectorRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteConnector(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export Connector Config
         * @param {ConnectorsCCApiExportConnectorConfigRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        exportConnectorConfig(requestParameters: ConnectorsCCApiExportConnectorConfigRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.exportConnectorConfig(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import Connector Config
         * @param {ConnectorsCCApiImportConnectorConfigRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        importConnectorConfig(requestParameters: ConnectorsCCApiImportConnectorConfigRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.importConnectorConfig(requestParameters.id, requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Connectors
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        listConnectors(options?: AxiosRequestConfig): AxiosPromise<ListConnectors200ResponseCC> {
            return localVarFp.listConnectors(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createConnector operation in ConnectorsCCApi.
 * @export
 * @interface ConnectorsCCApiCreateConnectorRequest
 */
export interface ConnectorsCCApiCreateConnectorRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectorsCCApiCreateConnector
     */
    readonly contentType?: string

    /**
     * 
     * @type {string}
     * @memberof ConnectorsCCApiCreateConnector
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof ConnectorsCCApiCreateConnector
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof ConnectorsCCApiCreateConnector
     */
    readonly className?: string

    /**
     * 
     * @type {boolean}
     * @memberof ConnectorsCCApiCreateConnector
     */
    readonly directConnect?: boolean

    /**
     * 
     * @type {string}
     * @memberof ConnectorsCCApiCreateConnector
     */
    readonly status?: string
}

/**
 * Request parameters for deleteConnector operation in ConnectorsCCApi.
 * @export
 * @interface ConnectorsCCApiDeleteConnectorRequest
 */
export interface ConnectorsCCApiDeleteConnectorRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectorsCCApiDeleteConnector
     */
    readonly id: string
}

/**
 * Request parameters for exportConnectorConfig operation in ConnectorsCCApi.
 * @export
 * @interface ConnectorsCCApiExportConnectorConfigRequest
 */
export interface ConnectorsCCApiExportConnectorConfigRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectorsCCApiExportConnectorConfig
     */
    readonly id: string
}

/**
 * Request parameters for importConnectorConfig operation in ConnectorsCCApi.
 * @export
 * @interface ConnectorsCCApiImportConnectorConfigRequest
 */
export interface ConnectorsCCApiImportConnectorConfigRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectorsCCApiImportConnectorConfig
     */
    readonly id: string

    /**
     * This is the connector config zip bundle which gets uploaded.
     * @type {File}
     * @memberof ConnectorsCCApiImportConnectorConfig
     */
    readonly file?: File
}

/**
 * ConnectorsCCApi - object-oriented interface
 * @export
 * @class ConnectorsCCApi
 * @extends {BaseAPI}
 */
export class ConnectorsCCApi extends BaseAPI {
    /**
     * 
     * @summary Create Connector
     * @param {ConnectorsCCApiCreateConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsCCApi
     */
    public createConnector(requestParameters: ConnectorsCCApiCreateConnectorRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsCCApiFp(this.configuration).createConnector(requestParameters.contentType, requestParameters.name, requestParameters.description, requestParameters.className, requestParameters.directConnect, requestParameters.status, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Connector
     * @param {ConnectorsCCApiDeleteConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsCCApi
     */
    public deleteConnector(requestParameters: ConnectorsCCApiDeleteConnectorRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsCCApiFp(this.configuration).deleteConnector(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export Connector Config
     * @param {ConnectorsCCApiExportConnectorConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsCCApi
     */
    public exportConnectorConfig(requestParameters: ConnectorsCCApiExportConnectorConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsCCApiFp(this.configuration).exportConnectorConfig(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import Connector Config
     * @param {ConnectorsCCApiImportConnectorConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsCCApi
     */
    public importConnectorConfig(requestParameters: ConnectorsCCApiImportConnectorConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsCCApiFp(this.configuration).importConnectorConfig(requestParameters.id, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Connectors
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsCCApi
     */
    public listConnectors(axiosOptions?: AxiosRequestConfig) {
        return ConnectorsCCApiFp(this.configuration).listConnectors(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SourcesAccountsCCApi - axios parameter creator
 * @export
 */
export const SourcesAccountsCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Exports a CSV of the accounts for a particular source.
         * @summary Export Account Feed
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportAccountFeed: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportAccountFeed', 'id', id)
            const localVarPath = `/cc/api/source/exportAccountFeed/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesAccountsCCApi - functional programming interface
 * @export
 */
export const SourcesAccountsCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourcesAccountsCCApiAxiosParamCreator(configuration)
    return {
        /**
         * Exports a CSV of the accounts for a particular source.
         * @summary Export Account Feed
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportAccountFeed(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportAccountFeed(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesAccountsCCApi.exportAccountFeed']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SourcesAccountsCCApi - factory interface
 * @export
 */
export const SourcesAccountsCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourcesAccountsCCApiFp(configuration)
    return {
        /**
         * Exports a CSV of the accounts for a particular source.
         * @summary Export Account Feed
         * @param {SourcesAccountsCCApiExportAccountFeedRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        exportAccountFeed(requestParameters: SourcesAccountsCCApiExportAccountFeedRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.exportAccountFeed(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for exportAccountFeed operation in SourcesAccountsCCApi.
 * @export
 * @interface SourcesAccountsCCApiExportAccountFeedRequest
 */
export interface SourcesAccountsCCApiExportAccountFeedRequest {
    /**
     * 
     * @type {string}
     * @memberof SourcesAccountsCCApiExportAccountFeed
     */
    readonly id: string
}

/**
 * SourcesAccountsCCApi - object-oriented interface
 * @export
 * @class SourcesAccountsCCApi
 * @extends {BaseAPI}
 */
export class SourcesAccountsCCApi extends BaseAPI {
    /**
     * Exports a CSV of the accounts for a particular source.
     * @summary Export Account Feed
     * @param {SourcesAccountsCCApiExportAccountFeedRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesAccountsCCApi
     */
    public exportAccountFeed(requestParameters: SourcesAccountsCCApiExportAccountFeedRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesAccountsCCApiFp(this.configuration).exportAccountFeed(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SourcesAggregationCCApi - axios parameter creator
 * @export
 */
export const SourcesAggregationCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Aggregates a delimited file for the given source.  This only works for file-based sources.
         * @summary Account Aggregation (File)
         * @param {string} id 
         * @param {string} [contentType] 
         * @param {boolean} [disableOptimization] 
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        loadAccounts: async (id: string, contentType?: string, disableOptimization?: boolean, file?: File, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('loadAccounts', 'id', id)
            const localVarPath = `/cc/api/source/loadAccounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


            if (disableOptimization !== undefined) { 
                localVarFormParams.append('disableOptimization', disableOptimization as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Aggregates a delimited file for the given source.  This only works for file-based sources.
         * @summary Account Aggregation (File)
         * @param {string} id 
         * @param {string} [contentType] 
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        loadEntitlements: async (id: string, contentType?: string, file?: File, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('loadEntitlements', 'id', id)
            const localVarPath = `/cc/api/source/loadEntitlements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesAggregationCCApi - functional programming interface
 * @export
 */
export const SourcesAggregationCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourcesAggregationCCApiAxiosParamCreator(configuration)
    return {
        /**
         * Aggregates a delimited file for the given source.  This only works for file-based sources.
         * @summary Account Aggregation (File)
         * @param {string} id 
         * @param {string} [contentType] 
         * @param {boolean} [disableOptimization] 
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async loadAccounts(id: string, contentType?: string, disableOptimization?: boolean, file?: File, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadAccounts(id, contentType, disableOptimization, file, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesAggregationCCApi.loadAccounts']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Aggregates a delimited file for the given source.  This only works for file-based sources.
         * @summary Account Aggregation (File)
         * @param {string} id 
         * @param {string} [contentType] 
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async loadEntitlements(id: string, contentType?: string, file?: File, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadEntitlements(id, contentType, file, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SourcesAggregationCCApi.loadEntitlements']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SourcesAggregationCCApi - factory interface
 * @export
 */
export const SourcesAggregationCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourcesAggregationCCApiFp(configuration)
    return {
        /**
         * Aggregates a delimited file for the given source.  This only works for file-based sources.
         * @summary Account Aggregation (File)
         * @param {SourcesAggregationCCApiLoadAccountsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        loadAccounts(requestParameters: SourcesAggregationCCApiLoadAccountsRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.loadAccounts(requestParameters.id, requestParameters.contentType, requestParameters.disableOptimization, requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * Aggregates a delimited file for the given source.  This only works for file-based sources.
         * @summary Account Aggregation (File)
         * @param {SourcesAggregationCCApiLoadEntitlementsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        loadEntitlements(requestParameters: SourcesAggregationCCApiLoadEntitlementsRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.loadEntitlements(requestParameters.id, requestParameters.contentType, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for loadAccounts operation in SourcesAggregationCCApi.
 * @export
 * @interface SourcesAggregationCCApiLoadAccountsRequest
 */
export interface SourcesAggregationCCApiLoadAccountsRequest {
    /**
     * 
     * @type {string}
     * @memberof SourcesAggregationCCApiLoadAccounts
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof SourcesAggregationCCApiLoadAccounts
     */
    readonly contentType?: string

    /**
     * 
     * @type {boolean}
     * @memberof SourcesAggregationCCApiLoadAccounts
     */
    readonly disableOptimization?: boolean

    /**
     * 
     * @type {File}
     * @memberof SourcesAggregationCCApiLoadAccounts
     */
    readonly file?: File
}

/**
 * Request parameters for loadEntitlements operation in SourcesAggregationCCApi.
 * @export
 * @interface SourcesAggregationCCApiLoadEntitlementsRequest
 */
export interface SourcesAggregationCCApiLoadEntitlementsRequest {
    /**
     * 
     * @type {string}
     * @memberof SourcesAggregationCCApiLoadEntitlements
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof SourcesAggregationCCApiLoadEntitlements
     */
    readonly contentType?: string

    /**
     * 
     * @type {File}
     * @memberof SourcesAggregationCCApiLoadEntitlements
     */
    readonly file?: File
}

/**
 * SourcesAggregationCCApi - object-oriented interface
 * @export
 * @class SourcesAggregationCCApi
 * @extends {BaseAPI}
 */
export class SourcesAggregationCCApi extends BaseAPI {
    /**
     * Aggregates a delimited file for the given source.  This only works for file-based sources.
     * @summary Account Aggregation (File)
     * @param {SourcesAggregationCCApiLoadAccountsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesAggregationCCApi
     */
    public loadAccounts(requestParameters: SourcesAggregationCCApiLoadAccountsRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesAggregationCCApiFp(this.configuration).loadAccounts(requestParameters.id, requestParameters.contentType, requestParameters.disableOptimization, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Aggregates a delimited file for the given source.  This only works for file-based sources.
     * @summary Account Aggregation (File)
     * @param {SourcesAggregationCCApiLoadEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesAggregationCCApi
     */
    public loadEntitlements(requestParameters: SourcesAggregationCCApiLoadEntitlementsRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesAggregationCCApiFp(this.configuration).loadEntitlements(requestParameters.id, requestParameters.contentType, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemCCApi - axios parameter creator
 * @export
 */
export const SystemCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This kicks off an identity refresh for a specified set of identity attributes.  This can be a long running process.  IdentityNow has pre-scheduled versions of this task at set intervals and events already, so only run this when directed by SailPoint.  _Note: If the identities specified by the filter do not exist, a full identity refresh will be run.  Use with caution._  Refresh Arguments:  | Key                   | Description                                        | |-----------------------|----------------------------------------------------| | correlateEntitlements | Analyzes entitlements, access profiles, and roles. | | promoteAttributes     | Calculates identity attributes.                    | | refreshManagerStatus  | Calculates manager correlation and manager status. | | synchronizeAttributes | Performs attribute sync provisioning.              | | pruneIdentities       | Removes any identities which don\'t have accounts.  | | provision             | Provisions any assigned roles or access profiles.  |
         * @summary Refresh Identities
         * @param {string} [contentType] 
         * @param {RefreshIdentitiesRequestCC} [refreshIdentitiesRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        refreshIdentities: async (contentType?: string, refreshIdentitiesRequestCC?: RefreshIdentitiesRequestCC, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/system/refreshIdentities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshIdentitiesRequestCC, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemCCApi - functional programming interface
 * @export
 */
export const SystemCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemCCApiAxiosParamCreator(configuration)
    return {
        /**
         * This kicks off an identity refresh for a specified set of identity attributes.  This can be a long running process.  IdentityNow has pre-scheduled versions of this task at set intervals and events already, so only run this when directed by SailPoint.  _Note: If the identities specified by the filter do not exist, a full identity refresh will be run.  Use with caution._  Refresh Arguments:  | Key                   | Description                                        | |-----------------------|----------------------------------------------------| | correlateEntitlements | Analyzes entitlements, access profiles, and roles. | | promoteAttributes     | Calculates identity attributes.                    | | refreshManagerStatus  | Calculates manager correlation and manager status. | | synchronizeAttributes | Performs attribute sync provisioning.              | | pruneIdentities       | Removes any identities which don\'t have accounts.  | | provision             | Provisions any assigned roles or access profiles.  |
         * @summary Refresh Identities
         * @param {string} [contentType] 
         * @param {RefreshIdentitiesRequestCC} [refreshIdentitiesRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async refreshIdentities(contentType?: string, refreshIdentitiesRequestCC?: RefreshIdentitiesRequestCC, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshIdentities(contentType, refreshIdentitiesRequestCC, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemCCApi.refreshIdentities']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SystemCCApi - factory interface
 * @export
 */
export const SystemCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemCCApiFp(configuration)
    return {
        /**
         * This kicks off an identity refresh for a specified set of identity attributes.  This can be a long running process.  IdentityNow has pre-scheduled versions of this task at set intervals and events already, so only run this when directed by SailPoint.  _Note: If the identities specified by the filter do not exist, a full identity refresh will be run.  Use with caution._  Refresh Arguments:  | Key                   | Description                                        | |-----------------------|----------------------------------------------------| | correlateEntitlements | Analyzes entitlements, access profiles, and roles. | | promoteAttributes     | Calculates identity attributes.                    | | refreshManagerStatus  | Calculates manager correlation and manager status. | | synchronizeAttributes | Performs attribute sync provisioning.              | | pruneIdentities       | Removes any identities which don\'t have accounts.  | | provision             | Provisions any assigned roles or access profiles.  |
         * @summary Refresh Identities
         * @param {SystemCCApiRefreshIdentitiesRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        refreshIdentities(requestParameters: SystemCCApiRefreshIdentitiesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.refreshIdentities(requestParameters.contentType, requestParameters.refreshIdentitiesRequestCC, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for refreshIdentities operation in SystemCCApi.
 * @export
 * @interface SystemCCApiRefreshIdentitiesRequest
 */
export interface SystemCCApiRefreshIdentitiesRequest {
    /**
     * 
     * @type {string}
     * @memberof SystemCCApiRefreshIdentities
     */
    readonly contentType?: string

    /**
     * 
     * @type {RefreshIdentitiesRequestCC}
     * @memberof SystemCCApiRefreshIdentities
     */
    readonly refreshIdentitiesRequestCC?: RefreshIdentitiesRequestCC
}

/**
 * SystemCCApi - object-oriented interface
 * @export
 * @class SystemCCApi
 * @extends {BaseAPI}
 */
export class SystemCCApi extends BaseAPI {
    /**
     * This kicks off an identity refresh for a specified set of identity attributes.  This can be a long running process.  IdentityNow has pre-scheduled versions of this task at set intervals and events already, so only run this when directed by SailPoint.  _Note: If the identities specified by the filter do not exist, a full identity refresh will be run.  Use with caution._  Refresh Arguments:  | Key                   | Description                                        | |-----------------------|----------------------------------------------------| | correlateEntitlements | Analyzes entitlements, access profiles, and roles. | | promoteAttributes     | Calculates identity attributes.                    | | refreshManagerStatus  | Calculates manager correlation and manager status. | | synchronizeAttributes | Performs attribute sync provisioning.              | | pruneIdentities       | Removes any identities which don\'t have accounts.  | | provision             | Provisions any assigned roles or access profiles.  |
     * @summary Refresh Identities
     * @param {SystemCCApiRefreshIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemCCApi
     */
    public refreshIdentities(requestParameters: SystemCCApiRefreshIdentitiesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SystemCCApiFp(this.configuration).refreshIdentities(requestParameters.contentType, requestParameters.refreshIdentitiesRequestCC, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserCCApi - axios parameter creator
 * @export
 */
export const UserCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Single Identity
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentity: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentity', 'id', id)
            const localVarPath = `/cc/api/user/get/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update User Permissions
         * @param {UpdateUserPermissionsRequestCC} [updateUserPermissionsRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPermissions: async (updateUserPermissionsRequestCC?: UpdateUserPermissionsRequestCC, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/user/updatePermissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPermissionsRequestCC, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserCCApi - functional programming interface
 * @export
 */
export const UserCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserCCApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Single Identity
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentity(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentity200ResponseCC>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentity(id, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserCCApi.getIdentity']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update User Permissions
         * @param {UpdateUserPermissionsRequestCC} [updateUserPermissionsRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPermissions(updateUserPermissionsRequestCC?: UpdateUserPermissionsRequestCC, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPermissions(updateUserPermissionsRequestCC, axiosOptions);
            const serverMapIndex = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserCCApi.updateUserPermissions']?.[serverMapIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserCCApi - factory interface
 * @export
 */
export const UserCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserCCApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Single Identity
         * @param {UserCCApiGetIdentityRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        getIdentity(requestParameters: UserCCApiGetIdentityRequest, options?: AxiosRequestConfig): AxiosPromise<GetIdentity200ResponseCC> {
            return localVarFp.getIdentity(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update User Permissions
         * @param {UserCCApiUpdateUserPermissionsRequest} requestParameters Request parameters.
        * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
    
        updateUserPermissions(requestParameters: UserCCApiUpdateUserPermissionsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserPermissions(requestParameters.updateUserPermissionsRequestCC, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getIdentity operation in UserCCApi.
 * @export
 * @interface UserCCApiGetIdentityRequest
 */
export interface UserCCApiGetIdentityRequest {
    /**
     * 
     * @type {string}
     * @memberof UserCCApiGetIdentity
     */
    readonly id: string
}

/**
 * Request parameters for updateUserPermissions operation in UserCCApi.
 * @export
 * @interface UserCCApiUpdateUserPermissionsRequest
 */
export interface UserCCApiUpdateUserPermissionsRequest {
    /**
     * 
     * @type {UpdateUserPermissionsRequestCC}
     * @memberof UserCCApiUpdateUserPermissions
     */
    readonly updateUserPermissionsRequestCC?: UpdateUserPermissionsRequestCC
}

/**
 * UserCCApi - object-oriented interface
 * @export
 * @class UserCCApi
 * @extends {BaseAPI}
 */
export class UserCCApi extends BaseAPI {
    /**
     * 
     * @summary Get Single Identity
     * @param {UserCCApiGetIdentityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCCApi
     */
    public getIdentity(requestParameters: UserCCApiGetIdentityRequest, axiosOptions?: AxiosRequestConfig) {
        return UserCCApiFp(this.configuration).getIdentity(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update User Permissions
     * @param {UserCCApiUpdateUserPermissionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCCApi
     */
    public updateUserPermissions(requestParameters: UserCCApiUpdateUserPermissionsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return UserCCApiFp(this.configuration).updateUserPermissions(requestParameters.updateUserPermissionsRequestCC, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



