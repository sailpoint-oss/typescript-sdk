/* tslint:disable */
/* eslint-disable */
/**
 * Identity Security Cloud V3 API
 * Use these APIs to interact with the Identity Security Cloud platform to achieve repeatable, automated processes with greater scalability. We encourage you to join the SailPoint Developer Community forum at https://developer.sailpoint.com/discuss to connect with other developers using our APIs.
 *
 * The version of the OpenAPI document: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof Access
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof Access
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'displayName'?: string;
    /**
     * Description of access item.
     * @type {string}
     * @memberof Access
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AccessApps
 */
export interface AccessApps {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessApps
     */
    'id'?: string;
    /**
     * Name of application
     * @type {string}
     * @memberof AccessApps
     */
    'name'?: string;
    /**
     * Description of application.
     * @type {string}
     * @memberof AccessApps
     */
    'description'?: string;
    /**
     * 
     * @type {AccessAppsOwner}
     * @memberof AccessApps
     */
    'owner'?: AccessAppsOwner;
}
/**
 * Owner\'s identity.
 * @export
 * @interface AccessAppsOwner
 */
export interface AccessAppsOwner {
    /**
     * Owner\'s DTO type.
     * @type {string}
     * @memberof AccessAppsOwner
     */
    'type'?: AccessAppsOwnerTypeV3;
    /**
     * Owner\'s identity ID.
     * @type {string}
     * @memberof AccessAppsOwner
     */
    'id'?: string;
    /**
     * Owner\'s display name.
     * @type {string}
     * @memberof AccessAppsOwner
     */
    'name'?: string;
    /**
     * Owner\'s email.
     * @type {string}
     * @memberof AccessAppsOwner
     */
    'email'?: string;
}

export const AccessAppsOwnerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type AccessAppsOwnerTypeV3 = typeof AccessAppsOwnerTypeV3[keyof typeof AccessAppsOwnerTypeV3];

/**
 * 
 * @export
 * @interface AccessConstraint
 */
export interface AccessConstraint {
    /**
     * Type of Access
     * @type {string}
     * @memberof AccessConstraint
     */
    'type': AccessConstraintTypeV3;
    /**
     * Must be set only if operator is SELECTED.
     * @type {Array<string>}
     * @memberof AccessConstraint
     */
    'ids'?: Array<string>;
    /**
     * Used to determine whether the scope of the campaign should be reduced for selected ids or all.
     * @type {string}
     * @memberof AccessConstraint
     */
    'operator': AccessConstraintOperatorV3;
}

export const AccessConstraintTypeV3 = {
    Entitlement: 'ENTITLEMENT',
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE'
} as const;

export type AccessConstraintTypeV3 = typeof AccessConstraintTypeV3[keyof typeof AccessConstraintTypeV3];
export const AccessConstraintOperatorV3 = {
    All: 'ALL',
    Selected: 'SELECTED'
} as const;

export type AccessConstraintOperatorV3 = typeof AccessConstraintOperatorV3[keyof typeof AccessConstraintOperatorV3];

/**
 * 
 * @export
 * @interface AccessCriteria
 */
export interface AccessCriteria {
    /**
     * Business name for the access construct list
     * @type {string}
     * @memberof AccessCriteria
     */
    'name'?: string;
    /**
     * List of criteria. There is a min of 1 and max of 50 items in the list.
     * @type {Array<AccessCriteriaCriteriaListInner>}
     * @memberof AccessCriteria
     */
    'criteriaList'?: Array<AccessCriteriaCriteriaListInner>;
}
/**
 * 
 * @export
 * @interface AccessCriteriaCriteriaListInner
 */
export interface AccessCriteriaCriteriaListInner {
    /**
     * Type of the propery to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInner
     */
    'type'?: AccessCriteriaCriteriaListInnerTypeV3;
    /**
     * ID of the object to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInner
     */
    'name'?: string;
}

export const AccessCriteriaCriteriaListInnerTypeV3 = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessCriteriaCriteriaListInnerTypeV3 = typeof AccessCriteriaCriteriaListInnerTypeV3[keyof typeof AccessCriteriaCriteriaListInnerTypeV3];

/**
 * Identity the access item is requested for.
 * @export
 * @interface AccessItemRequestedFor
 */
export interface AccessItemRequestedFor {
    /**
     * DTO type of identity the access item is requested for.
     * @type {string}
     * @memberof AccessItemRequestedFor
     */
    'type'?: AccessItemRequestedForTypeV3;
    /**
     * ID of identity the access item is requested for.
     * @type {string}
     * @memberof AccessItemRequestedFor
     */
    'id'?: string;
    /**
     * Human-readable display name of identity the access item is requested for.
     * @type {string}
     * @memberof AccessItemRequestedFor
     */
    'name'?: string;
}

export const AccessItemRequestedForTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type AccessItemRequestedForTypeV3 = typeof AccessItemRequestedForTypeV3[keyof typeof AccessItemRequestedForTypeV3];

/**
 * Access item requester\'s identity.
 * @export
 * @interface AccessItemRequester
 */
export interface AccessItemRequester {
    /**
     * Access item requester\'s DTO type.
     * @type {string}
     * @memberof AccessItemRequester
     */
    'type'?: AccessItemRequesterTypeV3;
    /**
     * Access item requester\'s identity ID.
     * @type {string}
     * @memberof AccessItemRequester
     */
    'id'?: string;
    /**
     * Access item owner\'s human-readable display name.
     * @type {string}
     * @memberof AccessItemRequester
     */
    'name'?: string;
}

export const AccessItemRequesterTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type AccessItemRequesterTypeV3 = typeof AccessItemRequesterTypeV3[keyof typeof AccessItemRequesterTypeV3];

/**
 * Identity who reviewed the access item request.
 * @export
 * @interface AccessItemReviewedBy
 */
export interface AccessItemReviewedBy {
    /**
     * DTO type of identity who reviewed the access item request.
     * @type {string}
     * @memberof AccessItemReviewedBy
     */
    'type'?: AccessItemReviewedByTypeV3;
    /**
     * ID of identity who reviewed the access item request.
     * @type {string}
     * @memberof AccessItemReviewedBy
     */
    'id'?: string;
    /**
     * Human-readable display name of identity who reviewed the access item request.
     * @type {string}
     * @memberof AccessItemReviewedBy
     */
    'name'?: string;
}

export const AccessItemReviewedByTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type AccessItemReviewedByTypeV3 = typeof AccessItemReviewedByTypeV3[keyof typeof AccessItemReviewedByTypeV3];

/**
 * Metadata that describes an access item
 * @export
 * @interface AccessModelMetadata
 */
export interface AccessModelMetadata {
    /**
     * Unique identifier for the metadata type
     * @type {string}
     * @memberof AccessModelMetadata
     */
    'key'?: string;
    /**
     * Human readable name of the metadata type
     * @type {string}
     * @memberof AccessModelMetadata
     */
    'name'?: string;
    /**
     * Allows selecting multiple values
     * @type {boolean}
     * @memberof AccessModelMetadata
     */
    'multiselect'?: boolean;
    /**
     * The state of the metadata item
     * @type {string}
     * @memberof AccessModelMetadata
     */
    'status'?: string;
    /**
     * The type of the metadata item
     * @type {string}
     * @memberof AccessModelMetadata
     */
    'type'?: string;
    /**
     * The types of objects
     * @type {Array<string>}
     * @memberof AccessModelMetadata
     */
    'objectTypes'?: Array<string>;
    /**
     * Describes the metadata item
     * @type {string}
     * @memberof AccessModelMetadata
     */
    'description'?: string;
    /**
     * The value to assign to the metadata item
     * @type {Array<AccessModelMetadataValuesInner>}
     * @memberof AccessModelMetadata
     */
    'values'?: Array<AccessModelMetadataValuesInner>;
}
/**
 * An individual value to assign to the metadata item
 * @export
 * @interface AccessModelMetadataValuesInner
 */
export interface AccessModelMetadataValuesInner {
    /**
     * The value to assign to the metdata item
     * @type {string}
     * @memberof AccessModelMetadataValuesInner
     */
    'value'?: string;
    /**
     * Display name of the value
     * @type {string}
     * @memberof AccessModelMetadataValuesInner
     */
    'name'?: string;
    /**
     * The status of the individual value
     * @type {string}
     * @memberof AccessModelMetadataValuesInner
     */
    'status'?: string;
}
/**
 * Access Profile
 * @export
 * @interface AccessProfile
 */
export interface AccessProfile {
    /**
     * The ID of the Access Profile
     * @type {string}
     * @memberof AccessProfile
     */
    'id'?: string;
    /**
     * Name of the Access Profile
     * @type {string}
     * @memberof AccessProfile
     */
    'name': string;
    /**
     * Information about the Access Profile
     * @type {string}
     * @memberof AccessProfile
     */
    'description'?: string | null;
    /**
     * Date the Access Profile was created
     * @type {string}
     * @memberof AccessProfile
     */
    'created'?: string;
    /**
     * Date the Access Profile was last modified.
     * @type {string}
     * @memberof AccessProfile
     */
    'modified'?: string;
    /**
     * Whether the Access Profile is enabled. If the Access Profile is enabled then you must include at least one Entitlement.
     * @type {boolean}
     * @memberof AccessProfile
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {OwnerReference}
     * @memberof AccessProfile
     */
    'owner': OwnerReference;
    /**
     * 
     * @type {AccessProfileSourceRef}
     * @memberof AccessProfile
     */
    'source': AccessProfileSourceRef;
    /**
     * A list of entitlements associated with the Access Profile. If enabled is false this is allowed to be empty otherwise it needs to contain at least one Entitlement.
     * @type {Array<EntitlementRef>}
     * @memberof AccessProfile
     */
    'entitlements'?: Array<EntitlementRef> | null;
    /**
     * Whether the Access Profile is requestable via access request. Currently, making an Access Profile non-requestable is only supported  for customers enabled with the new Request Center. Otherwise, attempting to create an Access Profile with a value  **false** in this field results in a 400 error.
     * @type {boolean}
     * @memberof AccessProfile
     */
    'requestable'?: boolean;
    /**
     * 
     * @type {Requestability}
     * @memberof AccessProfile
     */
    'accessRequestConfig'?: Requestability | null;
    /**
     * 
     * @type {Revocability}
     * @memberof AccessProfile
     */
    'revocationRequestConfig'?: Revocability | null;
    /**
     * List of IDs of segments, if any, to which this Access Profile is assigned.
     * @type {Array<string>}
     * @memberof AccessProfile
     */
    'segments'?: Array<string> | null;
    /**
     * 
     * @type {ProvisioningCriteriaLevel1}
     * @memberof AccessProfile
     */
    'provisioningCriteria'?: ProvisioningCriteriaLevel1 | null;
}
/**
 * 
 * @export
 * @interface AccessProfileApprovalScheme
 */
export interface AccessProfileApprovalScheme {
    /**
     * Describes the individual or group that is responsible for an approval step. Values are as follows. **APP_OWNER**: The owner of the Application  **OWNER**: Owner of the associated Access Profile or Role  **SOURCE_OWNER**: Owner of the Source associated with an Access Profile  **MANAGER**: Manager of the Identity making the request  **GOVERNANCE_GROUP**: A Governance Group, the ID of which is specified by the **approverId** field
     * @type {string}
     * @memberof AccessProfileApprovalScheme
     */
    'approverType'?: AccessProfileApprovalSchemeApproverTypeV3;
    /**
     * Id of the specific approver, used only when approverType is GOVERNANCE_GROUP
     * @type {string}
     * @memberof AccessProfileApprovalScheme
     */
    'approverId'?: string | null;
}

export const AccessProfileApprovalSchemeApproverTypeV3 = {
    AppOwner: 'APP_OWNER',
    Owner: 'OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type AccessProfileApprovalSchemeApproverTypeV3 = typeof AccessProfileApprovalSchemeApproverTypeV3[keyof typeof AccessProfileApprovalSchemeApproverTypeV3];

/**
 * 
 * @export
 * @interface AccessProfileBulkDeleteRequest
 */
export interface AccessProfileBulkDeleteRequest {
    /**
     * List of IDs of Access Profiles to be deleted.
     * @type {Array<string>}
     * @memberof AccessProfileBulkDeleteRequest
     */
    'accessProfileIds'?: Array<string>;
    /**
     * If **true**, silently skip over any of the specified Access Profiles if they cannot be deleted because they are in use. If **false**, no deletions will be attempted if any of the Access Profiles are in use.
     * @type {boolean}
     * @memberof AccessProfileBulkDeleteRequest
     */
    'bestEffortOnly'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileBulkDeleteResponse
 */
export interface AccessProfileBulkDeleteResponse {
    /**
     * ID of the task which is executing the bulk deletion. This can be passed to the **_/task-status** API to track status.
     * @type {string}
     * @memberof AccessProfileBulkDeleteResponse
     */
    'taskId'?: string;
    /**
     * List of IDs of Access Profiles which are pending deletion.
     * @type {Array<string>}
     * @memberof AccessProfileBulkDeleteResponse
     */
    'pending'?: Array<string>;
    /**
     * List of usages of Access Profiles targeted for deletion.
     * @type {Array<AccessProfileUsage>}
     * @memberof AccessProfileBulkDeleteResponse
     */
    'inUse'?: Array<AccessProfileUsage>;
}
/**
 * More complete representation of an access profile.  
 * @export
 * @interface AccessProfileDocument
 */
export interface AccessProfileDocument {
    /**
     * Access item\'s description.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'description'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'synced'?: string | null;
    /**
     * Indicates whether the access item is currently enabled.
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'enabled'?: boolean;
    /**
     * Indicates whether the access item can be requested.
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'requestable'?: boolean;
    /**
     * Indicates whether comments are required for requests to access the item.
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {BaseAccessOwner}
     * @memberof AccessProfileDocument
     */
    'owner'?: BaseAccessOwner;
    /**
     * Access profile\'s ID.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'id': string;
    /**
     * Access profile\'s name.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'name': string;
    /**
     * 
     * @type {AccessProfileDocumentAllOfSource}
     * @memberof AccessProfileDocument
     */
    'source'?: AccessProfileDocumentAllOfSource;
    /**
     * Entitlements the access profile has access to.
     * @type {Array<BaseEntitlement>}
     * @memberof AccessProfileDocument
     */
    'entitlements'?: Array<BaseEntitlement>;
    /**
     * Number of entitlements.
     * @type {number}
     * @memberof AccessProfileDocument
     */
    'entitlementCount'?: number;
    /**
     * Segments with the access profile.
     * @type {Array<BaseSegment>}
     * @memberof AccessProfileDocument
     */
    'segments'?: Array<BaseSegment>;
    /**
     * Number of segments with the access profile.
     * @type {number}
     * @memberof AccessProfileDocument
     */
    'segmentCount'?: number;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof AccessProfileDocument
     */
    'tags'?: Array<string>;
    /**
     * Applications with the access profile
     * @type {Array<AccessApps>}
     * @memberof AccessProfileDocument
     */
    'apps'?: Array<AccessApps>;
}
/**
 * Access profile\'s source.
 * @export
 * @interface AccessProfileDocumentAllOfSource
 */
export interface AccessProfileDocumentAllOfSource {
    /**
     * Source\'s ID.
     * @type {string}
     * @memberof AccessProfileDocumentAllOfSource
     */
    'id'?: string;
    /**
     * Source\'s name.
     * @type {string}
     * @memberof AccessProfileDocumentAllOfSource
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface AccessProfileDocuments
 */
export interface AccessProfileDocuments {
    /**
     * Access item\'s description.
     * @type {string}
     * @memberof AccessProfileDocuments
     */
    'description'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof AccessProfileDocuments
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof AccessProfileDocuments
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof AccessProfileDocuments
     */
    'synced'?: string | null;
    /**
     * Indicates whether the access item is currently enabled.
     * @type {boolean}
     * @memberof AccessProfileDocuments
     */
    'enabled'?: boolean;
    /**
     * Indicates whether the access item can be requested.
     * @type {boolean}
     * @memberof AccessProfileDocuments
     */
    'requestable'?: boolean;
    /**
     * Indicates whether comments are required for requests to access the item.
     * @type {boolean}
     * @memberof AccessProfileDocuments
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {BaseAccessOwner}
     * @memberof AccessProfileDocuments
     */
    'owner'?: BaseAccessOwner;
    /**
     * Access profile\'s ID.
     * @type {string}
     * @memberof AccessProfileDocuments
     */
    'id': string;
    /**
     * Access profile\'s name.
     * @type {string}
     * @memberof AccessProfileDocuments
     */
    'name': string;
    /**
     * 
     * @type {AccessProfileDocumentAllOfSource}
     * @memberof AccessProfileDocuments
     */
    'source'?: AccessProfileDocumentAllOfSource;
    /**
     * Entitlements the access profile has access to.
     * @type {Array<BaseEntitlement>}
     * @memberof AccessProfileDocuments
     */
    'entitlements'?: Array<BaseEntitlement>;
    /**
     * Number of entitlements.
     * @type {number}
     * @memberof AccessProfileDocuments
     */
    'entitlementCount'?: number;
    /**
     * Segments with the access profile.
     * @type {Array<BaseSegment>}
     * @memberof AccessProfileDocuments
     */
    'segments'?: Array<BaseSegment>;
    /**
     * Number of segments with the access profile.
     * @type {number}
     * @memberof AccessProfileDocuments
     */
    'segmentCount'?: number;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof AccessProfileDocuments
     */
    'tags'?: Array<string>;
    /**
     * Applications with the access profile
     * @type {Array<AccessApps>}
     * @memberof AccessProfileDocuments
     */
    'apps'?: Array<AccessApps>;
    /**
     * Name of the pod.
     * @type {string}
     * @memberof AccessProfileDocuments
     */
    'pod'?: string;
    /**
     * Name of the tenant.
     * @type {string}
     * @memberof AccessProfileDocuments
     */
    'org'?: string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccessProfileDocuments
     */
    '_type'?: DocumentType;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccessProfileDocuments
     */
    'type'?: DocumentType;
    /**
     * Version number.
     * @type {string}
     * @memberof AccessProfileDocuments
     */
    '_version'?: string;
}


/**
 * EntitlementReference
 * @export
 * @interface AccessProfileEntitlement
 */
export interface AccessProfileEntitlement {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'displayName'?: string;
    /**
     * Description of access item.
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileEntitlement
     */
    'source'?: Reference1;
    /**
     * Type of the access item.
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileEntitlement
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'attribute'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileEntitlement
     */
    'standalone'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileRef
 */
export interface AccessProfileRef {
    /**
     * ID of the Access Profile
     * @type {string}
     * @memberof AccessProfileRef
     */
    'id'?: string;
    /**
     * Type of requested object. This field must be either left null or set to \'ACCESS_PROFILE\' when creating an Access Profile, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof AccessProfileRef
     */
    'type'?: AccessProfileRefTypeV3;
    /**
     * Human-readable display name of the Access Profile. This field is ignored on input.
     * @type {string}
     * @memberof AccessProfileRef
     */
    'name'?: string;
}

export const AccessProfileRefTypeV3 = {
    AccessProfile: 'ACCESS_PROFILE'
} as const;

export type AccessProfileRefTypeV3 = typeof AccessProfileRefTypeV3[keyof typeof AccessProfileRefTypeV3];

/**
 * Role
 * @export
 * @interface AccessProfileRole
 */
export interface AccessProfileRole {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileRole
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileRole
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileRole
     */
    'displayName'?: string;
    /**
     * Description of access item.
     * @type {string}
     * @memberof AccessProfileRole
     */
    'description'?: string | null;
    /**
     * Type of the access item.
     * @type {string}
     * @memberof AccessProfileRole
     */
    'type'?: string;
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccessProfileRole
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileRole
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileRole
     */
    'revocable'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileSourceRef
 */
export interface AccessProfileSourceRef {
    /**
     * The ID of the Source with with which the Access Profile is associated
     * @type {string}
     * @memberof AccessProfileSourceRef
     */
    'id'?: string;
    /**
     * The type of the Source, will always be SOURCE
     * @type {string}
     * @memberof AccessProfileSourceRef
     */
    'type'?: AccessProfileSourceRefTypeV3;
    /**
     * The display name of the associated Source
     * @type {string}
     * @memberof AccessProfileSourceRef
     */
    'name'?: string;
}

export const AccessProfileSourceRefTypeV3 = {
    Source: 'SOURCE'
} as const;

export type AccessProfileSourceRefTypeV3 = typeof AccessProfileSourceRefTypeV3[keyof typeof AccessProfileSourceRefTypeV3];

/**
 * This is a summary representation of an access profile.
 * @export
 * @interface AccessProfileSummary
 */
export interface AccessProfileSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'displayName'?: string;
    /**
     * Description of access item.
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'description'?: string | null;
    /**
     * Type of the access item.
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'type'?: string;
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileSummary
     */
    'source'?: Reference1;
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccessProfileSummary
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileSummary
     */
    'revocable'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileUsage
 */
export interface AccessProfileUsage {
    /**
     * ID of the Access Profile that is in use
     * @type {string}
     * @memberof AccessProfileUsage
     */
    'accessProfileId'?: string;
    /**
     * List of references to objects which are using the indicated Access Profile
     * @type {Array<AccessProfileUsageUsedByInner>}
     * @memberof AccessProfileUsage
     */
    'usedBy'?: Array<AccessProfileUsageUsedByInner>;
}
/**
 * Role using the access profile.
 * @export
 * @interface AccessProfileUsageUsedByInner
 */
export interface AccessProfileUsageUsedByInner {
    /**
     * DTO type of role using the access profile.
     * @type {string}
     * @memberof AccessProfileUsageUsedByInner
     */
    'type'?: AccessProfileUsageUsedByInnerTypeV3;
    /**
     * ID of role using the access profile.
     * @type {string}
     * @memberof AccessProfileUsageUsedByInner
     */
    'id'?: string;
    /**
     * Display name of role using the access profile.
     * @type {string}
     * @memberof AccessProfileUsageUsedByInner
     */
    'name'?: string;
}

export const AccessProfileUsageUsedByInnerTypeV3 = {
    Role: 'ROLE'
} as const;

export type AccessProfileUsageUsedByInnerTypeV3 = typeof AccessProfileUsageUsedByInnerTypeV3[keyof typeof AccessProfileUsageUsedByInnerTypeV3];

/**
 * 
 * @export
 * @interface AccessRequest
 */
export interface AccessRequest {
    /**
     * A list of Identity IDs for whom the Access is requested. If it\'s a Revoke request, there can only be one Identity ID.
     * @type {Array<string>}
     * @memberof AccessRequest
     */
    'requestedFor': Array<string>;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof AccessRequest
     */
    'requestType'?: AccessRequestType | null;
    /**
     * 
     * @type {Array<AccessRequestItem>}
     * @memberof AccessRequest
     */
    'requestedItems': Array<AccessRequestItem>;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on associated APIs such as /account-activities.
     * @type {{ [key: string]: string; }}
     * @memberof AccessRequest
     */
    'clientMetadata'?: { [key: string]: string; };
}


/**
 * 
 * @export
 * @interface AccessRequestConfig
 */
export interface AccessRequestConfig {
    /**
     * If this is true, approvals must be processed by an external system. Also, if this is true, it blocks Request Center access requests and returns an error for any user who isn\'t an org admin.
     * @type {boolean}
     * @memberof AccessRequestConfig
     */
    'approvalsMustBeExternal'?: boolean;
    /**
     * If this is true and the requester and reviewer are the same, the request is automatically approved.
     * @type {boolean}
     * @memberof AccessRequestConfig
     */
    'autoApprovalEnabled'?: boolean;
    /**
     * If this is true, reauthorization will be enforced for appropriately configured access items. Enablement of this feature is currently in a limited state.
     * @type {boolean}
     * @memberof AccessRequestConfig
     */
    'reauthorizationEnabled'?: boolean;
    /**
     * 
     * @type {RequestOnBehalfOfConfig}
     * @memberof AccessRequestConfig
     */
    'requestOnBehalfOfConfig'?: RequestOnBehalfOfConfig;
    /**
     * 
     * @type {ApprovalReminderAndEscalationConfig}
     * @memberof AccessRequestConfig
     */
    'approvalReminderAndEscalationConfig'?: ApprovalReminderAndEscalationConfig;
    /**
     * 
     * @type {EntitlementRequestConfig}
     * @memberof AccessRequestConfig
     */
    'entitlementRequestConfig'?: EntitlementRequestConfig;
}
/**
 * 
 * @export
 * @interface AccessRequestItem
 */
export interface AccessRequestItem {
    /**
     * The type of the item being requested.
     * @type {string}
     * @memberof AccessRequestItem
     */
    'type': AccessRequestItemTypeV3;
    /**
     * ID of Role, Access Profile or Entitlement being requested.
     * @type {string}
     * @memberof AccessRequestItem
     */
    'id': string;
    /**
     * Comment provided by requester. * Comment is required when the request is of type Revoke Access. 
     * @type {string}
     * @memberof AccessRequestItem
     */
    'comment'?: string;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on associated APIs such as /account-activities and /access-request-status.
     * @type {{ [key: string]: string; }}
     * @memberof AccessRequestItem
     */
    'clientMetadata'?: { [key: string]: string; };
    /**
     * The date the role or access profile or entitlement is no longer assigned to the specified identity. Also known as the expiration date. * Specify a date in the future. * The current SLA for the deprovisioning is 24 hours. * This date can be modified to either extend or decrease the duration of access item assignments for the specified identity. You can change the expiration date for requests for yourself or direct reports, but you cannot remove an expiration date on an already approved item. If the access request has not been approved, you can cancel it and submit a new one without the expiration. If it has already been approved, then you have to revoke the access and then re-request without the expiration. 
     * @type {string}
     * @memberof AccessRequestItem
     */
    'removeDate'?: string;
}

export const AccessRequestItemTypeV3 = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessRequestItemTypeV3 = typeof AccessRequestItemTypeV3[keyof typeof AccessRequestItemTypeV3];

/**
 * Provides additional details about this access request phase.
 * @export
 * @interface AccessRequestPhases
 */
export interface AccessRequestPhases {
    /**
     * The time that this phase started.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'started'?: string;
    /**
     * The time that this phase finished.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'finished'?: string | null;
    /**
     * The name of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'name'?: string;
    /**
     * The state of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'state'?: AccessRequestPhasesStateV3;
    /**
     * The state of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'result'?: AccessRequestPhasesResultV3 | null;
    /**
     * A reference to another object on the RequestedItemStatus that contains more details about the phase. Note that for the Provisioning phase, this will be empty if there are no manual work items.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'phaseReference'?: string | null;
}

export const AccessRequestPhasesStateV3 = {
    Pending: 'PENDING',
    Executing: 'EXECUTING',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    NotExecuted: 'NOT_EXECUTED'
} as const;

export type AccessRequestPhasesStateV3 = typeof AccessRequestPhasesStateV3[keyof typeof AccessRequestPhasesStateV3];
export const AccessRequestPhasesResultV3 = {
    Successful: 'SUCCESSFUL',
    Failed: 'FAILED'
} as const;

export type AccessRequestPhasesResultV3 = typeof AccessRequestPhasesResultV3[keyof typeof AccessRequestPhasesResultV3];

/**
 * 
 * @export
 * @interface AccessRequestResponse
 */
export interface AccessRequestResponse {
    /**
     * A list of new access request tracking data mapped to the values requested.
     * @type {Array<AccessRequestTracking>}
     * @memberof AccessRequestResponse
     */
    'newRequests'?: Array<AccessRequestTracking>;
    /**
     * A list of existing access request tracking data mapped to the values requested.  This indicates access has already been requested for this item.
     * @type {Array<AccessRequestTracking>}
     * @memberof AccessRequestResponse
     */
    'existingRequests'?: Array<AccessRequestTracking>;
}
/**
 * 
 * @export
 * @interface AccessRequestTracking
 */
export interface AccessRequestTracking {
    /**
     * The identity id in which the access request is for.
     * @type {string}
     * @memberof AccessRequestTracking
     */
    'requestedFor'?: string;
    /**
     * The details of the item requested.
     * @type {Array<RequestedItemDetails>}
     * @memberof AccessRequestTracking
     */
    'requestedItemsDetails'?: Array<RequestedItemDetails>;
    /**
     * a hash representation of the access requested, useful for longer term tracking client side.
     * @type {number}
     * @memberof AccessRequestTracking
     */
    'attributesHash'?: number;
    /**
     * a list of access request identifiers, generally only one will be populated, but high volume requested may result in multiple ids.
     * @type {Array<string>}
     * @memberof AccessRequestTracking
     */
    'accessRequestIds'?: Array<string>;
}
/**
 * Access request type. Defaults to GRANT_ACCESS. REVOKE_ACCESS type can only have a single Identity ID in the requestedFor field.
 * @export
 * @enum {string}
 */

export const AccessRequestType = {
    GrantAccess: 'GRANT_ACCESS',
    RevokeAccess: 'REVOKE_ACCESS'
} as const;

export type AccessRequestType = typeof AccessRequestType[keyof typeof AccessRequestType];


/**
 * 
 * @export
 * @interface AccessReviewItem
 */
export interface AccessReviewItem {
    /**
     * 
     * @type {AccessSummary}
     * @memberof AccessReviewItem
     */
    'accessSummary'?: AccessSummary;
    /**
     * 
     * @type {CertificationIdentitySummary}
     * @memberof AccessReviewItem
     */
    'identitySummary'?: CertificationIdentitySummary;
    /**
     * The review item\'s id
     * @type {string}
     * @memberof AccessReviewItem
     */
    'id'?: string;
    /**
     * Whether the review item is complete
     * @type {boolean}
     * @memberof AccessReviewItem
     */
    'completed'?: boolean;
    /**
     * Indicates whether the review item is for new access to a source
     * @type {boolean}
     * @memberof AccessReviewItem
     */
    'newAccess'?: boolean;
    /**
     * 
     * @type {CertificationDecision}
     * @memberof AccessReviewItem
     */
    'decision'?: CertificationDecision;
    /**
     * Comments for this review item
     * @type {string}
     * @memberof AccessReviewItem
     */
    'comments'?: string | null;
}


/**
 * 
 * @export
 * @interface AccessReviewReassignment
 */
export interface AccessReviewReassignment {
    /**
     * 
     * @type {Array<ReassignReference>}
     * @memberof AccessReviewReassignment
     */
    'reassign': Array<ReassignReference>;
    /**
     * The ID of the identity to which the certification is reassigned
     * @type {string}
     * @memberof AccessReviewReassignment
     */
    'reassignTo': string;
    /**
     * The reason comment for why the reassign was made
     * @type {string}
     * @memberof AccessReviewReassignment
     */
    'reason': string;
}
/**
 * An object holding the access that is being reviewed
 * @export
 * @interface AccessSummary
 */
export interface AccessSummary {
    /**
     * 
     * @type {AccessSummaryAccess}
     * @memberof AccessSummary
     */
    'access'?: AccessSummaryAccess;
    /**
     * 
     * @type {ReviewableEntitlement}
     * @memberof AccessSummary
     */
    'entitlement'?: ReviewableEntitlement | null;
    /**
     * 
     * @type {ReviewableAccessProfile}
     * @memberof AccessSummary
     */
    'accessProfile'?: ReviewableAccessProfile;
    /**
     * 
     * @type {ReviewableRole}
     * @memberof AccessSummary
     */
    'role'?: ReviewableRole | null;
}
/**
 * 
 * @export
 * @interface AccessSummaryAccess
 */
export interface AccessSummaryAccess {
    /**
     * 
     * @type {DtoType}
     * @memberof AccessSummaryAccess
     */
    'type'?: DtoType;
    /**
     * The ID of the item being certified
     * @type {string}
     * @memberof AccessSummaryAccess
     */
    'id'?: string;
    /**
     * The name of the item being certified
     * @type {string}
     * @memberof AccessSummaryAccess
     */
    'name'?: string;
}


/**
 * Access type of API Client indicating online or offline use
 * @export
 * @enum {string}
 */

export const AccessType = {
    Online: 'ONLINE',
    Offline: 'OFFLINE'
} as const;

export type AccessType = typeof AccessType[keyof typeof AccessType];


/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof Account
     */
    'name': string | null;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof Account
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof Account
     */
    'modified'?: string;
    /**
     * The unique ID of the source this account belongs to
     * @type {string}
     * @memberof Account
     */
    'sourceId': string;
    /**
     * The display name of the source this account belongs to
     * @type {string}
     * @memberof Account
     */
    'sourceName': string | null;
    /**
     * The unique ID of the identity this account is correlated to
     * @type {string}
     * @memberof Account
     */
    'identityId'?: string;
    /**
     * The lifecycle state of the identity this account is correlated to
     * @type {string}
     * @memberof Account
     */
    'cloudLifecycleState'?: string | null;
    /**
     * The identity state of the identity this account is correlated to
     * @type {string}
     * @memberof Account
     */
    'identityState'?: string | null;
    /**
     * The connection type of the source this account is from
     * @type {string}
     * @memberof Account
     */
    'connectionType'?: string | null;
    /**
     * Indicates if the account is of machine type
     * @type {boolean}
     * @memberof Account
     */
    'isMachine'?: boolean;
    /**
     * 
     * @type {AccountAllOfRecommendation}
     * @memberof Account
     */
    'recommendation'?: AccountAllOfRecommendation;
    /**
     * The account attributes that are aggregated
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    'attributes': { [key: string]: any; } | null;
    /**
     * Indicates if this account is from an authoritative source
     * @type {boolean}
     * @memberof Account
     */
    'authoritative': boolean;
    /**
     * A description of the account
     * @type {string}
     * @memberof Account
     */
    'description'?: string | null;
    /**
     * Indicates if the account is currently disabled
     * @type {boolean}
     * @memberof Account
     */
    'disabled': boolean;
    /**
     * Indicates if the account is currently locked
     * @type {boolean}
     * @memberof Account
     */
    'locked': boolean;
    /**
     * The unique ID of the account generated by the source system
     * @type {string}
     * @memberof Account
     */
    'nativeIdentity': string;
    /**
     * If true, this is a user account within IdentityNow.  If false, this is an account from a source system.
     * @type {boolean}
     * @memberof Account
     */
    'systemAccount': boolean;
    /**
     * Indicates if this account is not correlated to an identity
     * @type {boolean}
     * @memberof Account
     */
    'uncorrelated': boolean;
    /**
     * The unique ID of the account as determined by the account schema
     * @type {string}
     * @memberof Account
     */
    'uuid'?: string | null;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof Account
     */
    'manuallyCorrelated': boolean;
    /**
     * Indicates if the account has entitlements
     * @type {boolean}
     * @memberof Account
     */
    'hasEntitlements': boolean;
    /**
     * 
     * @type {AccountAllOfIdentity}
     * @memberof Account
     */
    'identity'?: AccountAllOfIdentity;
    /**
     * 
     * @type {AccountAllOfSourceOwner}
     * @memberof Account
     */
    'sourceOwner'?: AccountAllOfSourceOwner | null;
    /**
     * A string list containing the owning source\'s features
     * @type {string}
     * @memberof Account
     */
    'features'?: string | null;
    /**
     * The origin of the account either aggregated or provisioned
     * @type {string}
     * @memberof Account
     */
    'origin'?: AccountOriginV3 | null;
    /**
     * 
     * @type {AccountAllOfOwnerIdentity}
     * @memberof Account
     */
    'ownerIdentity'?: AccountAllOfOwnerIdentity;
}

export const AccountOriginV3 = {
    Aggregated: 'AGGREGATED',
    Provisioned: 'PROVISIONED'
} as const;

export type AccountOriginV3 = typeof AccountOriginV3[keyof typeof AccountOriginV3];

/**
 * Object for specifying Actions to be performed on a specified list of sources\' account.
 * @export
 * @interface AccountAction
 */
export interface AccountAction {
    /**
     * Describes if action will be enabled or disabled
     * @type {string}
     * @memberof AccountAction
     */
    'action'?: AccountActionActionV3;
    /**
     * List of unique source IDs. The sources must have the ENABLE feature or flat file source. See \"/sources\" endpoint for source features.
     * @type {Set<string>}
     * @memberof AccountAction
     */
    'sourceIds'?: Set<string>;
}

export const AccountActionActionV3 = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type AccountActionActionV3 = typeof AccountActionActionV3[keyof typeof AccountActionActionV3];

/**
 * 
 * @export
 * @interface AccountActivity
 */
export interface AccountActivity {
    /**
     * Id of the account activity
     * @type {string}
     * @memberof AccountActivity
     */
    'id'?: string;
    /**
     * The name of the activity
     * @type {string}
     * @memberof AccountActivity
     */
    'name'?: string;
    /**
     * When the activity was first created
     * @type {string}
     * @memberof AccountActivity
     */
    'created'?: string;
    /**
     * When the activity was last modified
     * @type {string}
     * @memberof AccountActivity
     */
    'modified'?: string | null;
    /**
     * When the activity was completed
     * @type {string}
     * @memberof AccountActivity
     */
    'completed'?: string | null;
    /**
     * 
     * @type {CompletionStatus}
     * @memberof AccountActivity
     */
    'completionStatus'?: CompletionStatus | null;
    /**
     * The type of action the activity performed.  Please see the following list of types.  This list may grow over time.  - CloudAutomated - IdentityAttributeUpdate - appRequest - LifecycleStateChange - AccountStateUpdate - AccountAttributeUpdate - CloudPasswordRequest - Attribute Synchronization Refresh - Certification - Identity Refresh - Lifecycle Change Refresh   [Learn more here](https://documentation.sailpoint.com/saas/help/search/searchable-fields.html#searching-account-activity-data). 
     * @type {string}
     * @memberof AccountActivity
     */
    'type'?: string | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivity
     */
    'requesterIdentitySummary'?: IdentitySummary | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivity
     */
    'targetIdentitySummary'?: IdentitySummary | null;
    /**
     * A list of error messages, if any, that were encountered.
     * @type {Array<string>}
     * @memberof AccountActivity
     */
    'errors'?: Array<string> | null;
    /**
     * A list of warning messages, if any, that were encountered.
     * @type {Array<string>}
     * @memberof AccountActivity
     */
    'warnings'?: Array<string> | null;
    /**
     * Individual actions performed as part of this account activity
     * @type {Array<AccountActivityItem>}
     * @memberof AccountActivity
     */
    'items'?: Array<AccountActivityItem> | null;
    /**
     * 
     * @type {ExecutionStatus}
     * @memberof AccountActivity
     */
    'executionStatus'?: ExecutionStatus;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request
     * @type {{ [key: string]: string; }}
     * @memberof AccountActivity
     */
    'clientMetadata'?: { [key: string]: string; } | null;
}


/**
 * The state of an approval status
 * @export
 * @enum {string}
 */

export const AccountActivityApprovalStatus = {
    Finished: 'FINISHED',
    Rejected: 'REJECTED',
    Returned: 'RETURNED',
    Expired: 'EXPIRED',
    Pending: 'PENDING',
    Canceled: 'CANCELED'
} as const;

export type AccountActivityApprovalStatus = typeof AccountActivityApprovalStatus[keyof typeof AccountActivityApprovalStatus];


/**
 * AccountActivity
 * @export
 * @interface AccountActivityDocument
 */
export interface AccountActivityDocument {
    /**
     * ID of account activity.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'id'?: string;
    /**
     * Type of action performed in the activity.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'action'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'synced'?: string;
    /**
     * Activity\'s current stage.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'stage'?: string;
    /**
     * Activity\'s current status.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'status'?: string;
    /**
     * 
     * @type {ActivityIdentity}
     * @memberof AccountActivityDocument
     */
    'requester'?: ActivityIdentity;
    /**
     * 
     * @type {ActivityIdentity}
     * @memberof AccountActivityDocument
     */
    'recipient'?: ActivityIdentity;
    /**
     * Account activity\'s tracking number.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'trackingNumber'?: string;
    /**
     * Errors provided by the source while completing account actions.
     * @type {Array<string>}
     * @memberof AccountActivityDocument
     */
    'errors'?: Array<string> | null;
    /**
     * Warnings provided by the source while completing account actions.
     * @type {Array<string>}
     * @memberof AccountActivityDocument
     */
    'warnings'?: Array<string> | null;
    /**
     * Approvals performed on an item during activity.
     * @type {Array<Approval>}
     * @memberof AccountActivityDocument
     */
    'approvals'?: Array<Approval>;
    /**
     * Original actions that triggered all individual source actions related to the account action.
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivityDocument
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * Controls that translated the attribute requests into actual provisioning actions on the source.
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivityDocument
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * Account data for each individual source action triggered by the original requests.
     * @type {Array<AccountRequest>}
     * @memberof AccountActivityDocument
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * Sources involved in the account activity.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'sources'?: string;
}
/**
 * 
 * @export
 * @interface AccountActivityDocuments
 */
export interface AccountActivityDocuments {
    /**
     * ID of account activity.
     * @type {string}
     * @memberof AccountActivityDocuments
     */
    'id'?: string;
    /**
     * Type of action performed in the activity.
     * @type {string}
     * @memberof AccountActivityDocuments
     */
    'action'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof AccountActivityDocuments
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof AccountActivityDocuments
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof AccountActivityDocuments
     */
    'synced'?: string;
    /**
     * Activity\'s current stage.
     * @type {string}
     * @memberof AccountActivityDocuments
     */
    'stage'?: string;
    /**
     * Activity\'s current status.
     * @type {string}
     * @memberof AccountActivityDocuments
     */
    'status'?: string;
    /**
     * 
     * @type {ActivityIdentity}
     * @memberof AccountActivityDocuments
     */
    'requester'?: ActivityIdentity;
    /**
     * 
     * @type {ActivityIdentity}
     * @memberof AccountActivityDocuments
     */
    'recipient'?: ActivityIdentity;
    /**
     * Account activity\'s tracking number.
     * @type {string}
     * @memberof AccountActivityDocuments
     */
    'trackingNumber'?: string;
    /**
     * Errors provided by the source while completing account actions.
     * @type {Array<string>}
     * @memberof AccountActivityDocuments
     */
    'errors'?: Array<string> | null;
    /**
     * Warnings provided by the source while completing account actions.
     * @type {Array<string>}
     * @memberof AccountActivityDocuments
     */
    'warnings'?: Array<string> | null;
    /**
     * Approvals performed on an item during activity.
     * @type {Array<Approval>}
     * @memberof AccountActivityDocuments
     */
    'approvals'?: Array<Approval>;
    /**
     * Original actions that triggered all individual source actions related to the account action.
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivityDocuments
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * Controls that translated the attribute requests into actual provisioning actions on the source.
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivityDocuments
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * Account data for each individual source action triggered by the original requests.
     * @type {Array<AccountRequest>}
     * @memberof AccountActivityDocuments
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * Sources involved in the account activity.
     * @type {string}
     * @memberof AccountActivityDocuments
     */
    'sources'?: string;
    /**
     * Name of the pod.
     * @type {string}
     * @memberof AccountActivityDocuments
     */
    'pod'?: string;
    /**
     * Name of the tenant.
     * @type {string}
     * @memberof AccountActivityDocuments
     */
    'org'?: string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccountActivityDocuments
     */
    '_type'?: DocumentType;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccountActivityDocuments
     */
    'type'?: DocumentType;
    /**
     * Version number.
     * @type {string}
     * @memberof AccountActivityDocuments
     */
    '_version'?: string;
}


/**
 * 
 * @export
 * @interface AccountActivityItem
 */
export interface AccountActivityItem {
    /**
     * Item id
     * @type {string}
     * @memberof AccountActivityItem
     */
    'id'?: string;
    /**
     * Human-readable display name of item
     * @type {string}
     * @memberof AccountActivityItem
     */
    'name'?: string;
    /**
     * Date and time item was requested
     * @type {string}
     * @memberof AccountActivityItem
     */
    'requested'?: string;
    /**
     * 
     * @type {AccountActivityApprovalStatus}
     * @memberof AccountActivityItem
     */
    'approvalStatus'?: AccountActivityApprovalStatus | null;
    /**
     * 
     * @type {ProvisioningState}
     * @memberof AccountActivityItem
     */
    'provisioningStatus'?: ProvisioningState;
    /**
     * 
     * @type {Comment}
     * @memberof AccountActivityItem
     */
    'requesterComment'?: Comment | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivityItem
     */
    'reviewerIdentitySummary'?: IdentitySummary | null;
    /**
     * 
     * @type {Comment}
     * @memberof AccountActivityItem
     */
    'reviewerComment'?: Comment | null;
    /**
     * 
     * @type {AccountActivityItemOperation}
     * @memberof AccountActivityItem
     */
    'operation'?: AccountActivityItemOperation | null;
    /**
     * Attribute to which account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'attribute'?: string | null;
    /**
     * Value of attribute
     * @type {string}
     * @memberof AccountActivityItem
     */
    'value'?: string | null;
    /**
     * Native identity in the target system to which the account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'nativeIdentity'?: string | null;
    /**
     * Id of Source to which account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'sourceId'?: string;
    /**
     * 
     * @type {AccountRequestInfo}
     * @memberof AccountActivityItem
     */
    'accountRequestInfo'?: AccountRequestInfo | null;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request item
     * @type {{ [key: string]: string; }}
     * @memberof AccountActivityItem
     */
    'clientMetadata'?: { [key: string]: string; } | null;
    /**
     * The date the role or access profile or entitlement is no longer assigned to the specified identity.
     * @type {string}
     * @memberof AccountActivityItem
     */
    'removeDate'?: string | null;
}


/**
 * Represents an operation in an account activity item
 * @export
 * @enum {string}
 */

export const AccountActivityItemOperation = {
    Add: 'ADD',
    Create: 'CREATE',
    Modify: 'MODIFY',
    Delete: 'DELETE',
    Disable: 'DISABLE',
    Enable: 'ENABLE',
    Unlock: 'UNLOCK',
    Lock: 'LOCK',
    Remove: 'REMOVE',
    Set: 'SET'
} as const;

export type AccountActivityItemOperation = typeof AccountActivityItemOperation[keyof typeof AccountActivityItemOperation];


/**
 * AccountActivity
 * @export
 * @interface AccountActivitySearchedItem
 */
export interface AccountActivitySearchedItem {
    /**
     * ID of account activity.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'id'?: string;
    /**
     * Type of action performed in the activity.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'action'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'synced'?: string;
    /**
     * Activity\'s current stage.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'stage'?: string;
    /**
     * Activity\'s current status.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'status'?: string;
    /**
     * 
     * @type {ActivityIdentity}
     * @memberof AccountActivitySearchedItem
     */
    'requester'?: ActivityIdentity;
    /**
     * 
     * @type {ActivityIdentity}
     * @memberof AccountActivitySearchedItem
     */
    'recipient'?: ActivityIdentity;
    /**
     * Account activity\'s tracking number.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'trackingNumber'?: string;
    /**
     * Errors provided by the source while completing account actions.
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItem
     */
    'errors'?: Array<string> | null;
    /**
     * Warnings provided by the source while completing account actions.
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItem
     */
    'warnings'?: Array<string> | null;
    /**
     * Approvals performed on an item during activity.
     * @type {Array<Approval>}
     * @memberof AccountActivitySearchedItem
     */
    'approvals'?: Array<Approval>;
    /**
     * Original actions that triggered all individual source actions related to the account action.
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivitySearchedItem
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * Controls that translated the attribute requests into actual provisioning actions on the source.
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivitySearchedItem
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * Account data for each individual source action triggered by the original requests.
     * @type {Array<AccountRequest>}
     * @memberof AccountActivitySearchedItem
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * Sources involved in the account activity.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'sources'?: string;
}
/**
 * The identity this account is correlated to
 * @export
 * @interface AccountAllOfIdentity
 */
export interface AccountAllOfIdentity {
    /**
     * The ID of the identity
     * @type {string}
     * @memberof AccountAllOfIdentity
     */
    'id'?: string;
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof AccountAllOfIdentity
     */
    'type'?: AccountAllOfIdentityTypeV3;
    /**
     * display name of identity
     * @type {string}
     * @memberof AccountAllOfIdentity
     */
    'name'?: string;
}

export const AccountAllOfIdentityTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type AccountAllOfIdentityTypeV3 = typeof AccountAllOfIdentityTypeV3[keyof typeof AccountAllOfIdentityTypeV3];

/**
 * 
 * @export
 * @interface AccountAllOfOwnerIdentity
 */
export interface AccountAllOfOwnerIdentity {
    /**
     * 
     * @type {DtoType}
     * @memberof AccountAllOfOwnerIdentity
     */
    'type'?: DtoType;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof AccountAllOfOwnerIdentity
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof AccountAllOfOwnerIdentity
     */
    'name'?: string;
}


/**
 * 
 * @export
 * @interface AccountAllOfRecommendation
 */
export interface AccountAllOfRecommendation {
    /**
     * Recommended type of account.
     * @type {string}
     * @memberof AccountAllOfRecommendation
     */
    'type': AccountAllOfRecommendationTypeV3;
    /**
     * Method used to produce the recommendation. DISCOVERY - suggested by AI, SOURCE - the account comes from a source flagged as containing machine accounts, CRITERIA - the account satisfies classification criteria.
     * @type {string}
     * @memberof AccountAllOfRecommendation
     */
    'method': AccountAllOfRecommendationMethodV3;
}

export const AccountAllOfRecommendationTypeV3 = {
    Human: 'HUMAN',
    Machine: 'MACHINE'
} as const;

export type AccountAllOfRecommendationTypeV3 = typeof AccountAllOfRecommendationTypeV3[keyof typeof AccountAllOfRecommendationTypeV3];
export const AccountAllOfRecommendationMethodV3 = {
    Discovery: 'DISCOVERY',
    Source: 'SOURCE',
    Criteria: 'CRITERIA'
} as const;

export type AccountAllOfRecommendationMethodV3 = typeof AccountAllOfRecommendationMethodV3[keyof typeof AccountAllOfRecommendationMethodV3];

/**
 * The owner of the source this account belongs to.
 * @export
 * @interface AccountAllOfSourceOwner
 */
export interface AccountAllOfSourceOwner {
    /**
     * The ID of the identity
     * @type {string}
     * @memberof AccountAllOfSourceOwner
     */
    'id'?: string;
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof AccountAllOfSourceOwner
     */
    'type'?: AccountAllOfSourceOwnerTypeV3;
    /**
     * display name of identity
     * @type {string}
     * @memberof AccountAllOfSourceOwner
     */
    'name'?: string;
}

export const AccountAllOfSourceOwnerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type AccountAllOfSourceOwnerTypeV3 = typeof AccountAllOfSourceOwnerTypeV3[keyof typeof AccountAllOfSourceOwnerTypeV3];

/**
 * 
 * @export
 * @interface AccountAttribute
 */
export interface AccountAttribute {
    /**
     * A reference to the source to search for the account
     * @type {string}
     * @memberof AccountAttribute
     */
    'sourceName': string;
    /**
     * The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema.
     * @type {string}
     * @memberof AccountAttribute
     */
    'attributeName': string;
    /**
     * The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountSortAttribute'?: string;
    /**
     * The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'accountSortDescending'?: boolean;
    /**
     * The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'accountReturnFirstLink'?: boolean;
    /**
     * This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria. Only certain searchable attributes are available:  - `nativeIdentity` - the Account ID  - `displayName` - the Account Name  - `entitlements` - a boolean value to determine if the account has entitlements
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountFilter'?: string;
    /**
     * This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.  All account attributes are available for filtering as this operation is performed in memory.
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountPropertyFilter'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof AccountAttribute
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface AccountAttributes
 */
export interface AccountAttributes {
    /**
     * The schema attribute values for the account
     * @type {{ [key: string]: any; }}
     * @memberof AccountAttributes
     */
    'attributes': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface AccountAttributesCreate
 */
export interface AccountAttributesCreate {
    /**
     * 
     * @type {AccountAttributesCreateAttributes}
     * @memberof AccountAttributesCreate
     */
    'attributes': AccountAttributesCreateAttributes;
}
/**
 * The schema attribute values for the account
 * @export
 * @interface AccountAttributesCreateAttributes
 */
export interface AccountAttributesCreateAttributes {
    [key: string]: string | any;

    /**
     * Target source to create an account
     * @type {string}
     * @memberof AccountAttributesCreateAttributes
     */
    'sourceId': string;
}
/**
 * 
 * @export
 * @interface AccountRequest
 */
export interface AccountRequest {
    /**
     * Unique ID of the account
     * @type {string}
     * @memberof AccountRequest
     */
    'accountId'?: string;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof AccountRequest
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * The operation that was performed
     * @type {string}
     * @memberof AccountRequest
     */
    'op'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountRequest
     */
    'provisioningTarget'?: AccountSource;
    /**
     * 
     * @type {AccountRequestResult}
     * @memberof AccountRequest
     */
    'result'?: AccountRequestResult;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountRequest
     */
    'source'?: AccountSource;
}
/**
 * If an account activity item is associated with an access request, captures details of that request.
 * @export
 * @interface AccountRequestInfo
 */
export interface AccountRequestInfo {
    /**
     * Id of requested object
     * @type {string}
     * @memberof AccountRequestInfo
     */
    'requestedObjectId'?: string;
    /**
     * Human-readable name of requested object
     * @type {string}
     * @memberof AccountRequestInfo
     */
    'requestedObjectName'?: string;
    /**
     * 
     * @type {RequestableObjectType}
     * @memberof AccountRequestInfo
     */
    'requestedObjectType'?: RequestableObjectType;
}


/**
 * 
 * @export
 * @interface AccountRequestResult
 */
export interface AccountRequestResult {
    /**
     * Error message.
     * @type {Array<string>}
     * @memberof AccountRequestResult
     */
    'errors'?: Array<string>;
    /**
     * The status of the account request
     * @type {string}
     * @memberof AccountRequestResult
     */
    'status'?: string;
    /**
     * ID of associated ticket.
     * @type {string}
     * @memberof AccountRequestResult
     */
    'ticketId'?: string | null;
}
/**
 * 
 * @export
 * @interface AccountSource
 */
export interface AccountSource {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccountSource
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccountSource
     */
    'name'?: string;
    /**
     * Type of source returned.
     * @type {string}
     * @memberof AccountSource
     */
    'type'?: string;
}
/**
 * Request used for account enable/disable
 * @export
 * @interface AccountToggleRequest
 */
export interface AccountToggleRequest {
    /**
     * If set, an external process validates that the user wants to proceed with this request.
     * @type {string}
     * @memberof AccountToggleRequest
     */
    'externalVerificationId'?: string;
    /**
     * If set, provisioning updates the account attribute at the source.   This option is used when the account is not synced to ensure the attribute is updated. Providing \'true\' for an unlocked account will add and process \'Unlock\' operation by the workflow.
     * @type {boolean}
     * @memberof AccountToggleRequest
     */
    'forceProvisioning'?: boolean;
}
/**
 * Request used for account unlock
 * @export
 * @interface AccountUnlockRequest
 */
export interface AccountUnlockRequest {
    /**
     * If set, an external process validates that the user wants to proceed with this request.
     * @type {string}
     * @memberof AccountUnlockRequest
     */
    'externalVerificationId'?: string;
    /**
     * If set, the IDN account is unlocked after the workflow completes.
     * @type {boolean}
     * @memberof AccountUnlockRequest
     */
    'unlockIDNAccount'?: boolean;
    /**
     * If set, provisioning updates the account attribute at the source.   This option is used when the account is not synced to ensure the attribute is updated.
     * @type {boolean}
     * @memberof AccountUnlockRequest
     */
    'forceProvisioning'?: boolean;
}
/**
 * 
 * @export
 * @interface AccountUsage
 */
export interface AccountUsage {
    /**
     * The first day of the month for which activity is aggregated.
     * @type {string}
     * @memberof AccountUsage
     */
    'date'?: string;
    /**
     * The number of days within the month that the account was active in a source.
     * @type {number}
     * @memberof AccountUsage
     */
    'count'?: number;
}
/**
 * Accounts async response containing details on started async process
 * @export
 * @interface AccountsAsyncResult
 */
export interface AccountsAsyncResult {
    /**
     * id of the task
     * @type {string}
     * @memberof AccountsAsyncResult
     */
    'id': string;
}
/**
 * Arguments for Account Export report (ACCOUNTS)
 * @export
 * @interface AccountsExportReportArguments
 */
export interface AccountsExportReportArguments {
    /**
     * Source ID.
     * @type {string}
     * @memberof AccountsExportReportArguments
     */
    'application': string;
    /**
     * Source name.
     * @type {string}
     * @memberof AccountsExportReportArguments
     */
    'sourceName': string;
}
/**
 * 
 * @export
 * @interface ActivateCampaignOptions
 */
export interface ActivateCampaignOptions {
    /**
     * The timezone must be in a valid ISO 8601 format. Timezones in ISO 8601 are represented as UTC (represented as \'Z\') or as an offset from UTC. The offset format can be +/-hh:mm, +/-hhmm, or +/-hh.
     * @type {string}
     * @memberof ActivateCampaignOptions
     */
    'timeZone'?: string;
}
/**
 * 
 * @export
 * @interface ActivityIdentity
 */
export interface ActivityIdentity {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof ActivityIdentity
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof ActivityIdentity
     */
    'name'?: string;
    /**
     * Type of object
     * @type {string}
     * @memberof ActivityIdentity
     */
    'type'?: string;
}
/**
 * Insights into account activity
 * @export
 * @interface ActivityInsights
 */
export interface ActivityInsights {
    /**
     * UUID of the account
     * @type {string}
     * @memberof ActivityInsights
     */
    'accountID'?: string;
    /**
     * The number of days of activity
     * @type {number}
     * @memberof ActivityInsights
     */
    'usageDays'?: number;
    /**
     * Status indicating if the activity is complete or unknown
     * @type {string}
     * @memberof ActivityInsights
     */
    'usageDaysState'?: ActivityInsightsUsageDaysStateV3;
}

export const ActivityInsightsUsageDaysStateV3 = {
    Complete: 'COMPLETE',
    Unknown: 'UNKNOWN'
} as const;

export type ActivityInsightsUsageDaysStateV3 = typeof ActivityInsightsUsageDaysStateV3[keyof typeof ActivityInsightsUsageDaysStateV3];

/**
 * 
 * @export
 * @interface AdminReviewReassign
 */
export interface AdminReviewReassign {
    /**
     * List of certification IDs to reassign
     * @type {Array<string>}
     * @memberof AdminReviewReassign
     */
    'certificationIds'?: Array<string>;
    /**
     * 
     * @type {AdminReviewReassignReassignTo}
     * @memberof AdminReviewReassign
     */
    'reassignTo'?: AdminReviewReassignReassignTo;
    /**
     * Comment to explain why the certification was reassigned
     * @type {string}
     * @memberof AdminReviewReassign
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface AdminReviewReassignReassignTo
 */
export interface AdminReviewReassignReassignTo {
    /**
     * The identity ID to which the review is being assigned.
     * @type {string}
     * @memberof AdminReviewReassignReassignTo
     */
    'id'?: string;
    /**
     * The type of the ID provided.
     * @type {string}
     * @memberof AdminReviewReassignReassignTo
     */
    'type'?: AdminReviewReassignReassignToTypeV3;
}

export const AdminReviewReassignReassignToTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type AdminReviewReassignReassignToTypeV3 = typeof AdminReviewReassignReassignToTypeV3[keyof typeof AdminReviewReassignReassignToTypeV3];

/**
 * 
 * @export
 * @interface AggregationResult
 */
export interface AggregationResult {
    /**
     * The document containing the results of the aggregation. This document is controlled by Elasticsearch and depends on the type of aggregation query that is run.  See Elasticsearch [Aggregations](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations.html) documentation for information. 
     * @type {object}
     * @memberof AggregationResult
     */
    'aggregations'?: object;
    /**
     * The results of the aggregation search query. 
     * @type {Array<SearchDocuments>}
     * @memberof AggregationResult
     */
    'hits'?: Array<SearchDocuments>;
}
/**
 * Enum representing the currently available query languages for aggregations, which are used to perform calculations or groupings on search results.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const AggregationType = {
    Dsl: 'DSL',
    Sailpoint: 'SAILPOINT'
} as const;

export type AggregationType = typeof AggregationType[keyof typeof AggregationType];


/**
 * 
 * @export
 * @interface Aggregations
 */
export interface Aggregations {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof Aggregations
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof Aggregations
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof Aggregations
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof Aggregations
     */
    'bucket'?: BucketAggregation;
}
/**
 * 
 * @export
 * @interface App
 */
export interface App {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof App
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof App
     */
    'name'?: string;
    /**
     * 
     * @type {Reference1}
     * @memberof App
     */
    'source'?: Reference1;
    /**
     * 
     * @type {AppAllOfAccount}
     * @memberof App
     */
    'account'?: AppAllOfAccount;
}
/**
 * 
 * @export
 * @interface AppAllOfAccount
 */
export interface AppAllOfAccount {
    /**
     * The SailPoint generated unique ID
     * @type {string}
     * @memberof AppAllOfAccount
     */
    'id'?: string;
    /**
     * The account ID generated by the source
     * @type {string}
     * @memberof AppAllOfAccount
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface Approval
 */
export interface Approval {
    /**
     * 
     * @type {Array<ApprovalComment>}
     * @memberof Approval
     */
    'comments'?: Array<ApprovalComment>;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Approval
     */
    'modified'?: string | null;
    /**
     * 
     * @type {ActivityIdentity}
     * @memberof Approval
     */
    'owner'?: ActivityIdentity;
    /**
     * The result of the approval
     * @type {string}
     * @memberof Approval
     */
    'result'?: string;
    /**
     * 
     * @type {AttributeRequest}
     * @memberof Approval
     */
    'attributeRequest'?: AttributeRequest;
    /**
     * 
     * @type {AccountSource}
     * @memberof Approval
     */
    'source'?: AccountSource;
}
/**
 * 
 * @export
 * @interface ApprovalComment
 */
export interface ApprovalComment {
    /**
     * The comment text
     * @type {string}
     * @memberof ApprovalComment
     */
    'comment'?: string;
    /**
     * The name of the commenter
     * @type {string}
     * @memberof ApprovalComment
     */
    'commenter'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof ApprovalComment
     */
    'date'?: string | null;
}
/**
 * 
 * @export
 * @interface ApprovalForwardHistory
 */
export interface ApprovalForwardHistory {
    /**
     * Display name of approver from whom the approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'oldApproverName'?: string;
    /**
     * Display name of approver to whom the approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'newApproverName'?: string;
    /**
     * Comment made while forwarding.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'comment'?: string | null;
    /**
     * Time at which approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'modified'?: string;
    /**
     * Display name of forwarder who forwarded the approval.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'forwarderName'?: string | null;
    /**
     * 
     * @type {ReassignmentType}
     * @memberof ApprovalForwardHistory
     */
    'reassignmentType'?: ReassignmentType;
}


/**
 * 
 * @export
 * @interface ApprovalItemDetails
 */
export interface ApprovalItemDetails {
    /**
     * The approval item\'s ID
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'id'?: string;
    /**
     * The account referenced by the approval item
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'account'?: string | null;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'application'?: string;
    /**
     * The attribute\'s name
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'name'?: string | null;
    /**
     * The attribute\'s operation
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'operation'?: string;
    /**
     * The attribute\'s value
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'value'?: string | null;
    /**
     * 
     * @type {WorkItemState & object}
     * @memberof ApprovalItemDetails
     */
    'state'?: WorkItemState & object;
}
/**
 * 
 * @export
 * @interface ApprovalItems
 */
export interface ApprovalItems {
    /**
     * The approval item\'s ID
     * @type {string}
     * @memberof ApprovalItems
     */
    'id'?: string;
    /**
     * The account referenced by the approval item
     * @type {string}
     * @memberof ApprovalItems
     */
    'account'?: string | null;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof ApprovalItems
     */
    'application'?: string;
    /**
     * The attribute\'s name
     * @type {string}
     * @memberof ApprovalItems
     */
    'name'?: string | null;
    /**
     * The attribute\'s operation
     * @type {string}
     * @memberof ApprovalItems
     */
    'operation'?: string;
    /**
     * The attribute\'s value
     * @type {string}
     * @memberof ApprovalItems
     */
    'value'?: string | null;
    /**
     * 
     * @type {WorkItemState & object}
     * @memberof ApprovalItems
     */
    'state'?: WorkItemState & object;
}
/**
 * 
 * @export
 * @interface ApprovalReminderAndEscalationConfig
 */
export interface ApprovalReminderAndEscalationConfig {
    /**
     * Number of days to wait before the first reminder. If no reminders are configured, then this is the number of days to wait before escalation.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'daysUntilEscalation'?: number | null;
    /**
     * Number of days to wait between reminder notifications.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'daysBetweenReminders'?: number | null;
    /**
     * Maximum number of reminder notification to send to the reviewer before approval escalation.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'maxReminders'?: number | null;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'fallbackApproverRef'?: IdentityReferenceWithNameAndEmail | null;
}
/**
 * Describes the individual or group that is responsible for an approval step.
 * @export
 * @enum {string}
 */

export const ApprovalScheme = {
    AppOwner: 'APP_OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    RoleOwner: 'ROLE_OWNER',
    AccessProfileOwner: 'ACCESS_PROFILE_OWNER',
    EntitlementOwner: 'ENTITLEMENT_OWNER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type ApprovalScheme = typeof ApprovalScheme[keyof typeof ApprovalScheme];


/**
 * 
 * @export
 * @interface ApprovalSchemeForRole
 */
export interface ApprovalSchemeForRole {
    /**
     * Describes the individual or group that is responsible for an approval step. Values are as follows.  **OWNER**: Owner of the associated Role  **MANAGER**: Manager of the Identity making the request  **GOVERNANCE_GROUP**: A Governance Group, the ID of which is specified by the **approverId** field
     * @type {string}
     * @memberof ApprovalSchemeForRole
     */
    'approverType'?: ApprovalSchemeForRoleApproverTypeV3;
    /**
     * Id of the specific approver, used only when approverType is GOVERNANCE_GROUP
     * @type {string}
     * @memberof ApprovalSchemeForRole
     */
    'approverId'?: string | null;
}

export const ApprovalSchemeForRoleApproverTypeV3 = {
    Owner: 'OWNER',
    Manager: 'MANAGER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type ApprovalSchemeForRoleApproverTypeV3 = typeof ApprovalSchemeForRoleApproverTypeV3[keyof typeof ApprovalSchemeForRoleApproverTypeV3];

/**
 * Enum representing the non-employee request approval status
 * @export
 * @enum {string}
 */

export const ApprovalStatus = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Pending: 'PENDING',
    NotReady: 'NOT_READY',
    Cancelled: 'CANCELLED'
} as const;

export type ApprovalStatus = typeof ApprovalStatus[keyof typeof ApprovalStatus];


/**
 * 
 * @export
 * @interface ApprovalStatusDto
 */
export interface ApprovalStatusDto {
    /**
     * Unique identifier for the approval.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'approvalId'?: string | null;
    /**
     * True if the request for this item was forwarded from one owner to another.
     * @type {boolean}
     * @memberof ApprovalStatusDto
     */
    'forwarded'?: boolean;
    /**
     * 
     * @type {ApprovalStatusDtoOriginalOwner}
     * @memberof ApprovalStatusDto
     */
    'originalOwner'?: ApprovalStatusDtoOriginalOwner;
    /**
     * 
     * @type {ApprovalStatusDtoCurrentOwner}
     * @memberof ApprovalStatusDto
     */
    'currentOwner'?: ApprovalStatusDtoCurrentOwner;
    /**
     * Time at which item was modified.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'modified'?: string | null;
    /**
     * 
     * @type {ManualWorkItemState}
     * @memberof ApprovalStatusDto
     */
    'status'?: ManualWorkItemState;
    /**
     * 
     * @type {ApprovalScheme}
     * @memberof ApprovalStatusDto
     */
    'scheme'?: ApprovalScheme;
    /**
     * If the request failed, includes any error messages that were generated.
     * @type {Array<ErrorMessageDto>}
     * @memberof ApprovalStatusDto
     */
    'errorMessages'?: Array<ErrorMessageDto> | null;
    /**
     * Comment, if any, provided by the approver.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'comment'?: string | null;
    /**
     * The date the role or access profile or entitlement is no longer assigned to the specified identity.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'removeDate'?: string | null;
}


/**
 * 
 * @export
 * @interface ApprovalStatusDtoCurrentOwner
 */
export interface ApprovalStatusDtoCurrentOwner {
    /**
     * DTO type of identity who reviewed the access item request.
     * @type {string}
     * @memberof ApprovalStatusDtoCurrentOwner
     */
    'type'?: ApprovalStatusDtoCurrentOwnerTypeV3;
    /**
     * ID of identity who reviewed the access item request.
     * @type {string}
     * @memberof ApprovalStatusDtoCurrentOwner
     */
    'id'?: string;
    /**
     * Human-readable display name of identity who reviewed the access item request.
     * @type {string}
     * @memberof ApprovalStatusDtoCurrentOwner
     */
    'name'?: string;
}

export const ApprovalStatusDtoCurrentOwnerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type ApprovalStatusDtoCurrentOwnerTypeV3 = typeof ApprovalStatusDtoCurrentOwnerTypeV3[keyof typeof ApprovalStatusDtoCurrentOwnerTypeV3];

/**
 * Identity of orginal approval owner.
 * @export
 * @interface ApprovalStatusDtoOriginalOwner
 */
export interface ApprovalStatusDtoOriginalOwner {
    /**
     * DTO type of original approval owner\'s identity.
     * @type {string}
     * @memberof ApprovalStatusDtoOriginalOwner
     */
    'type'?: ApprovalStatusDtoOriginalOwnerTypeV3;
    /**
     * ID of original approval owner\'s identity.
     * @type {string}
     * @memberof ApprovalStatusDtoOriginalOwner
     */
    'id'?: string;
    /**
     * Display name of original approval owner.
     * @type {string}
     * @memberof ApprovalStatusDtoOriginalOwner
     */
    'name'?: string;
}

export const ApprovalStatusDtoOriginalOwnerTypeV3 = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type ApprovalStatusDtoOriginalOwnerTypeV3 = typeof ApprovalStatusDtoOriginalOwnerTypeV3[keyof typeof ApprovalStatusDtoOriginalOwnerTypeV3];

/**
 * 
 * @export
 * @interface ApprovalSummary
 */
export interface ApprovalSummary {
    /**
     * The number of pending access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'pending'?: number;
    /**
     * The number of approved access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'approved'?: number;
    /**
     * The number of rejected access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'rejected'?: number;
}
/**
 * 
 * @export
 * @interface ArrayInner
 */
export interface ArrayInner {
}
/**
 * 
 * @export
 * @interface AttributeDTO
 */
export interface AttributeDTO {
    /**
     * Technical name of the Attribute. This is unique and cannot be changed after creation.
     * @type {string}
     * @memberof AttributeDTO
     */
    'key'?: string;
    /**
     * The display name of the key.
     * @type {string}
     * @memberof AttributeDTO
     */
    'name'?: string;
    /**
     * Indicates whether the attribute can have multiple values.
     * @type {boolean}
     * @memberof AttributeDTO
     */
    'multiselect'?: boolean;
    /**
     * The status of the Attribute.
     * @type {string}
     * @memberof AttributeDTO
     */
    'status'?: string;
    /**
     * The type of the Attribute. This can be either \"custom\" or \"governance\".
     * @type {string}
     * @memberof AttributeDTO
     */
    'type'?: string;
    /**
     * An array of object types this attributes values can be applied to. Possible values are \"all\" or \"entitlement\". Value \"all\" means this attribute can be used with all object types that are supported.
     * @type {Array<string>}
     * @memberof AttributeDTO
     */
    'objectTypes'?: Array<string> | null;
    /**
     * The description of the Attribute.
     * @type {string}
     * @memberof AttributeDTO
     */
    'description'?: string;
    /**
     * 
     * @type {Array<AttributeValueDTO>}
     * @memberof AttributeDTO
     */
    'values'?: Array<AttributeValueDTO> | null;
}
/**
 * 
 * @export
 * @interface AttributeDTOList
 */
export interface AttributeDTOList {
    /**
     * 
     * @type {Array<AttributeDTO>}
     * @memberof AttributeDTOList
     */
    'attributes'?: Array<AttributeDTO> | null;
}
/**
 * 
 * @export
 * @interface AttributeDefinition
 */
export interface AttributeDefinition {
    /**
     * The name of the attribute.
     * @type {string}
     * @memberof AttributeDefinition
     */
    'name'?: string;
    /**
     * 
     * @type {AttributeDefinitionType}
     * @memberof AttributeDefinition
     */
    'type'?: AttributeDefinitionType;
    /**
     * 
     * @type {AttributeDefinitionSchema}
     * @memberof AttributeDefinition
     */
    'schema'?: AttributeDefinitionSchema;
    /**
     * A human-readable description of the attribute.
     * @type {string}
     * @memberof AttributeDefinition
     */
    'description'?: string;
    /**
     * Flag indicating whether or not the attribute is multi-valued.
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isMulti'?: boolean;
    /**
     * Flag indicating whether or not the attribute is an entitlement.
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isEntitlement'?: boolean;
    /**
     * Flag indicating whether or not the attribute represents a group. This can only be `true` if `isEntitlement` is also `true` **and** there is a schema defined for the attribute.. 
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isGroup'?: boolean;
}


/**
 * A reference to the schema on the source to the attribute values map to.
 * @export
 * @interface AttributeDefinitionSchema
 */
export interface AttributeDefinitionSchema {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'type'?: AttributeDefinitionSchemaTypeV3;
    /**
     * The object ID this reference applies to.
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'id'?: string;
    /**
     * The human-readable display name of the object.
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'name'?: string;
}

export const AttributeDefinitionSchemaTypeV3 = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
} as const;

export type AttributeDefinitionSchemaTypeV3 = typeof AttributeDefinitionSchemaTypeV3[keyof typeof AttributeDefinitionSchemaTypeV3];

/**
 * The underlying type of the value which an AttributeDefinition represents.
 * @export
 * @enum {string}
 */

export const AttributeDefinitionType = {
    String: 'STRING',
    Long: 'LONG',
    Int: 'INT',
    Boolean: 'BOOLEAN'
} as const;

export type AttributeDefinitionType = typeof AttributeDefinitionType[keyof typeof AttributeDefinitionType];


/**
 * 
 * @export
 * @interface AttributeRequest
 */
export interface AttributeRequest {
    /**
     * Attribute name.
     * @type {string}
     * @memberof AttributeRequest
     */
    'name'?: string;
    /**
     * Operation to perform on attribute.
     * @type {string}
     * @memberof AttributeRequest
     */
    'op'?: string;
    /**
     * 
     * @type {AttributeRequestValue}
     * @memberof AttributeRequest
     */
    'value'?: AttributeRequestValue;
}
/**
 * @type AttributeRequestValue
 * Value of attribute.
 * @export
 */
export type AttributeRequestValue = Array<string> | string;

/**
 * 
 * @export
 * @interface AttributeValueDTO
 */
export interface AttributeValueDTO {
    /**
     * Technical name of the Attribute value. This is unique and cannot be changed after creation.
     * @type {string}
     * @memberof AttributeValueDTO
     */
    'value'?: string;
    /**
     * The display name of the Attribute value.
     * @type {string}
     * @memberof AttributeValueDTO
     */
    'name'?: string;
    /**
     * The status of the Attribute value.
     * @type {string}
     * @memberof AttributeValueDTO
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface AuthUser
 */
export interface AuthUser {
    /**
     * Tenant name.
     * @type {string}
     * @memberof AuthUser
     */
    'tenant'?: string;
    /**
     * Identity ID.
     * @type {string}
     * @memberof AuthUser
     */
    'id'?: string;
    /**
     * Identity\'s unique identitifier.
     * @type {string}
     * @memberof AuthUser
     */
    'uid'?: string;
    /**
     * ID of the auth profile associated with the auth user.
     * @type {string}
     * @memberof AuthUser
     */
    'profile'?: string;
    /**
     * Auth user\'s employee number.
     * @type {string}
     * @memberof AuthUser
     */
    'identificationNumber'?: string | null;
    /**
     * Auth user\'s email.
     * @type {string}
     * @memberof AuthUser
     */
    'email'?: string | null;
    /**
     * Auth user\'s phone number.
     * @type {string}
     * @memberof AuthUser
     */
    'phone'?: string | null;
    /**
     * Auth user\'s work phone number.
     * @type {string}
     * @memberof AuthUser
     */
    'workPhone'?: string | null;
    /**
     * Auth user\'s personal email.
     * @type {string}
     * @memberof AuthUser
     */
    'personalEmail'?: string | null;
    /**
     * Auth user\'s first name.
     * @type {string}
     * @memberof AuthUser
     */
    'firstname'?: string | null;
    /**
     * Auth user\'s last name.
     * @type {string}
     * @memberof AuthUser
     */
    'lastname'?: string | null;
    /**
     * Auth user\'s name in displayed format.
     * @type {string}
     * @memberof AuthUser
     */
    'displayName'?: string;
    /**
     * Auth user\'s alias.
     * @type {string}
     * @memberof AuthUser
     */
    'alias'?: string;
    /**
     * Date of last password change.
     * @type {string}
     * @memberof AuthUser
     */
    'lastPasswordChangeDate'?: string | null;
    /**
     * Timestamp of the last login (long type value).
     * @type {number}
     * @memberof AuthUser
     */
    'lastLoginTimestamp'?: number;
    /**
     * Timestamp of the current login (long type value).
     * @type {number}
     * @memberof AuthUser
     */
    'currentLoginTimestamp'?: number;
    /**
     * The date and time when the user was last unlocked.
     * @type {string}
     * @memberof AuthUser
     */
    'lastUnlockTimestamp'?: string | null;
    /**
     * Array of the auth user\'s capabilities.
     * @type {Array<string>}
     * @memberof AuthUser
     */
    'capabilities'?: Array<AuthUserCapabilitiesV3> | null;
}

export const AuthUserCapabilitiesV3 = {
    CertAdmin: 'CERT_ADMIN',
    CloudGovAdmin: 'CLOUD_GOV_ADMIN',
    CloudGovUser: 'CLOUD_GOV_USER',
    Helpdesk: 'HELPDESK',
    OrgAdmin: 'ORG_ADMIN',
    ReportAdmin: 'REPORT_ADMIN',
    RoleAdmin: 'ROLE_ADMIN',
    RoleSubadmin: 'ROLE_SUBADMIN',
    SaasManagementAdmin: 'SAAS_MANAGEMENT_ADMIN',
    SaasManagementReader: 'SAAS_MANAGEMENT_READER',
    SourceAdmin: 'SOURCE_ADMIN',
    SourceSubadmin: 'SOURCE_SUBADMIN',
    DasUiAdministrator: 'das:ui-administrator',
    DasUiComplianceManager: 'das:ui-compliance_manager',
    DasUiAuditor: 'das:ui-auditor',
    DasUiDataScope: 'das:ui-data-scope',
    SpAicDashboardRead: 'sp:aic-dashboard-read',
    SpAicDashboardWrite: 'sp:aic-dashboard-write',
    SpUiConfigHubAdmin: 'sp:ui-config-hub-admin',
    SpUiConfigHubBackupAdmin: 'sp:ui-config-hub-backup-admin',
    SpUiConfigHubRead: 'sp:ui-config-hub-read'
} as const;

export type AuthUserCapabilitiesV3 = typeof AuthUserCapabilitiesV3[keyof typeof AuthUserCapabilitiesV3];

/**
 * Backup options control what will be included in the backup.
 * @export
 * @interface BackupOptions
 */
export interface BackupOptions {
    /**
     * Object type names to be included in a Configuration Hub backup command.
     * @type {Array<string>}
     * @memberof BackupOptions
     */
    'includeTypes'?: Array<BackupOptionsIncludeTypesV3>;
    /**
     * Additional options targeting specific objects related to each item in the includeTypes field.
     * @type {{ [key: string]: ObjectExportImportNames; }}
     * @memberof BackupOptions
     */
    'objectOptions'?: { [key: string]: ObjectExportImportNames; };
}

export const BackupOptionsIncludeTypesV3 = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    Segment: 'SEGMENT',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflow: 'WORKFLOW'
} as const;

export type BackupOptionsIncludeTypesV3 = typeof BackupOptionsIncludeTypesV3[keyof typeof BackupOptionsIncludeTypesV3];

/**
 * 
 * @export
 * @interface BackupResponse
 */
export interface BackupResponse {
    /**
     * Unique id assigned to this backup.
     * @type {string}
     * @memberof BackupResponse
     */
    'jobId'?: string;
    /**
     * Status of the backup.
     * @type {string}
     * @memberof BackupResponse
     */
    'status'?: BackupResponseStatusV3;
    /**
     * Type of the job, will always be BACKUP for this type of job.
     * @type {string}
     * @memberof BackupResponse
     */
    'type'?: BackupResponseTypeV3;
    /**
     * The name of the tenant performing the upload
     * @type {string}
     * @memberof BackupResponse
     */
    'tenant'?: string;
    /**
     * The name of the requester.
     * @type {string}
     * @memberof BackupResponse
     */
    'requesterName'?: string;
    /**
     * Whether or not a file was created and stored for this backup.
     * @type {boolean}
     * @memberof BackupResponse
     */
    'fileExists'?: boolean;
    /**
     * The time the job was started.
     * @type {string}
     * @memberof BackupResponse
     */
    'created'?: string;
    /**
     * The time of the last update to the job.
     * @type {string}
     * @memberof BackupResponse
     */
    'modified'?: string;
    /**
     * The time the job was completed.
     * @type {string}
     * @memberof BackupResponse
     */
    'completed'?: string;
    /**
     * The name assigned to the upload file in the request body.
     * @type {string}
     * @memberof BackupResponse
     */
    'name'?: string;
    /**
     * Whether this backup can be deleted by a regular user.
     * @type {boolean}
     * @memberof BackupResponse
     */
    'userCanDelete'?: boolean;
    /**
     * Whether this backup contains all supported object types or only some of them.
     * @type {boolean}
     * @memberof BackupResponse
     */
    'isPartial'?: boolean;
    /**
     * Denotes how this backup was created. - MANUAL - The backup was created by a user. - AUTOMATED - The backup was created by devops. - AUTOMATED_DRAFT - The backup was created during a draft process. - UPLOADED - The backup was created by uploading an existing configuration file.
     * @type {string}
     * @memberof BackupResponse
     */
    'backupType'?: BackupResponseBackupTypeV3;
    /**
     * 
     * @type {BackupOptions}
     * @memberof BackupResponse
     */
    'options'?: BackupOptions | null;
    /**
     * Whether the object details of this backup are ready.
     * @type {string}
     * @memberof BackupResponse
     */
    'hydrationStatus'?: BackupResponseHydrationStatusV3;
    /**
     * Number of objects contained in this backup.
     * @type {number}
     * @memberof BackupResponse
     */
    'totalObjectCount'?: number;
    /**
     * Whether this backup has been transferred to a customer storage location.
     * @type {string}
     * @memberof BackupResponse
     */
    'cloudStorageStatus'?: BackupResponseCloudStorageStatusV3;
}

export const BackupResponseStatusV3 = {
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    Complete: 'COMPLETE',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED'
} as const;

export type BackupResponseStatusV3 = typeof BackupResponseStatusV3[keyof typeof BackupResponseStatusV3];
export const BackupResponseTypeV3 = {
    Backup: 'BACKUP'
} as const;

export type BackupResponseTypeV3 = typeof BackupResponseTypeV3[keyof typeof BackupResponseTypeV3];
export const BackupResponseBackupTypeV3 = {
    Uploaded: 'UPLOADED',
    Automated: 'AUTOMATED',
    Manual: 'MANUAL'
} as const;

export type BackupResponseBackupTypeV3 = typeof BackupResponseBackupTypeV3[keyof typeof BackupResponseBackupTypeV3];
export const BackupResponseHydrationStatusV3 = {
    Hydrated: 'HYDRATED',
    NotHydrated: 'NOT_HYDRATED'
} as const;

export type BackupResponseHydrationStatusV3 = typeof BackupResponseHydrationStatusV3[keyof typeof BackupResponseHydrationStatusV3];
export const BackupResponseCloudStorageStatusV3 = {
    Synced: 'SYNCED',
    NotSynced: 'NOT_SYNCED',
    SyncFailed: 'SYNC_FAILED'
} as const;

export type BackupResponseCloudStorageStatusV3 = typeof BackupResponseCloudStorageStatusV3[keyof typeof BackupResponseCloudStorageStatusV3];

/**
 * 
 * @export
 * @interface Base64Decode
 */
export interface Base64Decode {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Base64Decode
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Base64Decode
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Base64Encode
 */
export interface Base64Encode {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Base64Encode
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Base64Encode
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BaseAccess
 */
export interface BaseAccess {
    /**
     * Access item\'s description.
     * @type {string}
     * @memberof BaseAccess
     */
    'description'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof BaseAccess
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof BaseAccess
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof BaseAccess
     */
    'synced'?: string | null;
    /**
     * Indicates whether the access item is currently enabled.
     * @type {boolean}
     * @memberof BaseAccess
     */
    'enabled'?: boolean;
    /**
     * Indicates whether the access item can be requested.
     * @type {boolean}
     * @memberof BaseAccess
     */
    'requestable'?: boolean;
    /**
     * Indicates whether comments are required for requests to access the item.
     * @type {boolean}
     * @memberof BaseAccess
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {BaseAccessOwner}
     * @memberof BaseAccess
     */
    'owner'?: BaseAccessOwner;
}
/**
 * Owner\'s identity.
 * @export
 * @interface BaseAccessOwner
 */
export interface BaseAccessOwner {
    /**
     * Owner\'s DTO type.
     * @type {string}
     * @memberof BaseAccessOwner
     */
    'type'?: BaseAccessOwnerTypeV3;
    /**
     * Owner\'s identity ID.
     * @type {string}
     * @memberof BaseAccessOwner
     */
    'id'?: string;
    /**
     * Owner\'s display name.
     * @type {string}
     * @memberof BaseAccessOwner
     */
    'name'?: string;
    /**
     * Owner\'s email.
     * @type {string}
     * @memberof BaseAccessOwner
     */
    'email'?: string;
}

export const BaseAccessOwnerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type BaseAccessOwnerTypeV3 = typeof BaseAccessOwnerTypeV3[keyof typeof BaseAccessOwnerTypeV3];

/**
 * 
 * @export
 * @interface BaseAccessProfile
 */
export interface BaseAccessProfile {
    /**
     * Access profile\'s unique ID.
     * @type {string}
     * @memberof BaseAccessProfile
     */
    'id'?: string;
    /**
     * Access profile\'s display name.
     * @type {string}
     * @memberof BaseAccessProfile
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface BaseAccount
 */
export interface BaseAccount {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof BaseAccount
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof BaseAccount
     */
    'name'?: string;
    /**
     * Account ID.
     * @type {string}
     * @memberof BaseAccount
     */
    'accountId'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof BaseAccount
     */
    'source'?: AccountSource;
    /**
     * Indicates whether the account is disabled.
     * @type {boolean}
     * @memberof BaseAccount
     */
    'disabled'?: boolean;
    /**
     * Indicates whether the account is locked.
     * @type {boolean}
     * @memberof BaseAccount
     */
    'locked'?: boolean;
    /**
     * Indicates whether the account is privileged.
     * @type {boolean}
     * @memberof BaseAccount
     */
    'privileged'?: boolean;
    /**
     * Indicates whether the account has been manually correlated to an identity.
     * @type {boolean}
     * @memberof BaseAccount
     */
    'manuallyCorrelated'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccount
     */
    'passwordLastSet'?: string | null;
    /**
     * Map or dictionary of key/value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof BaseAccount
     */
    'entitlementAttributes'?: { [key: string]: any; } | null;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof BaseAccount
     */
    'created'?: string | null;
    /**
     * Indicates whether the account supports password change.
     * @type {boolean}
     * @memberof BaseAccount
     */
    'supportsPasswordChange'?: boolean;
    /**
     * Map or dictionary of key/value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof BaseAccount
     */
    'accountAttributes'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface BaseCommonDto
 */
export interface BaseCommonDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'name': string | null;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface BaseDocument
 */
export interface BaseDocument {
    /**
     * ID of the referenced object.
     * @type {string}
     * @memberof BaseDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof BaseDocument
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface BaseEntitlement
 */
export interface BaseEntitlement {
    /**
     * Indicates whether the entitlement has permissions.
     * @type {boolean}
     * @memberof BaseEntitlement
     */
    'hasPermissions'?: boolean;
    /**
     * Entitlement\'s description.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'description'?: string | null;
    /**
     * Entitlement attribute\'s name.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'attribute'?: string;
    /**
     * Entitlement\'s value.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'value'?: string;
    /**
     * Entitlement\'s schema.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'schema'?: string;
    /**
     * Indicates whether the entitlement is privileged.
     * @type {boolean}
     * @memberof BaseEntitlement
     */
    'privileged'?: boolean;
    /**
     * Entitlement\'s ID.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'id'?: string;
    /**
     * Entitlement\'s name.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface BaseReferenceDto
 */
export interface BaseReferenceDto {
    /**
     * 
     * @type {DtoType}
     * @memberof BaseReferenceDto
     */
    'type'?: DtoType;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof BaseReferenceDto
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof BaseReferenceDto
     */
    'name'?: string;
}


/**
 * 
 * @export
 * @interface BaseSegment
 */
export interface BaseSegment {
    /**
     * Segment\'s unique ID.
     * @type {string}
     * @memberof BaseSegment
     */
    'id'?: string;
    /**
     * Segment\'s display name.
     * @type {string}
     * @memberof BaseSegment
     */
    'name'?: string;
}
/**
 * Before Provisioning Rule.
 * @export
 * @interface BeforeProvisioningRuleDto
 */
export interface BeforeProvisioningRuleDto {
    /**
     * Before Provisioning Rule DTO type.
     * @type {string}
     * @memberof BeforeProvisioningRuleDto
     */
    'type'?: BeforeProvisioningRuleDtoTypeV3;
    /**
     * Before Provisioning Rule ID.
     * @type {string}
     * @memberof BeforeProvisioningRuleDto
     */
    'id'?: string;
    /**
     * Rule display name.
     * @type {string}
     * @memberof BeforeProvisioningRuleDto
     */
    'name'?: string;
}

export const BeforeProvisioningRuleDtoTypeV3 = {
    Rule: 'RULE'
} as const;

export type BeforeProvisioningRuleDtoTypeV3 = typeof BeforeProvisioningRuleDtoTypeV3[keyof typeof BeforeProvisioningRuleDtoTypeV3];

/**
 * 
 * @export
 * @interface Bound
 */
export interface Bound {
    /**
     * The value of the range\'s endpoint.
     * @type {string}
     * @memberof Bound
     */
    'value': string;
    /**
     * Indicates if the endpoint is included in the range.
     * @type {boolean}
     * @memberof Bound
     */
    'inclusive'?: boolean;
}
/**
 * 
 * @export
 * @interface BrandingItem
 */
export interface BrandingItem {
    /**
     * name of branding item
     * @type {string}
     * @memberof BrandingItem
     */
    'name'?: string;
    /**
     * product name
     * @type {string}
     * @memberof BrandingItem
     */
    'productName'?: string | null;
    /**
     * hex value of color for action button
     * @type {string}
     * @memberof BrandingItem
     */
    'actionButtonColor'?: string | null;
    /**
     * hex value of color for link
     * @type {string}
     * @memberof BrandingItem
     */
    'activeLinkColor'?: string | null;
    /**
     * hex value of color for navigation bar
     * @type {string}
     * @memberof BrandingItem
     */
    'navigationColor'?: string | null;
    /**
     * email from address
     * @type {string}
     * @memberof BrandingItem
     */
    'emailFromAddress'?: string | null;
    /**
     * url to standard logo
     * @type {string}
     * @memberof BrandingItem
     */
    'standardLogoURL'?: string | null;
    /**
     * login information message
     * @type {string}
     * @memberof BrandingItem
     */
    'loginInformationalMessage'?: string | null;
}
/**
 * 
 * @export
 * @interface BrandingItemCreate
 */
export interface BrandingItemCreate {
    /**
     * name of branding item
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'name': string;
    /**
     * product name
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'productName': string | null;
    /**
     * hex value of color for action button
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'actionButtonColor'?: string;
    /**
     * hex value of color for link
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'activeLinkColor'?: string;
    /**
     * hex value of color for navigation bar
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'navigationColor'?: string;
    /**
     * email from address
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'emailFromAddress'?: string;
    /**
     * login information message
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'loginInformationalMessage'?: string;
    /**
     * png file with logo
     * @type {File}
     * @memberof BrandingItemCreate
     */
    'fileStandard'?: File;
}
/**
 * The bucket to group the results of the aggregation query by.
 * @export
 * @interface BucketAggregation
 */
export interface BucketAggregation {
    /**
     * The name of the bucket aggregate to be included in the result.
     * @type {string}
     * @memberof BucketAggregation
     */
    'name': string;
    /**
     * 
     * @type {BucketType}
     * @memberof BucketAggregation
     */
    'type'?: BucketType;
    /**
     * The field to bucket on. Prefix the field name with \'@\' to reference a nested object.
     * @type {string}
     * @memberof BucketAggregation
     */
    'field': string;
    /**
     * Maximum number of buckets to include.
     * @type {number}
     * @memberof BucketAggregation
     */
    'size'?: number;
    /**
     * Minimum number of documents a bucket should have.
     * @type {number}
     * @memberof BucketAggregation
     */
    'minDocCount'?: number;
}


/**
 * Enum representing the currently supported bucket aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const BucketType = {
    Terms: 'TERMS'
} as const;

export type BucketType = typeof BucketType[keyof typeof BucketType];


/**
 * 
 * @export
 * @interface BulkAddTaggedObject
 */
export interface BulkAddTaggedObject {
    /**
     * 
     * @type {Array<TaggedObjectDto>}
     * @memberof BulkAddTaggedObject
     */
    'objectRefs'?: Array<TaggedObjectDto>;
    /**
     * Label to be applied to an Object
     * @type {Array<string>}
     * @memberof BulkAddTaggedObject
     */
    'tags'?: Array<string>;
    /**
     * If APPEND, tags are appended to the list of tags for the object. A 400 error is returned if this would add duplicate tags to the object.  If MERGE, tags are merged with the existing tags. Duplicate tags are silently ignored.
     * @type {string}
     * @memberof BulkAddTaggedObject
     */
    'operation'?: BulkAddTaggedObjectOperationV3;
}

export const BulkAddTaggedObjectOperationV3 = {
    Append: 'APPEND',
    Merge: 'MERGE'
} as const;

export type BulkAddTaggedObjectOperationV3 = typeof BulkAddTaggedObjectOperationV3[keyof typeof BulkAddTaggedObjectOperationV3];

/**
 * 
 * @export
 * @interface BulkRemoveTaggedObject
 */
export interface BulkRemoveTaggedObject {
    /**
     * 
     * @type {Array<TaggedObjectDto>}
     * @memberof BulkRemoveTaggedObject
     */
    'objectRefs'?: Array<TaggedObjectDto>;
    /**
     * Label to be applied to an Object
     * @type {Array<string>}
     * @memberof BulkRemoveTaggedObject
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface BulkTaggedObjectResponse
 */
export interface BulkTaggedObjectResponse {
    /**
     * 
     * @type {Array<TaggedObjectDto>}
     * @memberof BulkTaggedObjectResponse
     */
    'objectRefs'?: Array<TaggedObjectDto>;
    /**
     * Label to be applied to an Object
     * @type {Array<string>}
     * @memberof BulkTaggedObjectResponse
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     * Id of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'id'?: string;
    /**
     * The campaign name. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details. 
     * @type {string}
     * @memberof Campaign
     */
    'name': string;
    /**
     * The campaign description. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details. 
     * @type {string}
     * @memberof Campaign
     */
    'description': string | null;
    /**
     * The campaign\'s completion deadline.  This date must be in the future in order to activate the campaign.  If you try to activate a campaign with a deadline of today or in the past, you will receive a 400 error response.
     * @type {string}
     * @memberof Campaign
     */
    'deadline'?: string;
    /**
     * The type of campaign. Could be extended in the future.
     * @type {string}
     * @memberof Campaign
     */
    'type': CampaignTypeV3;
    /**
     * Enables email notification for this campaign
     * @type {boolean}
     * @memberof Campaign
     */
    'emailNotificationEnabled'?: boolean;
    /**
     * Allows auto revoke for this campaign
     * @type {boolean}
     * @memberof Campaign
     */
    'autoRevokeAllowed'?: boolean;
    /**
     * Enables IAI for this campaign. Accepts true even if the IAI product feature is off. If IAI is turned off then campaigns generated from this template will indicate false. The real value will then be returned if IAI is ever enabled for the org in the future.
     * @type {boolean}
     * @memberof Campaign
     */
    'recommendationsEnabled'?: boolean;
    /**
     * The campaign\'s current status.
     * @type {string}
     * @memberof Campaign
     */
    'status'?: CampaignStatusV3;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {string}
     * @memberof Campaign
     */
    'correlatedStatus'?: CampaignCorrelatedStatusV3;
    /**
     * Created time of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'created'?: string;
    /**
     * The total number of certifications in this campaign.
     * @type {number}
     * @memberof Campaign
     */
    'totalCertifications'?: number;
    /**
     * The number of completed certifications in this campaign.
     * @type {number}
     * @memberof Campaign
     */
    'completedCertifications'?: number;
    /**
     * A list of errors and warnings that have accumulated.
     * @type {Array<CampaignAlert>}
     * @memberof Campaign
     */
    'alerts'?: Array<CampaignAlert>;
    /**
     * Modified time of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'modified'?: string;
    /**
     * 
     * @type {CampaignAllOfFilter}
     * @memberof Campaign
     */
    'filter'?: CampaignAllOfFilter;
    /**
     * Determines if comments on sunset date changes are required.
     * @type {boolean}
     * @memberof Campaign
     */
    'sunsetCommentsRequired'?: boolean;
    /**
     * 
     * @type {CampaignAllOfSourceOwnerCampaignInfo}
     * @memberof Campaign
     */
    'sourceOwnerCampaignInfo'?: CampaignAllOfSourceOwnerCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfSearchCampaignInfo}
     * @memberof Campaign
     */
    'searchCampaignInfo'?: CampaignAllOfSearchCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfRoleCompositionCampaignInfo}
     * @memberof Campaign
     */
    'roleCompositionCampaignInfo'?: CampaignAllOfRoleCompositionCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfMachineAccountCampaignInfo}
     * @memberof Campaign
     */
    'machineAccountCampaignInfo'?: CampaignAllOfMachineAccountCampaignInfo;
    /**
     * A list of sources in the campaign that contain \\\"orphan entitlements\\\" (entitlements without a corresponding Managed Attribute). An empty list indicates the campaign has no orphan entitlements. Null indicates there may be unknown orphan entitlements in the campaign (the campaign was created before this feature was implemented).
     * @type {Array<CampaignAllOfSourcesWithOrphanEntitlements>}
     * @memberof Campaign
     */
    'sourcesWithOrphanEntitlements'?: Array<CampaignAllOfSourcesWithOrphanEntitlements>;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof Campaign
     */
    'mandatoryCommentRequirement'?: CampaignMandatoryCommentRequirementV3;
}

export const CampaignTypeV3 = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION',
    MachineAccount: 'MACHINE_ACCOUNT'
} as const;

export type CampaignTypeV3 = typeof CampaignTypeV3[keyof typeof CampaignTypeV3];
export const CampaignStatusV3 = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
} as const;

export type CampaignStatusV3 = typeof CampaignStatusV3[keyof typeof CampaignStatusV3];
export const CampaignCorrelatedStatusV3 = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type CampaignCorrelatedStatusV3 = typeof CampaignCorrelatedStatusV3[keyof typeof CampaignCorrelatedStatusV3];
export const CampaignMandatoryCommentRequirementV3 = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type CampaignMandatoryCommentRequirementV3 = typeof CampaignMandatoryCommentRequirementV3[keyof typeof CampaignMandatoryCommentRequirementV3];

/**
 * 
 * @export
 * @interface CampaignAlert
 */
export interface CampaignAlert {
    /**
     * Denotes the level of the message
     * @type {string}
     * @memberof CampaignAlert
     */
    'level'?: CampaignAlertLevelV3;
    /**
     * 
     * @type {Array<ErrorMessageDto>}
     * @memberof CampaignAlert
     */
    'localizations'?: Array<ErrorMessageDto>;
}

export const CampaignAlertLevelV3 = {
    Error: 'ERROR',
    Warn: 'WARN',
    Info: 'INFO'
} as const;

export type CampaignAlertLevelV3 = typeof CampaignAlertLevelV3[keyof typeof CampaignAlertLevelV3];

/**
 * Determines which items will be included in this campaign. The default campaign filter is used if this field is left blank.
 * @export
 * @interface CampaignAllOfFilter
 */
export interface CampaignAllOfFilter {
    /**
     * The ID of whatever type of filter is being used.
     * @type {string}
     * @memberof CampaignAllOfFilter
     */
    'id'?: string;
    /**
     * Type of the filter
     * @type {string}
     * @memberof CampaignAllOfFilter
     */
    'type'?: CampaignAllOfFilterTypeV3;
    /**
     * Name of the filter
     * @type {string}
     * @memberof CampaignAllOfFilter
     */
    'name'?: string;
}

export const CampaignAllOfFilterTypeV3 = {
    CampaignFilter: 'CAMPAIGN_FILTER',
    Rule: 'RULE'
} as const;

export type CampaignAllOfFilterTypeV3 = typeof CampaignAllOfFilterTypeV3[keyof typeof CampaignAllOfFilterTypeV3];

/**
 * Must be set only if the campaign type is MACHINE_ACCOUNT.
 * @export
 * @interface CampaignAllOfMachineAccountCampaignInfo
 */
export interface CampaignAllOfMachineAccountCampaignInfo {
    /**
     * The list of sources to be included in the campaign.
     * @type {Array<string>}
     * @memberof CampaignAllOfMachineAccountCampaignInfo
     */
    'sourceIds'?: Array<string>;
    /**
     * The reviewer\'s type.
     * @type {string}
     * @memberof CampaignAllOfMachineAccountCampaignInfo
     */
    'reviewerType'?: CampaignAllOfMachineAccountCampaignInfoReviewerTypeV3;
}

export const CampaignAllOfMachineAccountCampaignInfoReviewerTypeV3 = {
    AccountOwner: 'ACCOUNT_OWNER'
} as const;

export type CampaignAllOfMachineAccountCampaignInfoReviewerTypeV3 = typeof CampaignAllOfMachineAccountCampaignInfoReviewerTypeV3[keyof typeof CampaignAllOfMachineAccountCampaignInfoReviewerTypeV3];

/**
 * Optional configuration options for role composition campaigns.
 * @export
 * @interface CampaignAllOfRoleCompositionCampaignInfo
 */
export interface CampaignAllOfRoleCompositionCampaignInfo {
    /**
     * 
     * @type {CampaignAllOfSearchCampaignInfoReviewer}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'reviewer'?: CampaignAllOfSearchCampaignInfoReviewer;
    /**
     * Optional list of roles to include in this campaign. Only one of `roleIds` and `query` may be set; if neither are set, all roles are included.
     * @type {Array<string>}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'roleIds'?: Array<string>;
    /**
     * 
     * @type {CampaignAllOfRoleCompositionCampaignInfoRemediatorRef}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'remediatorRef': CampaignAllOfRoleCompositionCampaignInfoRemediatorRef;
    /**
     * Optional search query to scope this campaign to a set of roles. Only one of `roleIds` and `query` may be set; if neither are set, all roles are included.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'query'?: string;
    /**
     * Describes this role composition campaign. Intended for storing the query used, and possibly the number of roles selected/available.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'description'?: string;
}
/**
 * This determines who remediation tasks will be assigned to. Remediation tasks are created for each revoke decision on items in the campaign. The only legal remediator type is \'IDENTITY\', and the chosen identity must be a Role Admin or Org Admin.
 * @export
 * @interface CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
 */
export interface CampaignAllOfRoleCompositionCampaignInfoRemediatorRef {
    /**
     * Legal Remediator Type
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
     */
    'type': CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeV3;
    /**
     * The ID of the remediator.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
     */
    'id': string;
    /**
     * The name of the remediator.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
     */
    'name'?: string;
}

export const CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeV3 = typeof CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeV3[keyof typeof CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeV3];

/**
 * Must be set only if the campaign type is SEARCH.
 * @export
 * @interface CampaignAllOfSearchCampaignInfo
 */
export interface CampaignAllOfSearchCampaignInfo {
    /**
     * The type of search campaign represented.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'type': CampaignAllOfSearchCampaignInfoTypeV3;
    /**
     * Describes this search campaign. Intended for storing the query used, and possibly the number of identities selected/available.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'description'?: string;
    /**
     * 
     * @type {CampaignAllOfSearchCampaignInfoReviewer}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'reviewer'?: CampaignAllOfSearchCampaignInfoReviewer;
    /**
     * The scope for the campaign. The campaign will cover identities returned by the query and identities that have access items returned by the query. One of `query` or `identityIds` must be set.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'query'?: string;
    /**
     * A direct list of identities to include in this campaign. One of `identityIds` or `query` must be set.
     * @type {Array<string>}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'identityIds'?: Array<string>;
    /**
     * Further reduces the scope of the campaign by excluding identities (from `query` or `identityIds`) that do not have this access.
     * @type {Array<AccessConstraint>}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'accessConstraints'?: Array<AccessConstraint>;
}

export const CampaignAllOfSearchCampaignInfoTypeV3 = {
    Identity: 'IDENTITY',
    Access: 'ACCESS'
} as const;

export type CampaignAllOfSearchCampaignInfoTypeV3 = typeof CampaignAllOfSearchCampaignInfoTypeV3[keyof typeof CampaignAllOfSearchCampaignInfoTypeV3];

/**
 * If specified, this identity or governance group will be the reviewer for all certifications in this campaign. The allowed DTO types are IDENTITY and GOVERNANCE_GROUP.
 * @export
 * @interface CampaignAllOfSearchCampaignInfoReviewer
 */
export interface CampaignAllOfSearchCampaignInfoReviewer {
    /**
     * The reviewer\'s DTO type.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfoReviewer
     */
    'type'?: CampaignAllOfSearchCampaignInfoReviewerTypeV3;
    /**
     * The reviewer\'s ID.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfoReviewer
     */
    'id'?: string;
    /**
     * The reviewer\'s name.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfoReviewer
     */
    'name'?: string;
}

export const CampaignAllOfSearchCampaignInfoReviewerTypeV3 = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type CampaignAllOfSearchCampaignInfoReviewerTypeV3 = typeof CampaignAllOfSearchCampaignInfoReviewerTypeV3[keyof typeof CampaignAllOfSearchCampaignInfoReviewerTypeV3];

/**
 * Must be set only if the campaign type is SOURCE_OWNER.
 * @export
 * @interface CampaignAllOfSourceOwnerCampaignInfo
 */
export interface CampaignAllOfSourceOwnerCampaignInfo {
    /**
     * The list of sources to be included in the campaign.
     * @type {Array<string>}
     * @memberof CampaignAllOfSourceOwnerCampaignInfo
     */
    'sourceIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CampaignAllOfSourcesWithOrphanEntitlements
 */
export interface CampaignAllOfSourcesWithOrphanEntitlements {
    /**
     * Id of the source
     * @type {string}
     * @memberof CampaignAllOfSourcesWithOrphanEntitlements
     */
    'id'?: string;
    /**
     * Type
     * @type {string}
     * @memberof CampaignAllOfSourcesWithOrphanEntitlements
     */
    'type'?: CampaignAllOfSourcesWithOrphanEntitlementsTypeV3;
    /**
     * Name of the source
     * @type {string}
     * @memberof CampaignAllOfSourcesWithOrphanEntitlements
     */
    'name'?: string;
}

export const CampaignAllOfSourcesWithOrphanEntitlementsTypeV3 = {
    Source: 'SOURCE'
} as const;

export type CampaignAllOfSourcesWithOrphanEntitlementsTypeV3 = typeof CampaignAllOfSourcesWithOrphanEntitlementsTypeV3[keyof typeof CampaignAllOfSourcesWithOrphanEntitlementsTypeV3];

/**
 * 
 * @export
 * @interface CampaignCompleteOptions
 */
export interface CampaignCompleteOptions {
    /**
     * Determines whether to auto-approve(APPROVE) or auto-revoke(REVOKE) upon campaign completion.
     * @type {string}
     * @memberof CampaignCompleteOptions
     */
    'autoCompleteAction'?: CampaignCompleteOptionsAutoCompleteActionV3;
}

export const CampaignCompleteOptionsAutoCompleteActionV3 = {
    Approve: 'APPROVE',
    Revoke: 'REVOKE'
} as const;

export type CampaignCompleteOptionsAutoCompleteActionV3 = typeof CampaignCompleteOptionsAutoCompleteActionV3[keyof typeof CampaignCompleteOptionsAutoCompleteActionV3];

/**
 * Campaign Filter Details
 * @export
 * @interface CampaignFilterDetails
 */
export interface CampaignFilterDetails {
    /**
     * The unique ID of the campaign filter
     * @type {string}
     * @memberof CampaignFilterDetails
     */
    'id': string;
    /**
     * Campaign filter name.
     * @type {string}
     * @memberof CampaignFilterDetails
     */
    'name': string;
    /**
     * Campaign filter description.
     * @type {string}
     * @memberof CampaignFilterDetails
     */
    'description'?: string;
    /**
     * Owner of the filter. This field automatically populates at creation time with the current user.
     * @type {string}
     * @memberof CampaignFilterDetails
     */
    'owner': string | null;
    /**
     * Mode/type of filter, either the INCLUSION or EXCLUSION type. The INCLUSION type includes the data in generated campaigns  as per specified in the criteria, whereas the EXCLUSION type excludes the data in generated campaigns as per specified in criteria.
     * @type {object}
     * @memberof CampaignFilterDetails
     */
    'mode': CampaignFilterDetailsModeV3;
    /**
     * List of criteria.
     * @type {Array<CampaignFilterDetailsCriteriaListInner>}
     * @memberof CampaignFilterDetails
     */
    'criteriaList'?: Array<CampaignFilterDetailsCriteriaListInner>;
    /**
     * If true, the filter is created by the system. If false, the filter is created by a user.
     * @type {boolean}
     * @memberof CampaignFilterDetails
     */
    'isSystemFilter': boolean;
}

export const CampaignFilterDetailsModeV3 = {
    Inclusion: 'INCLUSION',
    Exclusion: 'EXCLUSION'
} as const;

export type CampaignFilterDetailsModeV3 = typeof CampaignFilterDetailsModeV3[keyof typeof CampaignFilterDetailsModeV3];

/**
 * 
 * @export
 * @interface CampaignFilterDetailsCriteriaListInner
 */
export interface CampaignFilterDetailsCriteriaListInner {
    /**
     * 
     * @type {CriteriaType}
     * @memberof CampaignFilterDetailsCriteriaListInner
     */
    'type': CriteriaType;
    /**
     * 
     * @type {Operation & object}
     * @memberof CampaignFilterDetailsCriteriaListInner
     */
    'operation': Operation & object;
    /**
     * Specified key from the type of criteria.
     * @type {string}
     * @memberof CampaignFilterDetailsCriteriaListInner
     */
    'property': string | null;
    /**
     * Value for the specified key from the type of criteria.
     * @type {string}
     * @memberof CampaignFilterDetailsCriteriaListInner
     */
    'value': string | null;
}


/**
 * 
 * @export
 * @interface CampaignReference
 */
export interface CampaignReference {
    /**
     * The unique ID of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'id': string;
    /**
     * The name of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'name': string;
    /**
     * The type of object that is being referenced.
     * @type {string}
     * @memberof CampaignReference
     */
    'type': CampaignReferenceTypeV3;
    /**
     * The type of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'campaignType': CampaignReferenceCampaignTypeV3;
    /**
     * The description of the campaign set by the admin who created it.
     * @type {string}
     * @memberof CampaignReference
     */
    'description': string | null;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {string}
     * @memberof CampaignReference
     */
    'correlatedStatus': CampaignReferenceCorrelatedStatusV3;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof CampaignReference
     */
    'mandatoryCommentRequirement': CampaignReferenceMandatoryCommentRequirementV3;
}

export const CampaignReferenceTypeV3 = {
    Campaign: 'CAMPAIGN'
} as const;

export type CampaignReferenceTypeV3 = typeof CampaignReferenceTypeV3[keyof typeof CampaignReferenceTypeV3];
export const CampaignReferenceCampaignTypeV3 = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH'
} as const;

export type CampaignReferenceCampaignTypeV3 = typeof CampaignReferenceCampaignTypeV3[keyof typeof CampaignReferenceCampaignTypeV3];
export const CampaignReferenceCorrelatedStatusV3 = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type CampaignReferenceCorrelatedStatusV3 = typeof CampaignReferenceCorrelatedStatusV3[keyof typeof CampaignReferenceCorrelatedStatusV3];
export const CampaignReferenceMandatoryCommentRequirementV3 = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type CampaignReferenceMandatoryCommentRequirementV3 = typeof CampaignReferenceMandatoryCommentRequirementV3[keyof typeof CampaignReferenceMandatoryCommentRequirementV3];

/**
 * 
 * @export
 * @interface CampaignReport
 */
export interface CampaignReport {
    /**
     * SOD policy violation report result DTO type.
     * @type {string}
     * @memberof CampaignReport
     */
    'type'?: CampaignReportTypeV3;
    /**
     * SOD policy violation report result ID.
     * @type {string}
     * @memberof CampaignReport
     */
    'id'?: string;
    /**
     * Human-readable name of the SOD policy violation report result.
     * @type {string}
     * @memberof CampaignReport
     */
    'name'?: string;
    /**
     * Status of a SOD policy violation report.
     * @type {string}
     * @memberof CampaignReport
     */
    'status'?: CampaignReportStatusV3;
    /**
     * 
     * @type {ReportType}
     * @memberof CampaignReport
     */
    'reportType': ReportType;
    /**
     * The most recent date and time this report was run
     * @type {string}
     * @memberof CampaignReport
     */
    'lastRunAt'?: string;
}

export const CampaignReportTypeV3 = {
    ReportResult: 'REPORT_RESULT'
} as const;

export type CampaignReportTypeV3 = typeof CampaignReportTypeV3[keyof typeof CampaignReportTypeV3];
export const CampaignReportStatusV3 = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
} as const;

export type CampaignReportStatusV3 = typeof CampaignReportStatusV3[keyof typeof CampaignReportStatusV3];

/**
 * 
 * @export
 * @interface CampaignReportsConfig
 */
export interface CampaignReportsConfig {
    /**
     * list of identity attribute columns
     * @type {Array<string>}
     * @memberof CampaignReportsConfig
     */
    'identityAttributeColumns'?: Array<string> | null;
}
/**
 * Campaign Template
 * @export
 * @interface CampaignTemplate
 */
export interface CampaignTemplate {
    /**
     * Id of the campaign template
     * @type {string}
     * @memberof CampaignTemplate
     */
    'id'?: string;
    /**
     * This template\'s name. Has no bearing on generated campaigns\' names.
     * @type {string}
     * @memberof CampaignTemplate
     */
    'name': string;
    /**
     * This template\'s description. Has no bearing on generated campaigns\' descriptions.
     * @type {string}
     * @memberof CampaignTemplate
     */
    'description': string;
    /**
     * Creation date of Campaign Template
     * @type {string}
     * @memberof CampaignTemplate
     */
    'created': string;
    /**
     * Modification date of Campaign Template
     * @type {string}
     * @memberof CampaignTemplate
     */
    'modified': string | null;
    /**
     * Indicates if this campaign template has been scheduled.
     * @type {boolean}
     * @memberof CampaignTemplate
     */
    'scheduled'?: boolean;
    /**
     * 
     * @type {CampaignTemplateOwnerRef}
     * @memberof CampaignTemplate
     */
    'ownerRef'?: CampaignTemplateOwnerRef;
    /**
     * The time period during which the campaign should be completed, formatted as an ISO-8601 Duration. When this template generates a campaign, the campaign\'s deadline will be the current date plus this duration. For example, if generation occurred on 2020-01-01 and this field was \"P2W\" (two weeks), the resulting campaign\'s deadline would be 2020-01-15 (the current date plus 14 days).
     * @type {string}
     * @memberof CampaignTemplate
     */
    'deadlineDuration'?: string;
    /**
     * 
     * @type {Campaign}
     * @memberof CampaignTemplate
     */
    'campaign': Campaign;
}
/**
 * The owner of this template, and the owner of campaigns generated from this template via a schedule. This field is automatically populated at creation time with the current user.
 * @export
 * @interface CampaignTemplateOwnerRef
 */
export interface CampaignTemplateOwnerRef {
    /**
     * Id of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRef
     */
    'id'?: string;
    /**
     * Type of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRef
     */
    'type'?: CampaignTemplateOwnerRefTypeV3;
    /**
     * Name of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRef
     */
    'name'?: string;
    /**
     * Email of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRef
     */
    'email'?: string;
}

export const CampaignTemplateOwnerRefTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type CampaignTemplateOwnerRefTypeV3 = typeof CampaignTemplateOwnerRefTypeV3[keyof typeof CampaignTemplateOwnerRefTypeV3];

/**
 * 
 * @export
 * @interface CampaignsDeleteRequest
 */
export interface CampaignsDeleteRequest {
    /**
     * The ids of the campaigns to delete
     * @type {Array<string>}
     * @memberof CampaignsDeleteRequest
     */
    'ids'?: Array<string>;
}
/**
 * Request body payload for cancel access request endpoint.
 * @export
 * @interface CancelAccessRequest
 */
export interface CancelAccessRequest {
    /**
     * This refers to the identityRequestId. To successfully cancel an access request, you must provide the identityRequestId.
     * @type {string}
     * @memberof CancelAccessRequest
     */
    'accountActivityId': string;
    /**
     * Reason for cancelling the pending access request.
     * @type {string}
     * @memberof CancelAccessRequest
     */
    'comment': string;
}
/**
 * Provides additional details for a request that has been cancelled.
 * @export
 * @interface CancelledRequestDetails
 */
export interface CancelledRequestDetails {
    /**
     * Comment made by the owner when cancelling the associated request.
     * @type {string}
     * @memberof CancelledRequestDetails
     */
    'comment'?: string;
    /**
     * 
     * @type {OwnerDto}
     * @memberof CancelledRequestDetails
     */
    'owner'?: OwnerDto;
    /**
     * Date comment was added by the owner when cancelling the associated request.
     * @type {string}
     * @memberof CancelledRequestDetails
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface Certification
 */
export interface Certification {
    /**
     * id of the certification
     * @type {string}
     * @memberof Certification
     */
    'id'?: string;
    /**
     * name of the certification
     * @type {string}
     * @memberof Certification
     */
    'name'?: string;
    /**
     * 
     * @type {CampaignReference}
     * @memberof Certification
     */
    'campaign'?: CampaignReference;
    /**
     * Have all decisions been made?
     * @type {boolean}
     * @memberof Certification
     */
    'completed'?: boolean;
    /**
     * The number of identities for whom all decisions have been made and are complete.
     * @type {number}
     * @memberof Certification
     */
    'identitiesCompleted'?: number;
    /**
     * The total number of identities in the Certification, both complete and incomplete.
     * @type {number}
     * @memberof Certification
     */
    'identitiesTotal'?: number;
    /**
     * created date
     * @type {string}
     * @memberof Certification
     */
    'created'?: string;
    /**
     * modified date
     * @type {string}
     * @memberof Certification
     */
    'modified'?: string;
    /**
     * The number of approve/revoke/acknowledge decisions that have been made.
     * @type {number}
     * @memberof Certification
     */
    'decisionsMade'?: number;
    /**
     * The total number of approve/revoke/acknowledge decisions.
     * @type {number}
     * @memberof Certification
     */
    'decisionsTotal'?: number;
    /**
     * The due date of the certification.
     * @type {string}
     * @memberof Certification
     */
    'due'?: string | null;
    /**
     * The date the reviewer signed off on the Certification.
     * @type {string}
     * @memberof Certification
     */
    'signed'?: string | null;
    /**
     * 
     * @type {Reviewer}
     * @memberof Certification
     */
    'reviewer'?: Reviewer;
    /**
     * 
     * @type {Reassignment}
     * @memberof Certification
     */
    'reassignment'?: Reassignment | null;
    /**
     * Identifies if the certification has an error
     * @type {boolean}
     * @memberof Certification
     */
    'hasErrors'?: boolean;
    /**
     * Description of the certification error
     * @type {string}
     * @memberof Certification
     */
    'errorMessage'?: string | null;
    /**
     * 
     * @type {CertificationPhase}
     * @memberof Certification
     */
    'phase'?: CertificationPhase;
}


/**
 * The decision to approve or revoke the review item
 * @export
 * @enum {string}
 */

export const CertificationDecision = {
    Approve: 'APPROVE',
    Revoke: 'REVOKE'
} as const;

export type CertificationDecision = typeof CertificationDecision[keyof typeof CertificationDecision];


/**
 * 
 * @export
 * @interface CertificationIdentitySummary
 */
export interface CertificationIdentitySummary {
    /**
     * The ID of the identity summary
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'id'?: string;
    /**
     * Name of the linked identity
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'name'?: string;
    /**
     * The ID of the identity being certified
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'identityId'?: string;
    /**
     * Indicates whether the review items for the linked identity\'s certification have been completed
     * @type {boolean}
     * @memberof CertificationIdentitySummary
     */
    'completed'?: boolean;
}
/**
 * The current phase of the campaign. * `STAGED`: The campaign is waiting to be activated. * `ACTIVE`: The campaign is active. * `SIGNED`: The reviewer has signed off on the campaign, and it is considered complete. 
 * @export
 * @enum {string}
 */

export const CertificationPhase = {
    Staged: 'STAGED',
    Active: 'ACTIVE',
    Signed: 'SIGNED'
} as const;

export type CertificationPhase = typeof CertificationPhase[keyof typeof CertificationPhase];


/**
 * 
 * @export
 * @interface CertificationReference
 */
export interface CertificationReference {
    /**
     * The id of the certification.
     * @type {string}
     * @memberof CertificationReference
     */
    'id'?: string;
    /**
     * The name of the certification.
     * @type {string}
     * @memberof CertificationReference
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CertificationReference
     */
    'type'?: CertificationReferenceTypeV3;
    /**
     * 
     * @type {Reviewer}
     * @memberof CertificationReference
     */
    'reviewer'?: Reviewer;
}

export const CertificationReferenceTypeV3 = {
    Certification: 'CERTIFICATION'
} as const;

export type CertificationReferenceTypeV3 = typeof CertificationReferenceTypeV3[keyof typeof CertificationReferenceTypeV3];

/**
 * 
 * @export
 * @interface CertificationTask
 */
export interface CertificationTask {
    /**
     * The ID of the certification task.
     * @type {string}
     * @memberof CertificationTask
     */
    'id'?: string;
    /**
     * The type of the certification task. More values may be added in the future.
     * @type {string}
     * @memberof CertificationTask
     */
    'type'?: CertificationTaskTypeV3;
    /**
     * The type of item that is being operated on by this task whose ID is stored in the targetId field.
     * @type {string}
     * @memberof CertificationTask
     */
    'targetType'?: CertificationTaskTargetTypeV3;
    /**
     * The ID of the item being operated on by this task.
     * @type {string}
     * @memberof CertificationTask
     */
    'targetId'?: string;
    /**
     * The status of the task.
     * @type {string}
     * @memberof CertificationTask
     */
    'status'?: CertificationTaskStatusV3;
    /**
     * 
     * @type {Array<ErrorMessageDto>}
     * @memberof CertificationTask
     */
    'errors'?: Array<ErrorMessageDto>;
    /**
     * Reassignment trails that lead to self certification identity
     * @type {Array<ReassignmentTrailDTO>}
     * @memberof CertificationTask
     */
    'reassignmentTrailDTOs'?: Array<ReassignmentTrailDTO>;
    /**
     * The date and time on which this task was created.
     * @type {string}
     * @memberof CertificationTask
     */
    'created'?: string;
}

export const CertificationTaskTypeV3 = {
    Reassign: 'REASSIGN',
    AdminReassign: 'ADMIN_REASSIGN',
    CompleteCertification: 'COMPLETE_CERTIFICATION',
    FinishCertification: 'FINISH_CERTIFICATION',
    CompleteCampaign: 'COMPLETE_CAMPAIGN',
    ActivateCampaign: 'ACTIVATE_CAMPAIGN',
    CampaignCreate: 'CAMPAIGN_CREATE',
    CampaignDelete: 'CAMPAIGN_DELETE'
} as const;

export type CertificationTaskTypeV3 = typeof CertificationTaskTypeV3[keyof typeof CertificationTaskTypeV3];
export const CertificationTaskTargetTypeV3 = {
    Certification: 'CERTIFICATION',
    Campaign: 'CAMPAIGN'
} as const;

export type CertificationTaskTargetTypeV3 = typeof CertificationTaskTargetTypeV3[keyof typeof CertificationTaskTargetTypeV3];
export const CertificationTaskStatusV3 = {
    Queued: 'QUEUED',
    InProgress: 'IN_PROGRESS',
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type CertificationTaskStatusV3 = typeof CertificationTaskStatusV3[keyof typeof CertificationTaskStatusV3];

/**
 * Client Runtime Logging Configuration
 * @export
 * @interface ClientLogConfiguration
 */
export interface ClientLogConfiguration {
    /**
     * Log configuration\'s client ID
     * @type {string}
     * @memberof ClientLogConfiguration
     */
    'clientId'?: string;
    /**
     * Duration in minutes for log configuration to remain in effect before resetting to defaults.
     * @type {number}
     * @memberof ClientLogConfiguration
     */
    'durationMinutes'?: number;
    /**
     * Expiration date-time of the log configuration request.  Can be no greater than 24 hours from current date-time.
     * @type {string}
     * @memberof ClientLogConfiguration
     */
    'expiration'?: string;
    /**
     * 
     * @type {StandardLevel}
     * @memberof ClientLogConfiguration
     */
    'rootLevel': StandardLevel;
    /**
     * Mapping of identifiers to Standard Log Level values
     * @type {{ [key: string]: StandardLevel; }}
     * @memberof ClientLogConfiguration
     */
    'logLevels'?: { [key: string]: StandardLevel; };
}


/**
 * Client Runtime Logging Configuration
 * @export
 * @interface ClientLogConfigurationDurationMinutes
 */
export interface ClientLogConfigurationDurationMinutes {
    /**
     * Log configuration\'s client ID
     * @type {string}
     * @memberof ClientLogConfigurationDurationMinutes
     */
    'clientId'?: string;
    /**
     * Duration in minutes for log configuration to remain in effect before resetting to defaults.
     * @type {number}
     * @memberof ClientLogConfigurationDurationMinutes
     */
    'durationMinutes'?: number;
    /**
     * 
     * @type {StandardLevel}
     * @memberof ClientLogConfigurationDurationMinutes
     */
    'rootLevel': StandardLevel;
    /**
     * Mapping of identifiers to Standard Log Level values
     * @type {{ [key: string]: StandardLevel; }}
     * @memberof ClientLogConfigurationDurationMinutes
     */
    'logLevels'?: { [key: string]: StandardLevel; };
}


/**
 * Client Runtime Logging Configuration
 * @export
 * @interface ClientLogConfigurationExpiration
 */
export interface ClientLogConfigurationExpiration {
    /**
     * Log configuration\'s client ID
     * @type {string}
     * @memberof ClientLogConfigurationExpiration
     */
    'clientId'?: string;
    /**
     * Expiration date-time of the log configuration request.  Can be no greater than 24 hours from current date-time.
     * @type {string}
     * @memberof ClientLogConfigurationExpiration
     */
    'expiration'?: string;
    /**
     * 
     * @type {StandardLevel}
     * @memberof ClientLogConfigurationExpiration
     */
    'rootLevel': StandardLevel;
    /**
     * Mapping of identifiers to Standard Log Level values
     * @type {{ [key: string]: StandardLevel; }}
     * @memberof ClientLogConfigurationExpiration
     */
    'logLevels'?: { [key: string]: StandardLevel; };
}


/**
 * Type of an API Client indicating public or confidentials use
 * @export
 * @enum {string}
 */

export const ClientType = {
    Confidential: 'CONFIDENTIAL',
    Public: 'PUBLIC'
} as const;

export type ClientType = typeof ClientType[keyof typeof ClientType];


/**
 * 
 * @export
 * @interface Column
 */
export interface Column {
    /**
     * The name of the field. 
     * @type {string}
     * @memberof Column
     */
    'field': string;
    /**
     * The value of the header. 
     * @type {string}
     * @memberof Column
     */
    'header'?: string;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * Id of the identity making the comment
     * @type {string}
     * @memberof Comment
     */
    'commenterId'?: string;
    /**
     * Human-readable display name of the identity making the comment
     * @type {string}
     * @memberof Comment
     */
    'commenterName'?: string;
    /**
     * Content of the comment
     * @type {string}
     * @memberof Comment
     */
    'body'?: string;
    /**
     * Date and time comment was made
     * @type {string}
     * @memberof Comment
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface CommentDto
 */
export interface CommentDto {
    /**
     * Comment content.
     * @type {string}
     * @memberof CommentDto
     */
    'comment'?: string | null;
    /**
     * Date and time comment was created.
     * @type {string}
     * @memberof CommentDto
     */
    'created'?: string;
    /**
     * 
     * @type {CommentDtoAuthor}
     * @memberof CommentDto
     */
    'author'?: CommentDtoAuthor;
}
/**
 * Author of the comment
 * @export
 * @interface CommentDtoAuthor
 */
export interface CommentDtoAuthor {
    /**
     * The type of object
     * @type {string}
     * @memberof CommentDtoAuthor
     */
    'type'?: CommentDtoAuthorTypeV3;
    /**
     * The unique ID of the object
     * @type {string}
     * @memberof CommentDtoAuthor
     */
    'id'?: string;
    /**
     * The display name of the object
     * @type {string}
     * @memberof CommentDtoAuthor
     */
    'name'?: string;
}

export const CommentDtoAuthorTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type CommentDtoAuthorTypeV3 = typeof CommentDtoAuthorTypeV3[keyof typeof CommentDtoAuthorTypeV3];

/**
 * 
 * @export
 * @interface CompletedApproval
 */
export interface CompletedApproval {
    /**
     * The approval id.
     * @type {string}
     * @memberof CompletedApproval
     */
    'id'?: string;
    /**
     * The name of the approval.
     * @type {string}
     * @memberof CompletedApproval
     */
    'name'?: string;
    /**
     * When the approval was created.
     * @type {string}
     * @memberof CompletedApproval
     */
    'created'?: string;
    /**
     * When the approval was modified last time.
     * @type {string}
     * @memberof CompletedApproval
     */
    'modified'?: string;
    /**
     * When the access-request was created.
     * @type {string}
     * @memberof CompletedApproval
     */
    'requestCreated'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof CompletedApproval
     */
    'requestType'?: AccessRequestType | null;
    /**
     * 
     * @type {AccessItemRequester}
     * @memberof CompletedApproval
     */
    'requester'?: AccessItemRequester;
    /**
     * 
     * @type {RequestedItemStatusRequestedFor}
     * @memberof CompletedApproval
     */
    'requestedFor'?: RequestedItemStatusRequestedFor;
    /**
     * 
     * @type {AccessItemReviewedBy}
     * @memberof CompletedApproval
     */
    'reviewedBy'?: AccessItemReviewedBy;
    /**
     * 
     * @type {OwnerDto}
     * @memberof CompletedApproval
     */
    'owner'?: OwnerDto;
    /**
     * 
     * @type {RequestableObjectReference}
     * @memberof CompletedApproval
     */
    'requestedObject'?: RequestableObjectReference;
    /**
     * 
     * @type {CompletedApprovalRequesterComment}
     * @memberof CompletedApproval
     */
    'requesterComment'?: CompletedApprovalRequesterComment;
    /**
     * 
     * @type {CompletedApprovalReviewerComment}
     * @memberof CompletedApproval
     */
    'reviewerComment'?: CompletedApprovalReviewerComment;
    /**
     * The history of the previous reviewers comments.
     * @type {Array<CommentDto>}
     * @memberof CompletedApproval
     */
    'previousReviewersComments'?: Array<CommentDto>;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof CompletedApproval
     */
    'forwardHistory'?: Array<ApprovalForwardHistory>;
    /**
     * When true the rejector has to provide comments when rejecting
     * @type {boolean}
     * @memberof CompletedApproval
     */
    'commentRequiredWhenRejected'?: boolean;
    /**
     * 
     * @type {CompletedApprovalState}
     * @memberof CompletedApproval
     */
    'state'?: CompletedApprovalState;
    /**
     * The date the role or access profile or entitlement is no longer assigned to the specified identity.
     * @type {string}
     * @memberof CompletedApproval
     */
    'removeDate'?: string | null;
    /**
     * If true, then the request was to change the remove date or sunset date.
     * @type {boolean}
     * @memberof CompletedApproval
     */
    'removeDateUpdateRequested'?: boolean;
    /**
     * The remove date or sunset date that was assigned at the time of the request.
     * @type {string}
     * @memberof CompletedApproval
     */
    'currentRemoveDate'?: string | null;
    /**
     * 
     * @type {SodViolationContextCheckCompleted}
     * @memberof CompletedApproval
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted | null;
    /**
     * 
     * @type {CompletedApprovalPreApprovalTriggerResult}
     * @memberof CompletedApproval
     */
    'preApprovalTriggerResult'?: CompletedApprovalPreApprovalTriggerResult | null;
    /**
     * Arbitrary key-value pairs provided during the request.
     * @type {{ [key: string]: string; }}
     * @memberof CompletedApproval
     */
    'clientMetadata'?: { [key: string]: string; };
}


/**
 * If the access request submitted event trigger is configured and this access request was intercepted by it, then this is the result of the trigger\'s decision to either approve or deny the request.
 * @export
 * @interface CompletedApprovalPreApprovalTriggerResult
 */
export interface CompletedApprovalPreApprovalTriggerResult {
    /**
     * The comment from the trigger
     * @type {string}
     * @memberof CompletedApprovalPreApprovalTriggerResult
     */
    'comment'?: string;
    /**
     * 
     * @type {CompletedApprovalState}
     * @memberof CompletedApprovalPreApprovalTriggerResult
     */
    'decision'?: CompletedApprovalState;
    /**
     * The name of the approver
     * @type {string}
     * @memberof CompletedApprovalPreApprovalTriggerResult
     */
    'reviewer'?: string;
    /**
     * The date and time the trigger decided on the request
     * @type {string}
     * @memberof CompletedApprovalPreApprovalTriggerResult
     */
    'date'?: string;
}


/**
 * 
 * @export
 * @interface CompletedApprovalRequesterComment
 */
export interface CompletedApprovalRequesterComment {
    /**
     * Comment content.
     * @type {string}
     * @memberof CompletedApprovalRequesterComment
     */
    'comment'?: string | null;
    /**
     * Date and time comment was created.
     * @type {string}
     * @memberof CompletedApprovalRequesterComment
     */
    'created'?: string;
    /**
     * 
     * @type {CommentDtoAuthor}
     * @memberof CompletedApprovalRequesterComment
     */
    'author'?: CommentDtoAuthor;
}
/**
 * 
 * @export
 * @interface CompletedApprovalReviewerComment
 */
export interface CompletedApprovalReviewerComment {
    /**
     * Comment content.
     * @type {string}
     * @memberof CompletedApprovalReviewerComment
     */
    'comment'?: string | null;
    /**
     * Date and time comment was created.
     * @type {string}
     * @memberof CompletedApprovalReviewerComment
     */
    'created'?: string;
    /**
     * 
     * @type {CommentDtoAuthor}
     * @memberof CompletedApprovalReviewerComment
     */
    'author'?: CommentDtoAuthor;
}
/**
 * Enum represents completed approval object\'s state.
 * @export
 * @enum {string}
 */

export const CompletedApprovalState = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type CompletedApprovalState = typeof CompletedApprovalState[keyof typeof CompletedApprovalState];


/**
 * The status after completion.
 * @export
 * @enum {string}
 */

export const CompletionStatus = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Incomplete: 'INCOMPLETE',
    Pending: 'PENDING'
} as const;

export type CompletionStatus = typeof CompletionStatus[keyof typeof CompletionStatus];


/**
 * 
 * @export
 * @interface Concatenation
 */
export interface Concatenation {
    /**
     * An array of items to join together
     * @type {Array<object>}
     * @memberof Concatenation
     */
    'values': Array<object>;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Concatenation
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Concatenation
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Conditional
 */
export interface Conditional {
    /**
     * A comparison statement that follows the structure of `ValueA eq ValueB` where `ValueA` and `ValueB` are static strings or outputs of other transforms.   The `eq` operator is the only valid comparison
     * @type {string}
     * @memberof Conditional
     */
    'expression': string;
    /**
     * The output of the transform if the expression evalutes to true
     * @type {string}
     * @memberof Conditional
     */
    'positiveCondition': string;
    /**
     * The output of the transform if the expression evalutes to false
     * @type {string}
     * @memberof Conditional
     */
    'negativeCondition': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Conditional
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Conditional
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ConflictingAccessCriteria
 */
export interface ConflictingAccessCriteria {
    /**
     * 
     * @type {AccessCriteria}
     * @memberof ConflictingAccessCriteria
     */
    'leftCriteria'?: AccessCriteria;
    /**
     * 
     * @type {AccessCriteria}
     * @memberof ConflictingAccessCriteria
     */
    'rightCriteria'?: AccessCriteria;
}
/**
 * 
 * @export
 * @interface ConnectorDetail
 */
export interface ConnectorDetail {
    /**
     * The connector name
     * @type {string}
     * @memberof ConnectorDetail
     */
    'name'?: string;
    /**
     * The connector type
     * @type {string}
     * @memberof ConnectorDetail
     */
    'type'?: string;
    /**
     * The connector class name
     * @type {string}
     * @memberof ConnectorDetail
     */
    'className'?: string;
    /**
     * The connector script name
     * @type {string}
     * @memberof ConnectorDetail
     */
    'scriptName'?: string;
    /**
     * The connector application xml
     * @type {string}
     * @memberof ConnectorDetail
     */
    'applicationXml'?: string;
    /**
     * The connector correlation config xml
     * @type {string}
     * @memberof ConnectorDetail
     */
    'correlationConfigXml'?: string;
    /**
     * The connector source config xml
     * @type {string}
     * @memberof ConnectorDetail
     */
    'sourceConfigXml'?: string;
    /**
     * The connector source config
     * @type {string}
     * @memberof ConnectorDetail
     */
    'sourceConfig'?: string;
    /**
     * The connector source config origin
     * @type {string}
     * @memberof ConnectorDetail
     */
    'sourceConfigFrom'?: string;
    /**
     * storage path key for this connector
     * @type {string}
     * @memberof ConnectorDetail
     */
    's3Location'?: string;
    /**
     * The list of uploaded files supported by the connector. If there was any executable files uploaded to thee connector. Typically this be empty as the executable be uploaded at source creation.
     * @type {Array<string>}
     * @memberof ConnectorDetail
     */
    'uploadedFiles'?: Array<string> | null;
    /**
     * true if the source is file upload
     * @type {boolean}
     * @memberof ConnectorDetail
     */
    'fileUpload'?: boolean;
    /**
     * true if the source is a direct connect source
     * @type {boolean}
     * @memberof ConnectorDetail
     */
    'directConnect'?: boolean;
    /**
     * A map containing translation attributes by loacale key
     * @type {{ [key: string]: any; }}
     * @memberof ConnectorDetail
     */
    'translationProperties'?: { [key: string]: any; };
    /**
     * A map containing metadata pertinent to the UI to be used
     * @type {{ [key: string]: any; }}
     * @memberof ConnectorDetail
     */
    'connectorMetadata'?: { [key: string]: any; };
    /**
     * The connector status
     * @type {string}
     * @memberof ConnectorDetail
     */
    'status'?: ConnectorDetailStatusV3;
}

export const ConnectorDetailStatusV3 = {
    Deprecated: 'DEPRECATED',
    Development: 'DEVELOPMENT',
    Demo: 'DEMO',
    Released: 'RELEASED'
} as const;

export type ConnectorDetailStatusV3 = typeof ConnectorDetailStatusV3[keyof typeof ConnectorDetailStatusV3];

/**
 * 
 * @export
 * @interface CreateExternalExecuteWorkflow200Response
 */
export interface CreateExternalExecuteWorkflow200Response {
    /**
     * The workflow execution id
     * @type {string}
     * @memberof CreateExternalExecuteWorkflow200Response
     */
    'workflowExecutionId'?: string;
    /**
     * An error message if any errors occurred
     * @type {string}
     * @memberof CreateExternalExecuteWorkflow200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface CreateExternalExecuteWorkflowRequest
 */
export interface CreateExternalExecuteWorkflowRequest {
    /**
     * The input for the workflow
     * @type {object}
     * @memberof CreateExternalExecuteWorkflowRequest
     */
    'input'?: object;
}
/**
 * 
 * @export
 * @interface CreateOAuthClientRequest
 */
export interface CreateOAuthClientRequest {
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'businessName'?: string | null;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'homepageUrl'?: string | null;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'name': string | null;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'description': string | null;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientRequest
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientRequest
     */
    'refreshTokenValiditySeconds'?: number;
    /**
     * A list of the approved redirect URIs. Provide one or more URIs when assigning the AUTHORIZATION_CODE grant type to a new OAuth Client.
     * @type {Array<string>}
     * @memberof CreateOAuthClientRequest
     */
    'redirectUris'?: Array<string> | null;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof CreateOAuthClientRequest
     */
    'grantTypes': Array<GrantType> | null;
    /**
     * 
     * @type {AccessType}
     * @memberof CreateOAuthClientRequest
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof CreateOAuthClientRequest
     */
    'type'?: ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal within the product.
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'internal'?: boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'strongAuthSupported'?: boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'claimsSupported'?: boolean;
    /**
     * Scopes of the API Client. If no scope is specified, the client will be created with the default scope \"sp:scopes:all\". This means the API Client will have all the rights of the owner who created it.
     * @type {Array<string>}
     * @memberof CreateOAuthClientRequest
     */
    'scope'?: Array<string> | null;
}


/**
 * 
 * @export
 * @interface CreateOAuthClientResponse
 */
export interface CreateOAuthClientResponse {
    /**
     * ID of the OAuth client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'id': string;
    /**
     * Secret of the OAuth client (This field is only returned on the intial create call.)
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'secret': string;
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'businessName': string;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'homepageUrl': string;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'name': string;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'description': string;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientResponse
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientResponse
     */
    'refreshTokenValiditySeconds': number;
    /**
     * A list of the approved redirect URIs used with the authorization_code flow
     * @type {Array<string>}
     * @memberof CreateOAuthClientResponse
     */
    'redirectUris': Array<string>;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof CreateOAuthClientResponse
     */
    'grantTypes': Array<GrantType>;
    /**
     * 
     * @type {AccessType}
     * @memberof CreateOAuthClientResponse
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof CreateOAuthClientResponse
     */
    'type': ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal to IDN
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'internal': boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'strongAuthSupported': boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'claimsSupported': boolean;
    /**
     * The date and time, down to the millisecond, when the API Client was created
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when the API Client was last updated
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'modified': string;
    /**
     * Scopes of the API Client.
     * @type {Array<string>}
     * @memberof CreateOAuthClientResponse
     */
    'scope': Array<string> | null;
}


/**
 * Object for specifying the name of a personal access token to create
 * @export
 * @interface CreatePersonalAccessTokenRequest
 */
export interface CreatePersonalAccessTokenRequest {
    /**
     * The name of the personal access token (PAT) to be created. Cannot be the same as another PAT owned by the user for whom this PAT is being created.
     * @type {string}
     * @memberof CreatePersonalAccessTokenRequest
     */
    'name': string;
    /**
     * Scopes of the personal  access token. If no scope is specified, the token will be created with the default scope \"sp:scopes:all\". This means the personal access token will have all the rights of the owner who created it.
     * @type {Array<string>}
     * @memberof CreatePersonalAccessTokenRequest
     */
    'scope'?: Array<string> | null;
    /**
     * Number of seconds an access token is valid when generated using this Personal Access Token. If no value is specified, the token will be created with the default value of 43200.
     * @type {number}
     * @memberof CreatePersonalAccessTokenRequest
     */
    'accessTokenValiditySeconds'?: number;
}
/**
 * 
 * @export
 * @interface CreatePersonalAccessTokenResponse
 */
export interface CreatePersonalAccessTokenResponse {
    /**
     * The ID of the personal access token (to be used as the username for Basic Auth).
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'id': string;
    /**
     * The secret of the personal access token (to be used as the password for Basic Auth).
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'secret': string;
    /**
     * Scopes of the personal  access token.
     * @type {Array<string>}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'scope': Array<string> | null;
    /**
     * The name of the personal access token. Cannot be the same as other personal access tokens owned by a user.
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'name': string;
    /**
     * 
     * @type {PatOwner}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'owner': PatOwner;
    /**
     * The date and time, down to the millisecond, when this personal access token was created.
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'created': string;
    /**
     * Number of seconds an access token is valid when generated using this Personal Access Token. If no value is specified, the token will be created with the default value of 43200.
     * @type {number}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'accessTokenValiditySeconds': number;
}
/**
 * 
 * @export
 * @interface CreateSavedSearchRequest
 */
export interface CreateSavedSearchRequest {
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'description'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof CreateSavedSearchRequest
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof CreateSavedSearchRequest
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof CreateSavedSearchRequest
     */
    'fields'?: Array<string> | null;
    /**
     * Sort by index. This takes precedence over the `sort` property. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof CreateSavedSearchRequest
     */
    'orderBy'?: { [key: string]: Array<string>; } | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof CreateSavedSearchRequest
     */
    'sort'?: Array<string> | null;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof CreateSavedSearchRequest
     */
    'filters'?: SavedSearchDetailFilters | null;
}
/**
 * 
 * @export
 * @interface CreateScheduledSearchRequest
 */
export interface CreateScheduledSearchRequest {
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'description'?: string | null;
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'savedSearchId': string;
    /**
     * The date the scheduled search was initially created.
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'created'?: string | null;
    /**
     * The last date the scheduled search was modified.
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'modified'?: string | null;
    /**
     * 
     * @type {Schedule1}
     * @memberof CreateScheduledSearchRequest
     */
    'schedule': Schedule1;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof CreateScheduledSearchRequest
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof CreateScheduledSearchRequest
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should occur when search returns no results. 
     * @type {boolean}
     * @memberof CreateScheduledSearchRequest
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof CreateScheduledSearchRequest
     */
    'displayQueryDetails'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateUploadedConfigurationRequest
 */
export interface CreateUploadedConfigurationRequest {
    /**
     * JSON file containing the objects to be imported.
     * @type {File}
     * @memberof CreateUploadedConfigurationRequest
     */
    'data': File;
    /**
     * Name that will be assigned to the uploaded configuration file.
     * @type {string}
     * @memberof CreateUploadedConfigurationRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateWorkflowRequest
 */
export interface CreateWorkflowRequest {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof CreateWorkflowRequest
     */
    'name': string;
    /**
     * 
     * @type {WorkflowBodyOwner}
     * @memberof CreateWorkflowRequest
     */
    'owner'?: WorkflowBodyOwner;
    /**
     * Description of what the workflow accomplishes
     * @type {string}
     * @memberof CreateWorkflowRequest
     */
    'description'?: string;
    /**
     * 
     * @type {WorkflowDefinition}
     * @memberof CreateWorkflowRequest
     */
    'definition'?: WorkflowDefinition;
    /**
     * Enable or disable the workflow.  Workflows cannot be created in an enabled state.
     * @type {boolean}
     * @memberof CreateWorkflowRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {WorkflowTrigger}
     * @memberof CreateWorkflowRequest
     */
    'trigger'?: WorkflowTrigger;
}
/**
 * Type of the criteria in the filter. The `COMPOSITE` filter can contain multiple filters in an AND/OR relationship.
 * @export
 * @enum {string}
 */

export const CriteriaType = {
    Composite: 'COMPOSITE',
    Role: 'ROLE',
    Identity: 'IDENTITY',
    IdentityAttribute: 'IDENTITY_ATTRIBUTE',
    Entitlement: 'ENTITLEMENT',
    AccessProfile: 'ACCESS_PROFILE',
    Source: 'SOURCE',
    Account: 'ACCOUNT',
    AggregatedEntitlement: 'AGGREGATED_ENTITLEMENT',
    InvalidCertifiableEntity: 'INVALID_CERTIFIABLE_ENTITY'
} as const;

export type CriteriaType = typeof CriteriaType[keyof typeof CriteriaType];


/**
 * DAS data for the entitlement
 * @export
 * @interface DataAccess
 */
export interface DataAccess {
    /**
     * List of classification policies that apply to resources the entitlement \\ groups has access to
     * @type {Array<DataAccessPoliciesInner>}
     * @memberof DataAccess
     */
    'policies'?: Array<DataAccessPoliciesInner>;
    /**
     * List of classification categories that apply to resources the entitlement \\ groups has access to
     * @type {Array<DataAccessCategoriesInner>}
     * @memberof DataAccess
     */
    'categories'?: Array<DataAccessCategoriesInner>;
    /**
     * 
     * @type {DataAccessImpactScore}
     * @memberof DataAccess
     */
    'impactScore'?: DataAccessImpactScore;
}
/**
 * 
 * @export
 * @interface DataAccessCategoriesInner
 */
export interface DataAccessCategoriesInner {
    /**
     * Value of the category
     * @type {string}
     * @memberof DataAccessCategoriesInner
     */
    'value'?: string;
    /**
     * Number of matched for each category
     * @type {number}
     * @memberof DataAccessCategoriesInner
     */
    'matchCount'?: number;
}
/**
 * 
 * @export
 * @interface DataAccessImpactScore
 */
export interface DataAccessImpactScore {
    /**
     * Impact Score for this data
     * @type {string}
     * @memberof DataAccessImpactScore
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface DataAccessPoliciesInner
 */
export interface DataAccessPoliciesInner {
    /**
     * Value of the policy
     * @type {string}
     * @memberof DataAccessPoliciesInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface DateCompare
 */
export interface DateCompare {
    /**
     * 
     * @type {DateCompareFirstDate}
     * @memberof DateCompare
     */
    'firstDate': DateCompareFirstDate;
    /**
     * 
     * @type {DateCompareSecondDate}
     * @memberof DateCompare
     */
    'secondDate': DateCompareSecondDate;
    /**
     * This is the comparison to perform. | Operation | Description | | --------- | ------- | | LT        | Strictly less than: `firstDate < secondDate` | | LTE       | Less than or equal to: `firstDate <= secondDate` | | GT        | Strictly greater than: `firstDate > secondDate` | | GTE       | Greater than or equal to: `firstDate >= secondDate` | 
     * @type {string}
     * @memberof DateCompare
     */
    'operator': DateCompareOperatorV3;
    /**
     * The output of the transform if the expression evalutes to true
     * @type {string}
     * @memberof DateCompare
     */
    'positiveCondition': string;
    /**
     * The output of the transform if the expression evalutes to false
     * @type {string}
     * @memberof DateCompare
     */
    'negativeCondition': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateCompare
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateCompare
     */
    'input'?: { [key: string]: any; };
}

export const DateCompareOperatorV3 = {
    Lt: 'LT',
    Lte: 'LTE',
    Gt: 'GT',
    Gte: 'GTE'
} as const;

export type DateCompareOperatorV3 = typeof DateCompareOperatorV3[keyof typeof DateCompareOperatorV3];

/**
 * @type DateCompareFirstDate
 * This is the first date to consider (The date that would be on the left hand side of the comparison operation).
 * @export
 */
export type DateCompareFirstDate = AccountAttribute | DateFormat;

/**
 * @type DateCompareSecondDate
 * This is the second date to consider (The date that would be on the right hand side of the comparison operation).
 * @export
 */
export type DateCompareSecondDate = AccountAttribute | DateFormat;

/**
 * 
 * @export
 * @interface DateFormat
 */
export interface DateFormat {
    /**
     * 
     * @type {DateFormatInputFormat}
     * @memberof DateFormat
     */
    'inputFormat'?: DateFormatInputFormat;
    /**
     * 
     * @type {DateFormatOutputFormat}
     * @memberof DateFormat
     */
    'outputFormat'?: DateFormatOutputFormat;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateFormat
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateFormat
     */
    'input'?: { [key: string]: any; };
}
/**
 * @type DateFormatInputFormat
 * A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.  *If no inputFormat is provided, the transform assumes that it is in ISO8601 format*
 * @export
 */
export type DateFormatInputFormat = NamedConstructs | string;

/**
 * @type DateFormatOutputFormat
 * A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.  *If no inputFormat is provided, the transform assumes that it is in ISO8601 format*
 * @export
 */
export type DateFormatOutputFormat = NamedConstructs | string;

/**
 * 
 * @export
 * @interface DateMath
 */
export interface DateMath {
    /**
     * A string value of the date and time components to operation on, along with the math operations to execute. 
     * @type {string}
     * @memberof DateMath
     */
    'expression': string;
    /**
     * A boolean value to indicate whether the transform should round up or down when a rounding `/` operation is defined in the expression.    If not provided, the transform will default to `false`   `true` indicates the transform should round up (i.e., truncate the fractional date/time component indicated and then add one unit of that component)   `false` indicates the transform should round down (i.e., truncate the fractional date/time component indicated) 
     * @type {boolean}
     * @memberof DateMath
     */
    'roundUp'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateMath
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateMath
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface DecomposeDiacriticalMarks
 */
export interface DecomposeDiacriticalMarks {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DecomposeDiacriticalMarks
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DecomposeDiacriticalMarks
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface DeleteNonEmployeeRecordsInBulkRequest
 */
export interface DeleteNonEmployeeRecordsInBulkRequest {
    /**
     * List of non-employee ids.
     * @type {Array<string>}
     * @memberof DeleteNonEmployeeRecordsInBulkRequest
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteSource202Response
 */
export interface DeleteSource202Response {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'type'?: DeleteSource202ResponseTypeV3;
    /**
     * Task result ID.
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'id'?: string;
    /**
     * Task result\'s human-readable display name (this should be null/empty).
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'name'?: string;
}

export const DeleteSource202ResponseTypeV3 = {
    TaskResult: 'TASK_RESULT'
} as const;

export type DeleteSource202ResponseTypeV3 = typeof DeleteSource202ResponseTypeV3[keyof typeof DeleteSource202ResponseTypeV3];

/**
 * 
 * @export
 * @interface DeleteVendorConnectorMapping200Response
 */
export interface DeleteVendorConnectorMapping200Response {
    /**
     * The number of vendor connector mappings successfully deleted.
     * @type {number}
     * @memberof DeleteVendorConnectorMapping200Response
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface DependantAppConnections
 */
export interface DependantAppConnections {
    /**
     * Id of the connected Application
     * @type {string}
     * @memberof DependantAppConnections
     */
    'cloudAppId'?: string;
    /**
     * Description of the connected Application
     * @type {string}
     * @memberof DependantAppConnections
     */
    'description'?: string;
    /**
     * Is the Application enabled
     * @type {boolean}
     * @memberof DependantAppConnections
     */
    'enabled'?: boolean;
    /**
     * Is Provisioning enabled for connected Application
     * @type {boolean}
     * @memberof DependantAppConnections
     */
    'provisionRequestEnabled'?: boolean;
    /**
     * 
     * @type {DependantAppConnectionsAccountSource}
     * @memberof DependantAppConnections
     */
    'accountSource'?: DependantAppConnectionsAccountSource;
    /**
     * The amount of launchers for connected Application (long type)
     * @type {number}
     * @memberof DependantAppConnections
     */
    'launcherCount'?: number;
    /**
     * Is Provisioning enabled for connected Application
     * @type {boolean}
     * @memberof DependantAppConnections
     */
    'matchAllAccount'?: boolean;
    /**
     * The owner of the connected Application
     * @type {Array<BaseReferenceDto>}
     * @memberof DependantAppConnections
     */
    'owner'?: Array<BaseReferenceDto>;
    /**
     * Is App Center enabled for connected Application
     * @type {boolean}
     * @memberof DependantAppConnections
     */
    'appCenterEnabled'?: boolean;
}
/**
 * The Account Source of the connected Application
 * @export
 * @interface DependantAppConnectionsAccountSource
 */
export interface DependantAppConnectionsAccountSource {
    /**
     * Use this Account Source for password management
     * @type {boolean}
     * @memberof DependantAppConnectionsAccountSource
     */
    'useForPasswordManagement'?: boolean;
    /**
     * A list of Password Policies for this Account Source
     * @type {Array<DependantAppConnectionsAccountSourcePasswordPoliciesInner>}
     * @memberof DependantAppConnectionsAccountSource
     */
    'passwordPolicies'?: Array<DependantAppConnectionsAccountSourcePasswordPoliciesInner>;
}
/**
 * 
 * @export
 * @interface DependantAppConnectionsAccountSourcePasswordPoliciesInner
 */
export interface DependantAppConnectionsAccountSourcePasswordPoliciesInner {
    /**
     * DTO type
     * @type {string}
     * @memberof DependantAppConnectionsAccountSourcePasswordPoliciesInner
     */
    'type'?: string;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof DependantAppConnectionsAccountSourcePasswordPoliciesInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof DependantAppConnectionsAccountSourcePasswordPoliciesInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface DependantConnectionsMissingDto
 */
export interface DependantConnectionsMissingDto {
    /**
     * The type of dependency type that is missing in the SourceConnections
     * @type {string}
     * @memberof DependantConnectionsMissingDto
     */
    'dependencyType'?: DependantConnectionsMissingDtoDependencyTypeV3;
    /**
     * The reason why this dependency is missing
     * @type {string}
     * @memberof DependantConnectionsMissingDto
     */
    'reason'?: string;
}

export const DependantConnectionsMissingDtoDependencyTypeV3 = {
    IdentityProfiles: 'identityProfiles',
    CredentialProfiles: 'credentialProfiles',
    MappingProfiles: 'mappingProfiles',
    SourceAttributes: 'sourceAttributes',
    DependantCustomTransforms: 'dependantCustomTransforms',
    DependantApps: 'dependantApps'
} as const;

export type DependantConnectionsMissingDtoDependencyTypeV3 = typeof DependantConnectionsMissingDtoDependencyTypeV3[keyof typeof DependantConnectionsMissingDtoDependencyTypeV3];

/**
 * 
 * @export
 * @interface DimensionRef
 */
export interface DimensionRef {
    /**
     * The type of the object to which this reference applies
     * @type {string}
     * @memberof DimensionRef
     */
    'type'?: DimensionRefTypeV3;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof DimensionRef
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof DimensionRef
     */
    'name'?: string;
}

export const DimensionRefTypeV3 = {
    Dimension: 'DIMENSION'
} as const;

export type DimensionRefTypeV3 = typeof DimensionRefTypeV3[keyof typeof DimensionRefTypeV3];

/**
 * 
 * @export
 * @interface DisplayReference
 */
export interface DisplayReference {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof DisplayReference
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof DisplayReference
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisplayReference
     */
    'displayName'?: string;
}
/**
 * 
 * @export
 * @interface DocumentFields
 */
export interface DocumentFields {
    /**
     * Name of the pod.
     * @type {string}
     * @memberof DocumentFields
     */
    'pod'?: string;
    /**
     * Name of the tenant.
     * @type {string}
     * @memberof DocumentFields
     */
    'org'?: string;
    /**
     * 
     * @type {DocumentType}
     * @memberof DocumentFields
     */
    '_type'?: DocumentType;
    /**
     * 
     * @type {DocumentType}
     * @memberof DocumentFields
     */
    'type'?: DocumentType;
    /**
     * Version number.
     * @type {string}
     * @memberof DocumentFields
     */
    '_version'?: string;
}


/**
 * Enum representing the currently supported document types.  Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const DocumentType = {
    Accessprofile: 'accessprofile',
    Accountactivity: 'accountactivity',
    Entitlement: 'entitlement',
    Event: 'event',
    Identity: 'identity',
    Role: 'role'
} as const;

export type DocumentType = typeof DocumentType[keyof typeof DocumentType];


/**
 * An enumeration of the types of DTOs supported within the IdentityNow infrastructure.
 * @export
 * @enum {string}
 */

export const DtoType = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG',
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestApproval: 'ACCESS_REQUEST_APPROVAL',
    Account: 'ACCOUNT',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    CampaignFilter: 'CAMPAIGN_FILTER',
    Certification: 'CERTIFICATION',
    Cluster: 'CLUSTER',
    ConnectorSchema: 'CONNECTOR_SCHEMA',
    Entitlement: 'ENTITLEMENT',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY',
    IdentityProfile: 'IDENTITY_PROFILE',
    IdentityRequest: 'IDENTITY_REQUEST',
    MachineIdentity: 'MACHINE_IDENTITY',
    LifecycleState: 'LIFECYCLE_STATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    Role: 'ROLE',
    Rule: 'RULE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    TagCategory: 'TAG_CATEGORY',
    TaskResult: 'TASK_RESULT',
    ReportResult: 'REPORT_RESULT',
    SodViolation: 'SOD_VIOLATION',
    AccountActivity: 'ACCOUNT_ACTIVITY',
    Workgroup: 'WORKGROUP'
} as const;

export type DtoType = typeof DtoType[keyof typeof DtoType];


/**
 * 
 * @export
 * @interface DuoVerificationRequest
 */
export interface DuoVerificationRequest {
    /**
     * User id for Verification request.
     * @type {string}
     * @memberof DuoVerificationRequest
     */
    'userId': string;
    /**
     * User id for Verification request.
     * @type {string}
     * @memberof DuoVerificationRequest
     */
    'signedResponse': string;
}
/**
 * 
 * @export
 * @interface E164phone
 */
export interface E164phone {
    /**
     * This is an optional attribute that can be used to define the region of the phone number to format into.   If defaultRegion is not provided, it will take US as the default country.   The format of the country code should be in [ISO 3166-1 alpha-2 format](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) 
     * @type {string}
     * @memberof E164phone
     */
    'defaultRegion'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof E164phone
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof E164phone
     */
    'input'?: { [key: string]: any; };
}
/**
 * This is used for representing email configuration for a lifecycle state
 * @export
 * @interface EmailNotificationOption
 */
export interface EmailNotificationOption {
    /**
     * If true, then the manager is notified of the lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifyManagers'?: boolean;
    /**
     * If true, then all the admins are notified of the lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifyAllAdmins'?: boolean;
    /**
     * If true, then the users specified in \"emailAddressList\" below are notified of lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifySpecificUsers'?: boolean;
    /**
     * List of user email addresses. If \"notifySpecificUsers\" option is true, then these users are notified of lifecycle state change.
     * @type {Array<string>}
     * @memberof EmailNotificationOption
     */
    'emailAddressList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Entitlement
 */
export interface Entitlement {
    /**
     * The entitlement id
     * @type {string}
     * @memberof Entitlement
     */
    'id'?: string;
    /**
     * The entitlement name
     * @type {string}
     * @memberof Entitlement
     */
    'name'?: string;
    /**
     * The entitlement attribute name
     * @type {string}
     * @memberof Entitlement
     */
    'attribute'?: string;
    /**
     * The value of the entitlement
     * @type {string}
     * @memberof Entitlement
     */
    'value'?: string;
    /**
     * The object type of the entitlement from the source schema
     * @type {string}
     * @memberof Entitlement
     */
    'sourceSchemaObjectType'?: string;
    /**
     * The description of the entitlement
     * @type {string}
     * @memberof Entitlement
     */
    'description'?: string | null;
    /**
     * True if the entitlement is privileged
     * @type {boolean}
     * @memberof Entitlement
     */
    'privileged'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof Entitlement
     */
    'cloudGoverned'?: boolean;
    /**
     * True if the entitlement is able to be directly requested
     * @type {boolean}
     * @memberof Entitlement
     */
    'requestable'?: boolean;
    /**
     * 
     * @type {EntitlementOwner}
     * @memberof Entitlement
     */
    'owner'?: EntitlementOwner | null;
    /**
     * A map of entitlement fields that have been manually updated. The key is the field name in UPPER_SNAKE_CASE format, and the value is true or false to indicate if the field has been updated.
     * @type {{ [key: string]: any; }}
     * @memberof Entitlement
     */
    'manuallyUpdatedFields'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {EntitlementAccessModelMetadata}
     * @memberof Entitlement
     */
    'accessModelMetadata'?: EntitlementAccessModelMetadata;
    /**
     * Time when the entitlement was created
     * @type {string}
     * @memberof Entitlement
     */
    'created'?: string;
    /**
     * Time when the entitlement was last modified
     * @type {string}
     * @memberof Entitlement
     */
    'modified'?: string;
    /**
     * 
     * @type {EntitlementSource}
     * @memberof Entitlement
     */
    'source'?: EntitlementSource;
    /**
     * A map of free-form key-value pairs from the source system
     * @type {{ [key: string]: any; }}
     * @memberof Entitlement
     */
    'attributes'?: { [key: string]: any; };
    /**
     * List of IDs of segments, if any, to which this Entitlement is assigned.
     * @type {Array<string>}
     * @memberof Entitlement
     */
    'segments'?: Array<string> | null;
    /**
     * 
     * @type {Array<PermissionDto>}
     * @memberof Entitlement
     */
    'directPermissions'?: Array<PermissionDto>;
}
/**
 * Additional data to classify the entitlement
 * @export
 * @interface EntitlementAccessModelMetadata
 */
export interface EntitlementAccessModelMetadata {
    /**
     * 
     * @type {Array<AccessModelMetadata>}
     * @memberof EntitlementAccessModelMetadata
     */
    'attributes'?: Array<AccessModelMetadata>;
}
/**
 * Entitlement
 * @export
 * @interface EntitlementDocument
 */
export interface EntitlementDocument {
    /**
     * ID of the referenced object.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'name': string;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof EntitlementDocument
     */
    'synced'?: string;
    /**
     * Entitlement\'s display name.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'displayName'?: string;
    /**
     * 
     * @type {EntitlementDocumentAllOfSource}
     * @memberof EntitlementDocument
     */
    'source'?: EntitlementDocumentAllOfSource;
    /**
     * Segments with the entitlement.
     * @type {Array<BaseSegment>}
     * @memberof EntitlementDocument
     */
    'segments'?: Array<BaseSegment>;
    /**
     * Number of segments with the role.
     * @type {number}
     * @memberof EntitlementDocument
     */
    'segmentCount'?: number;
    /**
     * Indicates whether the entitlement is requestable.
     * @type {boolean}
     * @memberof EntitlementDocument
     */
    'requestable'?: boolean;
    /**
     * Indicates whether the entitlement is cloud governed.
     * @type {boolean}
     * @memberof EntitlementDocument
     */
    'cloudGoverned'?: boolean;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'created'?: string | null;
    /**
     * Indicates whether the entitlement is privileged.
     * @type {boolean}
     * @memberof EntitlementDocument
     */
    'privileged'?: boolean;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof EntitlementDocument
     */
    'tags'?: Array<string>;
    /**
     * Attribute information for the entitlement.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'attribute'?: string;
    /**
     * Value of the entitlement.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'value'?: string;
    /**
     * Source schema object type of the entitlement.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'sourceSchemaObjectType'?: string;
    /**
     * Schema type of the entitlement.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'schema'?: string;
    /**
     * Read-only calculated hash value of an entitlement.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'hash'?: string;
    /**
     * Attributes of the entitlement.
     * @type {{ [key: string]: any; }}
     * @memberof EntitlementDocument
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Truncated attributes of the entitlement.
     * @type {Array<string>}
     * @memberof EntitlementDocument
     */
    'truncatedAttributes'?: Array<string>;
    /**
     * Indicates whether the entitlement contains data access.
     * @type {boolean}
     * @memberof EntitlementDocument
     */
    'containsDataAccess'?: boolean;
    /**
     * 
     * @type {EntitlementDocumentAllOfManuallyUpdatedFields}
     * @memberof EntitlementDocument
     */
    'manuallyUpdatedFields'?: EntitlementDocumentAllOfManuallyUpdatedFields | null;
    /**
     * 
     * @type {Array<EntitlementDocumentAllOfPermissions>}
     * @memberof EntitlementDocument
     */
    'permissions'?: Array<EntitlementDocumentAllOfPermissions>;
}
/**
 * Indicates whether the entitlement\'s display name and/or description have been manually updated.
 * @export
 * @interface EntitlementDocumentAllOfManuallyUpdatedFields
 */
export interface EntitlementDocumentAllOfManuallyUpdatedFields {
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementDocumentAllOfManuallyUpdatedFields
     */
    'DESCRIPTION'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementDocumentAllOfManuallyUpdatedFields
     */
    'DISPLAY_NAME'?: boolean;
}
/**
 * 
 * @export
 * @interface EntitlementDocumentAllOfPermissions
 */
export interface EntitlementDocumentAllOfPermissions {
    /**
     * The target the permission would grants rights on.
     * @type {string}
     * @memberof EntitlementDocumentAllOfPermissions
     */
    'target'?: string;
    /**
     * All the rights (e.g. actions) that this permission allows on the target
     * @type {Array<string>}
     * @memberof EntitlementDocumentAllOfPermissions
     */
    'rights'?: Array<string>;
}
/**
 * Entitlement\'s source.
 * @export
 * @interface EntitlementDocumentAllOfSource
 */
export interface EntitlementDocumentAllOfSource {
    /**
     * ID of entitlement\'s source.
     * @type {string}
     * @memberof EntitlementDocumentAllOfSource
     */
    'id'?: string;
    /**
     * Display name of entitlement\'s source.
     * @type {string}
     * @memberof EntitlementDocumentAllOfSource
     */
    'name'?: string;
    /**
     * Type of object.
     * @type {string}
     * @memberof EntitlementDocumentAllOfSource
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface EntitlementDocuments
 */
export interface EntitlementDocuments {
    /**
     * ID of the referenced object.
     * @type {string}
     * @memberof EntitlementDocuments
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof EntitlementDocuments
     */
    'name': string;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof EntitlementDocuments
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof EntitlementDocuments
     */
    'synced'?: string;
    /**
     * Entitlement\'s display name.
     * @type {string}
     * @memberof EntitlementDocuments
     */
    'displayName'?: string;
    /**
     * 
     * @type {EntitlementDocumentAllOfSource}
     * @memberof EntitlementDocuments
     */
    'source'?: EntitlementDocumentAllOfSource;
    /**
     * Segments with the entitlement.
     * @type {Array<BaseSegment>}
     * @memberof EntitlementDocuments
     */
    'segments'?: Array<BaseSegment>;
    /**
     * Number of segments with the role.
     * @type {number}
     * @memberof EntitlementDocuments
     */
    'segmentCount'?: number;
    /**
     * Indicates whether the entitlement is requestable.
     * @type {boolean}
     * @memberof EntitlementDocuments
     */
    'requestable'?: boolean;
    /**
     * Indicates whether the entitlement is cloud governed.
     * @type {boolean}
     * @memberof EntitlementDocuments
     */
    'cloudGoverned'?: boolean;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof EntitlementDocuments
     */
    'created'?: string | null;
    /**
     * Indicates whether the entitlement is privileged.
     * @type {boolean}
     * @memberof EntitlementDocuments
     */
    'privileged'?: boolean;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof EntitlementDocuments
     */
    'tags'?: Array<string>;
    /**
     * Attribute information for the entitlement.
     * @type {string}
     * @memberof EntitlementDocuments
     */
    'attribute'?: string;
    /**
     * Value of the entitlement.
     * @type {string}
     * @memberof EntitlementDocuments
     */
    'value'?: string;
    /**
     * Source schema object type of the entitlement.
     * @type {string}
     * @memberof EntitlementDocuments
     */
    'sourceSchemaObjectType'?: string;
    /**
     * Schema type of the entitlement.
     * @type {string}
     * @memberof EntitlementDocuments
     */
    'schema'?: string;
    /**
     * Read-only calculated hash value of an entitlement.
     * @type {string}
     * @memberof EntitlementDocuments
     */
    'hash'?: string;
    /**
     * Attributes of the entitlement.
     * @type {{ [key: string]: any; }}
     * @memberof EntitlementDocuments
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Truncated attributes of the entitlement.
     * @type {Array<string>}
     * @memberof EntitlementDocuments
     */
    'truncatedAttributes'?: Array<string>;
    /**
     * Indicates whether the entitlement contains data access.
     * @type {boolean}
     * @memberof EntitlementDocuments
     */
    'containsDataAccess'?: boolean;
    /**
     * 
     * @type {EntitlementDocumentAllOfManuallyUpdatedFields}
     * @memberof EntitlementDocuments
     */
    'manuallyUpdatedFields'?: EntitlementDocumentAllOfManuallyUpdatedFields | null;
    /**
     * 
     * @type {Array<EntitlementDocumentAllOfPermissions>}
     * @memberof EntitlementDocuments
     */
    'permissions'?: Array<EntitlementDocumentAllOfPermissions>;
    /**
     * Name of the pod.
     * @type {string}
     * @memberof EntitlementDocuments
     */
    'pod'?: string;
    /**
     * Name of the tenant.
     * @type {string}
     * @memberof EntitlementDocuments
     */
    'org'?: string;
    /**
     * 
     * @type {DocumentType}
     * @memberof EntitlementDocuments
     */
    '_type'?: DocumentType;
    /**
     * 
     * @type {DocumentType}
     * @memberof EntitlementDocuments
     */
    'type'?: DocumentType;
    /**
     * Version number.
     * @type {string}
     * @memberof EntitlementDocuments
     */
    '_version'?: string;
}


/**
 * The identity that owns the entitlement
 * @export
 * @interface EntitlementOwner
 */
export interface EntitlementOwner {
    /**
     * The identity ID
     * @type {string}
     * @memberof EntitlementOwner
     */
    'id'?: string;
    /**
     * The type of object
     * @type {string}
     * @memberof EntitlementOwner
     */
    'type'?: EntitlementOwnerTypeV3;
    /**
     * The display name of the identity
     * @type {string}
     * @memberof EntitlementOwner
     */
    'name'?: string;
}

export const EntitlementOwnerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type EntitlementOwnerTypeV3 = typeof EntitlementOwnerTypeV3[keyof typeof EntitlementOwnerTypeV3];

/**
 * Entitlement including a specific set of access.
 * @export
 * @interface EntitlementRef
 */
export interface EntitlementRef {
    /**
     * Entitlement\'s DTO type.
     * @type {string}
     * @memberof EntitlementRef
     */
    'type'?: EntitlementRefTypeV3;
    /**
     * Entitlement\'s ID.
     * @type {string}
     * @memberof EntitlementRef
     */
    'id'?: string;
    /**
     * Entitlement\'s display name.
     * @type {string}
     * @memberof EntitlementRef
     */
    'name'?: string | null;
}

export const EntitlementRefTypeV3 = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type EntitlementRefTypeV3 = typeof EntitlementRefTypeV3[keyof typeof EntitlementRefTypeV3];

/**
 * Entitlement including a specific set of access.
 * @export
 * @interface EntitlementRef1
 */
export interface EntitlementRef1 {
    /**
     * Entitlement\'s DTO type.
     * @type {string}
     * @memberof EntitlementRef1
     */
    'type'?: EntitlementRef1TypeV3;
    /**
     * Entitlement\'s ID.
     * @type {string}
     * @memberof EntitlementRef1
     */
    'id'?: string;
    /**
     * Entitlement\'s display name.
     * @type {string}
     * @memberof EntitlementRef1
     */
    'name'?: string;
}

export const EntitlementRef1TypeV3 = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type EntitlementRef1TypeV3 = typeof EntitlementRef1TypeV3[keyof typeof EntitlementRef1TypeV3];

/**
 * 
 * @export
 * @interface EntitlementRequestConfig
 */
export interface EntitlementRequestConfig {
    /**
     * If this is true, entitlement requests are allowed.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'allowEntitlementRequest'?: boolean;
    /**
     * If this is true, comments are required to submit entitlement requests.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'requestCommentsRequired'?: boolean;
    /**
     * If this is true, comments are required to reject entitlement requests.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'deniedCommentsRequired'?: boolean;
    /**
     * Approval schemes for granting entitlement request. This can be empty if no approval is needed. Multiple schemes must be comma-separated. The valid schemes are \"entitlementOwner\", \"sourceOwner\", \"manager\" and \"`workgroup:{id}`\". You can use multiple governance groups (workgroups). 
     * @type {string}
     * @memberof EntitlementRequestConfig
     */
    'grantRequestApprovalSchemes'?: string | null;
}
/**
 * 
 * @export
 * @interface EntitlementSource
 */
export interface EntitlementSource {
    /**
     * The source ID
     * @type {string}
     * @memberof EntitlementSource
     */
    'id'?: string;
    /**
     * The source type, will always be \"SOURCE\"
     * @type {string}
     * @memberof EntitlementSource
     */
    'type'?: string;
    /**
     * The source name
     * @type {string}
     * @memberof EntitlementSource
     */
    'name'?: string;
}
/**
 * EntitlementReference
 * @export
 * @interface EntitlementSummary
 */
export interface EntitlementSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof EntitlementSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof EntitlementSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'displayName'?: string;
    /**
     * Description of access item.
     * @type {string}
     * @memberof EntitlementSummary
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof EntitlementSummary
     */
    'source'?: Reference1;
    /**
     * Type of the access item.
     * @type {string}
     * @memberof EntitlementSummary
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummary
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'attribute'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummary
     */
    'standalone'?: boolean;
}
/**
 * 
 * @export
 * @interface ErrorMessageDto
 */
export interface ErrorMessageDto {
    /**
     * The locale for the message text, a BCP 47 language tag.
     * @type {string}
     * @memberof ErrorMessageDto
     */
    'locale'?: string | null;
    /**
     * 
     * @type {LocaleOrigin}
     * @memberof ErrorMessageDto
     */
    'localeOrigin'?: LocaleOrigin | null;
    /**
     * Actual text of the error message in the indicated locale.
     * @type {string}
     * @memberof ErrorMessageDto
     */
    'text'?: string;
}


/**
 * 
 * @export
 * @interface ErrorResponseDto
 */
export interface ErrorResponseDto {
    /**
     * Fine-grained error code providing more detail of the error.
     * @type {string}
     * @memberof ErrorResponseDto
     */
    'detailCode'?: string;
    /**
     * Unique tracking id for the error.
     * @type {string}
     * @memberof ErrorResponseDto
     */
    'trackingId'?: string;
    /**
     * Generic localized reason for error
     * @type {Array<ErrorMessageDto>}
     * @memberof ErrorResponseDto
     */
    'messages'?: Array<ErrorMessageDto>;
    /**
     * Plain-text descriptive reasons to provide additional detail to the text provided in the messages field
     * @type {Array<ErrorMessageDto>}
     * @memberof ErrorResponseDto
     */
    'causes'?: Array<ErrorMessageDto>;
}
/**
 * Event
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * ID of the entitlement.
     * @type {string}
     * @memberof Event
     */
    'id'?: string;
    /**
     * Name of the entitlement.
     * @type {string}
     * @memberof Event
     */
    'name'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof Event
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof Event
     */
    'synced'?: string;
    /**
     * Name of the event as it\'s displayed in audit reports.
     * @type {string}
     * @memberof Event
     */
    'action'?: string;
    /**
     * Event type. Refer to [Event Types](https://documentation.sailpoint.com/saas/help/search/index.html#event-types) for a list of event types and their meanings.
     * @type {string}
     * @memberof Event
     */
    'type'?: string;
    /**
     * 
     * @type {EventActor}
     * @memberof Event
     */
    'actor'?: EventActor;
    /**
     * 
     * @type {EventTarget}
     * @memberof Event
     */
    'target'?: EventTarget;
    /**
     * The event\'s stack.
     * @type {string}
     * @memberof Event
     */
    'stack'?: string;
    /**
     * ID of the group of events.
     * @type {string}
     * @memberof Event
     */
    'trackingNumber'?: string;
    /**
     * Target system\'s IP address.
     * @type {string}
     * @memberof Event
     */
    'ipAddress'?: string;
    /**
     * ID of event\'s details.
     * @type {string}
     * @memberof Event
     */
    'details'?: string;
    /**
     * Attributes involved in the event.
     * @type {{ [key: string]: any; }}
     * @memberof Event
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Objects the event is happening to.
     * @type {Array<string>}
     * @memberof Event
     */
    'objects'?: Array<string>;
    /**
     * Operation, or action, performed during the event.
     * @type {string}
     * @memberof Event
     */
    'operation'?: string;
    /**
     * Event status. Refer to [Event Statuses](https://documentation.sailpoint.com/saas/help/search/index.html#event-statuses) for a list of event statuses and their meanings.
     * @type {string}
     * @memberof Event
     */
    'status'?: string;
    /**
     * Event\'s normalized name. This normalized name always follows the pattern of \'objects_operation_status\'.
     * @type {string}
     * @memberof Event
     */
    'technicalName'?: string;
}
/**
 * 
 * @export
 * @interface EventActor
 */
export interface EventActor {
    /**
     * Name of the actor that generated the event.
     * @type {string}
     * @memberof EventActor
     */
    'name'?: string;
}
/**
 * Attributes related to an IdentityNow ETS event
 * @export
 * @interface EventAttributes
 */
export interface EventAttributes {
    /**
     * The unique ID of the trigger
     * @type {string}
     * @memberof EventAttributes
     */
    'id': string;
    /**
     * JSON path expression that will limit which events the trigger will fire on
     * @type {string}
     * @memberof EventAttributes
     */
    'filter.$'?: string;
    /**
     * Description of the event trigger
     * @type {string}
     * @memberof EventAttributes
     */
    'description'?: string;
    /**
     * The attribute to filter on
     * @type {string}
     * @memberof EventAttributes
     */
    'attributeToFilter'?: string;
}
/**
 * Event
 * @export
 * @interface EventDocument
 */
export interface EventDocument {
    /**
     * ID of the entitlement.
     * @type {string}
     * @memberof EventDocument
     */
    'id'?: string;
    /**
     * Name of the entitlement.
     * @type {string}
     * @memberof EventDocument
     */
    'name'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof EventDocument
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof EventDocument
     */
    'synced'?: string;
    /**
     * Name of the event as it\'s displayed in audit reports.
     * @type {string}
     * @memberof EventDocument
     */
    'action'?: string;
    /**
     * Event type. Refer to [Event Types](https://documentation.sailpoint.com/saas/help/search/index.html#event-types) for a list of event types and their meanings.
     * @type {string}
     * @memberof EventDocument
     */
    'type'?: string;
    /**
     * 
     * @type {EventActor}
     * @memberof EventDocument
     */
    'actor'?: EventActor;
    /**
     * 
     * @type {EventTarget}
     * @memberof EventDocument
     */
    'target'?: EventTarget;
    /**
     * The event\'s stack.
     * @type {string}
     * @memberof EventDocument
     */
    'stack'?: string;
    /**
     * ID of the group of events.
     * @type {string}
     * @memberof EventDocument
     */
    'trackingNumber'?: string;
    /**
     * Target system\'s IP address.
     * @type {string}
     * @memberof EventDocument
     */
    'ipAddress'?: string;
    /**
     * ID of event\'s details.
     * @type {string}
     * @memberof EventDocument
     */
    'details'?: string;
    /**
     * Attributes involved in the event.
     * @type {{ [key: string]: any; }}
     * @memberof EventDocument
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Objects the event is happening to.
     * @type {Array<string>}
     * @memberof EventDocument
     */
    'objects'?: Array<string>;
    /**
     * Operation, or action, performed during the event.
     * @type {string}
     * @memberof EventDocument
     */
    'operation'?: string;
    /**
     * Event status. Refer to [Event Statuses](https://documentation.sailpoint.com/saas/help/search/index.html#event-statuses) for a list of event statuses and their meanings.
     * @type {string}
     * @memberof EventDocument
     */
    'status'?: string;
    /**
     * Event\'s normalized name. This normalized name always follows the pattern of \'objects_operation_status\'.
     * @type {string}
     * @memberof EventDocument
     */
    'technicalName'?: string;
}
/**
 * 
 * @export
 * @interface EventDocuments
 */
export interface EventDocuments {
    /**
     * ID of the entitlement.
     * @type {string}
     * @memberof EventDocuments
     */
    'id'?: string;
    /**
     * Name of the entitlement.
     * @type {string}
     * @memberof EventDocuments
     */
    'name'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof EventDocuments
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof EventDocuments
     */
    'synced'?: string;
    /**
     * Name of the event as it\'s displayed in audit reports.
     * @type {string}
     * @memberof EventDocuments
     */
    'action'?: string;
    /**
     * Event type. Refer to [Event Types](https://documentation.sailpoint.com/saas/help/search/index.html#event-types) for a list of event types and their meanings.
     * @type {string}
     * @memberof EventDocuments
     */
    'type'?: string;
    /**
     * 
     * @type {EventActor}
     * @memberof EventDocuments
     */
    'actor'?: EventActor;
    /**
     * 
     * @type {EventTarget}
     * @memberof EventDocuments
     */
    'target'?: EventTarget;
    /**
     * The event\'s stack.
     * @type {string}
     * @memberof EventDocuments
     */
    'stack'?: string;
    /**
     * ID of the group of events.
     * @type {string}
     * @memberof EventDocuments
     */
    'trackingNumber'?: string;
    /**
     * Target system\'s IP address.
     * @type {string}
     * @memberof EventDocuments
     */
    'ipAddress'?: string;
    /**
     * ID of event\'s details.
     * @type {string}
     * @memberof EventDocuments
     */
    'details'?: string;
    /**
     * Attributes involved in the event.
     * @type {{ [key: string]: any; }}
     * @memberof EventDocuments
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Objects the event is happening to.
     * @type {Array<string>}
     * @memberof EventDocuments
     */
    'objects'?: Array<string>;
    /**
     * Operation, or action, performed during the event.
     * @type {string}
     * @memberof EventDocuments
     */
    'operation'?: string;
    /**
     * Event status. Refer to [Event Statuses](https://documentation.sailpoint.com/saas/help/search/index.html#event-statuses) for a list of event statuses and their meanings.
     * @type {string}
     * @memberof EventDocuments
     */
    'status'?: string;
    /**
     * Event\'s normalized name. This normalized name always follows the pattern of \'objects_operation_status\'.
     * @type {string}
     * @memberof EventDocuments
     */
    'technicalName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocuments
     */
    'pod'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocuments
     */
    'org'?: string;
    /**
     * 
     * @type {DocumentType}
     * @memberof EventDocuments
     */
    '_type'?: DocumentType;
    /**
     * 
     * @type {string}
     * @memberof EventDocuments
     */
    '_version'?: string;
}


/**
 * 
 * @export
 * @interface EventTarget
 */
export interface EventTarget {
    /**
     * Name of the target, or recipient, of the event.
     * @type {string}
     * @memberof EventTarget
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ExceptionAccessCriteria
 */
export interface ExceptionAccessCriteria {
    /**
     * 
     * @type {ExceptionCriteria}
     * @memberof ExceptionAccessCriteria
     */
    'leftCriteria'?: ExceptionCriteria;
    /**
     * 
     * @type {ExceptionCriteria}
     * @memberof ExceptionAccessCriteria
     */
    'rightCriteria'?: ExceptionCriteria;
}
/**
 * 
 * @export
 * @interface ExceptionCriteria
 */
export interface ExceptionCriteria {
    /**
     * List of exception criteria. There is a min of 1 and max of 50 items in the list.
     * @type {Array<ExceptionCriteriaCriteriaListInner>}
     * @memberof ExceptionCriteria
     */
    'criteriaList'?: Array<ExceptionCriteriaCriteriaListInner>;
}
/**
 * Access reference with addition of boolean existing flag to indicate whether the access was extant
 * @export
 * @interface ExceptionCriteriaAccess
 */
export interface ExceptionCriteriaAccess {
    /**
     * 
     * @type {DtoType}
     * @memberof ExceptionCriteriaAccess
     */
    'type'?: DtoType;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaAccess
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaAccess
     */
    'name'?: string;
    /**
     * Whether the subject identity already had that access or not
     * @type {boolean}
     * @memberof ExceptionCriteriaAccess
     */
    'existing'?: boolean;
}


/**
 * The types of objects supported for SOD violations
 * @export
 * @interface ExceptionCriteriaCriteriaListInner
 */
export interface ExceptionCriteriaCriteriaListInner {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'type'?: ExceptionCriteriaCriteriaListInnerTypeV3;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'name'?: string;
    /**
     * Whether the subject identity already had that access or not
     * @type {boolean}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'existing'?: boolean;
}

export const ExceptionCriteriaCriteriaListInnerTypeV3 = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type ExceptionCriteriaCriteriaListInnerTypeV3 = typeof ExceptionCriteriaCriteriaListInnerTypeV3[keyof typeof ExceptionCriteriaCriteriaListInnerTypeV3];

/**
 * The current state of execution.
 * @export
 * @enum {string}
 */

export const ExecutionStatus = {
    Executing: 'EXECUTING',
    Verifying: 'VERIFYING',
    Terminated: 'TERMINATED',
    Completed: 'COMPLETED'
} as const;

export type ExecutionStatus = typeof ExecutionStatus[keyof typeof ExecutionStatus];


/**
 * 
 * @export
 * @interface ExpansionItem
 */
export interface ExpansionItem {
    /**
     * The ID of the account
     * @type {string}
     * @memberof ExpansionItem
     */
    'accountId'?: string;
    /**
     * Cause of the expansion item.
     * @type {string}
     * @memberof ExpansionItem
     */
    'cause'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ExpansionItem
     */
    'name'?: string;
    /**
     * 
     * @type {AttributeRequest}
     * @memberof ExpansionItem
     */
    'attributeRequest'?: AttributeRequest;
    /**
     * 
     * @type {AccountSource}
     * @memberof ExpansionItem
     */
    'source'?: AccountSource;
    /**
     * ID of the expansion item
     * @type {string}
     * @memberof ExpansionItem
     */
    'id'?: string;
    /**
     * State of the expansion item
     * @type {string}
     * @memberof ExpansionItem
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface Expression
 */
export interface Expression {
    /**
     * Operator for the expression
     * @type {string}
     * @memberof Expression
     */
    'operator'?: ExpressionOperatorV3;
    /**
     * Name for the attribute
     * @type {string}
     * @memberof Expression
     */
    'attribute'?: string | null;
    /**
     * 
     * @type {Value}
     * @memberof Expression
     */
    'value'?: Value | null;
    /**
     * List of expressions
     * @type {Array<ExpressionChildrenInner>}
     * @memberof Expression
     */
    'children'?: Array<ExpressionChildrenInner> | null;
}

export const ExpressionOperatorV3 = {
    And: 'AND',
    Equals: 'EQUALS'
} as const;

export type ExpressionOperatorV3 = typeof ExpressionOperatorV3[keyof typeof ExpressionOperatorV3];

/**
 * 
 * @export
 * @interface ExpressionChildrenInner
 */
export interface ExpressionChildrenInner {
    /**
     * Operator for the expression
     * @type {string}
     * @memberof ExpressionChildrenInner
     */
    'operator'?: ExpressionChildrenInnerOperatorV3;
    /**
     * Name for the attribute
     * @type {string}
     * @memberof ExpressionChildrenInner
     */
    'attribute'?: string | null;
    /**
     * 
     * @type {Value}
     * @memberof ExpressionChildrenInner
     */
    'value'?: Value | null;
    /**
     * There cannot be anymore nested children. This will always be null.
     * @type {string}
     * @memberof ExpressionChildrenInner
     */
    'children'?: string | null;
}

export const ExpressionChildrenInnerOperatorV3 = {
    And: 'AND',
    Equals: 'EQUALS'
} as const;

export type ExpressionChildrenInnerOperatorV3 = typeof ExpressionChildrenInnerOperatorV3[keyof typeof ExpressionChildrenInnerOperatorV3];

/**
 * Attributes related to an external trigger
 * @export
 * @interface ExternalAttributes
 */
export interface ExternalAttributes {
    /**
     * A unique name for the external trigger
     * @type {string}
     * @memberof ExternalAttributes
     */
    'name'?: string;
    /**
     * Additonal context about the external trigger
     * @type {string}
     * @memberof ExternalAttributes
     */
    'description'?: string;
    /**
     * OAuth Client ID to authenticate with this trigger
     * @type {string}
     * @memberof ExternalAttributes
     */
    'clientId'?: string;
    /**
     * URL to invoke this workflow
     * @type {string}
     * @memberof ExternalAttributes
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface FederationProtocolDetails
 */
export interface FederationProtocolDetails {
    /**
     * Federation protocol role
     * @type {string}
     * @memberof FederationProtocolDetails
     */
    'role'?: FederationProtocolDetailsRoleV3;
    /**
     * An entity ID is a globally unique name for a SAML entity, either an Identity Provider (IDP) or a Service Provider (SP).
     * @type {string}
     * @memberof FederationProtocolDetails
     */
    'entityId'?: string;
}

export const FederationProtocolDetailsRoleV3 = {
    SamlIdp: 'SAML_IDP',
    SamlSp: 'SAML_SP'
} as const;

export type FederationProtocolDetailsRoleV3 = typeof FederationProtocolDetailsRoleV3[keyof typeof FederationProtocolDetailsRoleV3];

/**
 * 
 * @export
 * @interface FieldDetailsDto
 */
export interface FieldDetailsDto {
    /**
     * The name of the attribute.
     * @type {string}
     * @memberof FieldDetailsDto
     */
    'name'?: string;
    /**
     * The transform to apply to the field
     * @type {object}
     * @memberof FieldDetailsDto
     */
    'transform'?: object;
    /**
     * Attributes required for the transform
     * @type {object}
     * @memberof FieldDetailsDto
     */
    'attributes'?: object;
    /**
     * Flag indicating whether or not the attribute is required.
     * @type {boolean}
     * @memberof FieldDetailsDto
     */
    'isRequired'?: boolean;
    /**
     * The type of the attribute.
     * @type {string}
     * @memberof FieldDetailsDto
     */
    'type'?: string;
    /**
     * Flag indicating whether or not the attribute is multi-valued.
     * @type {boolean}
     * @memberof FieldDetailsDto
     */
    'isMultiValued'?: boolean;
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {FilterType}
     * @memberof Filter
     */
    'type'?: FilterType;
    /**
     * 
     * @type {Range}
     * @memberof Filter
     */
    'range'?: Range;
    /**
     * The terms to be filtered.
     * @type {Array<string>}
     * @memberof Filter
     */
    'terms'?: Array<string>;
    /**
     * Indicates if the filter excludes results.
     * @type {boolean}
     * @memberof Filter
     */
    'exclude'?: boolean;
}


/**
 * An additional filter to constrain the results of the search query.
 * @export
 * @interface FilterAggregation
 */
export interface FilterAggregation {
    /**
     * The name of the filter aggregate to be included in the result.
     * @type {string}
     * @memberof FilterAggregation
     */
    'name': string;
    /**
     * 
     * @type {SearchFilterType}
     * @memberof FilterAggregation
     */
    'type'?: SearchFilterType;
    /**
     * The search field to apply the filter to.  Prefix the field name with \'@\' to reference a nested object. 
     * @type {string}
     * @memberof FilterAggregation
     */
    'field': string;
    /**
     * The value to filter on.
     * @type {string}
     * @memberof FilterAggregation
     */
    'value': string;
}


/**
 * Enum representing the currently supported filter types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const FilterType = {
    Exists: 'EXISTS',
    Range: 'RANGE',
    Terms: 'TERMS'
} as const;

export type FilterType = typeof FilterType[keyof typeof FilterType];


/**
 * 
 * @export
 * @interface FirstValid
 */
export interface FirstValid {
    /**
     * An array of attributes to evaluate for existence.
     * @type {Array<object>}
     * @memberof FirstValid
     */
    'values': Array<object>;
    /**
     * a true or false value representing to move on to the next option if an error (like an Null Pointer Exception) were to occur.
     * @type {boolean}
     * @memberof FirstValid
     */
    'ignoreErrors'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof FirstValid
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface FormDetails
 */
export interface FormDetails {
    /**
     * ID of the form
     * @type {string}
     * @memberof FormDetails
     */
    'id'?: string | null;
    /**
     * Name of the form
     * @type {string}
     * @memberof FormDetails
     */
    'name'?: string | null;
    /**
     * The form title
     * @type {string}
     * @memberof FormDetails
     */
    'title'?: string;
    /**
     * The form subtitle.
     * @type {string}
     * @memberof FormDetails
     */
    'subtitle'?: string;
    /**
     * The name of the user that should be shown this form
     * @type {string}
     * @memberof FormDetails
     */
    'targetUser'?: string;
    /**
     * Sections of the form
     * @type {Array<SectionDetails>}
     * @memberof FormDetails
     */
    'sections'?: Array<SectionDetails>;
}
/**
 * 
 * @export
 * @interface FormItemDetails
 */
export interface FormItemDetails {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof FormItemDetails
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ForwardApprovalDto
 */
export interface ForwardApprovalDto {
    /**
     * The Id of the new owner
     * @type {string}
     * @memberof ForwardApprovalDto
     */
    'newOwnerId': string;
    /**
     * The comment provided by the forwarder
     * @type {string}
     * @memberof ForwardApprovalDto
     */
    'comment': string;
}
/**
 * Discovered applications with their respective associated sources
 * @export
 * @interface FullDiscoveredApplications
 */
export interface FullDiscoveredApplications {
    /**
     * Unique identifier for the discovered application.
     * @type {string}
     * @memberof FullDiscoveredApplications
     */
    'id'?: string;
    /**
     * Name of the discovered application.
     * @type {string}
     * @memberof FullDiscoveredApplications
     */
    'name'?: string;
    /**
     * Source from which the application was discovered.
     * @type {string}
     * @memberof FullDiscoveredApplications
     */
    'discoverySource'?: string;
    /**
     * The vendor associated with the discovered application.
     * @type {string}
     * @memberof FullDiscoveredApplications
     */
    'discoveredVendor'?: string;
    /**
     * A brief description of the discovered application.
     * @type {string}
     * @memberof FullDiscoveredApplications
     */
    'description'?: string;
    /**
     * List of recommended connectors for the application.
     * @type {Array<string>}
     * @memberof FullDiscoveredApplications
     */
    'recommendedConnectors'?: Array<string>;
    /**
     * The timestamp when the application was last received via an entitlement aggregation invocation  or a manual csv upload, in ISO 8601 format.
     * @type {string}
     * @memberof FullDiscoveredApplications
     */
    'discoveredAt'?: string;
    /**
     * The timestamp when the application was first discovered, in ISO 8601 format.
     * @type {string}
     * @memberof FullDiscoveredApplications
     */
    'createdAt'?: string;
    /**
     * The status of an application within the discovery source.  By default this field is set to \"ACTIVE\" when the application is discovered.  If an application has been deleted from within the discovery source, the status will be set to \"INACTIVE\".
     * @type {string}
     * @memberof FullDiscoveredApplications
     */
    'status'?: string;
    /**
     * List of associated sources related to this discovered application.
     * @type {Array<string>}
     * @memberof FullDiscoveredApplications
     */
    'associatedSources'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GenerateRandomString
 */
export interface GenerateRandomString {
    /**
     * This must always be set to \"Cloud Services Deployment Utility\"
     * @type {string}
     * @memberof GenerateRandomString
     */
    'name': string;
    /**
     * The operation to perform `generateRandomString`
     * @type {string}
     * @memberof GenerateRandomString
     */
    'operation': string;
    /**
     * This must be either \"true\" or \"false\" to indicate whether the generator logic should include numbers
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'includeNumbers': boolean;
    /**
     * This must be either \"true\" or \"false\" to indicate whether the generator logic should include special characters
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'includeSpecialChars': boolean;
    /**
     * This specifies how long the randomly generated string needs to be   >NOTE Due to identity attribute data constraints, the maximum allowable value is 450 characters 
     * @type {string}
     * @memberof GenerateRandomString
     */
    'length': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface GetActiveCampaigns200ResponseInner
 */
export interface GetActiveCampaigns200ResponseInner {
    /**
     * Id of the campaign
     * @type {string}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'id'?: string;
    /**
     * The campaign name. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details. 
     * @type {string}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'name': string;
    /**
     * The campaign description. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details. 
     * @type {string}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'description': string | null;
    /**
     * The campaign\'s completion deadline.  This date must be in the future in order to activate the campaign.  If you try to activate a campaign with a deadline of today or in the past, you will receive a 400 error response.
     * @type {string}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'deadline'?: string;
    /**
     * The type of campaign. Could be extended in the future.
     * @type {string}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'type': GetActiveCampaigns200ResponseInnerTypeV3;
    /**
     * Enables email notification for this campaign
     * @type {boolean}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'emailNotificationEnabled'?: boolean;
    /**
     * Allows auto revoke for this campaign
     * @type {boolean}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'autoRevokeAllowed'?: boolean;
    /**
     * Enables IAI for this campaign. Accepts true even if the IAI product feature is off. If IAI is turned off then campaigns generated from this template will indicate false. The real value will then be returned if IAI is ever enabled for the org in the future.
     * @type {boolean}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'recommendationsEnabled'?: boolean;
    /**
     * The campaign\'s current status.
     * @type {string}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'status'?: GetActiveCampaigns200ResponseInnerStatusV3;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {string}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'correlatedStatus'?: GetActiveCampaigns200ResponseInnerCorrelatedStatusV3;
    /**
     * Created time of the campaign
     * @type {string}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'created'?: string;
    /**
     * The total number of certifications in this campaign.
     * @type {number}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'totalCertifications'?: number;
    /**
     * The number of completed certifications in this campaign.
     * @type {number}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'completedCertifications'?: number;
    /**
     * A list of errors and warnings that have accumulated.
     * @type {Array<CampaignAlert>}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'alerts'?: Array<CampaignAlert>;
    /**
     * Modified time of the campaign
     * @type {string}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'modified'?: string;
    /**
     * 
     * @type {CampaignAllOfFilter}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'filter'?: CampaignAllOfFilter;
    /**
     * Determines if comments on sunset date changes are required.
     * @type {boolean}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'sunsetCommentsRequired'?: boolean;
    /**
     * 
     * @type {CampaignAllOfSourceOwnerCampaignInfo}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'sourceOwnerCampaignInfo'?: CampaignAllOfSourceOwnerCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfSearchCampaignInfo}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'searchCampaignInfo'?: CampaignAllOfSearchCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfRoleCompositionCampaignInfo}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'roleCompositionCampaignInfo'?: CampaignAllOfRoleCompositionCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfMachineAccountCampaignInfo}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'machineAccountCampaignInfo'?: CampaignAllOfMachineAccountCampaignInfo;
    /**
     * A list of sources in the campaign that contain \\\"orphan entitlements\\\" (entitlements without a corresponding Managed Attribute). An empty list indicates the campaign has no orphan entitlements. Null indicates there may be unknown orphan entitlements in the campaign (the campaign was created before this feature was implemented).
     * @type {Array<CampaignAllOfSourcesWithOrphanEntitlements>}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'sourcesWithOrphanEntitlements'?: Array<CampaignAllOfSourcesWithOrphanEntitlements>;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof GetActiveCampaigns200ResponseInner
     */
    'mandatoryCommentRequirement'?: GetActiveCampaigns200ResponseInnerMandatoryCommentRequirementV3;
}

export const GetActiveCampaigns200ResponseInnerTypeV3 = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION',
    MachineAccount: 'MACHINE_ACCOUNT'
} as const;

export type GetActiveCampaigns200ResponseInnerTypeV3 = typeof GetActiveCampaigns200ResponseInnerTypeV3[keyof typeof GetActiveCampaigns200ResponseInnerTypeV3];
export const GetActiveCampaigns200ResponseInnerStatusV3 = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
} as const;

export type GetActiveCampaigns200ResponseInnerStatusV3 = typeof GetActiveCampaigns200ResponseInnerStatusV3[keyof typeof GetActiveCampaigns200ResponseInnerStatusV3];
export const GetActiveCampaigns200ResponseInnerCorrelatedStatusV3 = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type GetActiveCampaigns200ResponseInnerCorrelatedStatusV3 = typeof GetActiveCampaigns200ResponseInnerCorrelatedStatusV3[keyof typeof GetActiveCampaigns200ResponseInnerCorrelatedStatusV3];
export const GetActiveCampaigns200ResponseInnerMandatoryCommentRequirementV3 = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type GetActiveCampaigns200ResponseInnerMandatoryCommentRequirementV3 = typeof GetActiveCampaigns200ResponseInnerMandatoryCommentRequirementV3[keyof typeof GetActiveCampaigns200ResponseInnerMandatoryCommentRequirementV3];

/**
 * @type GetDiscoveredApplications200ResponseInner
 * @export
 */
export type GetDiscoveredApplications200ResponseInner = FullDiscoveredApplications | SlimDiscoveredApplications;

/**
 * 
 * @export
 * @interface GetOAuthClientResponse
 */
export interface GetOAuthClientResponse {
    /**
     * ID of the OAuth client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'id': string;
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'businessName': string | null;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'homepageUrl': string | null;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'name': string;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'description': string | null;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof GetOAuthClientResponse
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof GetOAuthClientResponse
     */
    'refreshTokenValiditySeconds': number;
    /**
     * A list of the approved redirect URIs used with the authorization_code flow
     * @type {Array<string>}
     * @memberof GetOAuthClientResponse
     */
    'redirectUris': Array<string> | null;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof GetOAuthClientResponse
     */
    'grantTypes': Array<GrantType>;
    /**
     * 
     * @type {AccessType}
     * @memberof GetOAuthClientResponse
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof GetOAuthClientResponse
     */
    'type': ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal to IDN
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'internal': boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'strongAuthSupported': boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'claimsSupported': boolean;
    /**
     * The date and time, down to the millisecond, when the API Client was created
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when the API Client was last updated
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'modified': string;
    /**
     * 
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'secret'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'metadata'?: string | null;
    /**
     * The date and time, down to the millisecond, when this API Client was last used to generate an access token. This timestamp does not get updated on every API Client usage, but only once a day. This property can be useful for identifying which API Clients are no longer actively used and can be removed.
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'lastUsed'?: string | null;
    /**
     * Scopes of the API Client.
     * @type {Array<string>}
     * @memberof GetOAuthClientResponse
     */
    'scope': Array<string> | null;
}


/**
 * 
 * @export
 * @interface GetPersonalAccessTokenResponse
 */
export interface GetPersonalAccessTokenResponse {
    /**
     * The ID of the personal access token (to be used as the username for Basic Auth).
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'id': string;
    /**
     * The name of the personal access token. Cannot be the same as other personal access tokens owned by a user.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'name': string;
    /**
     * Scopes of the personal  access token.
     * @type {Array<string>}
     * @memberof GetPersonalAccessTokenResponse
     */
    'scope': Array<string> | null;
    /**
     * 
     * @type {PatOwner}
     * @memberof GetPersonalAccessTokenResponse
     */
    'owner': PatOwner;
    /**
     * The date and time, down to the millisecond, when this personal access token was created.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when this personal access token was last used to generate an access token. This timestamp does not get updated on every PAT usage, but only once a day. This property can be useful for identifying which PATs are no longer actively used and can be removed.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'lastUsed'?: string | null;
    /**
     * If true, this token is managed by the SailPoint platform, and is not visible in the user interface. For example, Workflows will create managed personal access tokens for users who create workflows.
     * @type {boolean}
     * @memberof GetPersonalAccessTokenResponse
     */
    'managed'?: boolean;
}
/**
 * 
 * @export
 * @interface GetReferenceIdentityAttribute
 */
export interface GetReferenceIdentityAttribute {
    /**
     * This must always be set to \"Cloud Services Deployment Utility\"
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'name': string;
    /**
     * The operation to perform `getReferenceIdentityAttribute`
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'operation': string;
    /**
     * This is the SailPoint User Name (uid) value of the identity whose attribute is desired  As a convenience feature, you can use the `manager` keyword to dynamically look up the user\'s manager and then get that manager\'s identity attribute. 
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'uid': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GetReferenceIdentityAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface GetVendorConnectorMappings405Response
 */
export interface GetVendorConnectorMappings405Response {
    /**
     * A message describing the error
     * @type {object}
     * @memberof GetVendorConnectorMappings405Response
     */
    'errorName'?: object;
    /**
     * Description of the error
     * @type {object}
     * @memberof GetVendorConnectorMappings405Response
     */
    'errorMessage'?: object;
    /**
     * Unique tracking id for the error.
     * @type {string}
     * @memberof GetVendorConnectorMappings405Response
     */
    'trackingId'?: string;
}
/**
 * OAuth2 Grant Type
 * @export
 * @enum {string}
 */

export const GrantType = {
    ClientCredentials: 'CLIENT_CREDENTIALS',
    AuthorizationCode: 'AUTHORIZATION_CODE',
    RefreshToken: 'REFRESH_TOKEN'
} as const;

export type GrantType = typeof GrantType[keyof typeof GrantType];


/**
 * 
 * @export
 * @interface ISO3166
 */
export interface ISO3166 {
    /**
     * An optional value to denote which ISO 3166 format to return. Valid values are:   `alpha2` - Two-character country code (e.g., \"US\"); this is the default value if no format is supplied   `alpha3` - Three-character country code (e.g., \"USA\")   `numeric` - The numeric country code (e.g., \"840\") 
     * @type {string}
     * @memberof ISO3166
     */
    'format'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof ISO3166
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof ISO3166
     */
    'input'?: { [key: string]: any; };
}
/**
 * Arguments for Identities Details report (IDENTITIES_DETAILS)
 * @export
 * @interface IdentitiesDetailsReportArguments
 */
export interface IdentitiesDetailsReportArguments {
    /**
     * Flag to specify if only correlated identities are included in report.
     * @type {boolean}
     * @memberof IdentitiesDetailsReportArguments
     */
    'correlatedOnly': boolean;
}
/**
 * Arguments for Identities report (IDENTITIES)
 * @export
 * @interface IdentitiesReportArguments
 */
export interface IdentitiesReportArguments {
    /**
     * Flag to specify if only correlated identities are included in report.
     * @type {boolean}
     * @memberof IdentitiesReportArguments
     */
    'correlatedOnly'?: boolean;
}
/**
 * @type IdentityAccess
 * @export
 */
export type IdentityAccess = { type: 'ACCESS_PROFILE' } & AccessProfileSummary | { type: 'ENTITLEMENT' } & AccessProfileEntitlement | { type: 'ROLE' } & AccessProfileRole;

/**
 * 
 * @export
 * @interface IdentityAttribute
 */
export interface IdentityAttribute {
    /**
     * The system (camel-cased) name of the identity attribute to bring in
     * @type {string}
     * @memberof IdentityAttribute
     */
    'name': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof IdentityAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof IdentityAttribute
     */
    'input'?: { [key: string]: any; };
}
/**
 * Defines all the identity attribute mapping configurations. This defines how to generate or collect data for each identity attributes in identity refresh process.
 * @export
 * @interface IdentityAttributeConfig
 */
export interface IdentityAttributeConfig {
    /**
     * Backend will only promote values if the profile/mapping is enabled.
     * @type {boolean}
     * @memberof IdentityAttributeConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<IdentityAttributeTransform>}
     * @memberof IdentityAttributeConfig
     */
    'attributeTransforms'?: Array<IdentityAttributeTransform>;
}
/**
 * 
 * @export
 * @interface IdentityAttributePreview
 */
export interface IdentityAttributePreview {
    /**
     * Name of the attribute that is being previewed.
     * @type {string}
     * @memberof IdentityAttributePreview
     */
    'name'?: string;
    /**
     * Value that was derived during the preview.
     * @type {string}
     * @memberof IdentityAttributePreview
     */
    'value'?: string;
    /**
     * The value of the attribute before the preview.
     * @type {string}
     * @memberof IdentityAttributePreview
     */
    'previousValue'?: string;
    /**
     * 
     * @type {Array<ErrorMessageDto>}
     * @memberof IdentityAttributePreview
     */
    'errorMessages'?: Array<ErrorMessageDto>;
}
/**
 * Transform definition for an identity attribute.
 * @export
 * @interface IdentityAttributeTransform
 */
export interface IdentityAttributeTransform {
    /**
     * Identity attribute\'s name.
     * @type {string}
     * @memberof IdentityAttributeTransform
     */
    'identityAttributeName'?: string;
    /**
     * 
     * @type {TransformDefinition}
     * @memberof IdentityAttributeTransform
     */
    'transformDefinition'?: TransformDefinition;
}
/**
 * 
 * @export
 * @interface IdentityCertDecisionSummary
 */
export interface IdentityCertDecisionSummary {
    /**
     * Number of entitlement decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementDecisionsMade'?: number;
    /**
     * Number of access profile decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfileDecisionsMade'?: number;
    /**
     * Number of role decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'roleDecisionsMade'?: number;
    /**
     * Number of account decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountDecisionsMade'?: number;
    /**
     * The total number of entitlement decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementDecisionsTotal'?: number;
    /**
     * The total number of access profile decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfileDecisionsTotal'?: number;
    /**
     * The total number of role decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'roleDecisionsTotal'?: number;
    /**
     * The total number of account decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountDecisionsTotal'?: number;
    /**
     * The number of entitlement decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementsApproved'?: number;
    /**
     * The number of entitlement decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementsRevoked'?: number;
    /**
     * The number of access profile decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfilesApproved'?: number;
    /**
     * The number of access profile decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfilesRevoked'?: number;
    /**
     * The number of role decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'rolesApproved'?: number;
    /**
     * The number of role decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'rolesRevoked'?: number;
    /**
     * The number of account decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountsApproved'?: number;
    /**
     * The number of account decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountsRevoked'?: number;
}
/**
 * 
 * @export
 * @interface IdentityCertificationDto
 */
export interface IdentityCertificationDto {
    /**
     * id of the certification
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'id'?: string;
    /**
     * name of the certification
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'name'?: string;
    /**
     * 
     * @type {CampaignReference}
     * @memberof IdentityCertificationDto
     */
    'campaign'?: CampaignReference;
    /**
     * Have all decisions been made?
     * @type {boolean}
     * @memberof IdentityCertificationDto
     */
    'completed'?: boolean;
    /**
     * The number of identities for whom all decisions have been made and are complete.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'identitiesCompleted'?: number;
    /**
     * The total number of identities in the Certification, both complete and incomplete.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'identitiesTotal'?: number;
    /**
     * created date
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'created'?: string;
    /**
     * modified date
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'modified'?: string;
    /**
     * The number of approve/revoke/acknowledge decisions that have been made.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'decisionsMade'?: number;
    /**
     * The total number of approve/revoke/acknowledge decisions.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'decisionsTotal'?: number;
    /**
     * The due date of the certification.
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'due'?: string | null;
    /**
     * The date the reviewer signed off on the Certification.
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'signed'?: string | null;
    /**
     * 
     * @type {Reviewer}
     * @memberof IdentityCertificationDto
     */
    'reviewer'?: Reviewer;
    /**
     * 
     * @type {Reassignment}
     * @memberof IdentityCertificationDto
     */
    'reassignment'?: Reassignment | null;
    /**
     * Identifies if the certification has an error
     * @type {boolean}
     * @memberof IdentityCertificationDto
     */
    'hasErrors'?: boolean;
    /**
     * Description of the certification error
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'errorMessage'?: string | null;
    /**
     * 
     * @type {CertificationPhase}
     * @memberof IdentityCertificationDto
     */
    'phase'?: CertificationPhase;
}


/**
 * Identity
 * @export
 * @interface IdentityDocument
 */
export interface IdentityDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof IdentityDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof IdentityDocument
     */
    'name': string;
    /**
     * Identity\'s display name.
     * @type {string}
     * @memberof IdentityDocument
     */
    'displayName'?: string;
    /**
     * Identity\'s first name.
     * @type {string}
     * @memberof IdentityDocument
     */
    'firstName'?: string;
    /**
     * Identity\'s last name.
     * @type {string}
     * @memberof IdentityDocument
     */
    'lastName'?: string;
    /**
     * Identity\'s primary email address.
     * @type {string}
     * @memberof IdentityDocument
     */
    'email'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof IdentityDocument
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof IdentityDocument
     */
    'modified'?: string | null;
    /**
     * Identity\'s phone number.
     * @type {string}
     * @memberof IdentityDocument
     */
    'phone'?: string;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof IdentityDocument
     */
    'synced'?: string;
    /**
     * Indicates whether the identity is inactive.
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'inactive'?: boolean;
    /**
     * Indicates whether the identity is protected.
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'protected'?: boolean;
    /**
     * Identity\'s status in SailPoint.
     * @type {string}
     * @memberof IdentityDocument
     */
    'status'?: string;
    /**
     * Identity\'s employee number.
     * @type {string}
     * @memberof IdentityDocument
     */
    'employeeNumber'?: string;
    /**
     * 
     * @type {IdentityDocumentAllOfManager}
     * @memberof IdentityDocument
     */
    'manager'?: IdentityDocumentAllOfManager | null;
    /**
     * Indicates whether the identity is a manager of other identities.
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'isManager'?: boolean;
    /**
     * 
     * @type {IdentityDocumentAllOfIdentityProfile}
     * @memberof IdentityDocument
     */
    'identityProfile'?: IdentityDocumentAllOfIdentityProfile;
    /**
     * 
     * @type {IdentityDocumentAllOfSource}
     * @memberof IdentityDocument
     */
    'source'?: IdentityDocumentAllOfSource;
    /**
     * Map or dictionary of key/value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof IdentityDocument
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Indicates whether the identity is disabled.
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'disabled'?: boolean;
    /**
     * Indicates whether the identity is locked.
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'locked'?: boolean;
    /**
     * Identity\'s processing state.
     * @type {string}
     * @memberof IdentityDocument
     */
    'processingState'?: string | null;
    /**
     * 
     * @type {ProcessingDetails}
     * @memberof IdentityDocument
     */
    'processingDetails'?: ProcessingDetails;
    /**
     * List of accounts associated with the identity.
     * @type {Array<BaseAccount>}
     * @memberof IdentityDocument
     */
    'accounts'?: Array<BaseAccount>;
    /**
     * Number of accounts associated with the identity.
     * @type {number}
     * @memberof IdentityDocument
     */
    'accountCount'?: number;
    /**
     * List of applications the identity has access to.
     * @type {Array<App>}
     * @memberof IdentityDocument
     */
    'apps'?: Array<App>;
    /**
     * Number of applications the identity has access to.
     * @type {number}
     * @memberof IdentityDocument
     */
    'appCount'?: number;
    /**
     * List of access items assigned to the identity.
     * @type {Array<IdentityAccess>}
     * @memberof IdentityDocument
     */
    'access'?: Array<IdentityAccess>;
    /**
     * Number of access items assigned to the identity.
     * @type {number}
     * @memberof IdentityDocument
     */
    'accessCount'?: number;
    /**
     * Number of entitlements assigned to the identity.
     * @type {number}
     * @memberof IdentityDocument
     */
    'entitlementCount'?: number;
    /**
     * Number of roles assigned to the identity.
     * @type {number}
     * @memberof IdentityDocument
     */
    'roleCount'?: number;
    /**
     * Number of access profiles assigned to the identity.
     * @type {number}
     * @memberof IdentityDocument
     */
    'accessProfileCount'?: number;
    /**
     * Access items the identity owns.
     * @type {Array<Owns>}
     * @memberof IdentityDocument
     */
    'owns'?: Array<Owns>;
    /**
     * Number of access items the identity owns.
     * @type {number}
     * @memberof IdentityDocument
     */
    'ownsCount'?: number;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof IdentityDocument
     */
    'tags'?: Array<string>;
    /**
     * Number of tags on the identity.
     * @type {number}
     * @memberof IdentityDocument
     */
    'tagsCount'?: number;
    /**
     * List of segments that the identity is in.
     * @type {Array<string>}
     * @memberof IdentityDocument
     */
    'visibleSegments'?: Array<string> | null;
    /**
     * Number of segments the identity is in.
     * @type {number}
     * @memberof IdentityDocument
     */
    'visibleSegmentCount'?: number;
}
/**
 * Identity\'s identity profile.
 * @export
 * @interface IdentityDocumentAllOfIdentityProfile
 */
export interface IdentityDocumentAllOfIdentityProfile {
    /**
     * Identity profile\'s ID.
     * @type {string}
     * @memberof IdentityDocumentAllOfIdentityProfile
     */
    'id'?: string;
    /**
     * Identity profile\'s name.
     * @type {string}
     * @memberof IdentityDocumentAllOfIdentityProfile
     */
    'name'?: string;
}
/**
 * Identity\'s manager.
 * @export
 * @interface IdentityDocumentAllOfManager
 */
export interface IdentityDocumentAllOfManager {
    /**
     * ID of identity\'s manager.
     * @type {string}
     * @memberof IdentityDocumentAllOfManager
     */
    'id'?: string;
    /**
     * Name of identity\'s manager.
     * @type {string}
     * @memberof IdentityDocumentAllOfManager
     */
    'name'?: string;
    /**
     * Display name of identity\'s manager.
     * @type {string}
     * @memberof IdentityDocumentAllOfManager
     */
    'displayName'?: string;
}
/**
 * Identity\'s source.
 * @export
 * @interface IdentityDocumentAllOfSource
 */
export interface IdentityDocumentAllOfSource {
    /**
     * ID of identity\'s source.
     * @type {string}
     * @memberof IdentityDocumentAllOfSource
     */
    'id'?: string;
    /**
     * Display name of identity\'s source.
     * @type {string}
     * @memberof IdentityDocumentAllOfSource
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface IdentityDocuments
 */
export interface IdentityDocuments {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'name': string;
    /**
     * Identity\'s display name.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'displayName'?: string;
    /**
     * Identity\'s first name.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'firstName'?: string;
    /**
     * Identity\'s last name.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'lastName'?: string;
    /**
     * Identity\'s primary email address.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'email'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'modified'?: string | null;
    /**
     * Identity\'s phone number.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'phone'?: string;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof IdentityDocuments
     */
    'synced'?: string;
    /**
     * Indicates whether the identity is inactive.
     * @type {boolean}
     * @memberof IdentityDocuments
     */
    'inactive'?: boolean;
    /**
     * Indicates whether the identity is protected.
     * @type {boolean}
     * @memberof IdentityDocuments
     */
    'protected'?: boolean;
    /**
     * Identity\'s status in SailPoint.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'status'?: string;
    /**
     * Identity\'s employee number.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'employeeNumber'?: string;
    /**
     * 
     * @type {IdentityDocumentAllOfManager}
     * @memberof IdentityDocuments
     */
    'manager'?: IdentityDocumentAllOfManager | null;
    /**
     * Indicates whether the identity is a manager of other identities.
     * @type {boolean}
     * @memberof IdentityDocuments
     */
    'isManager'?: boolean;
    /**
     * 
     * @type {IdentityDocumentAllOfIdentityProfile}
     * @memberof IdentityDocuments
     */
    'identityProfile'?: IdentityDocumentAllOfIdentityProfile;
    /**
     * 
     * @type {IdentityDocumentAllOfSource}
     * @memberof IdentityDocuments
     */
    'source'?: IdentityDocumentAllOfSource;
    /**
     * Map or dictionary of key/value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof IdentityDocuments
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Indicates whether the identity is disabled.
     * @type {boolean}
     * @memberof IdentityDocuments
     */
    'disabled'?: boolean;
    /**
     * Indicates whether the identity is locked.
     * @type {boolean}
     * @memberof IdentityDocuments
     */
    'locked'?: boolean;
    /**
     * Identity\'s processing state.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'processingState'?: string | null;
    /**
     * 
     * @type {ProcessingDetails}
     * @memberof IdentityDocuments
     */
    'processingDetails'?: ProcessingDetails;
    /**
     * List of accounts associated with the identity.
     * @type {Array<BaseAccount>}
     * @memberof IdentityDocuments
     */
    'accounts'?: Array<BaseAccount>;
    /**
     * Number of accounts associated with the identity.
     * @type {number}
     * @memberof IdentityDocuments
     */
    'accountCount'?: number;
    /**
     * List of applications the identity has access to.
     * @type {Array<App>}
     * @memberof IdentityDocuments
     */
    'apps'?: Array<App>;
    /**
     * Number of applications the identity has access to.
     * @type {number}
     * @memberof IdentityDocuments
     */
    'appCount'?: number;
    /**
     * List of access items assigned to the identity.
     * @type {Array<IdentityAccess>}
     * @memberof IdentityDocuments
     */
    'access'?: Array<IdentityAccess>;
    /**
     * Number of access items assigned to the identity.
     * @type {number}
     * @memberof IdentityDocuments
     */
    'accessCount'?: number;
    /**
     * Number of entitlements assigned to the identity.
     * @type {number}
     * @memberof IdentityDocuments
     */
    'entitlementCount'?: number;
    /**
     * Number of roles assigned to the identity.
     * @type {number}
     * @memberof IdentityDocuments
     */
    'roleCount'?: number;
    /**
     * Number of access profiles assigned to the identity.
     * @type {number}
     * @memberof IdentityDocuments
     */
    'accessProfileCount'?: number;
    /**
     * Access items the identity owns.
     * @type {Array<Owns>}
     * @memberof IdentityDocuments
     */
    'owns'?: Array<Owns>;
    /**
     * Number of access items the identity owns.
     * @type {number}
     * @memberof IdentityDocuments
     */
    'ownsCount'?: number;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof IdentityDocuments
     */
    'tags'?: Array<string>;
    /**
     * Number of tags on the identity.
     * @type {number}
     * @memberof IdentityDocuments
     */
    'tagsCount'?: number;
    /**
     * List of segments that the identity is in.
     * @type {Array<string>}
     * @memberof IdentityDocuments
     */
    'visibleSegments'?: Array<string> | null;
    /**
     * Number of segments the identity is in.
     * @type {number}
     * @memberof IdentityDocuments
     */
    'visibleSegmentCount'?: number;
    /**
     * Name of the pod.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'pod'?: string;
    /**
     * Name of the tenant.
     * @type {string}
     * @memberof IdentityDocuments
     */
    'org'?: string;
    /**
     * 
     * @type {DocumentType}
     * @memberof IdentityDocuments
     */
    '_type'?: DocumentType;
    /**
     * 
     * @type {DocumentType}
     * @memberof IdentityDocuments
     */
    'type'?: DocumentType;
    /**
     * Version number.
     * @type {string}
     * @memberof IdentityDocuments
     */
    '_version'?: string;
}


/**
 * 
 * @export
 * @interface IdentityExceptionReportReference
 */
export interface IdentityExceptionReportReference {
    /**
     * Task result ID.
     * @type {string}
     * @memberof IdentityExceptionReportReference
     */
    'taskResultId'?: string;
    /**
     * Report name.
     * @type {string}
     * @memberof IdentityExceptionReportReference
     */
    'reportName'?: string;
}
/**
 * 
 * @export
 * @interface IdentityPreviewRequest
 */
export interface IdentityPreviewRequest {
    /**
     * The Identity id
     * @type {string}
     * @memberof IdentityPreviewRequest
     */
    'identityId'?: string;
    /**
     * 
     * @type {IdentityAttributeConfig}
     * @memberof IdentityPreviewRequest
     */
    'identityAttributeConfig'?: IdentityAttributeConfig;
}
/**
 * 
 * @export
 * @interface IdentityPreviewResponse
 */
export interface IdentityPreviewResponse {
    /**
     * 
     * @type {IdentityPreviewResponseIdentity}
     * @memberof IdentityPreviewResponse
     */
    'identity'?: IdentityPreviewResponseIdentity;
    /**
     * 
     * @type {Array<IdentityAttributePreview>}
     * @memberof IdentityPreviewResponse
     */
    'previewAttributes'?: Array<IdentityAttributePreview>;
}
/**
 * Identity\'s basic details.
 * @export
 * @interface IdentityPreviewResponseIdentity
 */
export interface IdentityPreviewResponseIdentity {
    /**
     * Identity\'s DTO type.
     * @type {string}
     * @memberof IdentityPreviewResponseIdentity
     */
    'type'?: IdentityPreviewResponseIdentityTypeV3;
    /**
     * Identity ID.
     * @type {string}
     * @memberof IdentityPreviewResponseIdentity
     */
    'id'?: string;
    /**
     * Identity\'s display name.
     * @type {string}
     * @memberof IdentityPreviewResponseIdentity
     */
    'name'?: string;
}

export const IdentityPreviewResponseIdentityTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type IdentityPreviewResponseIdentityTypeV3 = typeof IdentityPreviewResponseIdentityTypeV3[keyof typeof IdentityPreviewResponseIdentityTypeV3];

/**
 * 
 * @export
 * @interface IdentityProfile
 */
export interface IdentityProfile {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'name': string | null;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'modified'?: string;
    /**
     * Identity profile\'s description.
     * @type {string}
     * @memberof IdentityProfile
     */
    'description'?: string | null;
    /**
     * 
     * @type {IdentityProfileAllOfOwner}
     * @memberof IdentityProfile
     */
    'owner'?: IdentityProfileAllOfOwner | null;
    /**
     * Identity profile\'s priority.
     * @type {number}
     * @memberof IdentityProfile
     */
    'priority'?: number;
    /**
     * 
     * @type {IdentityProfileAllOfAuthoritativeSource}
     * @memberof IdentityProfile
     */
    'authoritativeSource': IdentityProfileAllOfAuthoritativeSource;
    /**
     * Set this value to \'True\' if an identity refresh is necessary. You would typically want to trigger an identity refresh when a change has been made on the source.
     * @type {boolean}
     * @memberof IdentityProfile
     */
    'identityRefreshRequired'?: boolean;
    /**
     * Number of identities belonging to the identity profile.
     * @type {number}
     * @memberof IdentityProfile
     */
    'identityCount'?: number;
    /**
     * 
     * @type {IdentityAttributeConfig}
     * @memberof IdentityProfile
     */
    'identityAttributeConfig'?: IdentityAttributeConfig;
    /**
     * 
     * @type {IdentityExceptionReportReference}
     * @memberof IdentityProfile
     */
    'identityExceptionReportReference'?: IdentityExceptionReportReference | null;
    /**
     * Indicates the value of `requiresPeriodicRefresh` attribute for the identity profile.
     * @type {boolean}
     * @memberof IdentityProfile
     */
    'hasTimeBasedAttr'?: boolean;
}
/**
 * 
 * @export
 * @interface IdentityProfileAllOfAuthoritativeSource
 */
export interface IdentityProfileAllOfAuthoritativeSource {
    /**
     * Authoritative source\'s object type.
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'type'?: IdentityProfileAllOfAuthoritativeSourceTypeV3;
    /**
     * Authoritative source\'s ID.
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'id'?: string;
    /**
     * Authoritative source\'s name.
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'name'?: string;
}

export const IdentityProfileAllOfAuthoritativeSourceTypeV3 = {
    Source: 'SOURCE'
} as const;

export type IdentityProfileAllOfAuthoritativeSourceTypeV3 = typeof IdentityProfileAllOfAuthoritativeSourceTypeV3[keyof typeof IdentityProfileAllOfAuthoritativeSourceTypeV3];

/**
 * Identity profile\'s owner.
 * @export
 * @interface IdentityProfileAllOfOwner
 */
export interface IdentityProfileAllOfOwner {
    /**
     * Owner\'s object type.
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'type'?: IdentityProfileAllOfOwnerTypeV3;
    /**
     * Owner\'s ID.
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'id'?: string;
    /**
     * Owner\'s name.
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'name'?: string;
}

export const IdentityProfileAllOfOwnerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type IdentityProfileAllOfOwnerTypeV3 = typeof IdentityProfileAllOfOwnerTypeV3[keyof typeof IdentityProfileAllOfOwnerTypeV3];

/**
 * Identity profile exported object.
 * @export
 * @interface IdentityProfileExportedObject
 */
export interface IdentityProfileExportedObject {
    /**
     * Version or object from the target service.
     * @type {number}
     * @memberof IdentityProfileExportedObject
     */
    'version'?: number;
    /**
     * 
     * @type {IdentityProfileExportedObjectSelf}
     * @memberof IdentityProfileExportedObject
     */
    'self'?: IdentityProfileExportedObjectSelf;
    /**
     * 
     * @type {IdentityProfile}
     * @memberof IdentityProfileExportedObject
     */
    'object'?: IdentityProfile;
}
/**
 * Self block for exported object.
 * @export
 * @interface IdentityProfileExportedObjectSelf
 */
export interface IdentityProfileExportedObjectSelf {
    /**
     * Exported object\'s DTO type.
     * @type {string}
     * @memberof IdentityProfileExportedObjectSelf
     */
    'type'?: IdentityProfileExportedObjectSelfTypeV3;
    /**
     * Exported object\'s ID.
     * @type {string}
     * @memberof IdentityProfileExportedObjectSelf
     */
    'id'?: string;
    /**
     * Exported object\'s display name.
     * @type {string}
     * @memberof IdentityProfileExportedObjectSelf
     */
    'name'?: string;
}

export const IdentityProfileExportedObjectSelfTypeV3 = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    Segment: 'SEGMENT',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflow: 'WORKFLOW'
} as const;

export type IdentityProfileExportedObjectSelfTypeV3 = typeof IdentityProfileExportedObjectSelfTypeV3[keyof typeof IdentityProfileExportedObjectSelfTypeV3];

/**
 * Arguments for Identity Profile Identity Error report (IDENTITY_PROFILE_IDENTITY_ERROR)
 * @export
 * @interface IdentityProfileIdentityErrorReportArguments
 */
export interface IdentityProfileIdentityErrorReportArguments {
    /**
     * Source ID.
     * @type {string}
     * @memberof IdentityProfileIdentityErrorReportArguments
     */
    'authoritativeSource': string;
}
/**
 * 
 * @export
 * @interface IdentityProfilesConnections
 */
export interface IdentityProfilesConnections {
    /**
     * ID of the IdentityProfile this reference applies
     * @type {string}
     * @memberof IdentityProfilesConnections
     */
    'id'?: string;
    /**
     * Human-readable display name of the IdentityProfile to which this reference applies
     * @type {string}
     * @memberof IdentityProfilesConnections
     */
    'name'?: string;
    /**
     * The Number of Identities managed by this IdentityProfile
     * @type {number}
     * @memberof IdentityProfilesConnections
     */
    'identityCount'?: number;
}
/**
 * The manager for the identity.
 * @export
 * @interface IdentityReference
 */
export interface IdentityReference {
    /**
     * 
     * @type {DtoType}
     * @memberof IdentityReference
     */
    'type'?: DtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof IdentityReference
     */
    'id'?: string;
    /**
     * Human-readable display name of identity.
     * @type {string}
     * @memberof IdentityReference
     */
    'name'?: string;
}


/**
 * 
 * @export
 * @interface IdentityReferenceWithNameAndEmail
 */
export interface IdentityReferenceWithNameAndEmail {
    /**
     * The type can only be IDENTITY. This is read-only.
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'type'?: string;
    /**
     * Identity ID.
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'id'?: string;
    /**
     * Identity\'s human-readable display name. This is read-only.
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'name'?: string;
    /**
     * Identity\'s email address. This is read-only.
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface IdentitySummary
 */
export interface IdentitySummary {
    /**
     * ID of this identity summary
     * @type {string}
     * @memberof IdentitySummary
     */
    'id'?: string;
    /**
     * Human-readable display name of identity
     * @type {string}
     * @memberof IdentitySummary
     */
    'name'?: string;
    /**
     * ID of the identity that this summary represents
     * @type {string}
     * @memberof IdentitySummary
     */
    'identityId'?: string;
    /**
     * Indicates if all access items for this summary have been decided on
     * @type {boolean}
     * @memberof IdentitySummary
     */
    'completed'?: boolean;
}
/**
 * An identity with a set of access to be added
 * @export
 * @interface IdentityWithNewAccess
 */
export interface IdentityWithNewAccess {
    /**
     * Identity id to be checked.
     * @type {string}
     * @memberof IdentityWithNewAccess
     */
    'identityId': string;
    /**
     * The list of entitlements to consider for possible violations in a preventive check.
     * @type {Array<IdentityWithNewAccessAccessRefsInner>}
     * @memberof IdentityWithNewAccess
     */
    'accessRefs': Array<IdentityWithNewAccessAccessRefsInner>;
}
/**
 * An identity with a set of access to be added
 * @export
 * @interface IdentityWithNewAccess1
 */
export interface IdentityWithNewAccess1 {
    /**
     * Set of identity IDs to be checked.
     * @type {string}
     * @memberof IdentityWithNewAccess1
     */
    'identityId': string;
    /**
     * The bundle of access profiles to be added to the identities specified. All references must be ENTITLEMENT type.
     * @type {Array<EntitlementRef1>}
     * @memberof IdentityWithNewAccess1
     */
    'accessRefs': Array<EntitlementRef1>;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on completion of the violation check.
     * @type {{ [key: string]: string; }}
     * @memberof IdentityWithNewAccess1
     */
    'clientMetadata'?: { [key: string]: string; };
}
/**
 * Entitlement including a specific set of access.
 * @export
 * @interface IdentityWithNewAccessAccessRefsInner
 */
export interface IdentityWithNewAccessAccessRefsInner {
    /**
     * Entitlement\'s DTO type.
     * @type {string}
     * @memberof IdentityWithNewAccessAccessRefsInner
     */
    'type'?: IdentityWithNewAccessAccessRefsInnerTypeV3;
    /**
     * Entitlement\'s ID.
     * @type {string}
     * @memberof IdentityWithNewAccessAccessRefsInner
     */
    'id'?: string;
    /**
     * Entitlement\'s display name.
     * @type {string}
     * @memberof IdentityWithNewAccessAccessRefsInner
     */
    'name'?: string;
}

export const IdentityWithNewAccessAccessRefsInnerTypeV3 = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type IdentityWithNewAccessAccessRefsInnerTypeV3 = typeof IdentityWithNewAccessAccessRefsInnerTypeV3[keyof typeof IdentityWithNewAccessAccessRefsInnerTypeV3];

/**
 * 
 * @export
 * @interface IdpDetails
 */
export interface IdpDetails {
    /**
     * Federation protocol role
     * @type {string}
     * @memberof IdpDetails
     */
    'role'?: IdpDetailsRoleV3;
    /**
     * An entity ID is a globally unique name for a SAML entity, either an Identity Provider (IDP) or a Service Provider (SP).
     * @type {string}
     * @memberof IdpDetails
     */
    'entityId'?: string;
    /**
     * Defines the binding used for the SAML flow. Used with IDP configurations.
     * @type {string}
     * @memberof IdpDetails
     */
    'binding'?: string;
    /**
     * Specifies the SAML authentication method to use. Used with IDP configurations.
     * @type {string}
     * @memberof IdpDetails
     */
    'authContext'?: string;
    /**
     * The IDP logout URL. Used with IDP configurations.
     * @type {string}
     * @memberof IdpDetails
     */
    'logoutUrl'?: string;
    /**
     * Determines if the configured AuthnContext should be used or the default. Used with IDP configurations.
     * @type {boolean}
     * @memberof IdpDetails
     */
    'includeAuthContext'?: boolean;
    /**
     * The name id format to use. Used with IDP configurations.
     * @type {string}
     * @memberof IdpDetails
     */
    'nameId'?: string;
    /**
     * 
     * @type {JITConfiguration}
     * @memberof IdpDetails
     */
    'jitConfiguration'?: JITConfiguration;
    /**
     * The Base64-encoded certificate used by the IDP. Used with IDP configurations.
     * @type {string}
     * @memberof IdpDetails
     */
    'cert'?: string;
    /**
     * The IDP POST URL, used with IDP HTTP-POST bindings for IDP-initiated logins. Used with IDP configurations.
     * @type {string}
     * @memberof IdpDetails
     */
    'loginUrlPost'?: string;
    /**
     * The IDP Redirect URL. Used with IDP configurations.
     * @type {string}
     * @memberof IdpDetails
     */
    'loginUrlRedirect'?: string;
    /**
     * Return the saml Id for the given user, based on the IDN as SP settings of the org. Used with IDP configurations.
     * @type {string}
     * @memberof IdpDetails
     */
    'mappingAttribute'?: string;
    /**
     * The expiration date extracted from the certificate.
     * @type {string}
     * @memberof IdpDetails
     */
    'certificateExpirationDate'?: string;
    /**
     * The name extracted from the certificate.
     * @type {string}
     * @memberof IdpDetails
     */
    'certificateName'?: string;
}

export const IdpDetailsRoleV3 = {
    SamlIdp: 'SAML_IDP'
} as const;

export type IdpDetailsRoleV3 = typeof IdpDetailsRoleV3[keyof typeof IdpDetailsRoleV3];

/**
 * 
 * @export
 * @interface ImportNonEmployeeRecordsInBulkRequest
 */
export interface ImportNonEmployeeRecordsInBulkRequest {
    /**
     * 
     * @type {File}
     * @memberof ImportNonEmployeeRecordsInBulkRequest
     */
    'data': File;
}
/**
 * Object created or updated by import.
 * @export
 * @interface ImportObject
 */
export interface ImportObject {
    /**
     * DTO type of object created or updated by import.
     * @type {string}
     * @memberof ImportObject
     */
    'type'?: ImportObjectTypeV3;
    /**
     * ID of object created or updated by import.
     * @type {string}
     * @memberof ImportObject
     */
    'id'?: string;
    /**
     * Display name of object created or updated by import.
     * @type {string}
     * @memberof ImportObject
     */
    'name'?: string;
}

export const ImportObjectTypeV3 = {
    ConnectorRule: 'CONNECTOR_RULE',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    Rule: 'RULE',
    Source: 'SOURCE',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION'
} as const;

export type ImportObjectTypeV3 = typeof ImportObjectTypeV3[keyof typeof ImportObjectTypeV3];

/**
 * Enum representing the currently supported indices. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const Index = {
    Accessprofiles: 'accessprofiles',
    Accountactivities: 'accountactivities',
    Entitlements: 'entitlements',
    Events: 'events',
    Identities: 'identities',
    Roles: 'roles',
    Star: '*'
} as const;

export type Index = typeof Index[keyof typeof Index];


/**
 * 
 * @export
 * @interface IndexOf
 */
export interface IndexOf {
    /**
     * A substring to search for, searches the entire calling string, and returns the index of the first occurrence of the specified substring.
     * @type {string}
     * @memberof IndexOf
     */
    'substring': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof IndexOf
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof IndexOf
     */
    'input'?: { [key: string]: any; };
}
/**
 * Inner Hit query object that will cause the specified nested type to be returned as the result matching the supplied query.
 * @export
 * @interface InnerHit
 */
export interface InnerHit {
    /**
     * The search query using the Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL extended by SailPoint to support Nested queries.
     * @type {string}
     * @memberof InnerHit
     */
    'query': string;
    /**
     * The nested type to use in the inner hits query.  The nested type [Nested Type](https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html) refers to a document \"nested\" within another document. For example, an identity can have nested documents for access, accounts, and apps.
     * @type {string}
     * @memberof InnerHit
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface JITConfiguration
 */
export interface JITConfiguration {
    /**
     * The indicator for just-in-time provisioning enabled
     * @type {boolean}
     * @memberof JITConfiguration
     */
    'enabled'?: boolean;
    /**
     * the sourceId that mapped to just-in-time provisioning configuration
     * @type {string}
     * @memberof JITConfiguration
     */
    'sourceId'?: string;
    /**
     * A mapping of identity profile attribute names to SAML assertion attribute names
     * @type {{ [key: string]: string; }}
     * @memberof JITConfiguration
     */
    'sourceAttributeMappings'?: { [key: string]: string; };
}
/**
 * A JSONPatch Operation as defined by [RFC 6902 - JSON Patch](https://tools.ietf.org/html/rfc6902)
 * @export
 * @interface JsonPatchOperation
 */
export interface JsonPatchOperation {
    /**
     * The operation to be performed
     * @type {string}
     * @memberof JsonPatchOperation
     */
    'op': JsonPatchOperationOpV3;
    /**
     * A string JSON Pointer representing the target path to an element to be affected by the operation
     * @type {string}
     * @memberof JsonPatchOperation
     */
    'path': string;
    /**
     * 
     * @type {JsonPatchOperationValue}
     * @memberof JsonPatchOperation
     */
    'value'?: JsonPatchOperationValue;
}

export const JsonPatchOperationOpV3 = {
    Add: 'add',
    Remove: 'remove',
    Replace: 'replace',
    Move: 'move',
    Copy: 'copy',
    Test: 'test'
} as const;

export type JsonPatchOperationOpV3 = typeof JsonPatchOperationOpV3[keyof typeof JsonPatchOperationOpV3];

/**
 * @type JsonPatchOperationValue
 * The value to be used for the operation, required for \"add\" and \"replace\" operations
 * @export
 */
export type JsonPatchOperationValue = Array<ArrayInner> | boolean | number | object | string;

/**
 * 
 * @export
 * @interface KbaAnswerRequestItem
 */
export interface KbaAnswerRequestItem {
    /**
     * Question Id
     * @type {string}
     * @memberof KbaAnswerRequestItem
     */
    'id': string;
    /**
     * An answer for the KBA question
     * @type {string}
     * @memberof KbaAnswerRequestItem
     */
    'answer': string;
}
/**
 * 
 * @export
 * @interface KbaAnswerResponseItem
 */
export interface KbaAnswerResponseItem {
    /**
     * Question Id
     * @type {string}
     * @memberof KbaAnswerResponseItem
     */
    'id': string;
    /**
     * Question description
     * @type {string}
     * @memberof KbaAnswerResponseItem
     */
    'question': string;
    /**
     * Denotes whether the KBA question has an answer configured for the current user
     * @type {boolean}
     * @memberof KbaAnswerResponseItem
     */
    'hasAnswer': boolean;
}
/**
 * 
 * @export
 * @interface KbaAuthResponse
 */
export interface KbaAuthResponse {
    /**
     * 
     * @type {Array<KbaAuthResponseItem>}
     * @memberof KbaAuthResponse
     */
    'kbaAuthResponseItems'?: Array<KbaAuthResponseItem>;
    /**
     * MFA Authentication status
     * @type {string}
     * @memberof KbaAuthResponse
     */
    'status'?: KbaAuthResponseStatusV3;
}

export const KbaAuthResponseStatusV3 = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Lockout: 'LOCKOUT',
    NotEnoughData: 'NOT_ENOUGH_DATA'
} as const;

export type KbaAuthResponseStatusV3 = typeof KbaAuthResponseStatusV3[keyof typeof KbaAuthResponseStatusV3];

/**
 * 
 * @export
 * @interface KbaAuthResponseItem
 */
export interface KbaAuthResponseItem {
    /**
     * The KBA question id
     * @type {string}
     * @memberof KbaAuthResponseItem
     */
    'questionId'?: string | null;
    /**
     * Return true if verified
     * @type {boolean}
     * @memberof KbaAuthResponseItem
     */
    'isVerified'?: boolean | null;
}
/**
 * KBA Configuration
 * @export
 * @interface KbaQuestion
 */
export interface KbaQuestion {
    /**
     * KBA Question Id
     * @type {string}
     * @memberof KbaQuestion
     */
    'id': string;
    /**
     * KBA Question description
     * @type {string}
     * @memberof KbaQuestion
     */
    'text': string;
    /**
     * Denotes whether the KBA question has an answer configured for any user in the tenant
     * @type {boolean}
     * @memberof KbaQuestion
     */
    'hasAnswer': boolean;
    /**
     * Denotes the number of KBA configurations for this question
     * @type {number}
     * @memberof KbaQuestion
     */
    'numAnswers': number;
}
/**
 * 
 * @export
 * @interface LeftPad
 */
export interface LeftPad {
    /**
     * An integer value for the desired length of the final output string
     * @type {string}
     * @memberof LeftPad
     */
    'length': string;
    /**
     * A string value representing the character that the incoming data should be padded with to get to the desired length   If not provided, the transform will default to a single space (\" \") character for padding 
     * @type {string}
     * @memberof LeftPad
     */
    'padding'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof LeftPad
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof LeftPad
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface LifecycleState
 */
export interface LifecycleState {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'name': string | null;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'modified'?: string;
    /**
     * Indicates whether the lifecycle state is enabled or disabled.
     * @type {boolean}
     * @memberof LifecycleState
     */
    'enabled'?: boolean;
    /**
     * The lifecycle state\'s technical name. This is for internal use.
     * @type {string}
     * @memberof LifecycleState
     */
    'technicalName': string;
    /**
     * Lifecycle state\'s description.
     * @type {string}
     * @memberof LifecycleState
     */
    'description'?: string;
    /**
     * Number of identities that have the lifecycle state.
     * @type {number}
     * @memberof LifecycleState
     */
    'identityCount'?: number;
    /**
     * 
     * @type {EmailNotificationOption}
     * @memberof LifecycleState
     */
    'emailNotificationOption'?: EmailNotificationOption;
    /**
     * 
     * @type {Array<AccountAction>}
     * @memberof LifecycleState
     */
    'accountActions'?: Array<AccountAction>;
    /**
     * List of unique access-profile IDs that are associated with the lifecycle state.
     * @type {Set<string>}
     * @memberof LifecycleState
     */
    'accessProfileIds'?: Set<string>;
    /**
     * The lifecycle state\'s associated identity state. This field is generally \'null\'.
     * @type {string}
     * @memberof LifecycleState
     */
    'identityState'?: string | null;
}
/**
 * Deleted lifecycle state.
 * @export
 * @interface LifecyclestateDeleted
 */
export interface LifecyclestateDeleted {
    /**
     * Deleted lifecycle state\'s DTO type.
     * @type {string}
     * @memberof LifecyclestateDeleted
     */
    'type'?: LifecyclestateDeletedTypeV3;
    /**
     * Deleted lifecycle state ID.
     * @type {string}
     * @memberof LifecyclestateDeleted
     */
    'id'?: string;
    /**
     * Deleted lifecycle state\'s display name.
     * @type {string}
     * @memberof LifecyclestateDeleted
     */
    'name'?: string;
}

export const LifecyclestateDeletedTypeV3 = {
    LifecycleState: 'LIFECYCLE_STATE'
} as const;

export type LifecyclestateDeletedTypeV3 = typeof LifecyclestateDeletedTypeV3[keyof typeof LifecyclestateDeletedTypeV3];

/**
 * 
 * @export
 * @interface ListAccessProfiles401Response
 */
export interface ListAccessProfiles401Response {
    /**
     * A message describing the error
     * @type {object}
     * @memberof ListAccessProfiles401Response
     */
    'error'?: object;
}
/**
 * 
 * @export
 * @interface ListAccessProfiles429Response
 */
export interface ListAccessProfiles429Response {
    /**
     * A message describing the error
     * @type {object}
     * @memberof ListAccessProfiles429Response
     */
    'message'?: object;
}
/**
 * 
 * @export
 * @interface ListCampaignFilters200Response
 */
export interface ListCampaignFilters200Response {
    /**
     * List of campaign filters.
     * @type {Array<CampaignFilterDetails>}
     * @memberof ListCampaignFilters200Response
     */
    'items'?: Array<CampaignFilterDetails>;
    /**
     * Number of filters returned.
     * @type {number}
     * @memberof ListCampaignFilters200Response
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface ListCompleteWorkflowLibrary200ResponseInner
 */
export interface ListCompleteWorkflowLibrary200ResponseInner {
    /**
     * Operator ID.
     * @type {string}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'id'?: string;
    /**
     * Operator friendly name
     * @type {string}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'name'?: string;
    /**
     * Operator type
     * @type {string}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'type'?: string;
    /**
     * Description of the operator
     * @type {string}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'description'?: string;
    /**
     * One or more inputs that the operator accepts
     * @type {Array<WorkflowLibraryFormFields>}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'formFields'?: Array<WorkflowLibraryFormFields> | null;
    /**
     * 
     * @type {WorkflowLibraryActionExampleOutput}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'exampleOutput'?: WorkflowLibraryActionExampleOutput;
    /**
     * 
     * @type {boolean}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'deprecated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'deprecatedBy'?: string;
    /**
     * Version number
     * @type {number}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'versionNumber'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'isSimulationEnabled'?: boolean;
    /**
     * Determines whether the dynamic output schema is returned in place of the action\'s output schema. The dynamic schema lists non-static properties, like properties of a workflow form where each form has different fields. These will be provided dynamically based on available form fields.
     * @type {boolean}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'isDynamicSchema'?: boolean;
    /**
     * Example output schema
     * @type {object}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'outputSchema'?: object;
    /**
     * Example trigger payload if applicable
     * @type {object}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'inputExample'?: object | null;
}
/**
 * An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const LocaleOrigin = {
    Default: 'DEFAULT',
    Request: 'REQUEST'
} as const;

export type LocaleOrigin = typeof LocaleOrigin[keyof typeof LocaleOrigin];


/**
 * 
 * @export
 * @interface LockoutConfiguration
 */
export interface LockoutConfiguration {
    /**
     * The maximum attempts allowed before lockout occurs.
     * @type {number}
     * @memberof LockoutConfiguration
     */
    'maximumAttempts'?: number;
    /**
     * The total time in minutes a user will be locked out.
     * @type {number}
     * @memberof LockoutConfiguration
     */
    'lockoutDuration'?: number;
    /**
     * A rolling window where authentication attempts in a series count towards the maximum before lockout occurs.
     * @type {number}
     * @memberof LockoutConfiguration
     */
    'lockoutWindow'?: number;
}
/**
 * 
 * @export
 * @interface Lookup
 */
export interface Lookup {
    /**
     * This is a JSON object of key-value pairs. The key is the string that will attempt to be matched to the input, and the value is the output string that should be returned if the key is matched   >**Note** the use of the optional default key value here; if none of the three countries in the above example match the input string, the transform will return \"Unknown Region\" for the attribute that is mapped to this transform. 
     * @type {{ [key: string]: any; }}
     * @memberof Lookup
     */
    'table': { [key: string]: any; };
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Lookup
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Lookup
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Lower
 */
export interface Lower {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Lower
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Lower
     */
    'input'?: { [key: string]: any; };
}
/**
 * Managed Client
 * @export
 * @interface ManagedClient
 */
export interface ManagedClient {
    /**
     * ManagedClient ID
     * @type {string}
     * @memberof ManagedClient
     */
    'id'?: string | null;
    /**
     * ManagedClient alert key
     * @type {string}
     * @memberof ManagedClient
     */
    'alertKey'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ManagedClient
     */
    'apiGatewayBaseUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ManagedClient
     */
    'cookbook'?: string | null;
    /**
     * Previous CC ID to be used in data migration. (This field will be deleted after CC migration!)
     * @type {number}
     * @memberof ManagedClient
     */
    'ccId'?: number | null;
    /**
     * The client ID used in API management
     * @type {string}
     * @memberof ManagedClient
     */
    'clientId': string;
    /**
     * Cluster ID that the ManagedClient is linked to
     * @type {string}
     * @memberof ManagedClient
     */
    'clusterId': string;
    /**
     * ManagedClient description
     * @type {string}
     * @memberof ManagedClient
     */
    'description': string;
    /**
     * The public IP address of the ManagedClient
     * @type {string}
     * @memberof ManagedClient
     */
    'ipAddress'?: string | null;
    /**
     * When the ManagedClient was last seen by the server
     * @type {string}
     * @memberof ManagedClient
     */
    'lastSeen'?: string | null;
    /**
     * ManagedClient name
     * @type {string}
     * @memberof ManagedClient
     */
    'name'?: string | null;
    /**
     * Milliseconds since the ManagedClient has polled the server
     * @type {string}
     * @memberof ManagedClient
     */
    'sinceLastSeen'?: string | null;
    /**
     * Status of the ManagedClient
     * @type {string}
     * @memberof ManagedClient
     */
    'status'?: ManagedClientStatusV3 | null;
    /**
     * Type of the ManagedClient (VA, CCG)
     * @type {string}
     * @memberof ManagedClient
     */
    'type': string;
    /**
     * Cluster Type of the ManagedClient
     * @type {string}
     * @memberof ManagedClient
     */
    'clusterType'?: ManagedClientClusterTypeV3 | null;
    /**
     * ManagedClient VA download URL
     * @type {string}
     * @memberof ManagedClient
     */
    'vaDownloadUrl'?: string | null;
    /**
     * Version that the ManagedClient\'s VA is running
     * @type {string}
     * @memberof ManagedClient
     */
    'vaVersion'?: string | null;
    /**
     * Client\'s apiKey
     * @type {string}
     * @memberof ManagedClient
     */
    'secret'?: string | null;
    /**
     * The date/time this ManagedClient was created
     * @type {string}
     * @memberof ManagedClient
     */
    'createdAt'?: string | null;
    /**
     * The date/time this ManagedClient was last updated
     * @type {string}
     * @memberof ManagedClient
     */
    'updatedAt'?: string | null;
    /**
     * The provisioning status of the ManagedClient
     * @type {string}
     * @memberof ManagedClient
     */
    'provisionStatus'?: ManagedClientProvisionStatusV3 | null;
}

export const ManagedClientStatusV3 = {
    Normal: 'NORMAL',
    Undefined: 'UNDEFINED',
    NotConfigured: 'NOT_CONFIGURED',
    Configuring: 'CONFIGURING',
    Warning: 'WARNING',
    Error: 'ERROR',
    Failed: 'FAILED'
} as const;

export type ManagedClientStatusV3 = typeof ManagedClientStatusV3[keyof typeof ManagedClientStatusV3];
export const ManagedClientClusterTypeV3 = {
    Idn: 'idn',
    Iai: 'iai',
    SpConnectCluster: 'spConnectCluster',
    SqsCluster: 'sqsCluster',
    DasRc: 'das-rc',
    DasPc: 'das-pc',
    DasDc: 'das-dc'
} as const;

export type ManagedClientClusterTypeV3 = typeof ManagedClientClusterTypeV3[keyof typeof ManagedClientClusterTypeV3];
export const ManagedClientProvisionStatusV3 = {
    Provisioned: 'PROVISIONED',
    Draft: 'DRAFT'
} as const;

export type ManagedClientProvisionStatusV3 = typeof ManagedClientProvisionStatusV3[keyof typeof ManagedClientProvisionStatusV3];

/**
 * Managed Client Request
 * @export
 * @interface ManagedClientRequest
 */
export interface ManagedClientRequest {
    /**
     * Cluster ID that the ManagedClient is linked to
     * @type {string}
     * @memberof ManagedClientRequest
     */
    'clusterId': string;
    /**
     * description for the ManagedClient to create
     * @type {string}
     * @memberof ManagedClientRequest
     */
    'description'?: string | null;
    /**
     * name for the ManagedClient to create
     * @type {string}
     * @memberof ManagedClientRequest
     */
    'name'?: string | null;
    /**
     * Type of the ManagedClient (VA, CCG) to create
     * @type {string}
     * @memberof ManagedClientRequest
     */
    'type'?: string | null;
}
/**
 * Managed Client Status
 * @export
 * @interface ManagedClientStatus
 */
export interface ManagedClientStatus {
    /**
     * ManagedClientStatus body information
     * @type {object}
     * @memberof ManagedClientStatus
     */
    'body': object;
    /**
     * 
     * @type {ManagedClientStatusCode}
     * @memberof ManagedClientStatus
     */
    'status': ManagedClientStatusCode;
    /**
     * 
     * @type {ManagedClientType}
     * @memberof ManagedClientStatus
     */
    'type': ManagedClientType | null;
    /**
     * timestamp on the Client Status update
     * @type {string}
     * @memberof ManagedClientStatus
     */
    'timestamp': string;
}


/**
 * Status of a Managed Client
 * @export
 * @enum {string}
 */

export const ManagedClientStatusCode = {
    Normal: 'NORMAL',
    Undefined: 'UNDEFINED',
    NotConfigured: 'NOT_CONFIGURED',
    Configuring: 'CONFIGURING',
    Warning: 'WARNING',
    Error: 'ERROR',
    Failed: 'FAILED'
} as const;

export type ManagedClientStatusCode = typeof ManagedClientStatusCode[keyof typeof ManagedClientStatusCode];


/**
 * Managed Client type
 * @export
 * @enum {string}
 */

export const ManagedClientType = {
    Ccg: 'CCG',
    Va: 'VA',
    Internal: 'INTERNAL',
    IiqHarvester: 'IIQ_HARVESTER'
} as const;

export type ManagedClientType = typeof ManagedClientType[keyof typeof ManagedClientType];


/**
 * Managed Cluster
 * @export
 * @interface ManagedCluster
 */
export interface ManagedCluster {
    /**
     * ManagedCluster ID
     * @type {string}
     * @memberof ManagedCluster
     */
    'id': string;
    /**
     * ManagedCluster name
     * @type {string}
     * @memberof ManagedCluster
     */
    'name'?: string;
    /**
     * ManagedCluster pod
     * @type {string}
     * @memberof ManagedCluster
     */
    'pod'?: string;
    /**
     * ManagedCluster org
     * @type {string}
     * @memberof ManagedCluster
     */
    'org'?: string;
    /**
     * 
     * @type {ManagedClusterTypes}
     * @memberof ManagedCluster
     */
    'type'?: ManagedClusterTypes;
    /**
     * ManagedProcess configuration map
     * @type {{ [key: string]: string | null; }}
     * @memberof ManagedCluster
     */
    'configuration'?: { [key: string]: string | null; };
    /**
     * 
     * @type {ManagedClusterKeyPair}
     * @memberof ManagedCluster
     */
    'keyPair'?: ManagedClusterKeyPair;
    /**
     * 
     * @type {ManagedClusterAttributes}
     * @memberof ManagedCluster
     */
    'attributes'?: ManagedClusterAttributes;
    /**
     * ManagedCluster description
     * @type {string}
     * @memberof ManagedCluster
     */
    'description'?: string;
    /**
     * 
     * @type {ManagedClusterRedis}
     * @memberof ManagedCluster
     */
    'redis'?: ManagedClusterRedis;
    /**
     * 
     * @type {ManagedClientType}
     * @memberof ManagedCluster
     */
    'clientType': ManagedClientType | null;
    /**
     * CCG version used by the ManagedCluster
     * @type {string}
     * @memberof ManagedCluster
     */
    'ccgVersion': string;
    /**
     * boolean flag indiacting whether or not the cluster configuration is pinned
     * @type {boolean}
     * @memberof ManagedCluster
     */
    'pinnedConfig'?: boolean;
    /**
     * 
     * @type {ClientLogConfiguration}
     * @memberof ManagedCluster
     */
    'logConfiguration'?: ClientLogConfiguration | null;
    /**
     * Whether or not the cluster is operational or not
     * @type {boolean}
     * @memberof ManagedCluster
     */
    'operational'?: boolean;
    /**
     * Cluster status
     * @type {string}
     * @memberof ManagedCluster
     */
    'status'?: ManagedClusterStatusV3;
    /**
     * Public key certificate
     * @type {string}
     * @memberof ManagedCluster
     */
    'publicKeyCertificate'?: string | null;
    /**
     * Public key thumbprint
     * @type {string}
     * @memberof ManagedCluster
     */
    'publicKeyThumbprint'?: string | null;
    /**
     * Public key
     * @type {string}
     * @memberof ManagedCluster
     */
    'publicKey'?: string | null;
    /**
     * Key describing any immediate cluster alerts
     * @type {string}
     * @memberof ManagedCluster
     */
    'alertKey'?: string;
    /**
     * List of clients in a cluster
     * @type {Array<string>}
     * @memberof ManagedCluster
     */
    'clientIds'?: Array<string>;
    /**
     * Number of services bound to a cluster
     * @type {number}
     * @memberof ManagedCluster
     */
    'serviceCount'?: number;
    /**
     * CC ID only used in calling CC, will be removed without notice when Migration to CEGS is finished
     * @type {string}
     * @memberof ManagedCluster
     */
    'ccId'?: string;
    /**
     * The date/time this cluster was created
     * @type {string}
     * @memberof ManagedCluster
     */
    'createdAt'?: string | null;
    /**
     * The date/time this cluster was last updated
     * @type {string}
     * @memberof ManagedCluster
     */
    'updatedAt'?: string | null;
}

export const ManagedClusterStatusV3 = {
    Configuring: 'CONFIGURING',
    Failed: 'FAILED',
    NoClients: 'NO_CLIENTS',
    Normal: 'NORMAL',
    Warning: 'WARNING'
} as const;

export type ManagedClusterStatusV3 = typeof ManagedClusterStatusV3[keyof typeof ManagedClusterStatusV3];

/**
 * Managed Cluster Attributes for Cluster Configuration. Supported Cluster Types [sqsCluster, spConnectCluster]
 * @export
 * @interface ManagedClusterAttributes
 */
export interface ManagedClusterAttributes {
    /**
     * 
     * @type {ManagedClusterQueue}
     * @memberof ManagedClusterAttributes
     */
    'queue'?: ManagedClusterQueue;
    /**
     * ManagedCluster keystore for spConnectCluster type
     * @type {string}
     * @memberof ManagedClusterAttributes
     */
    'keystore'?: string | null;
}
/**
 * Managed Cluster key pair for Cluster
 * @export
 * @interface ManagedClusterKeyPair
 */
export interface ManagedClusterKeyPair {
    /**
     * ManagedCluster publicKey
     * @type {string}
     * @memberof ManagedClusterKeyPair
     */
    'publicKey'?: string | null;
    /**
     * ManagedCluster publicKeyThumbprint
     * @type {string}
     * @memberof ManagedClusterKeyPair
     */
    'publicKeyThumbprint'?: string | null;
    /**
     * ManagedCluster publicKeyCertificate
     * @type {string}
     * @memberof ManagedClusterKeyPair
     */
    'publicKeyCertificate'?: string | null;
}
/**
 * Managed Cluster key pair for Cluster
 * @export
 * @interface ManagedClusterQueue
 */
export interface ManagedClusterQueue {
    /**
     * ManagedCluster queue name
     * @type {string}
     * @memberof ManagedClusterQueue
     */
    'name'?: string;
    /**
     * ManagedCluster queue aws region
     * @type {string}
     * @memberof ManagedClusterQueue
     */
    'region'?: string;
}
/**
 * Managed Cluster Redis Configuration
 * @export
 * @interface ManagedClusterRedis
 */
export interface ManagedClusterRedis {
    /**
     * ManagedCluster redisHost
     * @type {string}
     * @memberof ManagedClusterRedis
     */
    'redisHost'?: string;
    /**
     * ManagedCluster redisPort
     * @type {number}
     * @memberof ManagedClusterRedis
     */
    'redisPort'?: number;
}
/**
 * Request to create Managed Cluster
 * @export
 * @interface ManagedClusterRequest
 */
export interface ManagedClusterRequest {
    /**
     * ManagedCluster name
     * @type {string}
     * @memberof ManagedClusterRequest
     */
    'name': string;
    /**
     * 
     * @type {ManagedClusterTypes}
     * @memberof ManagedClusterRequest
     */
    'type'?: ManagedClusterTypes;
    /**
     * ManagedProcess configuration map
     * @type {{ [key: string]: string; }}
     * @memberof ManagedClusterRequest
     */
    'configuration'?: { [key: string]: string; };
    /**
     * ManagedCluster description
     * @type {string}
     * @memberof ManagedClusterRequest
     */
    'description'?: string | null;
}


/**
 * The Type of Cluster
 * @export
 * @enum {string}
 */

export const ManagedClusterTypes = {
    Idn: 'idn',
    Iai: 'iai'
} as const;

export type ManagedClusterTypes = typeof ManagedClusterTypes[keyof typeof ManagedClusterTypes];


/**
 * 
 * @export
 * @interface ManagerCorrelationMapping
 */
export interface ManagerCorrelationMapping {
    /**
     * Name of the attribute to use for manager correlation. The value found on the account attribute will be used to lookup the manager\'s identity.
     * @type {string}
     * @memberof ManagerCorrelationMapping
     */
    'accountAttributeName'?: string;
    /**
     * Name of the identity attribute to search when trying to find a manager using the value from the accountAttribute.
     * @type {string}
     * @memberof ManagerCorrelationMapping
     */
    'identityAttributeName'?: string;
}
/**
 * 
 * @export
 * @interface ManualDiscoverApplications
 */
export interface ManualDiscoverApplications {
    /**
     * The CSV file to upload containing `application_name` and `description` columns. Each row represents an application to be discovered.
     * @type {File}
     * @memberof ManualDiscoverApplications
     */
    'file': File;
}
/**
 * 
 * @export
 * @interface ManualDiscoverApplicationsTemplate
 */
export interface ManualDiscoverApplicationsTemplate {
    /**
     * Name of the application.
     * @type {string}
     * @memberof ManualDiscoverApplicationsTemplate
     */
    'application_name'?: string;
    /**
     * Description of the application.
     * @type {string}
     * @memberof ManualDiscoverApplicationsTemplate
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ManualWorkItemDetails
 */
export interface ManualWorkItemDetails {
    /**
     * True if the request for this item was forwarded from one owner to another.
     * @type {boolean}
     * @memberof ManualWorkItemDetails
     */
    'forwarded'?: boolean;
    /**
     * 
     * @type {ManualWorkItemDetailsOriginalOwner}
     * @memberof ManualWorkItemDetails
     */
    'originalOwner'?: ManualWorkItemDetailsOriginalOwner | null;
    /**
     * 
     * @type {ManualWorkItemDetailsCurrentOwner}
     * @memberof ManualWorkItemDetails
     */
    'currentOwner'?: ManualWorkItemDetailsCurrentOwner | null;
    /**
     * Time at which item was modified.
     * @type {string}
     * @memberof ManualWorkItemDetails
     */
    'modified'?: string;
    /**
     * 
     * @type {ManualWorkItemState}
     * @memberof ManualWorkItemDetails
     */
    'status'?: ManualWorkItemState;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof ManualWorkItemDetails
     */
    'forwardHistory'?: Array<ApprovalForwardHistory> | null;
}


/**
 * Identity of current work item owner.
 * @export
 * @interface ManualWorkItemDetailsCurrentOwner
 */
export interface ManualWorkItemDetailsCurrentOwner {
    /**
     * DTO type of current work item owner\'s identity.
     * @type {string}
     * @memberof ManualWorkItemDetailsCurrentOwner
     */
    'type'?: ManualWorkItemDetailsCurrentOwnerTypeV3;
    /**
     * ID of current work item owner\'s identity.
     * @type {string}
     * @memberof ManualWorkItemDetailsCurrentOwner
     */
    'id'?: string;
    /**
     * Display name of current work item owner.
     * @type {string}
     * @memberof ManualWorkItemDetailsCurrentOwner
     */
    'name'?: string;
}

export const ManualWorkItemDetailsCurrentOwnerTypeV3 = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type ManualWorkItemDetailsCurrentOwnerTypeV3 = typeof ManualWorkItemDetailsCurrentOwnerTypeV3[keyof typeof ManualWorkItemDetailsCurrentOwnerTypeV3];

/**
 * Identity of original work item owner, if the work item has been forwarded.
 * @export
 * @interface ManualWorkItemDetailsOriginalOwner
 */
export interface ManualWorkItemDetailsOriginalOwner {
    /**
     * DTO type of original work item owner\'s identity.
     * @type {string}
     * @memberof ManualWorkItemDetailsOriginalOwner
     */
    'type'?: ManualWorkItemDetailsOriginalOwnerTypeV3;
    /**
     * ID of original work item owner\'s identity.
     * @type {string}
     * @memberof ManualWorkItemDetailsOriginalOwner
     */
    'id'?: string;
    /**
     * Display name of original work item owner.
     * @type {string}
     * @memberof ManualWorkItemDetailsOriginalOwner
     */
    'name'?: string;
}

export const ManualWorkItemDetailsOriginalOwnerTypeV3 = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type ManualWorkItemDetailsOriginalOwnerTypeV3 = typeof ManualWorkItemDetailsOriginalOwnerTypeV3[keyof typeof ManualWorkItemDetailsOriginalOwnerTypeV3];

/**
 * Indicates the state of the request processing for this item: * PENDING: The request for this item is awaiting processing. * APPROVED: The request for this item has been approved. * REJECTED: The request for this item was rejected. * EXPIRED: The request for this item expired with no action taken. * CANCELLED: The request for this item was cancelled with no user action. * ARCHIVED: The request for this item has been archived after completion.
 * @export
 * @enum {string}
 */

export const ManualWorkItemState = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED',
    Archived: 'ARCHIVED'
} as const;

export type ManualWorkItemState = typeof ManualWorkItemState[keyof typeof ManualWorkItemState];


/**
 * The calculation done on the results of the query
 * @export
 * @interface MetricAggregation
 */
export interface MetricAggregation {
    /**
     * The name of the metric aggregate to be included in the result. If the metric aggregation is omitted, the resulting aggregation will be a count of the documents in the search results.
     * @type {string}
     * @memberof MetricAggregation
     */
    'name': string;
    /**
     * 
     * @type {MetricType}
     * @memberof MetricAggregation
     */
    'type'?: MetricType;
    /**
     * The field the calculation is performed on.  Prefix the field name with \'@\' to reference a nested object. 
     * @type {string}
     * @memberof MetricAggregation
     */
    'field': string;
}


/**
 * Enum representing the currently supported metric aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const MetricType = {
    Count: 'COUNT',
    UniqueCount: 'UNIQUE_COUNT',
    Avg: 'AVG',
    Sum: 'SUM',
    Median: 'MEDIAN',
    Min: 'MIN',
    Max: 'MAX'
} as const;

export type MetricType = typeof MetricType[keyof typeof MetricType];


/**
 * Response model for configuration test of a given MFA method
 * @export
 * @interface MfaConfigTestResponse
 */
export interface MfaConfigTestResponse {
    /**
     * The configuration test result.
     * @type {string}
     * @memberof MfaConfigTestResponse
     */
    'state'?: MfaConfigTestResponseStateV3;
    /**
     * The error message to indicate the failure of configuration test.
     * @type {string}
     * @memberof MfaConfigTestResponse
     */
    'error'?: string;
}

export const MfaConfigTestResponseStateV3 = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type MfaConfigTestResponseStateV3 = typeof MfaConfigTestResponseStateV3[keyof typeof MfaConfigTestResponseStateV3];

/**
 * 
 * @export
 * @interface MfaDuoConfig
 */
export interface MfaDuoConfig {
    /**
     * Mfa method name
     * @type {string}
     * @memberof MfaDuoConfig
     */
    'mfaMethod'?: string | null;
    /**
     * If MFA method is enabled.
     * @type {boolean}
     * @memberof MfaDuoConfig
     */
    'enabled'?: boolean;
    /**
     * The server host name or IP address of the MFA provider.
     * @type {string}
     * @memberof MfaDuoConfig
     */
    'host'?: string | null;
    /**
     * The secret key for authenticating requests to the MFA provider.
     * @type {string}
     * @memberof MfaDuoConfig
     */
    'accessKey'?: string | null;
    /**
     * Optional. The name of the attribute for mapping IdentityNow identity to the MFA provider.
     * @type {string}
     * @memberof MfaDuoConfig
     */
    'identityAttribute'?: string | null;
    /**
     * A map with additional config properties for the given MFA method - duo-web.
     * @type {{ [key: string]: any; }}
     * @memberof MfaDuoConfig
     */
    'configProperties'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface MfaOktaConfig
 */
export interface MfaOktaConfig {
    /**
     * Mfa method name
     * @type {string}
     * @memberof MfaOktaConfig
     */
    'mfaMethod'?: string | null;
    /**
     * If MFA method is enabled.
     * @type {boolean}
     * @memberof MfaOktaConfig
     */
    'enabled'?: boolean;
    /**
     * The server host name or IP address of the MFA provider.
     * @type {string}
     * @memberof MfaOktaConfig
     */
    'host'?: string | null;
    /**
     * The secret key for authenticating requests to the MFA provider.
     * @type {string}
     * @memberof MfaOktaConfig
     */
    'accessKey'?: string | null;
    /**
     * Optional. The name of the attribute for mapping IdentityNow identity to the MFA provider.
     * @type {string}
     * @memberof MfaOktaConfig
     */
    'identityAttribute'?: string | null;
}
/**
 * 
 * @export
 * @interface MultiPolicyRequest
 */
export interface MultiPolicyRequest {
    /**
     * Multi-policy report will be run for this list of ids
     * @type {Array<string>}
     * @memberof MultiPolicyRequest
     */
    'filteredPolicyList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NameNormalizer
 */
export interface NameNormalizer {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof NameNormalizer
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof NameNormalizer
     */
    'input'?: { [key: string]: any; };
}
/**
 * | Construct       | Date Time Pattern | Description | | ---------       | ----------------- | ----------- | | ISO8601         | `yyyy-MM-dd\'T\'HH:mm:ss.SSSX` | The ISO8601 standard. |           | LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    | | PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. | | EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. | | EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. | 
 * @export
 * @enum {string}
 */

export const NamedConstructs = {
    Iso8601: 'ISO8601',
    Ldap: 'LDAP',
    PeopleSoft: 'PEOPLE_SOFT',
    EpochTimeJava: 'EPOCH_TIME_JAVA',
    EpochTimeWin32: 'EPOCH_TIME_WIN32'
} as const;

export type NamedConstructs = typeof NamedConstructs[keyof typeof NamedConstructs];


/**
 * The nested aggregation object.
 * @export
 * @interface NestedAggregation
 */
export interface NestedAggregation {
    /**
     * The name of the nested aggregate to be included in the result.
     * @type {string}
     * @memberof NestedAggregation
     */
    'name': string;
    /**
     * The type of the nested object.
     * @type {string}
     * @memberof NestedAggregation
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface NetworkConfiguration
 */
export interface NetworkConfiguration {
    /**
     * The collection of ip ranges.
     * @type {Array<string>}
     * @memberof NetworkConfiguration
     */
    'range'?: Array<string> | null;
    /**
     * The collection of country codes.
     * @type {Array<string>}
     * @memberof NetworkConfiguration
     */
    'geolocation'?: Array<string> | null;
    /**
     * Denotes whether the provided lists are whitelisted or blacklisted for geo location.
     * @type {boolean}
     * @memberof NetworkConfiguration
     */
    'whitelisted'?: boolean;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalDecision
 */
export interface NonEmployeeApprovalDecision {
    /**
     * Comment on the approval item.
     * @type {string}
     * @memberof NonEmployeeApprovalDecision
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItem
 */
export interface NonEmployeeApprovalItem {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItem
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItem
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItem
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeRequestLite}
     * @memberof NonEmployeeApprovalItem
     */
    'nonEmployeeRequest'?: NonEmployeeRequestLite;
}


/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemBase
 */
export interface NonEmployeeApprovalItemBase {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'created'?: string;
}


/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemDetail
 */
export interface NonEmployeeApprovalItemDetail {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeRequestWithoutApprovalItem}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'nonEmployeeRequest'?: NonEmployeeRequestWithoutApprovalItem;
}


/**
 * 
 * @export
 * @interface NonEmployeeApprovalSummary
 */
export interface NonEmployeeApprovalSummary {
    /**
     * The number of approved non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'approved'?: number;
    /**
     * The number of pending non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'pending'?: number;
    /**
     * The number of rejected non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'rejected'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeBulkUploadJob
 */
export interface NonEmployeeBulkUploadJob {
    /**
     * The bulk upload job\'s ID. (UUID)
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'id'?: string;
    /**
     * The ID of the source to bulk-upload non-employees to. (UUID)
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'sourceId'?: string;
    /**
     * The date-time the job was submitted.
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'created'?: string;
    /**
     * The date-time that the job was last updated.
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'modified'?: string;
    /**
     * Returns the following values indicating the progress or result of the bulk upload job. \"PENDING\" means the job is queued and waiting to be processed. \"IN_PROGRESS\" means the job is currently being processed. \"COMPLETED\" means the job has been completed without any errors. \"ERROR\" means the job failed to process with errors. 
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'status'?: NonEmployeeBulkUploadJobStatusV3;
}

export const NonEmployeeBulkUploadJobStatusV3 = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
} as const;

export type NonEmployeeBulkUploadJobStatusV3 = typeof NonEmployeeBulkUploadJobStatusV3[keyof typeof NonEmployeeBulkUploadJobStatusV3];

/**
 * 
 * @export
 * @interface NonEmployeeBulkUploadStatus
 */
export interface NonEmployeeBulkUploadStatus {
    /**
     * Returns the following values indicating the progress or result of the bulk upload job. \"PENDING\" means the job is queued and waiting to be processed. \"IN_PROGRESS\" means the job is currently being processed. \"COMPLETED\" means the job has been completed without any errors. \"ERROR\" means the job failed to process with errors. null means job has been submitted to the source. 
     * @type {string}
     * @memberof NonEmployeeBulkUploadStatus
     */
    'status'?: NonEmployeeBulkUploadStatusStatusV3;
}

export const NonEmployeeBulkUploadStatusStatusV3 = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
} as const;

export type NonEmployeeBulkUploadStatusStatusV3 = typeof NonEmployeeBulkUploadStatusStatusV3[keyof typeof NonEmployeeBulkUploadStatusStatusV3];

/**
 * Identifies if the identity is a normal identity or a governance group
 * @export
 * @enum {string}
 */

export const NonEmployeeIdentityDtoType = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type NonEmployeeIdentityDtoType = typeof NonEmployeeIdentityDtoType[keyof typeof NonEmployeeIdentityDtoType];


/**
 * 
 * @export
 * @interface NonEmployeeIdentityReferenceWithId
 */
export interface NonEmployeeIdentityReferenceWithId {
    /**
     * 
     * @type {NonEmployeeIdentityDtoType}
     * @memberof NonEmployeeIdentityReferenceWithId
     */
    'type'?: NonEmployeeIdentityDtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof NonEmployeeIdentityReferenceWithId
     */
    'id'?: string;
}


/**
 * 
 * @export
 * @interface NonEmployeeIdnUserRequest
 */
export interface NonEmployeeIdnUserRequest {
    /**
     * Identity id.
     * @type {string}
     * @memberof NonEmployeeIdnUserRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRecord
 */
export interface NonEmployeeRecord {
    /**
     * Non-Employee record id.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'id'?: string;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'manager'?: string;
    /**
     * Non-Employee\'s source id.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'sourceId'?: string;
    /**
     * Additional attributes for a non-employee. Up to 10 custom attributes can be added.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRecord
     */
    'data'?: { [key: string]: string; };
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRejectApprovalDecision
 */
export interface NonEmployeeRejectApprovalDecision {
    /**
     * Comment on the approval item.
     * @type {string}
     * @memberof NonEmployeeRejectApprovalDecision
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequest
 */
export interface NonEmployeeRequest {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'description'?: string;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLite}
     * @memberof NonEmployeeRequest
     */
    'nonEmployeeSource'?: NonEmployeeSourceLite;
    /**
     * Additional attributes for a non-employee. Up to 10 custom attributes can be added.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequest
     */
    'data'?: { [key: string]: string; };
    /**
     * List of approval item for the request
     * @type {Array<NonEmployeeApprovalItemBase>}
     * @memberof NonEmployeeRequest
     */
    'approvalItems'?: Array<NonEmployeeApprovalItemBase>;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequest
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Comment of requester
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'created'?: string;
}


/**
 * 
 * @export
 * @interface NonEmployeeRequestBody
 */
export interface NonEmployeeRequestBody {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'accountName': string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'firstName': string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'lastName': string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'email': string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'phone': string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'manager': string;
    /**
     * Non-Employee\'s source id.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'sourceId': string;
    /**
     * Additional attributes for a non-employee. Up to 10 custom attributes can be added.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestBody
     */
    'data'?: { [key: string]: string; };
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'startDate': string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'endDate': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestLite
 */
export interface NonEmployeeRequestLite {
    /**
     * Non-Employee request id.
     * @type {string}
     * @memberof NonEmployeeRequestLite
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeRequestLite
     */
    'requester'?: NonEmployeeIdentityReferenceWithId;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestSummary
 */
export interface NonEmployeeRequestSummary {
    /**
     * The number of approved non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'approved'?: number;
    /**
     * The number of rejected non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'rejected'?: number;
    /**
     * The number of pending non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'pending'?: number;
    /**
     * The number of non-employee records on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'nonEmployeeCount'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestWithoutApprovalItem
 */
export interface NonEmployeeRequestWithoutApprovalItem {
    /**
     * Non-Employee request id.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'requester'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLiteWithSchemaAttributes}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'nonEmployeeSource'?: NonEmployeeSourceLiteWithSchemaAttributes;
    /**
     * Additional attributes for a non-employee. Up to 10 custom attributes can be added.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'created'?: string;
}


/**
 * 
 * @export
 * @interface NonEmployeeSchemaAttribute
 */
export interface NonEmployeeSchemaAttribute {
    /**
     * Schema Attribute Id
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'id'?: string;
    /**
     * True if this schema attribute is mandatory on all non-employees sources.
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttribute
     */
    'system'?: boolean;
    /**
     * When the schema attribute was last modified.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'modified'?: string;
    /**
     * When the schema attribute was created.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeSchemaAttributeType}
     * @memberof NonEmployeeSchemaAttribute
     */
    'type': NonEmployeeSchemaAttributeType;
    /**
     * Label displayed on the UI for this schema attribute.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'label': string;
    /**
     * The technical name of the attribute. Must be unique per source.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'technicalName': string;
    /**
     * help text displayed by UI.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'helpText'?: string;
    /**
     * Hint text that fills UI box.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'placeholder'?: string;
    /**
     * If true, the schema attribute is required for all non-employees in the source
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttribute
     */
    'required'?: boolean;
}


/**
 * 
 * @export
 * @interface NonEmployeeSchemaAttributeBody
 */
export interface NonEmployeeSchemaAttributeBody {
    /**
     * Type of the attribute. Only type \'TEXT\' is supported for custom attributes.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'type': string;
    /**
     * Label displayed on the UI for this schema attribute.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'label': string;
    /**
     * The technical name of the attribute. Must be unique per source.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'technicalName': string;
    /**
     * help text displayed by UI.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'helpText'?: string;
    /**
     * Hint text that fills UI box.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'placeholder'?: string;
    /**
     * If true, the schema attribute is required for all non-employees in the source
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'required'?: boolean;
}
/**
 * Enum representing the type of data a schema attribute accepts.
 * @export
 * @enum {string}
 */

export const NonEmployeeSchemaAttributeType = {
    Text: 'TEXT',
    Date: 'DATE',
    Identity: 'IDENTITY'
} as const;

export type NonEmployeeSchemaAttributeType = typeof NonEmployeeSchemaAttributeType[keyof typeof NonEmployeeSchemaAttributeType];


/**
 * 
 * @export
 * @interface NonEmployeeSource
 */
export interface NonEmployeeSource {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSource
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSource
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLite
 */
export interface NonEmployeeSourceLite {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLiteWithSchemaAttributes
 */
export interface NonEmployeeSourceLiteWithSchemaAttributes {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'description'?: string;
    /**
     * List of schema attributes associated with this non-employee source.
     * @type {Array<NonEmployeeSchemaAttribute>}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'schemaAttributes'?: Array<NonEmployeeSchemaAttribute>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceRequestBody
 */
export interface NonEmployeeSourceRequestBody {
    /**
     * Name of non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'name': string;
    /**
     * Description of non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'description': string;
    /**
     * 
     * @type {NonEmployeeIdnUserRequest}
     * @memberof NonEmployeeSourceRequestBody
     */
    'owner': NonEmployeeIdnUserRequest;
    /**
     * The ID for the management workgroup that contains source sub-admins
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'managementWorkgroup'?: string;
    /**
     * List of approvers.
     * @type {Array<NonEmployeeIdnUserRequest>}
     * @memberof NonEmployeeSourceRequestBody
     */
    'approvers'?: Array<NonEmployeeIdnUserRequest>;
    /**
     * List of account managers.
     * @type {Array<NonEmployeeIdnUserRequest>}
     * @memberof NonEmployeeSourceRequestBody
     */
    'accountManagers'?: Array<NonEmployeeIdnUserRequest>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithCloudExternalId
 */
export interface NonEmployeeSourceWithCloudExternalId {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'created'?: string;
    /**
     * Legacy ID used for sources from the V1 API. This attribute will be removed from a future version of the API and will not be considered a breaking change. No clients should rely on this ID always being present.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'cloudExternalId'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithNECount
 */
export interface NonEmployeeSourceWithNECount {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithNECount
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithNECount
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'created'?: string;
    /**
     * Number of non-employee records associated with this source. This value is \'NULL\' by default. To get the non-employee count, you must set the `non-employee-count` flag in your request to \'true\'.
     * @type {number}
     * @memberof NonEmployeeSourceWithNECount
     */
    'nonEmployeeCount'?: number | null;
}
/**
 * 
 * @export
 * @interface ObjectExportImportNames
 */
export interface ObjectExportImportNames {
    /**
     * Object names to be included in a backup.
     * @type {Array<string>}
     * @memberof ObjectExportImportNames
     */
    'includedNames'?: Array<string>;
}
/**
 * Response model for import of a single object.
 * @export
 * @interface ObjectImportResult
 */
export interface ObjectImportResult {
    /**
     * Informational messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'infos': Array<SpConfigMessage>;
    /**
     * Warning messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'warnings': Array<SpConfigMessage>;
    /**
     * Error messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'errors': Array<SpConfigMessage>;
    /**
     * References to objects that were created or updated by the import.
     * @type {Array<ImportObject>}
     * @memberof ObjectImportResult
     */
    'importedObjects': Array<ImportObject>;
}
/**
 * 
 * @export
 * @interface ObjectMappingBulkCreateRequest
 */
export interface ObjectMappingBulkCreateRequest {
    /**
     * 
     * @type {Array<ObjectMappingRequest>}
     * @memberof ObjectMappingBulkCreateRequest
     */
    'newObjectsMappings': Array<ObjectMappingRequest>;
}
/**
 * 
 * @export
 * @interface ObjectMappingBulkCreateResponse
 */
export interface ObjectMappingBulkCreateResponse {
    /**
     * 
     * @type {Array<ObjectMappingResponse>}
     * @memberof ObjectMappingBulkCreateResponse
     */
    'addedObjects'?: Array<ObjectMappingResponse>;
}
/**
 * 
 * @export
 * @interface ObjectMappingBulkPatchRequest
 */
export interface ObjectMappingBulkPatchRequest {
    /**
     * Map of id of the object mapping to a JsonPatchOperation describing what to patch on that object mapping.
     * @type {{ [key: string]: Array<JsonPatchOperation>; }}
     * @memberof ObjectMappingBulkPatchRequest
     */
    'patches': { [key: string]: Array<JsonPatchOperation>; };
}
/**
 * 
 * @export
 * @interface ObjectMappingBulkPatchResponse
 */
export interface ObjectMappingBulkPatchResponse {
    /**
     * 
     * @type {Array<ObjectMappingResponse>}
     * @memberof ObjectMappingBulkPatchResponse
     */
    'patchedObjects'?: Array<ObjectMappingResponse>;
}
/**
 * 
 * @export
 * @interface ObjectMappingRequest
 */
export interface ObjectMappingRequest {
    /**
     * Type of the object the mapping value applies to, must be one from enum
     * @type {string}
     * @memberof ObjectMappingRequest
     */
    'objectType': ObjectMappingRequestObjectTypeV3;
    /**
     * JSONPath expression denoting the path within the object where the mapping value should be applied
     * @type {string}
     * @memberof ObjectMappingRequest
     */
    'jsonPath': string;
    /**
     * Original value at the jsonPath location within the object
     * @type {string}
     * @memberof ObjectMappingRequest
     */
    'sourceValue': string;
    /**
     * Value to be assigned at the jsonPath location within the object
     * @type {string}
     * @memberof ObjectMappingRequest
     */
    'targetValue': string;
    /**
     * Whether or not this object mapping is enabled
     * @type {boolean}
     * @memberof ObjectMappingRequest
     */
    'enabled'?: boolean;
}

export const ObjectMappingRequestObjectTypeV3 = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    Entitlement: 'ENTITLEMENT',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    Segment: 'SEGMENT',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflow: 'WORKFLOW'
} as const;

export type ObjectMappingRequestObjectTypeV3 = typeof ObjectMappingRequestObjectTypeV3[keyof typeof ObjectMappingRequestObjectTypeV3];

/**
 * 
 * @export
 * @interface ObjectMappingResponse
 */
export interface ObjectMappingResponse {
    /**
     * Id of the object mapping
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'objectMappingId'?: string;
    /**
     * Type of the object the mapping value applies to
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'objectType'?: ObjectMappingResponseObjectTypeV3;
    /**
     * JSONPath expression denoting the path within the object where the mapping value should be applied
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'jsonPath'?: string;
    /**
     * Original value at the jsonPath location within the object
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'sourceValue'?: string;
    /**
     * Value to be assigned at the jsonPath location within the object
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'targetValue'?: string;
    /**
     * Whether or not this object mapping is enabled
     * @type {boolean}
     * @memberof ObjectMappingResponse
     */
    'enabled'?: boolean;
    /**
     * Object mapping creation timestamp
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'created'?: string;
    /**
     * Object mapping latest update timestamp
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'modified'?: string;
}

export const ObjectMappingResponseObjectTypeV3 = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    Entitlement: 'ENTITLEMENT',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    Segment: 'SEGMENT',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflow: 'WORKFLOW'
} as const;

export type ObjectMappingResponseObjectTypeV3 = typeof ObjectMappingResponseObjectTypeV3[keyof typeof ObjectMappingResponseObjectTypeV3];

/**
 * 
 * @export
 * @interface OktaVerificationRequest
 */
export interface OktaVerificationRequest {
    /**
     * User identifier for Verification request. The value of the user\'s attribute.
     * @type {string}
     * @memberof OktaVerificationRequest
     */
    'userId': string;
}
/**
 * Operation on a specific criteria
 * @export
 * @enum {string}
 */

export const Operation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    And: 'AND',
    Or: 'OR'
} as const;

export type Operation = typeof Operation[keyof typeof Operation];


/**
 * 
 * @export
 * @interface OriginalRequest
 */
export interface OriginalRequest {
    /**
     * Account ID.
     * @type {string}
     * @memberof OriginalRequest
     */
    'accountId'?: string;
    /**
     * 
     * @type {Result}
     * @memberof OriginalRequest
     */
    'result'?: Result;
    /**
     * Attribute changes requested for account.
     * @type {Array<AttributeRequest>}
     * @memberof OriginalRequest
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * Operation used.
     * @type {string}
     * @memberof OriginalRequest
     */
    'op'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof OriginalRequest
     */
    'source'?: AccountSource;
}
/**
 * Arguments for Orphan Identities report (ORPHAN_IDENTITIES)
 * @export
 * @interface OrphanIdentitiesReportArguments
 */
export interface OrphanIdentitiesReportArguments {
    /**
     * Output report file formats. These are formats for calling GET endpoint as query parameter \'fileFormat\'.  In case report won\'t have this argument there will be [\'CSV\', \'PDF\'] as default.
     * @type {Array<string>}
     * @memberof OrphanIdentitiesReportArguments
     */
    'selectedFormats'?: Array<OrphanIdentitiesReportArgumentsSelectedFormatsV3>;
}

export const OrphanIdentitiesReportArgumentsSelectedFormatsV3 = {
    Csv: 'CSV',
    Pdf: 'PDF'
} as const;

export type OrphanIdentitiesReportArgumentsSelectedFormatsV3 = typeof OrphanIdentitiesReportArgumentsSelectedFormatsV3[keyof typeof OrphanIdentitiesReportArgumentsSelectedFormatsV3];

/**
 * Owner\'s identity.
 * @export
 * @interface OwnerDto
 */
export interface OwnerDto {
    /**
     * Owner\'s DTO type.
     * @type {string}
     * @memberof OwnerDto
     */
    'type'?: OwnerDtoTypeV3;
    /**
     * Owner\'s identity ID.
     * @type {string}
     * @memberof OwnerDto
     */
    'id'?: string;
    /**
     * Owner\'s name.
     * @type {string}
     * @memberof OwnerDto
     */
    'name'?: string;
}

export const OwnerDtoTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type OwnerDtoTypeV3 = typeof OwnerDtoTypeV3[keyof typeof OwnerDtoTypeV3];

/**
 * The owner of this object.
 * @export
 * @interface OwnerReference
 */
export interface OwnerReference {
    /**
     * Owner type. This field must be either left null or set to \'IDENTITY\' on input, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReference
     */
    'type'?: OwnerReferenceTypeV3;
    /**
     * Identity id
     * @type {string}
     * @memberof OwnerReference
     */
    'id'?: string;
    /**
     * Human-readable display name of the owner. It may be left null or omitted in a POST or PATCH. If set, it must match the current value of the owner\'s display name, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReference
     */
    'name'?: string;
}

export const OwnerReferenceTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type OwnerReferenceTypeV3 = typeof OwnerReferenceTypeV3[keyof typeof OwnerReferenceTypeV3];

/**
 * The owner of this object.
 * @export
 * @interface OwnerReferenceSegments
 */
export interface OwnerReferenceSegments {
    /**
     * Owner type. This field must be either left null or set to \'IDENTITY\' on input, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReferenceSegments
     */
    'type'?: OwnerReferenceSegmentsTypeV3;
    /**
     * Identity id
     * @type {string}
     * @memberof OwnerReferenceSegments
     */
    'id'?: string;
    /**
     * Human-readable display name of the owner. It may be left null or omitted in a POST or PATCH. If set, it must match the current value of the owner\'s display name, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReferenceSegments
     */
    'name'?: string;
}

export const OwnerReferenceSegmentsTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type OwnerReferenceSegmentsTypeV3 = typeof OwnerReferenceSegmentsTypeV3[keyof typeof OwnerReferenceSegmentsTypeV3];

/**
 * 
 * @export
 * @interface Owns
 */
export interface Owns {
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'sources'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'entitlements'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'accessProfiles'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'roles'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'apps'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'governanceGroups'?: Array<Reference1>;
    /**
     * 
     * @type {boolean}
     * @memberof Owns
     */
    'fallbackApprover'?: boolean;
}
/**
 * 
 * @export
 * @interface PasswordChangeRequest
 */
export interface PasswordChangeRequest {
    /**
     * The identity ID that requested the password change
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'identityId'?: string;
    /**
     * The RSA encrypted password
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'encryptedPassword'?: string;
    /**
     * The encryption key ID
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'publicKeyId'?: string;
    /**
     * Account ID of the account This is specified per account schema in the source configuration. It is used to distinguish accounts. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-ID-for-a/ta-p/80350
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'accountId'?: string;
    /**
     * The ID of the source for which identity is requesting the password change
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'sourceId'?: string;
}
/**
 * 
 * @export
 * @interface PasswordChangeResponse
 */
export interface PasswordChangeResponse {
    /**
     * The password change request ID
     * @type {string}
     * @memberof PasswordChangeResponse
     */
    'requestId'?: string | null;
    /**
     * Password change state
     * @type {string}
     * @memberof PasswordChangeResponse
     */
    'state'?: PasswordChangeResponseStateV3;
}

export const PasswordChangeResponseStateV3 = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
} as const;

export type PasswordChangeResponseStateV3 = typeof PasswordChangeResponseStateV3[keyof typeof PasswordChangeResponseStateV3];

/**
 * 
 * @export
 * @interface PasswordInfo
 */
export interface PasswordInfo {
    /**
     * Identity ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'identityId'?: string;
    /**
     * source ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'sourceId'?: string;
    /**
     * public key ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'publicKeyId'?: string;
    /**
     * User\'s public key with Base64 encoding
     * @type {string}
     * @memberof PasswordInfo
     */
    'publicKey'?: string;
    /**
     * Account info related to queried identity and source
     * @type {Array<PasswordInfoAccount>}
     * @memberof PasswordInfo
     */
    'accounts'?: Array<PasswordInfoAccount>;
    /**
     * Password constraints
     * @type {Array<string>}
     * @memberof PasswordInfo
     */
    'policies'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PasswordInfoAccount
 */
export interface PasswordInfoAccount {
    /**
     * Account ID of the account. This is specified per account schema in the source configuration. It is used to distinguish accounts. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-ID-for-a/ta-p/80350
     * @type {string}
     * @memberof PasswordInfoAccount
     */
    'accountId'?: string;
    /**
     * Display name of the account. This is specified per account schema in the source configuration. It is used to display name of the account. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-Name-for/ta-p/74008
     * @type {string}
     * @memberof PasswordInfoAccount
     */
    'accountName'?: string;
}
/**
 * 
 * @export
 * @interface PasswordInfoQueryDTO
 */
export interface PasswordInfoQueryDTO {
    /**
     * The login name of the user
     * @type {string}
     * @memberof PasswordInfoQueryDTO
     */
    'userName'?: string;
    /**
     * The display name of the source
     * @type {string}
     * @memberof PasswordInfoQueryDTO
     */
    'sourceName'?: string;
}
/**
 * 
 * @export
 * @interface PasswordOrgConfig
 */
export interface PasswordOrgConfig {
    /**
     * Indicator whether custom password instructions feature is enabled. The default value is false.
     * @type {boolean}
     * @memberof PasswordOrgConfig
     */
    'customInstructionsEnabled'?: boolean;
    /**
     * Indicator whether \"digit token\" feature is enabled. The default value is false.
     * @type {boolean}
     * @memberof PasswordOrgConfig
     */
    'digitTokenEnabled'?: boolean;
    /**
     * The duration of \"digit token\" in minutes. The default value is 5.
     * @type {number}
     * @memberof PasswordOrgConfig
     */
    'digitTokenDurationMinutes'?: number;
    /**
     * The length of \"digit token\". The default value is 6.
     * @type {number}
     * @memberof PasswordOrgConfig
     */
    'digitTokenLength'?: number;
}
/**
 * 
 * @export
 * @interface PasswordPolicyV3Dto
 */
export interface PasswordPolicyV3Dto {
    /**
     * The password policy Id.
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'id'?: string;
    /**
     * Description for current password policy.
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'description'?: string | null;
    /**
     * The name of the password policy.
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'name'?: string;
    /**
     * Date the Password Policy was created.
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'dateCreated'?: string;
    /**
     * Date the Password Policy was updated.
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'lastUpdated'?: string | null;
    /**
     * The number of days before expiration remaninder.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'firstExpirationReminder'?: number;
    /**
     * The minimun length of account Id. By default is equals to -1.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'accountIdMinWordLength'?: number;
    /**
     * The minimun length of account name. By default is equals to -1.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'accountNameMinWordLength'?: number;
    /**
     * Maximum alpha. By default is equals to 0.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minAlpha'?: number;
    /**
     * MinCharacterTypes. By default is equals to -1.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minCharacterTypes'?: number;
    /**
     * Maximum length of the password.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'maxLength'?: number;
    /**
     * Minimum length of the password. By default is equals to 0.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minLength'?: number;
    /**
     * Maximum repetition of the same character in the password. By default is equals to -1.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'maxRepeatedChars'?: number;
    /**
     * Minimum amount of lower case character in the password. By default is equals to 0.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minLower'?: number;
    /**
     * Minimum amount of numeric characters in the password. By default is equals to 0.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minNumeric'?: number;
    /**
     * Minimum amount of special symbols in the password. By default is equals to 0.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minSpecial'?: number;
    /**
     * Minimum amount of upper case symbols in the password. By default is equals to 0.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minUpper'?: number;
    /**
     * Number of days before current password expires. By default is equals to 90.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'passwordExpiration'?: number;
    /**
     * Defines whether this policy is default or not. Default policy is created automatically when an org is setup. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'defaultPolicy'?: boolean;
    /**
     * Defines whether this policy is enabled to expire or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'enablePasswdExpiration'?: boolean;
    /**
     * Defines whether this policy require strong Auth or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'requireStrongAuthn'?: boolean;
    /**
     * Defines whether this policy require strong Auth of network or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'requireStrongAuthOffNetwork'?: boolean;
    /**
     * Defines whether this policy require strong Auth for untrusted geographies. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'requireStrongAuthUntrustedGeographies'?: boolean;
    /**
     * Defines whether this policy uses account attributes or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'useAccountAttributes'?: boolean;
    /**
     * Defines whether this policy uses dictionary or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'useDictionary'?: boolean;
    /**
     * Defines whether this policy uses identity attributes or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'useIdentityAttributes'?: boolean;
    /**
     * Defines whether this policy validate against account id or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'validateAgainstAccountId'?: boolean;
    /**
     * Defines whether this policy validate against account name or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'validateAgainstAccountName'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'created'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'modified'?: string | null;
    /**
     * List of sources IDs managed by this password policy.
     * @type {Array<string>}
     * @memberof PasswordPolicyV3Dto
     */
    'sourceIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PasswordStatus
 */
export interface PasswordStatus {
    /**
     * The password change request ID
     * @type {string}
     * @memberof PasswordStatus
     */
    'requestId'?: string | null;
    /**
     * Password change state
     * @type {string}
     * @memberof PasswordStatus
     */
    'state'?: PasswordStatusStateV3;
    /**
     * The errors during the password change request
     * @type {Array<string>}
     * @memberof PasswordStatus
     */
    'errors'?: Array<string>;
    /**
     * List of source IDs in the password change request
     * @type {Array<string>}
     * @memberof PasswordStatus
     */
    'sourceIds'?: Array<string>;
}

export const PasswordStatusStateV3 = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
} as const;

export type PasswordStatusStateV3 = typeof PasswordStatusStateV3[keyof typeof PasswordStatusStateV3];

/**
 * 
 * @export
 * @interface PasswordSyncGroup
 */
export interface PasswordSyncGroup {
    /**
     * ID of the sync group
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'id'?: string;
    /**
     * Name of the sync group
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'name'?: string;
    /**
     * ID of the password policy
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'passwordPolicyId'?: string;
    /**
     * List of password managed sources IDs
     * @type {Array<string>}
     * @memberof PasswordSyncGroup
     */
    'sourceIds'?: Array<string>;
    /**
     * The date and time this sync group was created
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'created'?: string | null;
    /**
     * The date and time this sync group was last modified
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'modified'?: string | null;
}
/**
 * Personal access token owner\'s identity.
 * @export
 * @interface PatOwner
 */
export interface PatOwner {
    /**
     * Personal access token owner\'s DTO type.
     * @type {string}
     * @memberof PatOwner
     */
    'type'?: PatOwnerTypeV3;
    /**
     * Personal access token owner\'s identity ID.
     * @type {string}
     * @memberof PatOwner
     */
    'id'?: string;
    /**
     * Personal access token owner\'s human-readable display name.
     * @type {string}
     * @memberof PatOwner
     */
    'name'?: string;
}

export const PatOwnerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type PatOwnerTypeV3 = typeof PatOwnerTypeV3[keyof typeof PatOwnerTypeV3];

/**
 * A JSONPatch document as defined by [RFC 6902 - JSON Patch](https://tools.ietf.org/html/rfc6902).  Only `replace` operations are accepted by this endpoint.
 * @export
 * @interface PatchServiceDeskIntegrationRequest
 */
export interface PatchServiceDeskIntegrationRequest {
    /**
     * Operations to be applied
     * @type {Array<JsonPatchOperation>}
     * @memberof PatchServiceDeskIntegrationRequest
     */
    'operations'?: Array<JsonPatchOperation>;
}
/**
 * 
 * @export
 * @interface PendingApproval
 */
export interface PendingApproval {
    /**
     * The approval id.
     * @type {string}
     * @memberof PendingApproval
     */
    'id'?: string;
    /**
     * This is the access request id.
     * @type {string}
     * @memberof PendingApproval
     */
    'accessRequestId'?: string;
    /**
     * The name of the approval.
     * @type {string}
     * @memberof PendingApproval
     */
    'name'?: string;
    /**
     * When the approval was created.
     * @type {string}
     * @memberof PendingApproval
     */
    'created'?: string;
    /**
     * When the approval was modified last time.
     * @type {string}
     * @memberof PendingApproval
     */
    'modified'?: string;
    /**
     * When the access-request was created.
     * @type {string}
     * @memberof PendingApproval
     */
    'requestCreated'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof PendingApproval
     */
    'requestType'?: AccessRequestType | null;
    /**
     * 
     * @type {AccessItemRequester}
     * @memberof PendingApproval
     */
    'requester'?: AccessItemRequester;
    /**
     * 
     * @type {AccessItemRequestedFor}
     * @memberof PendingApproval
     */
    'requestedFor'?: AccessItemRequestedFor;
    /**
     * 
     * @type {PendingApprovalOwner}
     * @memberof PendingApproval
     */
    'owner'?: PendingApprovalOwner;
    /**
     * 
     * @type {RequestableObjectReference}
     * @memberof PendingApproval
     */
    'requestedObject'?: RequestableObjectReference;
    /**
     * 
     * @type {CommentDto}
     * @memberof PendingApproval
     */
    'requesterComment'?: CommentDto;
    /**
     * The history of the previous reviewers comments.
     * @type {Array<CommentDto>}
     * @memberof PendingApproval
     */
    'previousReviewersComments'?: Array<CommentDto>;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof PendingApproval
     */
    'forwardHistory'?: Array<ApprovalForwardHistory>;
    /**
     * When true the rejector has to provide comments when rejecting
     * @type {boolean}
     * @memberof PendingApproval
     */
    'commentRequiredWhenRejected'?: boolean;
    /**
     * 
     * @type {PendingApprovalAction}
     * @memberof PendingApproval
     */
    'actionInProcess'?: PendingApprovalAction;
    /**
     * The date the role or access profile or entitlement is no longer assigned to the specified identity.
     * @type {string}
     * @memberof PendingApproval
     */
    'removeDate'?: string;
    /**
     * If true, then the request is to change the remove date or sunset date.
     * @type {boolean}
     * @memberof PendingApproval
     */
    'removeDateUpdateRequested'?: boolean;
    /**
     * The remove date or sunset date that was assigned at the time of the request.
     * @type {string}
     * @memberof PendingApproval
     */
    'currentRemoveDate'?: string;
    /**
     * 
     * @type {SodViolationContextCheckCompleted}
     * @memberof PendingApproval
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted | null;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request item
     * @type {{ [key: string]: string; }}
     * @memberof PendingApproval
     */
    'clientMetadata'?: { [key: string]: string; } | null;
}


/**
 * Enum represents action that is being processed on an approval.
 * @export
 * @enum {string}
 */

export const PendingApprovalAction = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Forwarded: 'FORWARDED'
} as const;

export type PendingApprovalAction = typeof PendingApprovalAction[keyof typeof PendingApprovalAction];


/**
 * Access item owner\'s identity.
 * @export
 * @interface PendingApprovalOwner
 */
export interface PendingApprovalOwner {
    /**
     * Access item owner\'s DTO type.
     * @type {string}
     * @memberof PendingApprovalOwner
     */
    'type'?: PendingApprovalOwnerTypeV3;
    /**
     * Access item owner\'s identity ID.
     * @type {string}
     * @memberof PendingApprovalOwner
     */
    'id'?: string;
    /**
     * Access item owner\'s human-readable display name.
     * @type {string}
     * @memberof PendingApprovalOwner
     */
    'name'?: string;
}

export const PendingApprovalOwnerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type PendingApprovalOwnerTypeV3 = typeof PendingApprovalOwnerTypeV3[keyof typeof PendingApprovalOwnerTypeV3];

/**
 * Simplified DTO for the Permission objects stored in SailPoint\'s database. The data is aggregated from customer systems and is free-form, so its appearance can vary largely between different clients/customers.
 * @export
 * @interface PermissionDto
 */
export interface PermissionDto {
    /**
     * All the rights (e.g. actions) that this permission allows on the target
     * @type {Array<string>}
     * @memberof PermissionDto
     */
    'rights'?: Array<string>;
    /**
     * The target the permission would grants rights on.
     * @type {string}
     * @memberof PermissionDto
     */
    'target'?: string;
}
/**
 * Provides additional details about the pre-approval trigger for this request.
 * @export
 * @interface PreApprovalTriggerDetails
 */
export interface PreApprovalTriggerDetails {
    /**
     * Comment left for the pre-approval decision
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'comment'?: string;
    /**
     * The reviewer of the pre-approval decision
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'reviewer'?: string;
    /**
     * The decision of the pre-approval trigger
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'decision'?: PreApprovalTriggerDetailsDecisionV3;
}

export const PreApprovalTriggerDetailsDecisionV3 = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type PreApprovalTriggerDetailsDecisionV3 = typeof PreApprovalTriggerDetailsDecisionV3[keyof typeof PreApprovalTriggerDetailsDecisionV3];

/**
 * 
 * @export
 * @interface ProcessingDetails
 */
export interface ProcessingDetails {
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof ProcessingDetails
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'stage'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProcessingDetails
     */
    'retryCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'stackTrace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'message'?: string;
}
/**
 * Specification of a Service Desk integration provisioning configuration.
 * @export
 * @interface ProvisioningConfig
 */
export interface ProvisioningConfig {
    /**
     * Specifies whether this configuration is used to manage provisioning requests for all sources from the org.  If true, no managedResourceRefs are allowed.
     * @type {boolean}
     * @memberof ProvisioningConfig
     */
    'universalManager'?: boolean;
    /**
     * References to sources for the Service Desk integration template.  May only be specified if universalManager is false.
     * @type {Array<ServiceDeskSource>}
     * @memberof ProvisioningConfig
     */
    'managedResourceRefs'?: Array<ServiceDeskSource>;
    /**
     * 
     * @type {ProvisioningConfigPlanInitializerScript}
     * @memberof ProvisioningConfig
     */
    'planInitializerScript'?: ProvisioningConfigPlanInitializerScript | null;
    /**
     * Name of an attribute that when true disables the saving of ProvisioningRequest objects whenever plans are sent through this integration.
     * @type {boolean}
     * @memberof ProvisioningConfig
     */
    'noProvisioningRequests'?: boolean;
    /**
     * When saving pending requests is enabled, this defines the number of hours the request is allowed to live before it is considered expired and no longer affects plan compilation.
     * @type {number}
     * @memberof ProvisioningConfig
     */
    'provisioningRequestExpiration'?: number;
}
/**
 * This is a reference to a plan initializer script.
 * @export
 * @interface ProvisioningConfigPlanInitializerScript
 */
export interface ProvisioningConfigPlanInitializerScript {
    /**
     * This is a Rule that allows provisioning instruction changes.
     * @type {string}
     * @memberof ProvisioningConfigPlanInitializerScript
     */
    'source'?: string;
}
/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel1
 */
export interface ProvisioningCriteriaLevel1 {
    /**
     * 
     * @type {ProvisioningCriteriaOperation}
     * @memberof ProvisioningCriteriaLevel1
     */
    'operation'?: ProvisioningCriteriaOperation;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel1
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel1
     */
    'value'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes.
     * @type {Array<ProvisioningCriteriaLevel2>}
     * @memberof ProvisioningCriteriaLevel1
     */
    'children'?: Array<ProvisioningCriteriaLevel2> | null;
}


/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel2
 */
export interface ProvisioningCriteriaLevel2 {
    /**
     * 
     * @type {ProvisioningCriteriaOperation}
     * @memberof ProvisioningCriteriaLevel2
     */
    'operation'?: ProvisioningCriteriaOperation;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel2
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel2
     */
    'value'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes.
     * @type {Array<ProvisioningCriteriaLevel3>}
     * @memberof ProvisioningCriteriaLevel2
     */
    'children'?: Array<ProvisioningCriteriaLevel3> | null;
}


/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel3
 */
export interface ProvisioningCriteriaLevel3 {
    /**
     * 
     * @type {ProvisioningCriteriaOperation}
     * @memberof ProvisioningCriteriaLevel3
     */
    'operation'?: ProvisioningCriteriaOperation;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel3
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel3
     */
    'value'?: string;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel3
     */
    'children'?: string | null;
}


/**
 * Supported operations on ProvisioningCriteria
 * @export
 * @enum {string}
 */

export const ProvisioningCriteriaOperation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    Has: 'HAS',
    And: 'AND',
    Or: 'OR'
} as const;

export type ProvisioningCriteriaOperation = typeof ProvisioningCriteriaOperation[keyof typeof ProvisioningCriteriaOperation];


/**
 * Provides additional details about provisioning for this request.
 * @export
 * @interface ProvisioningDetails
 */
export interface ProvisioningDetails {
    /**
     * Ordered CSV of sub phase references to objects that contain more information about provisioning. For example, this can contain \"manualWorkItemDetails\" which indicate that there is further information in that object for this phase.
     * @type {string}
     * @memberof ProvisioningDetails
     */
    'orderedSubPhaseReferences'?: string;
}
/**
 * 
 * @export
 * @interface ProvisioningPolicy
 */
export interface ProvisioningPolicy {
    /**
     * the provisioning policy name
     * @type {string}
     * @memberof ProvisioningPolicy
     */
    'name': string;
    /**
     * the description of the provisioning policy
     * @type {string}
     * @memberof ProvisioningPolicy
     */
    'description'?: string;
    /**
     * 
     * @type {UsageType}
     * @memberof ProvisioningPolicy
     */
    'usageType'?: UsageType;
    /**
     * 
     * @type {Array<FieldDetailsDto>}
     * @memberof ProvisioningPolicy
     */
    'fields'?: Array<FieldDetailsDto>;
}


/**
 * 
 * @export
 * @interface ProvisioningPolicyDto
 */
export interface ProvisioningPolicyDto {
    /**
     * the provisioning policy name
     * @type {string}
     * @memberof ProvisioningPolicyDto
     */
    'name': string;
    /**
     * the description of the provisioning policy
     * @type {string}
     * @memberof ProvisioningPolicyDto
     */
    'description'?: string;
    /**
     * 
     * @type {UsageType}
     * @memberof ProvisioningPolicyDto
     */
    'usageType'?: UsageType;
    /**
     * 
     * @type {Array<FieldDetailsDto>}
     * @memberof ProvisioningPolicyDto
     */
    'fields'?: Array<FieldDetailsDto>;
}


/**
 * Provisioning state of an account activity item
 * @export
 * @enum {string}
 */

export const ProvisioningState = {
    Pending: 'PENDING',
    Finished: 'FINISHED',
    Unverifiable: 'UNVERIFIABLE',
    Commited: 'COMMITED',
    Failed: 'FAILED',
    Retry: 'RETRY'
} as const;

export type ProvisioningState = typeof ProvisioningState[keyof typeof ProvisioningState];


/**
 * Details about a public identity
 * @export
 * @interface PublicIdentity
 */
export interface PublicIdentity {
    /**
     * Identity id
     * @type {string}
     * @memberof PublicIdentity
     */
    'id'?: string;
    /**
     * Human-readable display name of identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'name'?: string;
    /**
     * Alternate unique identifier for the identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'alias'?: string;
    /**
     * Email address of identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'email'?: string | null;
    /**
     * The lifecycle status for the identity
     * @type {string}
     * @memberof PublicIdentity
     */
    'status'?: string | null;
    /**
     * The current state of the identity, which determines how Identity Security Cloud interacts with the identity. An identity that is Active will be included identity picklists in Request Center, identity processing, and more. Identities that are Inactive will be excluded from these features. 
     * @type {string}
     * @memberof PublicIdentity
     */
    'identityState'?: PublicIdentityIdentityStateV3 | null;
    /**
     * 
     * @type {IdentityReference}
     * @memberof PublicIdentity
     */
    'manager'?: IdentityReference | null;
    /**
     * The public identity attributes of the identity
     * @type {Array<PublicIdentityAttributesInner>}
     * @memberof PublicIdentity
     */
    'attributes'?: Array<PublicIdentityAttributesInner>;
}

export const PublicIdentityIdentityStateV3 = {
    Active: 'ACTIVE',
    InactiveShortTerm: 'INACTIVE_SHORT_TERM',
    InactiveLongTerm: 'INACTIVE_LONG_TERM'
} as const;

export type PublicIdentityIdentityStateV3 = typeof PublicIdentityIdentityStateV3[keyof typeof PublicIdentityIdentityStateV3];

/**
 * Used to map an attribute key for an Identity to its display name.
 * @export
 * @interface PublicIdentityAttributeConfig
 */
export interface PublicIdentityAttributeConfig {
    /**
     * The attribute key
     * @type {string}
     * @memberof PublicIdentityAttributeConfig
     */
    'key'?: string;
    /**
     * The attribute display name
     * @type {string}
     * @memberof PublicIdentityAttributeConfig
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PublicIdentityAttributesInner
 */
export interface PublicIdentityAttributesInner {
    /**
     * The attribute key
     * @type {string}
     * @memberof PublicIdentityAttributesInner
     */
    'key'?: string;
    /**
     * Human-readable display name of the attribute
     * @type {string}
     * @memberof PublicIdentityAttributesInner
     */
    'name'?: string;
    /**
     * The attribute value
     * @type {string}
     * @memberof PublicIdentityAttributesInner
     */
    'value'?: string | null;
}
/**
 * Details of up to 5 Identity attributes that will be publicly accessible for all Identities to anyone in the org.
 * @export
 * @interface PublicIdentityConfig
 */
export interface PublicIdentityConfig {
    /**
     * Up to 5 identity attributes that will be available to everyone in the org for all users in the org.
     * @type {Array<PublicIdentityAttributeConfig>}
     * @memberof PublicIdentityConfig
     */
    'attributes'?: Array<PublicIdentityAttributeConfig>;
    /**
     * When this configuration was last modified.
     * @type {string}
     * @memberof PublicIdentityConfig
     */
    'modified'?: string | null;
    /**
     * 
     * @type {IdentityReference}
     * @memberof PublicIdentityConfig
     */
    'modifiedBy'?: IdentityReference | null;
}
/**
 * @type PutClientLogConfigurationRequest
 * @export
 */
export type PutClientLogConfigurationRequest = ClientLogConfigurationDurationMinutes | ClientLogConfigurationExpiration;

/**
 * 
 * @export
 * @interface PutConnectorSourceConfigRequest
 */
export interface PutConnectorSourceConfigRequest {
    /**
     * connector source config xml file
     * @type {File}
     * @memberof PutConnectorSourceConfigRequest
     */
    'file': File;
}
/**
 * 
 * @export
 * @interface PutConnectorSourceTemplateRequest
 */
export interface PutConnectorSourceTemplateRequest {
    /**
     * connector source template xml file
     * @type {File}
     * @memberof PutConnectorSourceTemplateRequest
     */
    'file': File;
}
/**
 * 
 * @export
 * @interface PutPasswordDictionaryRequest
 */
export interface PutPasswordDictionaryRequest {
    /**
     * 
     * @type {File}
     * @memberof PutPasswordDictionaryRequest
     */
    'file'?: File;
}
/**
 * Query parameters used to construct an Elasticsearch query object.
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * The query using the Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL extended by SailPoint to support Nested queries.
     * @type {string}
     * @memberof Query
     */
    'query'?: string;
    /**
     * The fields the query will be applied to.  Fields provide you with a simple way to add additional fields to search, without making the query too complicated.  For example, you can use the fields to specify that you want your query of \"a*\" to be applied to \"name\", \"firstName\", and the \"source.name\".  The response will include all results matching the \"a*\" query found in those three fields.  A field\'s availability depends on the indices being searched.  For example, if you are searching \"identities\", you can apply your search to the \"firstName\" field, but you couldn\'t use \"firstName\" with a search on \"access profiles\".  Refer to the response schema for the respective lists of available fields. 
     * @type {string}
     * @memberof Query
     */
    'fields'?: string;
    /**
     * The time zone to be applied to any range query related to dates.
     * @type {string}
     * @memberof Query
     */
    'timeZone'?: string;
    /**
     * 
     * @type {InnerHit}
     * @memberof Query
     */
    'innerHit'?: InnerHit;
}
/**
 * Allows the query results to be filtered by specifying a list of fields to include and/or exclude from the result documents.
 * @export
 * @interface QueryResultFilter
 */
export interface QueryResultFilter {
    /**
     * The list of field names to include in the result documents.
     * @type {Array<string>}
     * @memberof QueryResultFilter
     */
    'includes'?: Array<string>;
    /**
     * The list of field names to exclude from the result documents.
     * @type {Array<string>}
     * @memberof QueryResultFilter
     */
    'excludes'?: Array<string>;
}
/**
 * The type of query to use.  By default, the `SAILPOINT` query type is used, which requires the `query` object to be defined in the request body. To use the `queryDsl` or `typeAheadQuery` objects in the request, you must set the type to `DSL` or `TYPEAHEAD` accordingly. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const QueryType = {
    Dsl: 'DSL',
    Sailpoint: 'SAILPOINT',
    Text: 'TEXT',
    Typeahead: 'TYPEAHEAD'
} as const;

export type QueryType = typeof QueryType[keyof typeof QueryType];


/**
 * Configuration of maximum number of days and interval for checking Service Desk integration queue status.
 * @export
 * @interface QueuedCheckConfigDetails
 */
export interface QueuedCheckConfigDetails {
    /**
     * Interval in minutes between status checks
     * @type {string}
     * @memberof QueuedCheckConfigDetails
     */
    'provisioningStatusCheckIntervalMinutes': string;
    /**
     * Maximum number of days to check
     * @type {string}
     * @memberof QueuedCheckConfigDetails
     */
    'provisioningMaxStatusCheckDays': string;
}
/**
 * 
 * @export
 * @interface RandomAlphaNumeric
 */
export interface RandomAlphaNumeric {
    /**
     * This is an integer value specifying the size/number of characters the random string must contain   * This value must be a positive number and cannot be blank   * If no length is provided, the transform will default to a value of `32`   * Due to identity attribute data constraints, the maximum allowable value is `450` characters 
     * @type {string}
     * @memberof RandomAlphaNumeric
     */
    'length'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RandomAlphaNumeric
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RandomAlphaNumeric
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface RandomNumeric
 */
export interface RandomNumeric {
    /**
     * This is an integer value specifying the size/number of characters the random string must contain   * This value must be a positive number and cannot be blank   * If no length is provided, the transform will default to a value of `32`   * Due to identity attribute data constraints, the maximum allowable value is `450` characters 
     * @type {string}
     * @memberof RandomNumeric
     */
    'length'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RandomNumeric
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RandomNumeric
     */
    'input'?: { [key: string]: any; };
}
/**
 * The range of values to be filtered.
 * @export
 * @interface Range
 */
export interface Range {
    /**
     * 
     * @type {Bound}
     * @memberof Range
     */
    'lower'?: Bound;
    /**
     * 
     * @type {Bound}
     * @memberof Range
     */
    'upper'?: Bound;
}
/**
 * 
 * @export
 * @interface ReassignReference
 */
export interface ReassignReference {
    /**
     * The ID of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignReference
     */
    'id': string;
    /**
     * The type of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignReference
     */
    'type': ReassignReferenceTypeV3;
}

export const ReassignReferenceTypeV3 = {
    TargetSummary: 'TARGET_SUMMARY',
    Item: 'ITEM',
    IdentitySummary: 'IDENTITY_SUMMARY'
} as const;

export type ReassignReferenceTypeV3 = typeof ReassignReferenceTypeV3[keyof typeof ReassignReferenceTypeV3];

/**
 * 
 * @export
 * @interface Reassignment
 */
export interface Reassignment {
    /**
     * 
     * @type {CertificationReference}
     * @memberof Reassignment
     */
    'from'?: CertificationReference;
    /**
     * The comment entered when the Certification was reassigned
     * @type {string}
     * @memberof Reassignment
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface ReassignmentReference
 */
export interface ReassignmentReference {
    /**
     * The ID of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignmentReference
     */
    'id': string;
    /**
     * The type of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignmentReference
     */
    'type': ReassignmentReferenceTypeV3;
}

export const ReassignmentReferenceTypeV3 = {
    TargetSummary: 'TARGET_SUMMARY',
    Item: 'ITEM',
    IdentitySummary: 'IDENTITY_SUMMARY'
} as const;

export type ReassignmentReferenceTypeV3 = typeof ReassignmentReferenceTypeV3[keyof typeof ReassignmentReferenceTypeV3];

/**
 * 
 * @export
 * @interface ReassignmentTrailDTO
 */
export interface ReassignmentTrailDTO {
    /**
     * The ID of previous owner identity.
     * @type {string}
     * @memberof ReassignmentTrailDTO
     */
    'previousOwner'?: string;
    /**
     * The ID of new owner identity.
     * @type {string}
     * @memberof ReassignmentTrailDTO
     */
    'newOwner'?: string;
    /**
     * The type of reassignment.
     * @type {string}
     * @memberof ReassignmentTrailDTO
     */
    'reassignmentType'?: string;
}
/**
 * The approval reassignment type.  * MANUAL_REASSIGNMENT: An approval with this reassignment type has been specifically reassigned by the approval task\'s owner, from their queue to someone else\'s.  * AUTOMATIC_REASSIGNMENT: An approval with this reassignment type has been automatically reassigned from another approver\'s queue, according to that approver\'s reassignment configuration. The approver\'s reassignment configuration may be set up to automatically reassign approval tasks for a defined (or possibly open-ended) period of time. * AUTO_ESCALATION: An approval with this reassignment type has been automatically reassigned from another approver\'s queue, according to the request\'s escalation configuration. For more information about escalation configuration, refer to [Setting Global Reminders and Escalation Policies](https://documentation.sailpoint.com/saas/help/requests/config_emails.html). * SELF_REVIEW_DELEGATION: An approval with this reassignment type has been automatically reassigned by the system to prevent self-review. This helps prevent situations like a requester being tasked with approving their own request. For more information about preventing self-review, refer to [Self-review Prevention](https://documentation.sailpoint.com/saas/help/users/work_reassignment.html#self-review-prevention) and [Preventing Self-approval](https://documentation.sailpoint.com/saas/help/requests/config_ap_roles.html#preventing-self-approval).
 * @export
 * @enum {string}
 */

export const ReassignmentType = {
    ManualReassignment: 'MANUAL_REASSIGNMENT',
    AutomaticReassignment: 'AUTOMATIC_REASSIGNMENT',
    AutoEscalation: 'AUTO_ESCALATION',
    SelfReviewDelegation: 'SELF_REVIEW_DELEGATION'
} as const;

export type ReassignmentType = typeof ReassignmentType[keyof typeof ReassignmentType];


/**
 * 
 * @export
 * @interface Recommendation
 */
export interface Recommendation {
    /**
     * Recommended type of account.
     * @type {string}
     * @memberof Recommendation
     */
    'type': RecommendationTypeV3;
    /**
     * Method used to produce the recommendation. DISCOVERY - suggested by AI, SOURCE - the account comes from a source flagged as containing machine accounts, CRITERIA - the account satisfies classification criteria.
     * @type {string}
     * @memberof Recommendation
     */
    'method': RecommendationMethodV3;
}

export const RecommendationTypeV3 = {
    Human: 'HUMAN',
    Machine: 'MACHINE'
} as const;

export type RecommendationTypeV3 = typeof RecommendationTypeV3[keyof typeof RecommendationTypeV3];
export const RecommendationMethodV3 = {
    Discovery: 'DISCOVERY',
    Source: 'SOURCE',
    Criteria: 'CRITERIA'
} as const;

export type RecommendationMethodV3 = typeof RecommendationMethodV3[keyof typeof RecommendationMethodV3];

/**
 * 
 * @export
 * @interface Reference
 */
export interface Reference {
    /**
     * This ID specifies the name of the pre-existing transform which you want to use within your current transform
     * @type {string}
     * @memberof Reference
     */
    'id': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Reference
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Reference
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Reference1
 */
export interface Reference1 {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof Reference1
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof Reference1
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RemediationItemDetails
 */
export interface RemediationItemDetails {
    /**
     * The ID of the certification
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'id'?: string;
    /**
     * The ID of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetId'?: string;
    /**
     * The name of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetName'?: string;
    /**
     * The display name of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetDisplayName'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'applicationName'?: string;
    /**
     * The name of the attribute being certified
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeName'?: string;
    /**
     * The operation of the certification on the attribute
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute being certified
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeValue'?: string;
    /**
     * The native identity of the target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'nativeIdentity'?: string;
}
/**
 * 
 * @export
 * @interface RemediationItems
 */
export interface RemediationItems {
    /**
     * The ID of the certification
     * @type {string}
     * @memberof RemediationItems
     */
    'id'?: string;
    /**
     * The ID of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetId'?: string;
    /**
     * The name of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetName'?: string;
    /**
     * The display name of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetDisplayName'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof RemediationItems
     */
    'applicationName'?: string;
    /**
     * The name of the attribute being certified
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeName'?: string;
    /**
     * The operation of the certification on the attribute
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute being certified
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeValue'?: string;
    /**
     * The native identity of the target
     * @type {string}
     * @memberof RemediationItems
     */
    'nativeIdentity'?: string;
}
/**
 * 
 * @export
 * @interface Replace
 */
export interface Replace {
    /**
     * This can be a string or a regex pattern in which you want to replace.
     * @type {string}
     * @memberof Replace
     */
    'regex': string;
    /**
     * This is the replacement string that should be substituded wherever the string or pattern is found.
     * @type {string}
     * @memberof Replace
     */
    'replacement': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Replace
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Replace
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ReplaceAll
 */
export interface ReplaceAll {
    /**
     * An attribute of key-value pairs. Each pair identifies the pattern to search for as its key, and the replacement string as its value.
     * @type {{ [key: string]: any; }}
     * @memberof ReplaceAll
     */
    'table': { [key: string]: any; };
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof ReplaceAll
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof ReplaceAll
     */
    'input'?: { [key: string]: any; };
}
/**
 * Details about report to be processed.
 * @export
 * @interface ReportDetails
 */
export interface ReportDetails {
    /**
     * Use this property to define what report should be processed in the RDE service.
     * @type {string}
     * @memberof ReportDetails
     */
    'reportType'?: ReportDetailsReportTypeV3;
    /**
     * 
     * @type {ReportDetailsArguments}
     * @memberof ReportDetails
     */
    'arguments'?: ReportDetailsArguments;
}

export const ReportDetailsReportTypeV3 = {
    Accounts: 'ACCOUNTS',
    IdentitiesDetails: 'IDENTITIES_DETAILS',
    Identities: 'IDENTITIES',
    IdentityProfileIdentityError: 'IDENTITY_PROFILE_IDENTITY_ERROR',
    OrphanIdentities: 'ORPHAN_IDENTITIES',
    SearchExport: 'SEARCH_EXPORT',
    UncorrelatedAccounts: 'UNCORRELATED_ACCOUNTS'
} as const;

export type ReportDetailsReportTypeV3 = typeof ReportDetailsReportTypeV3[keyof typeof ReportDetailsReportTypeV3];

/**
 * @type ReportDetailsArguments
 * The string-object map(dictionary) with the arguments needed for report processing.
 * @export
 */
export type ReportDetailsArguments = AccountsExportReportArguments | IdentitiesDetailsReportArguments | IdentitiesReportArguments | IdentityProfileIdentityErrorReportArguments | OrphanIdentitiesReportArguments | SearchExportReportArguments | UncorrelatedAccountsReportArguments;

/**
 * 
 * @export
 * @interface ReportResultReference
 */
export interface ReportResultReference {
    /**
     * SOD policy violation report result DTO type.
     * @type {string}
     * @memberof ReportResultReference
     */
    'type'?: ReportResultReferenceTypeV3;
    /**
     * SOD policy violation report result ID.
     * @type {string}
     * @memberof ReportResultReference
     */
    'id'?: string;
    /**
     * Human-readable name of the SOD policy violation report result.
     * @type {string}
     * @memberof ReportResultReference
     */
    'name'?: string;
    /**
     * Status of a SOD policy violation report.
     * @type {string}
     * @memberof ReportResultReference
     */
    'status'?: ReportResultReferenceStatusV3;
}

export const ReportResultReferenceTypeV3 = {
    ReportResult: 'REPORT_RESULT'
} as const;

export type ReportResultReferenceTypeV3 = typeof ReportResultReferenceTypeV3[keyof typeof ReportResultReferenceTypeV3];
export const ReportResultReferenceStatusV3 = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
} as const;

export type ReportResultReferenceStatusV3 = typeof ReportResultReferenceStatusV3[keyof typeof ReportResultReferenceStatusV3];

/**
 * Details about report result or current state.
 * @export
 * @interface ReportResults
 */
export interface ReportResults {
    /**
     * Use this property to define what report should be processed in the RDE service.
     * @type {string}
     * @memberof ReportResults
     */
    'reportType'?: ReportResultsReportTypeV3;
    /**
     * Name of the task definition which is started to process requesting report. Usually the same as report name
     * @type {string}
     * @memberof ReportResults
     */
    'taskDefName'?: string;
    /**
     * Unique task definition identifier.
     * @type {string}
     * @memberof ReportResults
     */
    'id'?: string;
    /**
     * Report processing start date
     * @type {string}
     * @memberof ReportResults
     */
    'created'?: string;
    /**
     * Report current state or result status.
     * @type {string}
     * @memberof ReportResults
     */
    'status'?: ReportResultsStatusV3;
    /**
     * Report processing time in ms.
     * @type {number}
     * @memberof ReportResults
     */
    'duration'?: number;
    /**
     * Report size in rows.
     * @type {number}
     * @memberof ReportResults
     */
    'rows'?: number;
    /**
     * Output report file formats. This are formats for calling get endpoint as a query parameter \'fileFormat\'.  In case report won\'t have this argument there will be [\'CSV\', \'PDF\'] as default.
     * @type {Array<string>}
     * @memberof ReportResults
     */
    'availableFormats'?: Array<ReportResultsAvailableFormatsV3>;
}

export const ReportResultsReportTypeV3 = {
    Accounts: 'ACCOUNTS',
    IdentitiesDetails: 'IDENTITIES_DETAILS',
    Identities: 'IDENTITIES',
    IdentityProfileIdentityError: 'IDENTITY_PROFILE_IDENTITY_ERROR',
    OrphanIdentities: 'ORPHAN_IDENTITIES',
    SearchExport: 'SEARCH_EXPORT',
    UncorrelatedAccounts: 'UNCORRELATED_ACCOUNTS'
} as const;

export type ReportResultsReportTypeV3 = typeof ReportResultsReportTypeV3[keyof typeof ReportResultsReportTypeV3];
export const ReportResultsStatusV3 = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Warning: 'WARNING',
    Terminated: 'TERMINATED'
} as const;

export type ReportResultsStatusV3 = typeof ReportResultsStatusV3[keyof typeof ReportResultsStatusV3];
export const ReportResultsAvailableFormatsV3 = {
    Csv: 'CSV',
    Pdf: 'PDF'
} as const;

export type ReportResultsAvailableFormatsV3 = typeof ReportResultsAvailableFormatsV3[keyof typeof ReportResultsAvailableFormatsV3];

/**
 * type of a Report
 * @export
 * @enum {string}
 */

export const ReportType = {
    CampaignCompositionReport: 'CAMPAIGN_COMPOSITION_REPORT',
    CampaignRemediationStatusReport: 'CAMPAIGN_REMEDIATION_STATUS_REPORT',
    CampaignStatusReport: 'CAMPAIGN_STATUS_REPORT',
    CertificationSignoffReport: 'CERTIFICATION_SIGNOFF_REPORT'
} as const;

export type ReportType = typeof ReportType[keyof typeof ReportType];


/**
 * 
 * @export
 * @interface RequestOnBehalfOfConfig
 */
export interface RequestOnBehalfOfConfig {
    /**
     * If this is true, anyone can request access for anyone.
     * @type {boolean}
     * @memberof RequestOnBehalfOfConfig
     */
    'allowRequestOnBehalfOfAnyoneByAnyone'?: boolean;
    /**
     * If this is true, a manager can request access for his or her direct reports.
     * @type {boolean}
     * @memberof RequestOnBehalfOfConfig
     */
    'allowRequestOnBehalfOfEmployeeByManager'?: boolean;
}
/**
 * 
 * @export
 * @interface Requestability
 */
export interface Requestability {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof Requestability
     */
    'commentsRequired'?: boolean | null;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof Requestability
     */
    'denialCommentsRequired'?: boolean | null;
    /**
     * List describing the steps in approving the request
     * @type {Array<AccessProfileApprovalScheme>}
     * @memberof Requestability
     */
    'approvalSchemes'?: Array<AccessProfileApprovalScheme> | null;
}
/**
 * 
 * @export
 * @interface RequestabilityForRole
 */
export interface RequestabilityForRole {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof RequestabilityForRole
     */
    'commentsRequired'?: boolean | null;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof RequestabilityForRole
     */
    'denialCommentsRequired'?: boolean | null;
    /**
     * List describing the steps in approving the request
     * @type {Array<ApprovalSchemeForRole>}
     * @memberof RequestabilityForRole
     */
    'approvalSchemes'?: Array<ApprovalSchemeForRole>;
}
/**
 * 
 * @export
 * @interface RequestableObject
 */
export interface RequestableObject {
    /**
     * Id of the requestable object itself
     * @type {string}
     * @memberof RequestableObject
     */
    'id'?: string;
    /**
     * Human-readable display name of the requestable object
     * @type {string}
     * @memberof RequestableObject
     */
    'name'?: string;
    /**
     * The time when the requestable object was created
     * @type {string}
     * @memberof RequestableObject
     */
    'created'?: string;
    /**
     * The time when the requestable object was last modified
     * @type {string}
     * @memberof RequestableObject
     */
    'modified'?: string | null;
    /**
     * Description of the requestable object.
     * @type {string}
     * @memberof RequestableObject
     */
    'description'?: string | null;
    /**
     * 
     * @type {RequestableObjectType}
     * @memberof RequestableObject
     */
    'type'?: RequestableObjectType;
    /**
     * 
     * @type {RequestableObjectRequestStatus & object}
     * @memberof RequestableObject
     */
    'requestStatus'?: RequestableObjectRequestStatus & object;
    /**
     * If *requestStatus* is *PENDING*, indicates the id of the associated account activity.
     * @type {string}
     * @memberof RequestableObject
     */
    'identityRequestId'?: string | null;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof RequestableObject
     */
    'ownerRef'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * Whether the requester must provide comments when requesting the object.
     * @type {boolean}
     * @memberof RequestableObject
     */
    'requestCommentsRequired'?: boolean;
}


/**
 * 
 * @export
 * @interface RequestableObjectReference
 */
export interface RequestableObjectReference {
    /**
     * Id of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'id'?: string;
    /**
     * Name of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'name'?: string;
    /**
     * Description of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'description'?: string;
    /**
     * Type of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'type'?: RequestableObjectReferenceTypeV3;
}

export const RequestableObjectReferenceTypeV3 = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestableObjectReferenceTypeV3 = typeof RequestableObjectReferenceTypeV3[keyof typeof RequestableObjectReferenceTypeV3];

/**
 * Status indicating the ability of an access request for the object to be made by or on behalf of the identity specified by *identity-id*. *AVAILABLE* indicates the object is available to request. *PENDING* indicates the object is unavailable because the identity has a pending request in flight. *ASSIGNED* indicates the object is unavailable because the identity already has the indicated role or access profile. If *identity-id* is not specified (allowed only for admin users), then status will be *AVAILABLE* for all results.
 * @export
 * @enum {string}
 */

export const RequestableObjectRequestStatus = {
    Available: 'AVAILABLE',
    Pending: 'PENDING',
    Assigned: 'ASSIGNED'
} as const;

export type RequestableObjectRequestStatus = typeof RequestableObjectRequestStatus[keyof typeof RequestableObjectRequestStatus];


/**
 * The currently supported requestable object types. 
 * @export
 * @enum {string}
 */

export const RequestableObjectType = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestableObjectType = typeof RequestableObjectType[keyof typeof RequestableObjectType];


/**
 * 
 * @export
 * @interface RequestedItemDetails
 */
export interface RequestedItemDetails {
    /**
     * The type of access item requested.
     * @type {string}
     * @memberof RequestedItemDetails
     */
    'type'?: RequestedItemDetailsTypeV3;
    /**
     * The id of the access item requested.
     * @type {string}
     * @memberof RequestedItemDetails
     */
    'id'?: string;
}

export const RequestedItemDetailsTypeV3 = {
    AccessProfile: 'ACCESS_PROFILE',
    Entitlement: 'ENTITLEMENT',
    Role: 'ROLE'
} as const;

export type RequestedItemDetailsTypeV3 = typeof RequestedItemDetailsTypeV3[keyof typeof RequestedItemDetailsTypeV3];

/**
 * 
 * @export
 * @interface RequestedItemStatus
 */
export interface RequestedItemStatus {
    /**
     * The ID of the access request.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'id'?: string;
    /**
     * Human-readable display name of the item being requested.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'name'?: string | null;
    /**
     * Type of requested object.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'type'?: RequestedItemStatusTypeV3 | null;
    /**
     * 
     * @type {RequestedItemStatusCancelledRequestDetails}
     * @memberof RequestedItemStatus
     */
    'cancelledRequestDetails'?: RequestedItemStatusCancelledRequestDetails;
    /**
     * List of list of localized error messages, if any, encountered during the approval/provisioning process.
     * @type {Array<Array<ErrorMessageDto>>}
     * @memberof RequestedItemStatus
     */
    'errorMessages'?: Array<Array<ErrorMessageDto>> | null;
    /**
     * 
     * @type {RequestedItemStatusRequestState}
     * @memberof RequestedItemStatus
     */
    'state'?: RequestedItemStatusRequestState;
    /**
     * Approval details for each item.
     * @type {Array<ApprovalStatusDto>}
     * @memberof RequestedItemStatus
     */
    'approvalDetails'?: Array<ApprovalStatusDto>;
    /**
     * List of approval IDs associated with the request.
     * @type {Array<string>}
     * @memberof RequestedItemStatus
     */
    'approvalIds'?: Array<string> | null;
    /**
     * Manual work items created for provisioning the item.
     * @type {Array<ManualWorkItemDetails>}
     * @memberof RequestedItemStatus
     */
    'manualWorkItemDetails'?: Array<ManualWorkItemDetails> | null;
    /**
     * Id of associated account activity item.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'accountActivityItemId'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof RequestedItemStatus
     */
    'requestType'?: AccessRequestType | null;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'modified'?: string | null;
    /**
     * When the request was created.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'created'?: string;
    /**
     * 
     * @type {AccessItemRequester}
     * @memberof RequestedItemStatus
     */
    'requester'?: AccessItemRequester;
    /**
     * 
     * @type {RequestedItemStatusRequestedFor}
     * @memberof RequestedItemStatus
     */
    'requestedFor'?: RequestedItemStatusRequestedFor;
    /**
     * 
     * @type {RequestedItemStatusRequesterComment}
     * @memberof RequestedItemStatus
     */
    'requesterComment'?: RequestedItemStatusRequesterComment;
    /**
     * 
     * @type {RequestedItemStatusSodViolationContext}
     * @memberof RequestedItemStatus
     */
    'sodViolationContext'?: RequestedItemStatusSodViolationContext;
    /**
     * 
     * @type {RequestedItemStatusProvisioningDetails}
     * @memberof RequestedItemStatus
     */
    'provisioningDetails'?: RequestedItemStatusProvisioningDetails;
    /**
     * 
     * @type {RequestedItemStatusPreApprovalTriggerDetails}
     * @memberof RequestedItemStatus
     */
    'preApprovalTriggerDetails'?: RequestedItemStatusPreApprovalTriggerDetails;
    /**
     * A list of Phases that the Access Request has gone through in order, to help determine the status of the request.
     * @type {Array<AccessRequestPhases>}
     * @memberof RequestedItemStatus
     */
    'accessRequestPhases'?: Array<AccessRequestPhases> | null;
    /**
     * Description associated to the requested object.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'description'?: string | null;
    /**
     * When the role access is scheduled for removal.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'removeDate'?: string | null;
    /**
     * True if the request can be canceled.
     * @type {boolean}
     * @memberof RequestedItemStatus
     */
    'cancelable'?: boolean;
    /**
     * This is the account activity id.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'accessRequestId'?: string;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request
     * @type {{ [key: string]: string; }}
     * @memberof RequestedItemStatus
     */
    'clientMetadata'?: { [key: string]: string; } | null;
}

export const RequestedItemStatusTypeV3 = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestedItemStatusTypeV3 = typeof RequestedItemStatusTypeV3[keyof typeof RequestedItemStatusTypeV3];

/**
 * 
 * @export
 * @interface RequestedItemStatusCancelledRequestDetails
 */
export interface RequestedItemStatusCancelledRequestDetails {
    /**
     * Comment made by the owner when cancelling the associated request.
     * @type {string}
     * @memberof RequestedItemStatusCancelledRequestDetails
     */
    'comment'?: string;
    /**
     * 
     * @type {OwnerDto}
     * @memberof RequestedItemStatusCancelledRequestDetails
     */
    'owner'?: OwnerDto;
    /**
     * Date comment was added by the owner when cancelling the associated request.
     * @type {string}
     * @memberof RequestedItemStatusCancelledRequestDetails
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface RequestedItemStatusPreApprovalTriggerDetails
 */
export interface RequestedItemStatusPreApprovalTriggerDetails {
    /**
     * Comment left for the pre-approval decision
     * @type {string}
     * @memberof RequestedItemStatusPreApprovalTriggerDetails
     */
    'comment'?: string;
    /**
     * The reviewer of the pre-approval decision
     * @type {string}
     * @memberof RequestedItemStatusPreApprovalTriggerDetails
     */
    'reviewer'?: string;
    /**
     * The decision of the pre-approval trigger
     * @type {string}
     * @memberof RequestedItemStatusPreApprovalTriggerDetails
     */
    'decision'?: RequestedItemStatusPreApprovalTriggerDetailsDecisionV3;
}

export const RequestedItemStatusPreApprovalTriggerDetailsDecisionV3 = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type RequestedItemStatusPreApprovalTriggerDetailsDecisionV3 = typeof RequestedItemStatusPreApprovalTriggerDetailsDecisionV3[keyof typeof RequestedItemStatusPreApprovalTriggerDetailsDecisionV3];

/**
 * 
 * @export
 * @interface RequestedItemStatusProvisioningDetails
 */
export interface RequestedItemStatusProvisioningDetails {
    /**
     * Ordered CSV of sub phase references to objects that contain more information about provisioning. For example, this can contain \"manualWorkItemDetails\" which indicate that there is further information in that object for this phase.
     * @type {string}
     * @memberof RequestedItemStatusProvisioningDetails
     */
    'orderedSubPhaseReferences'?: string;
}
/**
 * Indicates the state of an access request: * EXECUTING: The request is executing, which indicates the system is doing some processing. * REQUEST_COMPLETED: Indicates the request  has been completed. * CANCELLED: The request was cancelled with no user input. * TERMINATED: The request has been terminated before it was able to complete. * PROVISIONING_VERIFICATION_PENDING: The request has finished any approval steps and provisioning is waiting to be verified. * REJECTED: The request was rejected. * PROVISIONING_FAILED: The request has failed to complete. * NOT_ALL_ITEMS_PROVISIONED: One or more of the requested items failed to complete, but there were one or more  successes. * ERROR: An error occurred during request processing.
 * @export
 * @enum {string}
 */

export const RequestedItemStatusRequestState = {
    Executing: 'EXECUTING',
    RequestCompleted: 'REQUEST_COMPLETED',
    Cancelled: 'CANCELLED',
    Terminated: 'TERMINATED',
    ProvisioningVerificationPending: 'PROVISIONING_VERIFICATION_PENDING',
    Rejected: 'REJECTED',
    ProvisioningFailed: 'PROVISIONING_FAILED',
    NotAllItemsProvisioned: 'NOT_ALL_ITEMS_PROVISIONED',
    Error: 'ERROR'
} as const;

export type RequestedItemStatusRequestState = typeof RequestedItemStatusRequestState[keyof typeof RequestedItemStatusRequestState];


/**
 * Identity access was requested for.
 * @export
 * @interface RequestedItemStatusRequestedFor
 */
export interface RequestedItemStatusRequestedFor {
    /**
     * Type of the object to which this reference applies
     * @type {string}
     * @memberof RequestedItemStatusRequestedFor
     */
    'type'?: RequestedItemStatusRequestedForTypeV3;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof RequestedItemStatusRequestedFor
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof RequestedItemStatusRequestedFor
     */
    'name'?: string;
}

export const RequestedItemStatusRequestedForTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type RequestedItemStatusRequestedForTypeV3 = typeof RequestedItemStatusRequestedForTypeV3[keyof typeof RequestedItemStatusRequestedForTypeV3];

/**
 * 
 * @export
 * @interface RequestedItemStatusRequesterComment
 */
export interface RequestedItemStatusRequesterComment {
    /**
     * Comment content.
     * @type {string}
     * @memberof RequestedItemStatusRequesterComment
     */
    'comment'?: string | null;
    /**
     * Date and time comment was created.
     * @type {string}
     * @memberof RequestedItemStatusRequesterComment
     */
    'created'?: string;
    /**
     * 
     * @type {CommentDtoAuthor}
     * @memberof RequestedItemStatusRequesterComment
     */
    'author'?: CommentDtoAuthor;
}
/**
 * 
 * @export
 * @interface RequestedItemStatusSodViolationContext
 */
export interface RequestedItemStatusSodViolationContext {
    /**
     * The status of SOD violation check
     * @type {string}
     * @memberof RequestedItemStatusSodViolationContext
     */
    'state'?: RequestedItemStatusSodViolationContextStateV3 | null;
    /**
     * The id of the Violation check event
     * @type {string}
     * @memberof RequestedItemStatusSodViolationContext
     */
    'uuid'?: string | null;
    /**
     * 
     * @type {SodViolationCheckResult}
     * @memberof RequestedItemStatusSodViolationContext
     */
    'violationCheckResult'?: SodViolationCheckResult;
}

export const RequestedItemStatusSodViolationContextStateV3 = {
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type RequestedItemStatusSodViolationContextStateV3 = typeof RequestedItemStatusSodViolationContextStateV3[keyof typeof RequestedItemStatusSodViolationContextStateV3];

/**
 * 
 * @export
 * @interface Result
 */
export interface Result {
    /**
     * Request result status
     * @type {string}
     * @memberof Result
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ReviewDecision
 */
export interface ReviewDecision {
    /**
     * The id of the review decision
     * @type {string}
     * @memberof ReviewDecision
     */
    'id': string;
    /**
     * 
     * @type {CertificationDecision}
     * @memberof ReviewDecision
     */
    'decision': CertificationDecision;
    /**
     * The date at which a user\'s access should be taken away. Should only be set for `REVOKE` decisions.
     * @type {string}
     * @memberof ReviewDecision
     */
    'proposedEndDate'?: string;
    /**
     * Indicates whether decision should be marked as part of a larger bulk decision
     * @type {boolean}
     * @memberof ReviewDecision
     */
    'bulk': boolean;
    /**
     * 
     * @type {ReviewRecommendation}
     * @memberof ReviewDecision
     */
    'recommendation'?: ReviewRecommendation;
    /**
     * Comments recorded when the decision was made
     * @type {string}
     * @memberof ReviewDecision
     */
    'comments'?: string;
}


/**
 * 
 * @export
 * @interface ReviewReassign
 */
export interface ReviewReassign {
    /**
     * 
     * @type {Array<ReassignReference>}
     * @memberof ReviewReassign
     */
    'reassign': Array<ReassignReference>;
    /**
     * The ID of the identity to which the certification is reassigned
     * @type {string}
     * @memberof ReviewReassign
     */
    'reassignTo': string;
    /**
     * The reason comment for why the reassign was made
     * @type {string}
     * @memberof ReviewReassign
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface ReviewRecommendation
 */
export interface ReviewRecommendation {
    /**
     * The recommendation from IAI at the time of the decision. This field will be null if no recommendation was made.
     * @type {string}
     * @memberof ReviewRecommendation
     */
    'recommendation'?: string | null;
    /**
     * A list of reasons for the recommendation.
     * @type {Array<string>}
     * @memberof ReviewRecommendation
     */
    'reasons'?: Array<string>;
    /**
     * The time at which the recommendation was recorded.
     * @type {string}
     * @memberof ReviewRecommendation
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface ReviewableAccessProfile
 */
export interface ReviewableAccessProfile {
    /**
     * The id of the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'id'?: string;
    /**
     * Name of the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'name'?: string;
    /**
     * Information about the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'description'?: string;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableAccessProfile
     */
    'privileged'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof ReviewableAccessProfile
     */
    'cloudGoverned'?: boolean;
    /**
     * The date at which a user\'s access expires
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableAccessProfile
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * A list of entitlements associated with this Access Profile
     * @type {Array<ReviewableEntitlement>}
     * @memberof ReviewableAccessProfile
     */
    'entitlements'?: Array<ReviewableEntitlement>;
    /**
     * Date the Access Profile was created.
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'created'?: string;
    /**
     * Date the Access Profile was last modified.
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface ReviewableEntitlement
 */
export interface ReviewableEntitlement {
    /**
     * The id for the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'id'?: string;
    /**
     * The name of the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'name'?: string;
    /**
     * Information about the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'description'?: string | null;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableEntitlement
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * The name of the attribute on the source
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'attributeName'?: string;
    /**
     * The value of the attribute on the source
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'attributeValue'?: string;
    /**
     * The schema object type on the source used to represent the entitlement and its attributes
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceSchemaObjectType'?: string;
    /**
     * The name of the source for which this entitlement belongs
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceName'?: string;
    /**
     * The type of the source for which the entitlement belongs
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceType'?: string;
    /**
     * The ID of the source for which the entitlement belongs
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceId'?: string;
    /**
     * Indicates if the entitlement has permissions
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'hasPermissions'?: boolean;
    /**
     * Indicates if the entitlement is a representation of an account permission
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'isPermission'?: boolean;
    /**
     * Indicates whether the entitlement can be revoked
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'revocable'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'cloudGoverned'?: boolean;
    /**
     * True if the entitlement has DAS data
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'containsDataAccess'?: boolean;
    /**
     * 
     * @type {DataAccess}
     * @memberof ReviewableEntitlement
     */
    'dataAccess'?: DataAccess | null;
    /**
     * 
     * @type {ReviewableEntitlementAccount}
     * @memberof ReviewableEntitlement
     */
    'account'?: ReviewableEntitlementAccount | null;
}
/**
 * Information about the status of the entitlement
 * @export
 * @interface ReviewableEntitlementAccount
 */
export interface ReviewableEntitlementAccount {
    /**
     * The native identity for this account
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'nativeIdentity'?: string;
    /**
     * Indicates whether this account is currently disabled
     * @type {boolean}
     * @memberof ReviewableEntitlementAccount
     */
    'disabled'?: boolean;
    /**
     * Indicates whether this account is currently locked
     * @type {boolean}
     * @memberof ReviewableEntitlementAccount
     */
    'locked'?: boolean;
    /**
     * 
     * @type {DtoType}
     * @memberof ReviewableEntitlementAccount
     */
    'type'?: DtoType;
    /**
     * The id associated with the account
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'id'?: string | null;
    /**
     * The account name
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'name'?: string | null;
    /**
     * When the account was created
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'created'?: string | null;
    /**
     * When the account was last modified
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'modified'?: string | null;
    /**
     * 
     * @type {ActivityInsights}
     * @memberof ReviewableEntitlementAccount
     */
    'activityInsights'?: ActivityInsights;
    /**
     * Information about the account
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'description'?: string | null;
    /**
     * The id associated with the machine Account Governance Group
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'governanceGroupId'?: string | null;
    /**
     * 
     * @type {ReviewableEntitlementAccountOwner}
     * @memberof ReviewableEntitlementAccount
     */
    'owner'?: ReviewableEntitlementAccountOwner | null;
}


/**
 * Information about the machine account owner
 * @export
 * @interface ReviewableEntitlementAccountOwner
 */
export interface ReviewableEntitlementAccountOwner {
    /**
     * The id associated with the machine account owner
     * @type {string}
     * @memberof ReviewableEntitlementAccountOwner
     */
    'id'?: string | null;
    /**
     * An enumeration of the types of Owner supported within the IdentityNow infrastructure.
     * @type {string}
     * @memberof ReviewableEntitlementAccountOwner
     */
    'type'?: ReviewableEntitlementAccountOwnerTypeV3;
    /**
     * The machine account owner\'s display name
     * @type {string}
     * @memberof ReviewableEntitlementAccountOwner
     */
    'displayName'?: string | null;
}

export const ReviewableEntitlementAccountOwnerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type ReviewableEntitlementAccountOwnerTypeV3 = typeof ReviewableEntitlementAccountOwnerTypeV3[keyof typeof ReviewableEntitlementAccountOwnerTypeV3];

/**
 * 
 * @export
 * @interface ReviewableRole
 */
export interface ReviewableRole {
    /**
     * The id for the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'id'?: string;
    /**
     * The name of the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'name'?: string;
    /**
     * Information about the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'description'?: string;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableRole
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableRole
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * Indicates whether the Role can be revoked or requested
     * @type {boolean}
     * @memberof ReviewableRole
     */
    'revocable'?: boolean;
    /**
     * The date when a user\'s access expires.
     * @type {string}
     * @memberof ReviewableRole
     */
    'endDate'?: string;
    /**
     * The list of Access Profiles associated with this Role
     * @type {Array<ReviewableAccessProfile>}
     * @memberof ReviewableRole
     */
    'accessProfiles'?: Array<ReviewableAccessProfile>;
    /**
     * The list of entitlements associated with this Role
     * @type {Array<ReviewableEntitlement>}
     * @memberof ReviewableRole
     */
    'entitlements'?: Array<ReviewableEntitlement>;
}
/**
 * 
 * @export
 * @interface Reviewer
 */
export interface Reviewer {
    /**
     * The id of the reviewer.
     * @type {string}
     * @memberof Reviewer
     */
    'id'?: string;
    /**
     * The name of the reviewer.
     * @type {string}
     * @memberof Reviewer
     */
    'name'?: string;
    /**
     * The email of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'email'?: string;
    /**
     * The type of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'type'?: ReviewerTypeV3;
    /**
     * The created date of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'created'?: string | null;
    /**
     * The modified date of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'modified'?: string | null;
}

export const ReviewerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type ReviewerTypeV3 = typeof ReviewerTypeV3[keyof typeof ReviewerTypeV3];

/**
 * 
 * @export
 * @interface Revocability
 */
export interface Revocability {
    /**
     * List describing the steps in approving the revocation request
     * @type {Array<AccessProfileApprovalScheme>}
     * @memberof Revocability
     */
    'approvalSchemes'?: Array<AccessProfileApprovalScheme> | null;
}
/**
 * 
 * @export
 * @interface RevocabilityForRole
 */
export interface RevocabilityForRole {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof RevocabilityForRole
     */
    'commentsRequired'?: boolean | null;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof RevocabilityForRole
     */
    'denialCommentsRequired'?: boolean | null;
    /**
     * List describing the steps in approving the revocation request
     * @type {Array<ApprovalSchemeForRole>}
     * @memberof RevocabilityForRole
     */
    'approvalSchemes'?: Array<ApprovalSchemeForRole>;
}
/**
 * 
 * @export
 * @interface RightPad
 */
export interface RightPad {
    /**
     * An integer value for the desired length of the final output string
     * @type {string}
     * @memberof RightPad
     */
    'length': string;
    /**
     * A string value representing the character that the incoming data should be padded with to get to the desired length   If not provided, the transform will default to a single space (\" \") character for padding 
     * @type {string}
     * @memberof RightPad
     */
    'padding'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RightPad
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RightPad
     */
    'input'?: { [key: string]: any; };
}
/**
 * A Role
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * The id of the Role. This field must be left null when creating an Role, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof Role
     */
    'id'?: string;
    /**
     * The human-readable display name of the Role
     * @type {string}
     * @memberof Role
     */
    'name': string;
    /**
     * Date the Role was created
     * @type {string}
     * @memberof Role
     */
    'created'?: string;
    /**
     * Date the Role was last modified.
     * @type {string}
     * @memberof Role
     */
    'modified'?: string;
    /**
     * A human-readable description of the Role
     * @type {string}
     * @memberof Role
     */
    'description'?: string | null;
    /**
     * 
     * @type {OwnerReference}
     * @memberof Role
     */
    'owner': OwnerReference;
    /**
     * 
     * @type {Array<AccessProfileRef>}
     * @memberof Role
     */
    'accessProfiles'?: Array<AccessProfileRef> | null;
    /**
     * 
     * @type {Array<EntitlementRef>}
     * @memberof Role
     */
    'entitlements'?: Array<EntitlementRef>;
    /**
     * 
     * @type {RoleMembershipSelector}
     * @memberof Role
     */
    'membership'?: RoleMembershipSelector | null;
    /**
     * This field is not directly modifiable and is generally expected to be *null*. In very rare instances, some Roles may have been created using membership selection criteria that are no longer fully supported. While these Roles will still work, they should be migrated to STANDARD or IDENTITY_LIST selection criteria. This field exists for informational purposes as an aid to such migration.
     * @type {{ [key: string]: any; }}
     * @memberof Role
     */
    'legacyMembershipInfo'?: { [key: string]: any; } | null;
    /**
     * Whether the Role is enabled or not.
     * @type {boolean}
     * @memberof Role
     */
    'enabled'?: boolean;
    /**
     * Whether the Role can be the target of access requests.
     * @type {boolean}
     * @memberof Role
     */
    'requestable'?: boolean;
    /**
     * 
     * @type {RequestabilityForRole}
     * @memberof Role
     */
    'accessRequestConfig'?: RequestabilityForRole;
    /**
     * 
     * @type {RevocabilityForRole}
     * @memberof Role
     */
    'revocationRequestConfig'?: RevocabilityForRole;
    /**
     * List of IDs of segments, if any, to which this Role is assigned.
     * @type {Array<string>}
     * @memberof Role
     */
    'segments'?: Array<string> | null;
    /**
     * Whether the Role is dimensional.
     * @type {boolean}
     * @memberof Role
     */
    'dimensional'?: boolean | null;
    /**
     * List of references to dimensions to which this Role is assigned. This field is only relevant if the Role is dimensional.
     * @type {Array<DimensionRef>}
     * @memberof Role
     */
    'dimensionRefs'?: Array<DimensionRef> | null;
    /**
     * 
     * @type {AttributeDTOList}
     * @memberof Role
     */
    'accessModelMetadata'?: AttributeDTOList;
}
/**
 * Type which indicates how a particular Identity obtained a particular Role
 * @export
 * @enum {string}
 */

export const RoleAssignmentSourceType = {
    AccessRequest: 'ACCESS_REQUEST',
    RoleMembership: 'ROLE_MEMBERSHIP'
} as const;

export type RoleAssignmentSourceType = typeof RoleAssignmentSourceType[keyof typeof RoleAssignmentSourceType];


/**
 * 
 * @export
 * @interface RoleBulkDeleteRequest
 */
export interface RoleBulkDeleteRequest {
    /**
     * List of IDs of Roles to be deleted.
     * @type {Array<string>}
     * @memberof RoleBulkDeleteRequest
     */
    'roleIds': Array<string>;
}
/**
 * Refers to a specific Identity attribute, Account attibute, or Entitlement used in Role membership criteria
 * @export
 * @interface RoleCriteriaKey
 */
export interface RoleCriteriaKey {
    /**
     * 
     * @type {RoleCriteriaKeyType}
     * @memberof RoleCriteriaKey
     */
    'type': RoleCriteriaKeyType;
    /**
     * The name of the attribute or entitlement to which the associated criteria applies.
     * @type {string}
     * @memberof RoleCriteriaKey
     */
    'property': string;
    /**
     * ID of the Source from which an account attribute or entitlement is drawn. Required if type is ACCOUNT or ENTITLEMENT
     * @type {string}
     * @memberof RoleCriteriaKey
     */
    'sourceId'?: string | null;
}


/**
 * Indicates whether the associated criteria represents an expression on identity attributes, account attributes, or entitlements, respectively.
 * @export
 * @enum {string}
 */

export const RoleCriteriaKeyType = {
    Identity: 'IDENTITY',
    Account: 'ACCOUNT',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RoleCriteriaKeyType = typeof RoleCriteriaKeyType[keyof typeof RoleCriteriaKeyType];


/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel1
 */
export interface RoleCriteriaLevel1 {
    /**
     * 
     * @type {RoleCriteriaOperation}
     * @memberof RoleCriteriaLevel1
     */
    'operation'?: RoleCriteriaOperation;
    /**
     * 
     * @type {RoleCriteriaKey}
     * @memberof RoleCriteriaLevel1
     */
    'key'?: RoleCriteriaKey | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel1
     */
    'stringValue'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes. Additionally, AND nodes can only be children or OR nodes and vice-versa.
     * @type {Array<RoleCriteriaLevel2>}
     * @memberof RoleCriteriaLevel1
     */
    'children'?: Array<RoleCriteriaLevel2> | null;
}


/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel2
 */
export interface RoleCriteriaLevel2 {
    /**
     * 
     * @type {RoleCriteriaOperation}
     * @memberof RoleCriteriaLevel2
     */
    'operation'?: RoleCriteriaOperation;
    /**
     * 
     * @type {RoleCriteriaKey}
     * @memberof RoleCriteriaLevel2
     */
    'key'?: RoleCriteriaKey | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel2
     */
    'stringValue'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes. Additionally, AND nodes can only be children or OR nodes and vice-versa.
     * @type {Array<RoleCriteriaLevel3>}
     * @memberof RoleCriteriaLevel2
     */
    'children'?: Array<RoleCriteriaLevel3> | null;
}


/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel3
 */
export interface RoleCriteriaLevel3 {
    /**
     * 
     * @type {RoleCriteriaOperation}
     * @memberof RoleCriteriaLevel3
     */
    'operation'?: RoleCriteriaOperation;
    /**
     * 
     * @type {RoleCriteriaKey}
     * @memberof RoleCriteriaLevel3
     */
    'key'?: RoleCriteriaKey | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel3
     */
    'stringValue'?: string;
}


/**
 * An operation
 * @export
 * @enum {string}
 */

export const RoleCriteriaOperation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    And: 'AND',
    Or: 'OR'
} as const;

export type RoleCriteriaOperation = typeof RoleCriteriaOperation[keyof typeof RoleCriteriaOperation];


/**
 * Role
 * @export
 * @interface RoleDocument
 */
export interface RoleDocument {
    /**
     * Access item\'s description.
     * @type {string}
     * @memberof RoleDocument
     */
    'description'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof RoleDocument
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof RoleDocument
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof RoleDocument
     */
    'synced'?: string | null;
    /**
     * Indicates whether the access item is currently enabled.
     * @type {boolean}
     * @memberof RoleDocument
     */
    'enabled'?: boolean;
    /**
     * Indicates whether the access item can be requested.
     * @type {boolean}
     * @memberof RoleDocument
     */
    'requestable'?: boolean;
    /**
     * Indicates whether comments are required for requests to access the item.
     * @type {boolean}
     * @memberof RoleDocument
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {BaseAccessOwner}
     * @memberof RoleDocument
     */
    'owner'?: BaseAccessOwner;
    /**
     * ID of the role.
     * @type {string}
     * @memberof RoleDocument
     */
    'id': string;
    /**
     * Name of the role.
     * @type {string}
     * @memberof RoleDocument
     */
    'name': string;
    /**
     * Access profiles included with the role.
     * @type {Array<BaseAccessProfile>}
     * @memberof RoleDocument
     */
    'accessProfiles'?: Array<BaseAccessProfile> | null;
    /**
     * Number of access profiles included with the role.
     * @type {number}
     * @memberof RoleDocument
     */
    'accessProfileCount'?: number | null;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof RoleDocument
     */
    'tags'?: Array<string>;
    /**
     * Segments with the role.
     * @type {Array<BaseSegment>}
     * @memberof RoleDocument
     */
    'segments'?: Array<BaseSegment> | null;
    /**
     * Number of segments with the role.
     * @type {number}
     * @memberof RoleDocument
     */
    'segmentCount'?: number | null;
    /**
     * Entitlements included with the role.
     * @type {Array<RoleDocumentAllOfEntitlements>}
     * @memberof RoleDocument
     */
    'entitlements'?: Array<RoleDocumentAllOfEntitlements> | null;
    /**
     * Number of entitlements included with the role.
     * @type {number}
     * @memberof RoleDocument
     */
    'entitlementCount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof RoleDocument
     */
    'dimensional'?: boolean;
    /**
     * Number of dimension attributes included with the role.
     * @type {number}
     * @memberof RoleDocument
     */
    'dimensionSchemaAttributeCount'?: number | null;
    /**
     * Dimension attributes included with the role.
     * @type {Array<RoleDocumentAllOfDimensionSchemaAttributes>}
     * @memberof RoleDocument
     */
    'dimensionSchemaAttributes'?: Array<RoleDocumentAllOfDimensionSchemaAttributes> | null;
    /**
     * 
     * @type {Array<RoleDocumentAllOfDimensions>}
     * @memberof RoleDocument
     */
    'dimensions'?: Array<RoleDocumentAllOfDimensions> | null;
}
/**
 * 
 * @export
 * @interface RoleDocumentAllOfDimensionSchemaAttributes
 */
export interface RoleDocumentAllOfDimensionSchemaAttributes {
    /**
     * 
     * @type {boolean}
     * @memberof RoleDocumentAllOfDimensionSchemaAttributes
     */
    'derived'?: boolean;
    /**
     * Displayname of the dimension attribute.
     * @type {string}
     * @memberof RoleDocumentAllOfDimensionSchemaAttributes
     */
    'displayName'?: string;
    /**
     * Name of the dimension attribute.
     * @type {string}
     * @memberof RoleDocumentAllOfDimensionSchemaAttributes
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RoleDocumentAllOfDimensions
 */
export interface RoleDocumentAllOfDimensions {
    /**
     * Unique ID of the dimension.
     * @type {string}
     * @memberof RoleDocumentAllOfDimensions
     */
    'id'?: string;
    /**
     * Name of the dimension.
     * @type {string}
     * @memberof RoleDocumentAllOfDimensions
     */
    'name'?: string;
    /**
     * Description of the dimension.
     * @type {string}
     * @memberof RoleDocumentAllOfDimensions
     */
    'description'?: string | null;
    /**
     * Entitlements included with the role.
     * @type {Array<RoleDocumentAllOfEntitlements1>}
     * @memberof RoleDocumentAllOfDimensions
     */
    'entitlements'?: Array<RoleDocumentAllOfEntitlements1> | null;
    /**
     * Access profiles included in the dimension.
     * @type {Array<BaseAccessProfile>}
     * @memberof RoleDocumentAllOfDimensions
     */
    'accessProfiles'?: Array<BaseAccessProfile> | null;
}
/**
 * 
 * @export
 * @interface RoleDocumentAllOfEntitlements
 */
export interface RoleDocumentAllOfEntitlements {
    /**
     * Indicates whether the entitlement has permissions.
     * @type {boolean}
     * @memberof RoleDocumentAllOfEntitlements
     */
    'hasPermissions'?: boolean;
    /**
     * Entitlement\'s description.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements
     */
    'description'?: string | null;
    /**
     * Entitlement attribute\'s name.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements
     */
    'attribute'?: string;
    /**
     * Entitlement\'s value.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements
     */
    'value'?: string;
    /**
     * Entitlement\'s schema.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements
     */
    'schema'?: string;
    /**
     * Indicates whether the entitlement is privileged.
     * @type {boolean}
     * @memberof RoleDocumentAllOfEntitlements
     */
    'privileged'?: boolean;
    /**
     * Entitlement\'s ID.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements
     */
    'id'?: string;
    /**
     * Entitlement\'s name.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements
     */
    'name'?: string;
    /**
     * Schema objectType.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements
     */
    'sourceSchemaObjectType'?: string;
    /**
     * Read-only calculated hash value of an entitlement.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements
     */
    'hash'?: string;
}
/**
 * 
 * @export
 * @interface RoleDocumentAllOfEntitlements1
 */
export interface RoleDocumentAllOfEntitlements1 {
    /**
     * Indicates whether the entitlement has permissions.
     * @type {boolean}
     * @memberof RoleDocumentAllOfEntitlements1
     */
    'hasPermissions'?: boolean;
    /**
     * Entitlement\'s description.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements1
     */
    'description'?: string | null;
    /**
     * Entitlement attribute\'s name.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements1
     */
    'attribute'?: string;
    /**
     * Entitlement\'s value.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements1
     */
    'value'?: string;
    /**
     * Entitlement\'s schema.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements1
     */
    'schema'?: string;
    /**
     * Indicates whether the entitlement is privileged.
     * @type {boolean}
     * @memberof RoleDocumentAllOfEntitlements1
     */
    'privileged'?: boolean;
    /**
     * Entitlement\'s ID.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements1
     */
    'id'?: string;
    /**
     * Entitlement\'s name.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements1
     */
    'name'?: string;
    /**
     * Schema objectType.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements1
     */
    'sourceSchemaObjectType'?: string;
    /**
     * Read-only calculated hash value of an entitlement.
     * @type {string}
     * @memberof RoleDocumentAllOfEntitlements1
     */
    'hash'?: string;
}
/**
 * 
 * @export
 * @interface RoleDocuments
 */
export interface RoleDocuments {
    /**
     * Access item\'s description.
     * @type {string}
     * @memberof RoleDocuments
     */
    'description'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof RoleDocuments
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof RoleDocuments
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof RoleDocuments
     */
    'synced'?: string | null;
    /**
     * Indicates whether the access item is currently enabled.
     * @type {boolean}
     * @memberof RoleDocuments
     */
    'enabled'?: boolean;
    /**
     * Indicates whether the access item can be requested.
     * @type {boolean}
     * @memberof RoleDocuments
     */
    'requestable'?: boolean;
    /**
     * Indicates whether comments are required for requests to access the item.
     * @type {boolean}
     * @memberof RoleDocuments
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {BaseAccessOwner}
     * @memberof RoleDocuments
     */
    'owner'?: BaseAccessOwner;
    /**
     * ID of the role.
     * @type {string}
     * @memberof RoleDocuments
     */
    'id': string;
    /**
     * Name of the role.
     * @type {string}
     * @memberof RoleDocuments
     */
    'name': string;
    /**
     * Access profiles included with the role.
     * @type {Array<BaseAccessProfile>}
     * @memberof RoleDocuments
     */
    'accessProfiles'?: Array<BaseAccessProfile> | null;
    /**
     * Number of access profiles included with the role.
     * @type {number}
     * @memberof RoleDocuments
     */
    'accessProfileCount'?: number | null;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof RoleDocuments
     */
    'tags'?: Array<string>;
    /**
     * Segments with the role.
     * @type {Array<BaseSegment>}
     * @memberof RoleDocuments
     */
    'segments'?: Array<BaseSegment> | null;
    /**
     * Number of segments with the role.
     * @type {number}
     * @memberof RoleDocuments
     */
    'segmentCount'?: number | null;
    /**
     * Entitlements included with the role.
     * @type {Array<RoleDocumentAllOfEntitlements>}
     * @memberof RoleDocuments
     */
    'entitlements'?: Array<RoleDocumentAllOfEntitlements> | null;
    /**
     * Number of entitlements included with the role.
     * @type {number}
     * @memberof RoleDocuments
     */
    'entitlementCount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof RoleDocuments
     */
    'dimensional'?: boolean;
    /**
     * Number of dimension attributes included with the role.
     * @type {number}
     * @memberof RoleDocuments
     */
    'dimensionSchemaAttributeCount'?: number | null;
    /**
     * Dimension attributes included with the role.
     * @type {Array<RoleDocumentAllOfDimensionSchemaAttributes>}
     * @memberof RoleDocuments
     */
    'dimensionSchemaAttributes'?: Array<RoleDocumentAllOfDimensionSchemaAttributes> | null;
    /**
     * 
     * @type {Array<RoleDocumentAllOfDimensions>}
     * @memberof RoleDocuments
     */
    'dimensions'?: Array<RoleDocumentAllOfDimensions> | null;
    /**
     * Name of the pod.
     * @type {string}
     * @memberof RoleDocuments
     */
    'pod'?: string;
    /**
     * Name of the tenant.
     * @type {string}
     * @memberof RoleDocuments
     */
    'org'?: string;
    /**
     * 
     * @type {DocumentType}
     * @memberof RoleDocuments
     */
    '_type'?: DocumentType;
    /**
     * 
     * @type {DocumentType}
     * @memberof RoleDocuments
     */
    'type'?: DocumentType;
    /**
     * Version number.
     * @type {string}
     * @memberof RoleDocuments
     */
    '_version'?: string;
}


/**
 * A subset of the fields of an Identity which is a member of a Role.
 * @export
 * @interface RoleIdentity
 */
export interface RoleIdentity {
    /**
     * The ID of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'id'?: string;
    /**
     * The alias / username of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'aliasName'?: string;
    /**
     * The human-readable display name of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'name'?: string;
    /**
     * Email address of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'email'?: string;
    /**
     * 
     * @type {RoleAssignmentSourceType}
     * @memberof RoleIdentity
     */
    'roleAssignmentSource'?: RoleAssignmentSourceType;
}


/**
 * A reference to an Identity in an IDENTITY_LIST role membership criteria.
 * @export
 * @interface RoleMembershipIdentity
 */
export interface RoleMembershipIdentity {
    /**
     * 
     * @type {DtoType}
     * @memberof RoleMembershipIdentity
     */
    'type'?: DtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof RoleMembershipIdentity
     */
    'id'?: string;
    /**
     * Human-readable display name of the Identity.
     * @type {string}
     * @memberof RoleMembershipIdentity
     */
    'name'?: string | null;
    /**
     * User name of the Identity
     * @type {string}
     * @memberof RoleMembershipIdentity
     */
    'aliasName'?: string | null;
}


/**
 * When present, specifies that the Role is to be granted to Identities which either satisfy specific criteria or which are members of a given list of Identities.
 * @export
 * @interface RoleMembershipSelector
 */
export interface RoleMembershipSelector {
    /**
     * 
     * @type {RoleMembershipSelectorType}
     * @memberof RoleMembershipSelector
     */
    'type'?: RoleMembershipSelectorType;
    /**
     * 
     * @type {RoleCriteriaLevel1}
     * @memberof RoleMembershipSelector
     */
    'criteria'?: RoleCriteriaLevel1 | null;
    /**
     * Defines role membership as being exclusive to the specified Identities, when type is IDENTITY_LIST.
     * @type {Array<RoleMembershipIdentity>}
     * @memberof RoleMembershipSelector
     */
    'identities'?: Array<RoleMembershipIdentity> | null;
}


/**
 * This enum characterizes the type of a Role\'s membership selector. Only the following two are fully supported:  STANDARD: Indicates that Role membership is defined in terms of a criteria expression  IDENTITY_LIST: Indicates that Role membership is conferred on the specific identities listed
 * @export
 * @enum {string}
 */

export const RoleMembershipSelectorType = {
    Standard: 'STANDARD',
    IdentityList: 'IDENTITY_LIST'
} as const;

export type RoleMembershipSelectorType = typeof RoleMembershipSelectorType[keyof typeof RoleMembershipSelectorType];


/**
 * Role
 * @export
 * @interface RoleSummary
 */
export interface RoleSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof RoleSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof RoleSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleSummary
     */
    'displayName'?: string;
    /**
     * Description of access item.
     * @type {string}
     * @memberof RoleSummary
     */
    'description'?: string | null;
    /**
     * Type of the access item.
     * @type {string}
     * @memberof RoleSummary
     */
    'type'?: string;
    /**
     * 
     * @type {DisplayReference}
     * @memberof RoleSummary
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummary
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummary
     */
    'revocable'?: boolean;
}
/**
 * @type Rule
 * @export
 */
export type Rule = GenerateRandomString | GetReferenceIdentityAttribute | TransformRule;

/**
 * 
 * @export
 * @interface SavedSearch
 */
export interface SavedSearch {
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof SavedSearch
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof SavedSearch
     */
    'description'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearch
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearch
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof SavedSearch
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof SavedSearch
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof SavedSearch
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof SavedSearch
     */
    'fields'?: Array<string> | null;
    /**
     * Sort by index. This takes precedence over the `sort` property. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof SavedSearch
     */
    'orderBy'?: { [key: string]: Array<string>; } | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof SavedSearch
     */
    'sort'?: Array<string> | null;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof SavedSearch
     */
    'filters'?: SavedSearchDetailFilters | null;
    /**
     * The saved search ID. 
     * @type {string}
     * @memberof SavedSearch
     */
    'id'?: string;
    /**
     * 
     * @type {TypedReference}
     * @memberof SavedSearch
     */
    'owner'?: TypedReference;
    /**
     * The ID of the identity that owns this saved search.
     * @type {string}
     * @memberof SavedSearch
     */
    'ownerId'?: string;
    /**
     * Whether this saved search is visible to anyone but the owner. This field will always be false as there is no way to set a saved search as public at this time.
     * @type {boolean}
     * @memberof SavedSearch
     */
    'public'?: boolean;
}
/**
 * 
 * @export
 * @interface SavedSearchDetail
 */
export interface SavedSearchDetail {
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof SavedSearchDetail
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof SavedSearchDetail
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof SavedSearchDetail
     */
    'fields'?: Array<string> | null;
    /**
     * Sort by index. This takes precedence over the `sort` property. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof SavedSearchDetail
     */
    'orderBy'?: { [key: string]: Array<string>; } | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof SavedSearchDetail
     */
    'sort'?: Array<string> | null;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof SavedSearchDetail
     */
    'filters'?: SavedSearchDetailFilters | null;
}
/**
 * 
 * @export
 * @interface SavedSearchDetailFilters
 */
export interface SavedSearchDetailFilters {
    /**
     * 
     * @type {FilterType}
     * @memberof SavedSearchDetailFilters
     */
    'type'?: FilterType;
    /**
     * 
     * @type {Range}
     * @memberof SavedSearchDetailFilters
     */
    'range'?: Range;
    /**
     * The terms to be filtered.
     * @type {Array<string>}
     * @memberof SavedSearchDetailFilters
     */
    'terms'?: Array<string>;
    /**
     * Indicates if the filter excludes results.
     * @type {boolean}
     * @memberof SavedSearchDetailFilters
     */
    'exclude'?: boolean;
}


/**
 * 
 * @export
 * @interface SavedSearchName
 */
export interface SavedSearchName {
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof SavedSearchName
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof SavedSearchName
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * Determines the overall schedule cadence. In general, all time period fields smaller than the chosen type can be configured. For example, a DAILY schedule can have \'hours\' set, but not \'days\'; a WEEKLY schedule can have both \'hours\' and \'days\' set.
     * @type {string}
     * @memberof Schedule
     */
    'type': ScheduleTypeV3;
    /**
     * 
     * @type {ScheduleMonths}
     * @memberof Schedule
     */
    'months'?: ScheduleMonths | null;
    /**
     * 
     * @type {ScheduleDays}
     * @memberof Schedule
     */
    'days'?: ScheduleDays;
    /**
     * 
     * @type {ScheduleHours}
     * @memberof Schedule
     */
    'hours': ScheduleHours;
    /**
     * Specifies the time after which this schedule will no longer occur.
     * @type {string}
     * @memberof Schedule
     */
    'expiration'?: string | null;
    /**
     * The time zone to use when running the schedule. For instance, if the schedule is scheduled to run at 1AM, and this field is set to \"CST\", the schedule will run at 1AM CST.
     * @type {string}
     * @memberof Schedule
     */
    'timeZoneId'?: string;
}

export const ScheduleTypeV3 = {
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Annually: 'ANNUALLY',
    Calendar: 'CALENDAR'
} as const;

export type ScheduleTypeV3 = typeof ScheduleTypeV3[keyof typeof ScheduleTypeV3];

/**
 * The schedule information.
 * @export
 * @interface Schedule1
 */
export interface Schedule1 {
    /**
     * 
     * @type {ScheduleType}
     * @memberof Schedule1
     */
    'type': ScheduleType;
    /**
     * 
     * @type {Schedule1Months}
     * @memberof Schedule1
     */
    'months'?: Schedule1Months;
    /**
     * 
     * @type {Schedule1Days}
     * @memberof Schedule1
     */
    'days'?: Schedule1Days;
    /**
     * 
     * @type {Schedule1Hours}
     * @memberof Schedule1
     */
    'hours': Schedule1Hours;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Schedule1
     */
    'expiration'?: string | null;
    /**
     * The canonical TZ identifier the schedule will run in (ex. America/New_York).  If no timezone is specified, the org\'s default timezone is used.
     * @type {string}
     * @memberof Schedule1
     */
    'timeZoneId'?: string | null;
}


/**
 * 
 * @export
 * @interface Schedule1Days
 */
export interface Schedule1Days {
    /**
     * 
     * @type {SelectorType}
     * @memberof Schedule1Days
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Schedule1Days
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Schedule1Days
     */
    'interval'?: number | null;
}


/**
 * 
 * @export
 * @interface Schedule1Hours
 */
export interface Schedule1Hours {
    /**
     * 
     * @type {SelectorType}
     * @memberof Schedule1Hours
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Schedule1Hours
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Schedule1Hours
     */
    'interval'?: number | null;
}


/**
 * 
 * @export
 * @interface Schedule1Months
 */
export interface Schedule1Months {
    /**
     * 
     * @type {SelectorType}
     * @memberof Schedule1Months
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Schedule1Months
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Schedule1Months
     */
    'interval'?: number | null;
}


/**
 * Specifies which day(s) a schedule is active for. This is required for all schedule types. The \"values\" field holds different data depending on the type of schedule: * WEEKLY: days of the week (1-7) * MONTHLY: days of the month (1-31, L, L-1...) * ANNUALLY: if the \"months\" field is also set: days of the month (1-31, L, L-1...); otherwise: ISO-8601 dates without year (\"--12-31\") * CALENDAR: ISO-8601 dates (\"2020-12-31\")  Note that CALENDAR only supports the LIST type, and ANNUALLY does not support the RANGE type when provided with ISO-8601 dates without year.  Examples:  On Sundays: * type LIST * values \"1\"  The second to last day of the month: * type LIST * values \"L-1\"  From the 20th to the last day of the month: * type RANGE * values \"20\", \"L\"  Every March 2nd: * type LIST * values \"--03-02\"  On March 2nd, 2021: * type: LIST * values \"2021-03-02\" 
 * @export
 * @interface ScheduleDays
 */
export interface ScheduleDays {
    /**
     * Enum type to specify days value
     * @type {string}
     * @memberof ScheduleDays
     */
    'type': ScheduleDaysTypeV3;
    /**
     * Values of the days based on the enum type mentioned above
     * @type {Array<string>}
     * @memberof ScheduleDays
     */
    'values': Array<string>;
    /**
     * Interval between the cert generations
     * @type {number}
     * @memberof ScheduleDays
     */
    'interval'?: number | null;
}

export const ScheduleDaysTypeV3 = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type ScheduleDaysTypeV3 = typeof ScheduleDaysTypeV3[keyof typeof ScheduleDaysTypeV3];

/**
 * Specifies which hour(s) a schedule is active for. Examples:  Every three hours starting from 8AM, inclusive: * type LIST * values \"8\" * interval 3  During business hours: * type RANGE * values \"9\", \"5\"  At 5AM, noon, and 5PM: * type LIST * values \"5\", \"12\", \"17\" 
 * @export
 * @interface ScheduleHours
 */
export interface ScheduleHours {
    /**
     * Enum type to specify hours value
     * @type {string}
     * @memberof ScheduleHours
     */
    'type': ScheduleHoursTypeV3;
    /**
     * Values of the days based on the enum type mentioned above
     * @type {Array<string>}
     * @memberof ScheduleHours
     */
    'values': Array<string>;
    /**
     * Interval between the cert generations
     * @type {number}
     * @memberof ScheduleHours
     */
    'interval'?: number | null;
}

export const ScheduleHoursTypeV3 = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type ScheduleHoursTypeV3 = typeof ScheduleHoursTypeV3[keyof typeof ScheduleHoursTypeV3];

/**
 * Specifies which months of a schedule are active. Only valid for ANNUALLY schedule types. Examples:  On February and March: * type LIST * values \"2\", \"3\"  Every 3 months, starting in January (quarterly): * type LIST * values \"1\" * interval 3  Every two months between July and December: * type RANGE * values \"7\", \"12\" * interval 2 
 * @export
 * @interface ScheduleMonths
 */
export interface ScheduleMonths {
    /**
     * Enum type to specify months value
     * @type {string}
     * @memberof ScheduleMonths
     */
    'type': ScheduleMonthsTypeV3;
    /**
     * Values of the months based on the enum type mentioned above
     * @type {Array<string>}
     * @memberof ScheduleMonths
     */
    'values': Array<string>;
    /**
     * Interval between the cert generations
     * @type {number}
     * @memberof ScheduleMonths
     */
    'interval'?: number;
}

export const ScheduleMonthsTypeV3 = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type ScheduleMonthsTypeV3 = typeof ScheduleMonthsTypeV3[keyof typeof ScheduleMonthsTypeV3];

/**
 * Enum representing the currently supported schedule types.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const ScheduleType = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Calendar: 'CALENDAR',
    Annually: 'ANNUALLY'
} as const;

export type ScheduleType = typeof ScheduleType[keyof typeof ScheduleType];


/**
 * Attributes related to a scheduled trigger
 * @export
 * @interface ScheduledAttributes
 */
export interface ScheduledAttributes {
    /**
     * A valid CRON expression
     * @type {string}
     * @memberof ScheduledAttributes
     */
    'cronString'?: string;
    /**
     * Frequency of execution
     * @type {string}
     * @memberof ScheduledAttributes
     */
    'frequency': ScheduledAttributesFrequencyV3;
    /**
     * Time zone identifier
     * @type {string}
     * @memberof ScheduledAttributes
     */
    'timeZone'?: string;
    /**
     * Scheduled days of the week for execution
     * @type {Array<string>}
     * @memberof ScheduledAttributes
     */
    'weeklyDays'?: Array<string>;
    /**
     * Scheduled execution times
     * @type {Array<string>}
     * @memberof ScheduledAttributes
     */
    'weeklyTimes'?: Array<string>;
}

export const ScheduledAttributesFrequencyV3 = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly',
    Yearly: 'yearly',
    CronSchedule: 'cronSchedule'
} as const;

export type ScheduledAttributesFrequencyV3 = typeof ScheduledAttributesFrequencyV3[keyof typeof ScheduledAttributesFrequencyV3];

/**
 * 
 * @export
 * @interface ScheduledSearch
 */
export interface ScheduledSearch {
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearch
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearch
     */
    'description'?: string | null;
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'savedSearchId': string;
    /**
     * The date the scheduled search was initially created.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'created'?: string | null;
    /**
     * The last date the scheduled search was modified.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'modified'?: string | null;
    /**
     * 
     * @type {Schedule1}
     * @memberof ScheduledSearch
     */
    'schedule': Schedule1;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof ScheduledSearch
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should occur when search returns no results. 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'displayQueryDetails'?: boolean;
    /**
     * The scheduled search ID.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'id': string;
    /**
     * 
     * @type {ScheduledSearchAllOfOwner}
     * @memberof ScheduledSearch
     */
    'owner': ScheduledSearchAllOfOwner;
    /**
     * The ID of the scheduled search owner.  Please use the `id` in the `owner` object instead. 
     * @type {string}
     * @memberof ScheduledSearch
     * @deprecated
     */
    'ownerId': string;
}
/**
 * The owner of the scheduled search
 * @export
 * @interface ScheduledSearchAllOfOwner
 */
export interface ScheduledSearchAllOfOwner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof ScheduledSearchAllOfOwner
     */
    'type': ScheduledSearchAllOfOwnerTypeV3;
    /**
     * The ID of the referenced object
     * @type {string}
     * @memberof ScheduledSearchAllOfOwner
     */
    'id': string;
}

export const ScheduledSearchAllOfOwnerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type ScheduledSearchAllOfOwnerTypeV3 = typeof ScheduledSearchAllOfOwnerTypeV3[keyof typeof ScheduledSearchAllOfOwnerTypeV3];

/**
 * 
 * @export
 * @interface ScheduledSearchName
 */
export interface ScheduledSearchName {
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearchName
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearchName
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * The id of the Schema.
     * @type {string}
     * @memberof Schema
     */
    'id'?: string;
    /**
     * The name of the Schema.
     * @type {string}
     * @memberof Schema
     */
    'name'?: string;
    /**
     * The name of the object type on the native system that the schema represents.
     * @type {string}
     * @memberof Schema
     */
    'nativeObjectType'?: string;
    /**
     * The name of the attribute used to calculate the unique identifier for an object in the schema.
     * @type {string}
     * @memberof Schema
     */
    'identityAttribute'?: string;
    /**
     * The name of the attribute used to calculate the display value for an object in the schema.
     * @type {string}
     * @memberof Schema
     */
    'displayAttribute'?: string;
    /**
     * The name of the attribute whose values represent other objects in a hierarchy. Only relevant to group schemas.
     * @type {string}
     * @memberof Schema
     */
    'hierarchyAttribute'?: string;
    /**
     * Flag indicating whether or not the include permissions with the object data when aggregating the schema.
     * @type {boolean}
     * @memberof Schema
     */
    'includePermissions'?: boolean;
    /**
     * Optional features that can be supported by a source. Modifying the features array may cause source configuration errors that are unsupportable. It is recommended to not modify this array for SailPoint supported connectors. * AUTHENTICATE: The source supports pass-through authentication. * COMPOSITE: The source supports composite source creation. * DIRECT_PERMISSIONS: The source supports returning DirectPermissions. * DISCOVER_SCHEMA: The source supports discovering schemas for users and groups. * ENABLE The source supports reading if an account is enabled or disabled. * MANAGER_LOOKUP: The source supports looking up managers as they are encountered in a feed. This is the opposite of NO_RANDOM_ACCESS. * NO_RANDOM_ACCESS: The source does not support random access and the getObject() methods should not be called and expected to perform. * PROXY: The source can serve as a proxy for another source. When an source has a proxy, all connector calls made with that source are redirected through the connector for the proxy source. * SEARCH * TEMPLATE * UNLOCK: The source supports reading if an account is locked or unlocked. * UNSTRUCTURED_TARGETS: The source supports returning unstructured Targets. * SHAREPOINT_TARGET: The source supports returning unstructured Target data for SharePoint. It will be typically used by AD, LDAP sources. * PROVISIONING: The source can both read and write accounts. Having this feature implies that the provision() method is implemented. It also means that direct and target permissions can also be provisioned if they can be returned by aggregation. * GROUP_PROVISIONING: The source can both read and write groups. Having this feature implies that the provision() method is implemented. * SYNC_PROVISIONING: The source can provision accounts synchronously. * PASSWORD: The source can provision password changes. Since sources can never read passwords, this is should only be used in conjunction with the PROVISIONING feature. * CURRENT_PASSWORD: Some source types support verification of the current password * ACCOUNT_ONLY_REQUEST: The source supports requesting accounts without entitlements. * ADDITIONAL_ACCOUNT_REQUEST: The source supports requesting additional accounts. * NO_AGGREGATION: A source that does not support aggregation. * GROUPS_HAVE_MEMBERS: The source models group memberships with a member attribute on the group object rather than a groups attribute on the account object. This effects the implementation of delta account aggregation. * NO_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for accounts. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for accounts. * NO_GROUP_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for groups. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for groups. * NO_UNSTRUCTURED_TARGETS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING. * NO_DIRECT_PERMISSIONS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING. * USES_UUID: Connectivity 2.0 flag used to indicate that the connector supports a compound naming structure. * PREFER_UUID: Used in ISC Provisioning AND Aggregation to decide if it should prefer account.uuid to account.nativeIdentity when data is read in through aggregation OR pushed out through provisioning. * ARM_SECURITY_EXTRACT: Indicates the application supports Security extracts for ARM * ARM_UTILIZATION_EXTRACT: Indicates the application supports Utilization extracts for ARM * ARM_CHANGELOG_EXTRACT: Indicates the application supports Change-log extracts for ARM
     * @type {Array<string>}
     * @memberof Schema
     */
    'features'?: Array<SchemaFeaturesV3>;
    /**
     * Holds any extra configuration data that the schema may require.
     * @type {object}
     * @memberof Schema
     */
    'configuration'?: object;
    /**
     * The attribute definitions which form the schema.
     * @type {Array<AttributeDefinition>}
     * @memberof Schema
     */
    'attributes'?: Array<AttributeDefinition>;
    /**
     * The date the Schema was created.
     * @type {string}
     * @memberof Schema
     */
    'created'?: string;
    /**
     * The date the Schema was last modified.
     * @type {string}
     * @memberof Schema
     */
    'modified'?: string;
}

export const SchemaFeaturesV3 = {
    Authenticate: 'AUTHENTICATE',
    Composite: 'COMPOSITE',
    DirectPermissions: 'DIRECT_PERMISSIONS',
    DiscoverSchema: 'DISCOVER_SCHEMA',
    Enable: 'ENABLE',
    ManagerLookup: 'MANAGER_LOOKUP',
    NoRandomAccess: 'NO_RANDOM_ACCESS',
    Proxy: 'PROXY',
    Search: 'SEARCH',
    Template: 'TEMPLATE',
    Unlock: 'UNLOCK',
    UnstructuredTargets: 'UNSTRUCTURED_TARGETS',
    SharepointTarget: 'SHAREPOINT_TARGET',
    Provisioning: 'PROVISIONING',
    GroupProvisioning: 'GROUP_PROVISIONING',
    SyncProvisioning: 'SYNC_PROVISIONING',
    Password: 'PASSWORD',
    CurrentPassword: 'CURRENT_PASSWORD',
    AccountOnlyRequest: 'ACCOUNT_ONLY_REQUEST',
    AdditionalAccountRequest: 'ADDITIONAL_ACCOUNT_REQUEST',
    NoAggregation: 'NO_AGGREGATION',
    GroupsHaveMembers: 'GROUPS_HAVE_MEMBERS',
    NoPermissionsProvisioning: 'NO_PERMISSIONS_PROVISIONING',
    NoGroupPermissionsProvisioning: 'NO_GROUP_PERMISSIONS_PROVISIONING',
    NoUnstructuredTargetsProvisioning: 'NO_UNSTRUCTURED_TARGETS_PROVISIONING',
    NoDirectPermissionsProvisioning: 'NO_DIRECT_PERMISSIONS_PROVISIONING',
    PreferUuid: 'PREFER_UUID',
    ArmSecurityExtract: 'ARM_SECURITY_EXTRACT',
    ArmUtilizationExtract: 'ARM_UTILIZATION_EXTRACT',
    ArmChangelogExtract: 'ARM_CHANGELOG_EXTRACT',
    UsesUuid: 'USES_UUID'
} as const;

export type SchemaFeaturesV3 = typeof SchemaFeaturesV3[keyof typeof SchemaFeaturesV3];

/**
 * 
 * @export
 * @interface Search
 */
export interface Search {
    /**
     * The names of the Elasticsearch indices in which to search. If none are provided, then all indices will be searched.
     * @type {Array<Index>}
     * @memberof Search
     */
    'indices'?: Array<Index>;
    /**
     * 
     * @type {QueryType}
     * @memberof Search
     */
    'queryType'?: QueryType;
    /**
     * 
     * @type {string}
     * @memberof Search
     */
    'queryVersion'?: string;
    /**
     * 
     * @type {Query}
     * @memberof Search
     */
    'query'?: Query;
    /**
     * The search query using the Elasticsearch [Query DSL](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl.html) syntax.
     * @type {object}
     * @memberof Search
     */
    'queryDsl'?: object;
    /**
     * 
     * @type {TextQuery}
     * @memberof Search
     */
    'textQuery'?: TextQuery;
    /**
     * 
     * @type {TypeAheadQuery}
     * @memberof Search
     */
    'typeAheadQuery'?: TypeAheadQuery;
    /**
     * Indicates whether nested objects from returned search results should be included.
     * @type {boolean}
     * @memberof Search
     */
    'includeNested'?: boolean;
    /**
     * 
     * @type {QueryResultFilter}
     * @memberof Search
     */
    'queryResultFilter'?: QueryResultFilter;
    /**
     * 
     * @type {AggregationType}
     * @memberof Search
     */
    'aggregationType'?: AggregationType;
    /**
     * 
     * @type {string}
     * @memberof Search
     */
    'aggregationsVersion'?: string;
    /**
     * The aggregation search query using Elasticsearch [Aggregations](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations.html) syntax.
     * @type {object}
     * @memberof Search
     */
    'aggregationsDsl'?: object;
    /**
     * 
     * @type {SearchAggregationSpecification}
     * @memberof Search
     */
    'aggregations'?: SearchAggregationSpecification;
    /**
     * The fields to be used to sort the search results. Use + or - to specify the sort direction.
     * @type {Array<string>}
     * @memberof Search
     */
    'sort'?: Array<string>;
    /**
     * Used to begin the search window at the values specified. This parameter consists of the last values of the sorted fields in the current record set. This is used to expand the Elasticsearch limit of 10K records by shifting the 10K window to begin at this value. It is recommended that you always include the ID of the object in addition to any other fields on this parameter in order to ensure you don\'t get duplicate results while paging. For example, when searching for identities, if you are sorting by displayName you will also want to include ID, for example [\"displayName\", \"id\"].  If the last identity ID in the search result is 2c91808375d8e80a0175e1f88a575221 and the last displayName is \"John Doe\", then using that displayName and ID will start a new search after this identity. The searchAfter value will look like [\"John Doe\",\"2c91808375d8e80a0175e1f88a575221\"]
     * @type {Array<string>}
     * @memberof Search
     */
    'searchAfter'?: Array<string>;
    /**
     * The filters to be applied for each filtered field name.
     * @type {{ [key: string]: Filter; }}
     * @memberof Search
     */
    'filters'?: { [key: string]: Filter; };
}


/**
 * 
 * @export
 * @interface SearchAggregationSpecification
 */
export interface SearchAggregationSpecification {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof SearchAggregationSpecification
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof SearchAggregationSpecification
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof SearchAggregationSpecification
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof SearchAggregationSpecification
     */
    'bucket'?: BucketAggregation;
    /**
     * 
     * @type {SubSearchAggregationSpecification}
     * @memberof SearchAggregationSpecification
     */
    'subAggregation'?: SubSearchAggregationSpecification;
}
/**
 * 
 * @export
 * @interface SearchArguments
 */
export interface SearchArguments {
    /**
     * The ID of the scheduled search that triggered the saved search execution. 
     * @type {string}
     * @memberof SearchArguments
     */
    'scheduleId'?: string;
    /**
     * The owner of the scheduled search being tested. 
     * @type {TypedReference}
     * @memberof SearchArguments
     */
    'owner'?: TypedReference;
    /**
     * The email recipients of the scheduled search being tested. 
     * @type {Array<TypedReference>}
     * @memberof SearchArguments
     */
    'recipients'?: Array<TypedReference>;
}
/**
 * 
 * @export
 * @interface SearchAttributeConfig
 */
export interface SearchAttributeConfig {
    /**
     * Name of the new attribute
     * @type {string}
     * @memberof SearchAttributeConfig
     */
    'name'?: string;
    /**
     * The display name of the new attribute
     * @type {string}
     * @memberof SearchAttributeConfig
     */
    'displayName'?: string;
    /**
     * Map of application id and their associated attribute.
     * @type {object}
     * @memberof SearchAttributeConfig
     */
    'applicationAttributes'?: object;
}
/**
 * @type SearchDocument
 * @export
 */
export type SearchDocument = AccessProfileDocument | AccountActivityDocument | EntitlementDocument | EventDocument | IdentityDocument | RoleDocument;

/**
 * @type SearchDocuments
 * @export
 */
export type SearchDocuments = AccessProfileDocuments | AccountActivityDocuments | EntitlementDocuments | EventDocuments | IdentityDocuments | RoleDocuments;

/**
 * Arguments for Search Export report (SEARCH_EXPORT)  The report file generated will be a zip file containing csv files of the search results. 
 * @export
 * @interface SearchExportReportArguments
 */
export interface SearchExportReportArguments {
    /**
     * The names of the Elasticsearch indices in which to search. If none are provided, then all indices will be searched.
     * @type {Array<Index>}
     * @memberof SearchExportReportArguments
     */
    'indices'?: Array<Index>;
    /**
     * The query using the Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL extended by SailPoint to support Nested queries.
     * @type {string}
     * @memberof SearchExportReportArguments
     */
    'query': string;
    /**
     * Comma separated string consisting of technical attribute names of fields to include in report.  Use `access.spread`, `apps.spread`, `accounts.spread` to include respective identity access details.  Use `accessProfiles.spread` to unclude access profile details.  Use `entitlements.spread` to include entitlement details. 
     * @type {string}
     * @memberof SearchExportReportArguments
     */
    'columns'?: string;
    /**
     * The fields to be used to sort the search results. Use + or - to specify the sort direction.
     * @type {Array<string>}
     * @memberof SearchExportReportArguments
     */
    'sort'?: Array<string>;
}
/**
 * Enum representing the currently supported filter aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const SearchFilterType = {
    Term: 'TERM'
} as const;

export type SearchFilterType = typeof SearchFilterType[keyof typeof SearchFilterType];


/**
 * 
 * @export
 * @interface SearchSchedule
 */
export interface SearchSchedule {
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof SearchSchedule
     */
    'savedSearchId': string;
    /**
     * The date the scheduled search was initially created.
     * @type {string}
     * @memberof SearchSchedule
     */
    'created'?: string | null;
    /**
     * The last date the scheduled search was modified.
     * @type {string}
     * @memberof SearchSchedule
     */
    'modified'?: string | null;
    /**
     * 
     * @type {Schedule1}
     * @memberof SearchSchedule
     */
    'schedule': Schedule1;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof SearchSchedule
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should occur when search returns no results. 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'displayQueryDetails'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchScheduleRecipientsInner
 */
export interface SearchScheduleRecipientsInner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SearchScheduleRecipientsInner
     */
    'type': SearchScheduleRecipientsInnerTypeV3;
    /**
     * The ID of the referenced object
     * @type {string}
     * @memberof SearchScheduleRecipientsInner
     */
    'id': string;
}

export const SearchScheduleRecipientsInnerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type SearchScheduleRecipientsInnerTypeV3 = typeof SearchScheduleRecipientsInnerTypeV3[keyof typeof SearchScheduleRecipientsInnerTypeV3];

/**
 * 
 * @export
 * @interface SectionDetails
 */
export interface SectionDetails {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof SectionDetails
     */
    'name'?: string;
    /**
     * Label of the section
     * @type {string}
     * @memberof SectionDetails
     */
    'label'?: string;
    /**
     * List of FormItems. FormItems can be SectionDetails and/or FieldDetails
     * @type {Array<object>}
     * @memberof SectionDetails
     */
    'formItems'?: Array<object>;
}
/**
 * 
 * @export
 * @interface Segment
 */
export interface Segment {
    /**
     * The segment\'s ID.
     * @type {string}
     * @memberof Segment
     */
    'id'?: string;
    /**
     * The segment\'s business name.
     * @type {string}
     * @memberof Segment
     */
    'name'?: string;
    /**
     * The time when the segment is created.
     * @type {string}
     * @memberof Segment
     */
    'created'?: string;
    /**
     * The time when the segment is modified.
     * @type {string}
     * @memberof Segment
     */
    'modified'?: string;
    /**
     * The segment\'s optional description.
     * @type {string}
     * @memberof Segment
     */
    'description'?: string;
    /**
     * 
     * @type {OwnerReferenceSegments}
     * @memberof Segment
     */
    'owner'?: OwnerReferenceSegments | null;
    /**
     * 
     * @type {SegmentVisibilityCriteria}
     * @memberof Segment
     */
    'visibilityCriteria'?: SegmentVisibilityCriteria;
    /**
     * This boolean indicates whether the segment is currently active. Inactive segments have no effect.
     * @type {boolean}
     * @memberof Segment
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface SegmentVisibilityCriteria
 */
export interface SegmentVisibilityCriteria {
    /**
     * 
     * @type {Expression}
     * @memberof SegmentVisibilityCriteria
     */
    'expression'?: Expression;
}
/**
 * 
 * @export
 * @interface Selector
 */
export interface Selector {
    /**
     * 
     * @type {SelectorType}
     * @memberof Selector
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Selector
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Selector
     */
    'interval'?: number | null;
}


/**
 * Enum representing the currently supported selector types.  LIST - the *values* array contains one or more distinct values.  RANGE - the *values* array contains two values: the start and end of the range, inclusive.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const SelectorType = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type SelectorType = typeof SelectorType[keyof typeof SelectorType];


/**
 * 
 * @export
 * @interface SendTokenRequest
 */
export interface SendTokenRequest {
    /**
     * User alias from table spt_identity field named \'name\'
     * @type {string}
     * @memberof SendTokenRequest
     */
    'userAlias': string;
    /**
     * Token delivery type
     * @type {string}
     * @memberof SendTokenRequest
     */
    'deliveryType': SendTokenRequestDeliveryTypeV3;
}

export const SendTokenRequestDeliveryTypeV3 = {
    SmsPersonal: 'SMS_PERSONAL',
    VoicePersonal: 'VOICE_PERSONAL',
    SmsWork: 'SMS_WORK',
    VoiceWork: 'VOICE_WORK',
    EmailWork: 'EMAIL_WORK',
    EmailPersonal: 'EMAIL_PERSONAL'
} as const;

export type SendTokenRequestDeliveryTypeV3 = typeof SendTokenRequestDeliveryTypeV3[keyof typeof SendTokenRequestDeliveryTypeV3];

/**
 * 
 * @export
 * @interface SendTokenResponse
 */
export interface SendTokenResponse {
    /**
     * The token request ID
     * @type {string}
     * @memberof SendTokenResponse
     */
    'requestId'?: string | null;
    /**
     * Status of sending token
     * @type {string}
     * @memberof SendTokenResponse
     */
    'status'?: SendTokenResponseStatusV3;
    /**
     * Error messages from token send request
     * @type {string}
     * @memberof SendTokenResponse
     */
    'errorMessage'?: string | null;
}

export const SendTokenResponseStatusV3 = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type SendTokenResponseStatusV3 = typeof SendTokenResponseStatusV3[keyof typeof SendTokenResponseStatusV3];

/**
 * 
 * @export
 * @interface ServiceDeskIntegrationDto
 */
export interface ServiceDeskIntegrationDto {
    /**
     * Unique identifier for the Service Desk integration
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'id'?: string;
    /**
     * Service Desk integration\'s name. The name must be unique.
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'name': string;
    /**
     * The date and time the Service Desk integration was created
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'created'?: string;
    /**
     * The date and time the Service Desk integration was last modified
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'modified'?: string;
    /**
     * Service Desk integration\'s description.
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'description': string;
    /**
     * Service Desk integration types:  - ServiceNowSDIM - ServiceNow 
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'type': string;
    /**
     * 
     * @type {OwnerDto}
     * @memberof ServiceDeskIntegrationDto
     */
    'ownerRef'?: OwnerDto;
    /**
     * 
     * @type {SourceClusterDto}
     * @memberof ServiceDeskIntegrationDto
     */
    'clusterRef'?: SourceClusterDto;
    /**
     * Cluster ID for the Service Desk integration (replaced by clusterRef, retained for backward compatibility).
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     * @deprecated
     */
    'cluster'?: string | null;
    /**
     * Source IDs for the Service Desk integration (replaced by provisioningConfig.managedSResourceRefs, but retained here for backward compatibility).
     * @type {Array<string>}
     * @memberof ServiceDeskIntegrationDto
     * @deprecated
     */
    'managedSources'?: Array<string>;
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationDto
     */
    'provisioningConfig'?: ProvisioningConfig;
    /**
     * Service Desk integration\'s attributes. Validation constraints enforced by the implementation.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationDto
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {BeforeProvisioningRuleDto}
     * @memberof ServiceDeskIntegrationDto
     */
    'beforeProvisioningRule'?: BeforeProvisioningRuleDto;
}
/**
 * 
 * @export
 * @interface ServiceDeskIntegrationTemplateDto
 */
export interface ServiceDeskIntegrationTemplateDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'name': string | null;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'modified'?: string;
    /**
     * The \'type\' property specifies the type of the Service Desk integration template.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'type': string;
    /**
     * The \'attributes\' property value is a map of attributes available for integrations using this Service Desk integration template.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'provisioningConfig': ProvisioningConfig;
}
/**
 * This represents a Service Desk Integration template type.
 * @export
 * @interface ServiceDeskIntegrationTemplateType
 */
export interface ServiceDeskIntegrationTemplateType {
    /**
     * This is the name of the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'name'?: string;
    /**
     * This is the type value for the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'type': string;
    /**
     * This is the scriptName attribute value for the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'scriptName': string;
}
/**
 * Source for Service Desk integration template.
 * @export
 * @interface ServiceDeskSource
 */
export interface ServiceDeskSource {
    /**
     * DTO type of source for service desk integration template.
     * @type {string}
     * @memberof ServiceDeskSource
     */
    'type'?: ServiceDeskSourceTypeV3;
    /**
     * ID of source for service desk integration template.
     * @type {string}
     * @memberof ServiceDeskSource
     */
    'id'?: string;
    /**
     * Human-readable name of source for service desk integration template.
     * @type {string}
     * @memberof ServiceDeskSource
     */
    'name'?: string;
}

export const ServiceDeskSourceTypeV3 = {
    Source: 'SOURCE'
} as const;

export type ServiceDeskSourceTypeV3 = typeof ServiceDeskSourceTypeV3[keyof typeof ServiceDeskSourceTypeV3];

/**
 * Represents the IdentityNow as Service Provider Configuration allowing customers to log into IDN via an Identity Provider
 * @export
 * @interface ServiceProviderConfiguration
 */
export interface ServiceProviderConfiguration {
    /**
     * This determines whether or not the SAML authentication flow is enabled for an org
     * @type {boolean}
     * @memberof ServiceProviderConfiguration
     */
    'enabled'?: boolean;
    /**
     * This allows basic login with the parameter prompt=true. This is often toggled on when debugging SAML authentication setup. When false, only org admins with MFA-enabled can bypass the IDP.
     * @type {boolean}
     * @memberof ServiceProviderConfiguration
     */
    'bypassIdp'?: boolean;
    /**
     * This indicates whether or not the SAML configuration is valid.
     * @type {boolean}
     * @memberof ServiceProviderConfiguration
     */
    'samlConfigurationValid'?: boolean;
    /**
     * A list of the abstract implementations of the Federation Protocol details. Typically, this will include on SpDetails object and one IdpDetails object used in tandem to define a SAML integration between a customer\'s identity provider and a customer\'s SailPoint instance (i.e., the service provider).
     * @type {Array<ServiceProviderConfigurationFederationProtocolDetailsInner>}
     * @memberof ServiceProviderConfiguration
     */
    'federationProtocolDetails'?: Array<ServiceProviderConfigurationFederationProtocolDetailsInner>;
}
/**
 * @type ServiceProviderConfigurationFederationProtocolDetailsInner
 * @export
 */
export type ServiceProviderConfigurationFederationProtocolDetailsInner = IdpDetails | SpDetails;

/**
 * 
 * @export
 * @interface SessionConfiguration
 */
export interface SessionConfiguration {
    /**
     * The maximum time in minutes a session can be idle.
     * @type {number}
     * @memberof SessionConfiguration
     */
    'maxIdleTime'?: number;
    /**
     * Denotes if \'remember me\' is enabled.
     * @type {boolean}
     * @memberof SessionConfiguration
     */
    'rememberMe'?: boolean;
    /**
     * The maximum allowable session time in minutes.
     * @type {number}
     * @memberof SessionConfiguration
     */
    'maxSessionTime'?: number;
}
/**
 * 
 * @export
 * @interface SetLifecycleState200Response
 */
export interface SetLifecycleState200Response {
    /**
     * ID of the IdentityRequest object that is generated when the workflow launches. To follow the IdentityRequest, you can provide this ID with a [Get Account Activity request](https://developer.sailpoint.com/docs/api/v3/get-account-activity/). The response will contain relevant information about the IdentityRequest, such as its status.
     * @type {string}
     * @memberof SetLifecycleState200Response
     */
    'accountActivityId'?: string;
}
/**
 * 
 * @export
 * @interface SetLifecycleStateRequest
 */
export interface SetLifecycleStateRequest {
    /**
     * ID of the lifecycle state to set.
     * @type {string}
     * @memberof SetLifecycleStateRequest
     */
    'lifecycleStateId'?: string;
}
/**
 * 
 * @export
 * @interface SlimCampaign
 */
export interface SlimCampaign {
    /**
     * Id of the campaign
     * @type {string}
     * @memberof SlimCampaign
     */
    'id'?: string;
    /**
     * The campaign name. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details. 
     * @type {string}
     * @memberof SlimCampaign
     */
    'name': string;
    /**
     * The campaign description. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details. 
     * @type {string}
     * @memberof SlimCampaign
     */
    'description': string | null;
    /**
     * The campaign\'s completion deadline.  This date must be in the future in order to activate the campaign.  If you try to activate a campaign with a deadline of today or in the past, you will receive a 400 error response.
     * @type {string}
     * @memberof SlimCampaign
     */
    'deadline'?: string;
    /**
     * The type of campaign. Could be extended in the future.
     * @type {string}
     * @memberof SlimCampaign
     */
    'type': SlimCampaignTypeV3;
    /**
     * Enables email notification for this campaign
     * @type {boolean}
     * @memberof SlimCampaign
     */
    'emailNotificationEnabled'?: boolean;
    /**
     * Allows auto revoke for this campaign
     * @type {boolean}
     * @memberof SlimCampaign
     */
    'autoRevokeAllowed'?: boolean;
    /**
     * Enables IAI for this campaign. Accepts true even if the IAI product feature is off. If IAI is turned off then campaigns generated from this template will indicate false. The real value will then be returned if IAI is ever enabled for the org in the future.
     * @type {boolean}
     * @memberof SlimCampaign
     */
    'recommendationsEnabled'?: boolean;
    /**
     * The campaign\'s current status.
     * @type {string}
     * @memberof SlimCampaign
     */
    'status'?: SlimCampaignStatusV3;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {string}
     * @memberof SlimCampaign
     */
    'correlatedStatus'?: SlimCampaignCorrelatedStatusV3;
    /**
     * Created time of the campaign
     * @type {string}
     * @memberof SlimCampaign
     */
    'created'?: string;
    /**
     * The total number of certifications in this campaign.
     * @type {number}
     * @memberof SlimCampaign
     */
    'totalCertifications'?: number;
    /**
     * The number of completed certifications in this campaign.
     * @type {number}
     * @memberof SlimCampaign
     */
    'completedCertifications'?: number;
    /**
     * A list of errors and warnings that have accumulated.
     * @type {Array<CampaignAlert>}
     * @memberof SlimCampaign
     */
    'alerts'?: Array<CampaignAlert>;
}

export const SlimCampaignTypeV3 = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION',
    MachineAccount: 'MACHINE_ACCOUNT'
} as const;

export type SlimCampaignTypeV3 = typeof SlimCampaignTypeV3[keyof typeof SlimCampaignTypeV3];
export const SlimCampaignStatusV3 = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
} as const;

export type SlimCampaignStatusV3 = typeof SlimCampaignStatusV3[keyof typeof SlimCampaignStatusV3];
export const SlimCampaignCorrelatedStatusV3 = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type SlimCampaignCorrelatedStatusV3 = typeof SlimCampaignCorrelatedStatusV3[keyof typeof SlimCampaignCorrelatedStatusV3];

/**
 * Discovered applications
 * @export
 * @interface SlimDiscoveredApplications
 */
export interface SlimDiscoveredApplications {
    /**
     * Unique identifier for the discovered application.
     * @type {string}
     * @memberof SlimDiscoveredApplications
     */
    'id'?: string;
    /**
     * Name of the discovered application.
     * @type {string}
     * @memberof SlimDiscoveredApplications
     */
    'name'?: string;
    /**
     * Source from which the application was discovered.
     * @type {string}
     * @memberof SlimDiscoveredApplications
     */
    'discoverySource'?: string;
    /**
     * The vendor associated with the discovered application.
     * @type {string}
     * @memberof SlimDiscoveredApplications
     */
    'discoveredVendor'?: string;
    /**
     * A brief description of the discovered application.
     * @type {string}
     * @memberof SlimDiscoveredApplications
     */
    'description'?: string;
    /**
     * List of recommended connectors for the application.
     * @type {Array<string>}
     * @memberof SlimDiscoveredApplications
     */
    'recommendedConnectors'?: Array<string>;
    /**
     * The timestamp when the application was last received via an entitlement aggregation invocation  or a manual csv upload, in ISO 8601 format.
     * @type {string}
     * @memberof SlimDiscoveredApplications
     */
    'discoveredAt'?: string;
    /**
     * The timestamp when the application was first discovered, in ISO 8601 format.
     * @type {string}
     * @memberof SlimDiscoveredApplications
     */
    'createdAt'?: string;
    /**
     * The status of an application within the discovery source.  By default this field is set to \"ACTIVE\" when the application is discovered.  If an application has been deleted from within the discovery source, the status will be set to \"INACTIVE\".
     * @type {string}
     * @memberof SlimDiscoveredApplications
     */
    'status'?: string;
}
/**
 * Details of the Entitlement criteria
 * @export
 * @interface SodExemptCriteria
 */
export interface SodExemptCriteria {
    /**
     * If the entitlement already belonged to the user or not.
     * @type {boolean}
     * @memberof SodExemptCriteria
     */
    'existing'?: boolean;
    /**
     * 
     * @type {DtoType}
     * @memberof SodExemptCriteria
     */
    'type'?: DtoType;
    /**
     * Entitlement ID
     * @type {string}
     * @memberof SodExemptCriteria
     */
    'id'?: string;
    /**
     * Entitlement name
     * @type {string}
     * @memberof SodExemptCriteria
     */
    'name'?: string;
}


/**
 * 
 * @export
 * @interface SodPolicy
 */
export interface SodPolicy {
    /**
     * Policy id
     * @type {string}
     * @memberof SodPolicy
     */
    'id'?: string;
    /**
     * Policy Business Name
     * @type {string}
     * @memberof SodPolicy
     */
    'name'?: string;
    /**
     * The time when this SOD policy is created.
     * @type {string}
     * @memberof SodPolicy
     */
    'created'?: string;
    /**
     * The time when this SOD policy is modified.
     * @type {string}
     * @memberof SodPolicy
     */
    'modified'?: string;
    /**
     * Optional description of the SOD policy
     * @type {string}
     * @memberof SodPolicy
     */
    'description'?: string | null;
    /**
     * 
     * @type {SodPolicyOwnerRef}
     * @memberof SodPolicy
     */
    'ownerRef'?: SodPolicyOwnerRef;
    /**
     * Optional External Policy Reference
     * @type {string}
     * @memberof SodPolicy
     */
    'externalPolicyReference'?: string | null;
    /**
     * Search query of the SOD policy
     * @type {string}
     * @memberof SodPolicy
     */
    'policyQuery'?: string;
    /**
     * Optional compensating controls(Mitigating Controls)
     * @type {string}
     * @memberof SodPolicy
     */
    'compensatingControls'?: string | null;
    /**
     * Optional correction advice
     * @type {string}
     * @memberof SodPolicy
     */
    'correctionAdvice'?: string | null;
    /**
     * whether the policy is enforced or not
     * @type {string}
     * @memberof SodPolicy
     */
    'state'?: SodPolicyStateV3;
    /**
     * tags for this policy object
     * @type {Array<string>}
     * @memberof SodPolicy
     */
    'tags'?: Array<string>;
    /**
     * Policy\'s creator ID
     * @type {string}
     * @memberof SodPolicy
     */
    'creatorId'?: string;
    /**
     * Policy\'s modifier ID
     * @type {string}
     * @memberof SodPolicy
     */
    'modifierId'?: string | null;
    /**
     * 
     * @type {ViolationOwnerAssignmentConfig}
     * @memberof SodPolicy
     */
    'violationOwnerAssignmentConfig'?: ViolationOwnerAssignmentConfig;
    /**
     * defines whether a policy has been scheduled or not
     * @type {boolean}
     * @memberof SodPolicy
     */
    'scheduled'?: boolean;
    /**
     * whether a policy is query based or conflicting access based
     * @type {string}
     * @memberof SodPolicy
     */
    'type'?: SodPolicyTypeV3;
    /**
     * 
     * @type {SodPolicyConflictingAccessCriteria}
     * @memberof SodPolicy
     */
    'conflictingAccessCriteria'?: SodPolicyConflictingAccessCriteria;
}

export const SodPolicyStateV3 = {
    Enforced: 'ENFORCED',
    NotEnforced: 'NOT_ENFORCED'
} as const;

export type SodPolicyStateV3 = typeof SodPolicyStateV3[keyof typeof SodPolicyStateV3];
export const SodPolicyTypeV3 = {
    General: 'GENERAL',
    ConflictingAccessBased: 'CONFLICTING_ACCESS_BASED'
} as const;

export type SodPolicyTypeV3 = typeof SodPolicyTypeV3[keyof typeof SodPolicyTypeV3];

/**
 * 
 * @export
 * @interface SodPolicyConflictingAccessCriteria
 */
export interface SodPolicyConflictingAccessCriteria {
    /**
     * 
     * @type {AccessCriteria}
     * @memberof SodPolicyConflictingAccessCriteria
     */
    'leftCriteria'?: AccessCriteria;
    /**
     * 
     * @type {AccessCriteria}
     * @memberof SodPolicyConflictingAccessCriteria
     */
    'rightCriteria'?: AccessCriteria;
}
/**
 * SOD policy.
 * @export
 * @interface SodPolicyDto
 */
export interface SodPolicyDto {
    /**
     * SOD policy DTO type.
     * @type {string}
     * @memberof SodPolicyDto
     */
    'type'?: SodPolicyDtoTypeV3;
    /**
     * SOD policy ID.
     * @type {string}
     * @memberof SodPolicyDto
     */
    'id'?: string;
    /**
     * SOD policy display name.
     * @type {string}
     * @memberof SodPolicyDto
     */
    'name'?: string;
}

export const SodPolicyDtoTypeV3 = {
    SodPolicy: 'SOD_POLICY'
} as const;

export type SodPolicyDtoTypeV3 = typeof SodPolicyDtoTypeV3[keyof typeof SodPolicyDtoTypeV3];

/**
 * The owner of the SOD policy.
 * @export
 * @interface SodPolicyOwnerRef
 */
export interface SodPolicyOwnerRef {
    /**
     * Owner type.
     * @type {string}
     * @memberof SodPolicyOwnerRef
     */
    'type'?: SodPolicyOwnerRefTypeV3;
    /**
     * Owner\'s ID.
     * @type {string}
     * @memberof SodPolicyOwnerRef
     */
    'id'?: string;
    /**
     * Owner\'s name.
     * @type {string}
     * @memberof SodPolicyOwnerRef
     */
    'name'?: string;
}

export const SodPolicyOwnerRefTypeV3 = {
    Identity: 'IDENTITY',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type SodPolicyOwnerRefTypeV3 = typeof SodPolicyOwnerRefTypeV3[keyof typeof SodPolicyOwnerRefTypeV3];

/**
 * 
 * @export
 * @interface SodPolicySchedule
 */
export interface SodPolicySchedule {
    /**
     * SOD Policy schedule name
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'name'?: string;
    /**
     * The time when this SOD policy schedule is created.
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'created'?: string;
    /**
     * The time when this SOD policy schedule is modified.
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'modified'?: string;
    /**
     * SOD Policy schedule description
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'description'?: string;
    /**
     * 
     * @type {Schedule1}
     * @memberof SodPolicySchedule
     */
    'schedule'?: Schedule1;
    /**
     * 
     * @type {Array<SodRecipient>}
     * @memberof SodPolicySchedule
     */
    'recipients'?: Array<SodRecipient>;
    /**
     * Indicates if empty results need to be emailed
     * @type {boolean}
     * @memberof SodPolicySchedule
     */
    'emailEmptyResults'?: boolean;
    /**
     * Policy\'s creator ID
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'creatorId'?: string;
    /**
     * Policy\'s modifier ID
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'modifierId'?: string;
}
/**
 * SOD policy recipient.
 * @export
 * @interface SodRecipient
 */
export interface SodRecipient {
    /**
     * SOD policy recipient DTO type.
     * @type {string}
     * @memberof SodRecipient
     */
    'type'?: SodRecipientTypeV3;
    /**
     * SOD policy recipient\'s identity ID.
     * @type {string}
     * @memberof SodRecipient
     */
    'id'?: string;
    /**
     * SOD policy recipient\'s display name.
     * @type {string}
     * @memberof SodRecipient
     */
    'name'?: string;
}

export const SodRecipientTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type SodRecipientTypeV3 = typeof SodRecipientTypeV3[keyof typeof SodRecipientTypeV3];

/**
 * SOD policy violation report result.
 * @export
 * @interface SodReportResultDto
 */
export interface SodReportResultDto {
    /**
     * SOD policy violation report result DTO type.
     * @type {string}
     * @memberof SodReportResultDto
     */
    'type'?: SodReportResultDtoTypeV3;
    /**
     * SOD policy violation report result ID.
     * @type {string}
     * @memberof SodReportResultDto
     */
    'id'?: string;
    /**
     * Human-readable name of the SOD policy violation report result.
     * @type {string}
     * @memberof SodReportResultDto
     */
    'name'?: string;
}

export const SodReportResultDtoTypeV3 = {
    ReportResult: 'REPORT_RESULT'
} as const;

export type SodReportResultDtoTypeV3 = typeof SodReportResultDtoTypeV3[keyof typeof SodReportResultDtoTypeV3];

/**
 * An object referencing an SOD violation check
 * @export
 * @interface SodViolationCheck
 */
export interface SodViolationCheck {
    /**
     * The id of the original request
     * @type {string}
     * @memberof SodViolationCheck
     */
    'requestId': string;
    /**
     * The date-time when this request was created.
     * @type {string}
     * @memberof SodViolationCheck
     */
    'created'?: string;
}
/**
 * The inner object representing the completed SOD Violation check
 * @export
 * @interface SodViolationCheckResult
 */
export interface SodViolationCheckResult {
    /**
     * 
     * @type {ErrorMessageDto}
     * @memberof SodViolationCheckResult
     */
    'message'?: ErrorMessageDto;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on completion of the violation check.
     * @type {{ [key: string]: string; }}
     * @memberof SodViolationCheckResult
     */
    'clientMetadata'?: { [key: string]: string; } | null;
    /**
     * 
     * @type {Array<SodViolationContext>}
     * @memberof SodViolationCheckResult
     */
    'violationContexts'?: Array<SodViolationContext> | null;
    /**
     * A list of the SOD policies that were violated.
     * @type {Array<SodPolicyDto>}
     * @memberof SodViolationCheckResult
     */
    'violatedPolicies'?: Array<SodPolicyDto> | null;
}
/**
 * The contextual information of the violated criteria
 * @export
 * @interface SodViolationContext
 */
export interface SodViolationContext {
    /**
     * 
     * @type {SodPolicyDto}
     * @memberof SodViolationContext
     */
    'policy'?: SodPolicyDto;
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteria}
     * @memberof SodViolationContext
     */
    'conflictingAccessCriteria'?: SodViolationContextConflictingAccessCriteria;
}
/**
 * An object referencing a completed SOD violation check
 * @export
 * @interface SodViolationContextCheckCompleted
 */
export interface SodViolationContextCheckCompleted {
    /**
     * The status of SOD violation check
     * @type {string}
     * @memberof SodViolationContextCheckCompleted
     */
    'state'?: SodViolationContextCheckCompletedStateV3 | null;
    /**
     * The id of the Violation check event
     * @type {string}
     * @memberof SodViolationContextCheckCompleted
     */
    'uuid'?: string | null;
    /**
     * 
     * @type {SodViolationCheckResult}
     * @memberof SodViolationContextCheckCompleted
     */
    'violationCheckResult'?: SodViolationCheckResult;
}

export const SodViolationContextCheckCompletedStateV3 = {
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type SodViolationContextCheckCompletedStateV3 = typeof SodViolationContextCheckCompletedStateV3[keyof typeof SodViolationContextCheckCompletedStateV3];

/**
 * The object which contains the left and right hand side of the entitlements that got violated according to the policy.
 * @export
 * @interface SodViolationContextConflictingAccessCriteria
 */
export interface SodViolationContextConflictingAccessCriteria {
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteriaLeftCriteria}
     * @memberof SodViolationContextConflictingAccessCriteria
     */
    'leftCriteria'?: SodViolationContextConflictingAccessCriteriaLeftCriteria;
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteriaLeftCriteria}
     * @memberof SodViolationContextConflictingAccessCriteria
     */
    'rightCriteria'?: SodViolationContextConflictingAccessCriteriaLeftCriteria;
}
/**
 * 
 * @export
 * @interface SodViolationContextConflictingAccessCriteriaLeftCriteria
 */
export interface SodViolationContextConflictingAccessCriteriaLeftCriteria {
    /**
     * 
     * @type {Array<SodExemptCriteria>}
     * @memberof SodViolationContextConflictingAccessCriteriaLeftCriteria
     */
    'criteriaList'?: Array<SodExemptCriteria>;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * Source ID.
     * @type {string}
     * @memberof Source
     */
    'id'?: string;
    /**
     * Source\'s human-readable name.
     * @type {string}
     * @memberof Source
     */
    'name': string;
    /**
     * Source\'s human-readable description.
     * @type {string}
     * @memberof Source
     */
    'description'?: string;
    /**
     * 
     * @type {SourceOwner}
     * @memberof Source
     */
    'owner': SourceOwner;
    /**
     * 
     * @type {SourceCluster}
     * @memberof Source
     */
    'cluster'?: SourceCluster | null;
    /**
     * 
     * @type {SourceAccountCorrelationConfig}
     * @memberof Source
     */
    'accountCorrelationConfig'?: SourceAccountCorrelationConfig | null;
    /**
     * 
     * @type {SourceAccountCorrelationRule}
     * @memberof Source
     */
    'accountCorrelationRule'?: SourceAccountCorrelationRule | null;
    /**
     * 
     * @type {SourceManagerCorrelationMapping}
     * @memberof Source
     */
    'managerCorrelationMapping'?: SourceManagerCorrelationMapping;
    /**
     * 
     * @type {SourceManagerCorrelationRule}
     * @memberof Source
     */
    'managerCorrelationRule'?: SourceManagerCorrelationRule | null;
    /**
     * 
     * @type {SourceBeforeProvisioningRule}
     * @memberof Source
     */
    'beforeProvisioningRule'?: SourceBeforeProvisioningRule | null;
    /**
     * List of references to schema objects.
     * @type {Array<SourceSchemasInner>}
     * @memberof Source
     */
    'schemas'?: Array<SourceSchemasInner>;
    /**
     * List of references to the associated PasswordPolicy objects.
     * @type {Array<SourcePasswordPoliciesInner>}
     * @memberof Source
     */
    'passwordPolicies'?: Array<SourcePasswordPoliciesInner> | null;
    /**
     * Optional features that can be supported by a source. Modifying the features array may cause source configuration errors that are unsupportable. It is recommended to not modify this array for SailPoint supported connectors. * AUTHENTICATE: The source supports pass-through authentication. * COMPOSITE: The source supports composite source creation. * DIRECT_PERMISSIONS: The source supports returning DirectPermissions. * DISCOVER_SCHEMA: The source supports discovering schemas for users and groups. * ENABLE The source supports reading if an account is enabled or disabled. * MANAGER_LOOKUP: The source supports looking up managers as they are encountered in a feed. This is the opposite of NO_RANDOM_ACCESS. * NO_RANDOM_ACCESS: The source does not support random access and the getObject() methods should not be called and expected to perform. * PROXY: The source can serve as a proxy for another source. When an source has a proxy, all connector calls made with that source are redirected through the connector for the proxy source. * SEARCH * TEMPLATE * UNLOCK: The source supports reading if an account is locked or unlocked. * UNSTRUCTURED_TARGETS: The source supports returning unstructured Targets. * SHAREPOINT_TARGET: The source supports returning unstructured Target data for SharePoint. It will be typically used by AD, LDAP sources. * PROVISIONING: The source can both read and write accounts. Having this feature implies that the provision() method is implemented. It also means that direct and target permissions can also be provisioned if they can be returned by aggregation. * GROUP_PROVISIONING: The source can both read and write groups. Having this feature implies that the provision() method is implemented. * SYNC_PROVISIONING: The source can provision accounts synchronously. * PASSWORD: The source can provision password changes. Since sources can never read passwords, this is should only be used in conjunction with the PROVISIONING feature. * CURRENT_PASSWORD: Some source types support verification of the current password * ACCOUNT_ONLY_REQUEST: The source supports requesting accounts without entitlements. * ADDITIONAL_ACCOUNT_REQUEST: The source supports requesting additional accounts. * NO_AGGREGATION: A source that does not support aggregation. * GROUPS_HAVE_MEMBERS: The source models group memberships with a member attribute on the group object rather than a groups attribute on the account object. This effects the implementation of delta account aggregation. * NO_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for accounts. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for accounts. * NO_GROUP_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for groups. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for groups. * NO_UNSTRUCTURED_TARGETS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING. * NO_DIRECT_PERMISSIONS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING. * USES_UUID: Connectivity 2.0 flag used to indicate that the connector supports a compound naming structure. * PREFER_UUID: Used in ISC Provisioning AND Aggregation to decide if it should prefer account.uuid to account.nativeIdentity when data is read in through aggregation OR pushed out through provisioning. * ARM_SECURITY_EXTRACT: Indicates the application supports Security extracts for ARM * ARM_UTILIZATION_EXTRACT: Indicates the application supports Utilization extracts for ARM * ARM_CHANGELOG_EXTRACT: Indicates the application supports Change-log extracts for ARM
     * @type {Array<string>}
     * @memberof Source
     */
    'features'?: Array<SourceFeaturesV3>;
    /**
     * Specifies the type of system being managed e.g. Active Directory, Workday, etc.. If you are creating a delimited file source, you must set the `provisionasCsv` query parameter to `true`. 
     * @type {string}
     * @memberof Source
     */
    'type'?: string;
    /**
     * Connector script name.
     * @type {string}
     * @memberof Source
     */
    'connector': string;
    /**
     * Fully qualified name of the Java class that implements the connector interface.
     * @type {string}
     * @memberof Source
     */
    'connectorClass'?: string;
    /**
     * Connector specific configuration. This configuration will differ from type to type.
     * @type {object}
     * @memberof Source
     */
    'connectorAttributes'?: object;
    /**
     * Number from 0 to 100 that specifies when to skip the delete phase.
     * @type {number}
     * @memberof Source
     */
    'deleteThreshold'?: number;
    /**
     * When this is true, it indicates that the source is referenced by an identity profile.
     * @type {boolean}
     * @memberof Source
     */
    'authoritative'?: boolean;
    /**
     * 
     * @type {SourceManagementWorkgroup}
     * @memberof Source
     */
    'managementWorkgroup'?: SourceManagementWorkgroup | null;
    /**
     * When this is true, it indicates that the source is healthy.
     * @type {boolean}
     * @memberof Source
     */
    'healthy'?: boolean;
    /**
     * Status identifier that gives specific information about why a source is or isn\'t healthy. 
     * @type {string}
     * @memberof Source
     */
    'status'?: SourceStatusV3;
    /**
     * Timestamp that shows when a source health check was last performed.
     * @type {string}
     * @memberof Source
     */
    'since'?: string;
    /**
     * Connector ID
     * @type {string}
     * @memberof Source
     */
    'connectorId'?: string;
    /**
     * Name of the connector that was chosen during source creation.
     * @type {string}
     * @memberof Source
     */
    'connectorName'?: string;
    /**
     * Type of connection (direct or file).
     * @type {string}
     * @memberof Source
     */
    'connectionType'?: string;
    /**
     * Connector implementation ID.
     * @type {string}
     * @memberof Source
     */
    'connectorImplementationId'?: string;
    /**
     * Date-time when the source was created
     * @type {string}
     * @memberof Source
     */
    'created'?: string;
    /**
     * Date-time when the source was last modified.
     * @type {string}
     * @memberof Source
     */
    'modified'?: string;
    /**
     * If this is true, it enables a credential provider for the source. If credentialProvider is turned on,  then the source can use credential provider(s) to fetch credentials.
     * @type {boolean}
     * @memberof Source
     */
    'credentialProviderEnabled'?: boolean;
    /**
     * Source category (e.g. null, CredentialProvider).
     * @type {string}
     * @memberof Source
     */
    'category'?: string | null;
}

export const SourceFeaturesV3 = {
    Authenticate: 'AUTHENTICATE',
    Composite: 'COMPOSITE',
    DirectPermissions: 'DIRECT_PERMISSIONS',
    DiscoverSchema: 'DISCOVER_SCHEMA',
    Enable: 'ENABLE',
    ManagerLookup: 'MANAGER_LOOKUP',
    NoRandomAccess: 'NO_RANDOM_ACCESS',
    Proxy: 'PROXY',
    Search: 'SEARCH',
    Template: 'TEMPLATE',
    Unlock: 'UNLOCK',
    UnstructuredTargets: 'UNSTRUCTURED_TARGETS',
    SharepointTarget: 'SHAREPOINT_TARGET',
    Provisioning: 'PROVISIONING',
    GroupProvisioning: 'GROUP_PROVISIONING',
    SyncProvisioning: 'SYNC_PROVISIONING',
    Password: 'PASSWORD',
    CurrentPassword: 'CURRENT_PASSWORD',
    AccountOnlyRequest: 'ACCOUNT_ONLY_REQUEST',
    AdditionalAccountRequest: 'ADDITIONAL_ACCOUNT_REQUEST',
    NoAggregation: 'NO_AGGREGATION',
    GroupsHaveMembers: 'GROUPS_HAVE_MEMBERS',
    NoPermissionsProvisioning: 'NO_PERMISSIONS_PROVISIONING',
    NoGroupPermissionsProvisioning: 'NO_GROUP_PERMISSIONS_PROVISIONING',
    NoUnstructuredTargetsProvisioning: 'NO_UNSTRUCTURED_TARGETS_PROVISIONING',
    NoDirectPermissionsProvisioning: 'NO_DIRECT_PERMISSIONS_PROVISIONING',
    PreferUuid: 'PREFER_UUID',
    ArmSecurityExtract: 'ARM_SECURITY_EXTRACT',
    ArmUtilizationExtract: 'ARM_UTILIZATION_EXTRACT',
    ArmChangelogExtract: 'ARM_CHANGELOG_EXTRACT',
    UsesUuid: 'USES_UUID'
} as const;

export type SourceFeaturesV3 = typeof SourceFeaturesV3[keyof typeof SourceFeaturesV3];
export const SourceStatusV3 = {
    SourceStateErrorAccountFileImport: 'SOURCE_STATE_ERROR_ACCOUNT_FILE_IMPORT',
    SourceStateErrorCluster: 'SOURCE_STATE_ERROR_CLUSTER',
    SourceStateErrorSource: 'SOURCE_STATE_ERROR_SOURCE',
    SourceStateErrorVa: 'SOURCE_STATE_ERROR_VA',
    SourceStateFailureCluster: 'SOURCE_STATE_FAILURE_CLUSTER',
    SourceStateFailureSource: 'SOURCE_STATE_FAILURE_SOURCE',
    SourceStateHealthy: 'SOURCE_STATE_HEALTHY',
    SourceStateUncheckedCluster: 'SOURCE_STATE_UNCHECKED_CLUSTER',
    SourceStateUncheckedClusterNoSources: 'SOURCE_STATE_UNCHECKED_CLUSTER_NO_SOURCES',
    SourceStateUncheckedSource: 'SOURCE_STATE_UNCHECKED_SOURCE',
    SourceStateUncheckedSourceNoAccounts: 'SOURCE_STATE_UNCHECKED_SOURCE_NO_ACCOUNTS'
} as const;

export type SourceStatusV3 = typeof SourceStatusV3[keyof typeof SourceStatusV3];

/**
 * Reference to account correlation config object.
 * @export
 * @interface SourceAccountCorrelationConfig
 */
export interface SourceAccountCorrelationConfig {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'type'?: SourceAccountCorrelationConfigTypeV3;
    /**
     * Account correlation config ID.
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'id'?: string;
    /**
     * Account correlation config\'s human-readable display name.
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'name'?: string;
}

export const SourceAccountCorrelationConfigTypeV3 = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG'
} as const;

export type SourceAccountCorrelationConfigTypeV3 = typeof SourceAccountCorrelationConfigTypeV3[keyof typeof SourceAccountCorrelationConfigTypeV3];

/**
 * Reference to a rule that can do COMPLEX correlation. Only use this rule when you can\'t use accountCorrelationConfig.
 * @export
 * @interface SourceAccountCorrelationRule
 */
export interface SourceAccountCorrelationRule {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'type'?: SourceAccountCorrelationRuleTypeV3;
    /**
     * Rule ID.
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'id'?: string;
    /**
     * Rule\'s human-readable display name.
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'name'?: string;
}

export const SourceAccountCorrelationRuleTypeV3 = {
    Rule: 'RULE'
} as const;

export type SourceAccountCorrelationRuleTypeV3 = typeof SourceAccountCorrelationRuleTypeV3[keyof typeof SourceAccountCorrelationRuleTypeV3];

/**
 * Rule that runs on the CCG and allows for customization of provisioning plans before the API calls the connector. 
 * @export
 * @interface SourceBeforeProvisioningRule
 */
export interface SourceBeforeProvisioningRule {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'type'?: SourceBeforeProvisioningRuleTypeV3;
    /**
     * Rule ID.
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'id'?: string;
    /**
     * Rule\'s human-readable display name.
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'name'?: string;
}

export const SourceBeforeProvisioningRuleTypeV3 = {
    Rule: 'RULE'
} as const;

export type SourceBeforeProvisioningRuleTypeV3 = typeof SourceBeforeProvisioningRuleTypeV3[keyof typeof SourceBeforeProvisioningRuleTypeV3];

/**
 * Reference to the source\'s associated cluster.
 * @export
 * @interface SourceCluster
 */
export interface SourceCluster {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceCluster
     */
    'type': SourceClusterTypeV3;
    /**
     * Cluster ID.
     * @type {string}
     * @memberof SourceCluster
     */
    'id': string;
    /**
     * Cluster\'s human-readable display name.
     * @type {string}
     * @memberof SourceCluster
     */
    'name': string;
}

export const SourceClusterTypeV3 = {
    Cluster: 'CLUSTER'
} as const;

export type SourceClusterTypeV3 = typeof SourceClusterTypeV3[keyof typeof SourceClusterTypeV3];

/**
 * Source cluster.
 * @export
 * @interface SourceClusterDto
 */
export interface SourceClusterDto {
    /**
     * Source cluster DTO type.
     * @type {string}
     * @memberof SourceClusterDto
     */
    'type'?: SourceClusterDtoTypeV3;
    /**
     * Source cluster ID.
     * @type {string}
     * @memberof SourceClusterDto
     */
    'id'?: string;
    /**
     * Source cluster display name.
     * @type {string}
     * @memberof SourceClusterDto
     */
    'name'?: string;
}

export const SourceClusterDtoTypeV3 = {
    Cluster: 'CLUSTER'
} as const;

export type SourceClusterDtoTypeV3 = typeof SourceClusterDtoTypeV3[keyof typeof SourceClusterDtoTypeV3];

/**
 * 
 * @export
 * @interface SourceConnectionsDto
 */
export interface SourceConnectionsDto {
    /**
     * The IdentityProfile attached to this source
     * @type {Array<IdentityProfilesConnections>}
     * @memberof SourceConnectionsDto
     */
    'identityProfiles'?: Array<IdentityProfilesConnections>;
    /**
     * Name of the CredentialProfile attached to this source
     * @type {Array<string>}
     * @memberof SourceConnectionsDto
     */
    'credentialProfiles'?: Array<string>;
    /**
     * The attributes attached to this source
     * @type {Array<string>}
     * @memberof SourceConnectionsDto
     */
    'sourceAttributes'?: Array<string>;
    /**
     * The profiles attached to this source
     * @type {Array<string>}
     * @memberof SourceConnectionsDto
     */
    'mappingProfiles'?: Array<string>;
    /**
     * A list of custom transforms associated with this source. A transform will be considered associated with a source if any attributes of the transform specify the source as the sourceName.
     * @type {Array<TransformRead>}
     * @memberof SourceConnectionsDto
     */
    'dependentCustomTransforms'?: Array<TransformRead>;
    /**
     * 
     * @type {Array<DependantAppConnections>}
     * @memberof SourceConnectionsDto
     */
    'dependentApps'?: Array<DependantAppConnections>;
    /**
     * 
     * @type {Array<DependantConnectionsMissingDto>}
     * @memberof SourceConnectionsDto
     */
    'missingDependents'?: Array<DependantConnectionsMissingDto>;
}
/**
 * Dto for source health data
 * @export
 * @interface SourceHealthDto
 */
export interface SourceHealthDto {
    /**
     * the id of the Source
     * @type {string}
     * @memberof SourceHealthDto
     */
    'id'?: string;
    /**
     * Specifies the type of system being managed e.g. Active Directory, Workday, etc.. If you are creating a Delimited File source, you must set the `provisionasCsv` query parameter to `true`. 
     * @type {string}
     * @memberof SourceHealthDto
     */
    'type'?: string;
    /**
     * the name of the source
     * @type {string}
     * @memberof SourceHealthDto
     */
    'name'?: string;
    /**
     * source\'s org
     * @type {string}
     * @memberof SourceHealthDto
     */
    'org'?: string;
    /**
     * Is the source authoritative
     * @type {boolean}
     * @memberof SourceHealthDto
     */
    'isAuthoritative'?: boolean;
    /**
     * Is the source in a cluster
     * @type {boolean}
     * @memberof SourceHealthDto
     */
    'isCluster'?: boolean;
    /**
     * source\'s hostname
     * @type {string}
     * @memberof SourceHealthDto
     */
    'hostname'?: string;
    /**
     * source\'s pod
     * @type {string}
     * @memberof SourceHealthDto
     */
    'pod'?: string;
    /**
     * The version of the iqService
     * @type {string}
     * @memberof SourceHealthDto
     */
    'iqServiceVersion'?: string;
    /**
     * connection test result
     * @type {string}
     * @memberof SourceHealthDto
     */
    'status'?: SourceHealthDtoStatusV3;
}

export const SourceHealthDtoStatusV3 = {
    SourceStateErrorCluster: 'SOURCE_STATE_ERROR_CLUSTER',
    SourceStateErrorSource: 'SOURCE_STATE_ERROR_SOURCE',
    SourceStateErrorVa: 'SOURCE_STATE_ERROR_VA',
    SourceStateFailureCluster: 'SOURCE_STATE_FAILURE_CLUSTER',
    SourceStateFailureSource: 'SOURCE_STATE_FAILURE_SOURCE',
    SourceStateHealthy: 'SOURCE_STATE_HEALTHY',
    SourceStateUncheckedCluster: 'SOURCE_STATE_UNCHECKED_CLUSTER',
    SourceStateUncheckedClusterNoSources: 'SOURCE_STATE_UNCHECKED_CLUSTER_NO_SOURCES',
    SourceStateUncheckedSource: 'SOURCE_STATE_UNCHECKED_SOURCE',
    SourceStateUncheckedSourceNoAccounts: 'SOURCE_STATE_UNCHECKED_SOURCE_NO_ACCOUNTS'
} as const;

export type SourceHealthDtoStatusV3 = typeof SourceHealthDtoStatusV3[keyof typeof SourceHealthDtoStatusV3];

/**
 * Reference to management workgroup for the source.
 * @export
 * @interface SourceManagementWorkgroup
 */
export interface SourceManagementWorkgroup {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'type'?: SourceManagementWorkgroupTypeV3;
    /**
     * Management workgroup ID.
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'id'?: string;
    /**
     * Management workgroup\'s human-readable display name.
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'name'?: string;
}

export const SourceManagementWorkgroupTypeV3 = {
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type SourceManagementWorkgroupTypeV3 = typeof SourceManagementWorkgroupTypeV3[keyof typeof SourceManagementWorkgroupTypeV3];

/**
 * 
 * @export
 * @interface SourceManagerCorrelationMapping
 */
export interface SourceManagerCorrelationMapping {
    /**
     * Name of the attribute to use for manager correlation. The value found on the account attribute will be used to lookup the manager\'s identity.
     * @type {string}
     * @memberof SourceManagerCorrelationMapping
     */
    'accountAttributeName'?: string;
    /**
     * Name of the identity attribute to search when trying to find a manager using the value from the accountAttribute.
     * @type {string}
     * @memberof SourceManagerCorrelationMapping
     */
    'identityAttributeName'?: string;
}
/**
 * Reference to the ManagerCorrelationRule. Only use this rule when a simple filter isn\'t sufficient.
 * @export
 * @interface SourceManagerCorrelationRule
 */
export interface SourceManagerCorrelationRule {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'type'?: SourceManagerCorrelationRuleTypeV3;
    /**
     * Rule ID.
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'id'?: string;
    /**
     * Rule\'s human-readable display name.
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'name'?: string;
}

export const SourceManagerCorrelationRuleTypeV3 = {
    Rule: 'RULE'
} as const;

export type SourceManagerCorrelationRuleTypeV3 = typeof SourceManagerCorrelationRuleTypeV3[keyof typeof SourceManagerCorrelationRuleTypeV3];

/**
 * Reference to identity object who owns the source.
 * @export
 * @interface SourceOwner
 */
export interface SourceOwner {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceOwner
     */
    'type'?: SourceOwnerTypeV3;
    /**
     * Owner identity\'s ID.
     * @type {string}
     * @memberof SourceOwner
     */
    'id'?: string;
    /**
     * Owner identity\'s human-readable display name.
     * @type {string}
     * @memberof SourceOwner
     */
    'name'?: string;
}

export const SourceOwnerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type SourceOwnerTypeV3 = typeof SourceOwnerTypeV3[keyof typeof SourceOwnerTypeV3];

/**
 * 
 * @export
 * @interface SourcePasswordPoliciesInner
 */
export interface SourcePasswordPoliciesInner {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'type'?: SourcePasswordPoliciesInnerTypeV3;
    /**
     * Policy ID.
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'id'?: string;
    /**
     * Policy\'s human-readable display name.
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'name'?: string;
}

export const SourcePasswordPoliciesInnerTypeV3 = {
    PasswordPolicy: 'PASSWORD_POLICY'
} as const;

export type SourcePasswordPoliciesInnerTypeV3 = typeof SourcePasswordPoliciesInnerTypeV3[keyof typeof SourcePasswordPoliciesInnerTypeV3];

/**
 * 
 * @export
 * @interface SourceSchemasInner
 */
export interface SourceSchemasInner {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'type'?: SourceSchemasInnerTypeV3;
    /**
     * Schema ID.
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'id'?: string;
    /**
     * Schema\'s human-readable display name.
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'name'?: string;
}

export const SourceSchemasInnerTypeV3 = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
} as const;

export type SourceSchemasInnerTypeV3 = typeof SourceSchemasInnerTypeV3[keyof typeof SourceSchemasInnerTypeV3];

/**
 * 
 * @export
 * @interface SourceUsage
 */
export interface SourceUsage {
    /**
     * The first day of the month for which activity is aggregated.
     * @type {string}
     * @memberof SourceUsage
     */
    'date'?: string;
    /**
     * The average number of days that accounts were active within this source, for the month.
     * @type {number}
     * @memberof SourceUsage
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface SourceUsageStatus
 */
export interface SourceUsageStatus {
    /**
     * Source Usage Status. Acceptable values are:   - COMPLETE       - This status means that an activity data source has been setup and usage insights are available for the source.   - INCOMPLETE       - This status means that an activity data source has not been setup and usage insights are not available for the source.
     * @type {string}
     * @memberof SourceUsageStatus
     */
    'status'?: SourceUsageStatusStatusV3;
}

export const SourceUsageStatusStatusV3 = {
    Complete: 'COMPLETE',
    Incomplete: 'INCOMPLETE'
} as const;

export type SourceUsageStatusStatusV3 = typeof SourceUsageStatusStatusV3[keyof typeof SourceUsageStatusStatusV3];

/**
 * Message model for Config Import/Export.
 * @export
 * @interface SpConfigMessage
 */
export interface SpConfigMessage {
    /**
     * Message key.
     * @type {string}
     * @memberof SpConfigMessage
     */
    'key': string;
    /**
     * Message text.
     * @type {string}
     * @memberof SpConfigMessage
     */
    'text': string;
    /**
     * Message details if any, in key:value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof SpConfigMessage
     */
    'details': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SpDetails
 */
export interface SpDetails {
    /**
     * Federation protocol role
     * @type {string}
     * @memberof SpDetails
     */
    'role'?: SpDetailsRoleV3;
    /**
     * An entity ID is a globally unique name for a SAML entity, either an Identity Provider (IDP) or a Service Provider (SP).
     * @type {string}
     * @memberof SpDetails
     */
    'entityId'?: string;
    /**
     * Unique alias used to identify the selected local service provider based on used URL. Used with SP configurations.
     * @type {string}
     * @memberof SpDetails
     */
    'alias'?: string;
    /**
     * The allowed callback URL where users will be redirected to after authentication. Used with SP configurations.
     * @type {string}
     * @memberof SpDetails
     */
    'callbackUrl'?: string;
}

export const SpDetailsRoleV3 = {
    SamlSp: 'SAML_SP'
} as const;

export type SpDetailsRoleV3 = typeof SpDetailsRoleV3[keyof typeof SpDetailsRoleV3];

/**
 * 
 * @export
 * @interface Split
 */
export interface Split {
    /**
     * This can be either a single character or a regex expression, and is used by the transform to identify the break point between two substrings in the incoming data
     * @type {string}
     * @memberof Split
     */
    'delimiter': string;
    /**
     * An integer value for the desired array element after the incoming data has been split into a list; the array is a 0-based object, so the first array element would be index 0, the second element would be index 1, etc.
     * @type {string}
     * @memberof Split
     */
    'index': string;
    /**
     * A boolean (true/false) value which indicates whether an exception should be thrown and returned as an output when an index is out of bounds with the resultant array (i.e., the provided index value is larger than the size of the array)   `true` - The transform should return \"IndexOutOfBoundsException\"   `false` - The transform should return null   If not provided, the transform will default to false and return a null 
     * @type {boolean}
     * @memberof Split
     */
    'throws'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Split
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Split
     */
    'input'?: { [key: string]: any; };
}
/**
 * Standard Log4j log level
 * @export
 * @enum {string}
 */

export const StandardLevel = {
    False: 'false',
    Fatal: 'FATAL',
    Error: 'ERROR',
    Warn: 'WARN',
    Info: 'INFO',
    Debug: 'DEBUG',
    Trace: 'TRACE'
} as const;

export type StandardLevel = typeof StandardLevel[keyof typeof StandardLevel];


/**
 * 
 * @export
 * @interface Static
 */
export interface Static {
    /**
     * This must evaluate to a JSON string, either through a fixed value or through conditional logic using the Apache Velocity Template Language.
     * @type {string}
     * @memberof Static
     */
    'values': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Static
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface SubSearchAggregationSpecification
 */
export interface SubSearchAggregationSpecification {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'bucket'?: BucketAggregation;
    /**
     * 
     * @type {Aggregations}
     * @memberof SubSearchAggregationSpecification
     */
    'subAggregation'?: Aggregations;
}
/**
 * 
 * @export
 * @interface Substring
 */
export interface Substring {
    /**
     * The index of the first character to include in the returned substring.   If `begin` is set to -1, the transform will begin at character 0 of the input data 
     * @type {number}
     * @memberof Substring
     */
    'begin': number;
    /**
     * This integer value is the number of characters to add to the begin attribute when returning a substring.   This attribute is only used if begin is not -1. 
     * @type {number}
     * @memberof Substring
     */
    'beginOffset'?: number;
    /**
     * The index of the first character to exclude from the returned substring.  If end is -1 or not provided at all, the substring transform will return everything up to the end of the input string. 
     * @type {number}
     * @memberof Substring
     */
    'end'?: number;
    /**
     * This integer value is the number of characters to add to the end attribute when returning a substring.   This attribute is only used if end is provided and is not -1. 
     * @type {number}
     * @memberof Substring
     */
    'endOffset'?: number;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Substring
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Substring
     */
    'input'?: { [key: string]: any; };
}
/**
 * Tagged object.
 * @export
 * @interface TaggedObject
 */
export interface TaggedObject {
    /**
     * 
     * @type {TaggedObjectDto}
     * @memberof TaggedObject
     */
    'objectRef'?: TaggedObjectDto;
    /**
     * Labels to be applied to an Object
     * @type {Array<string>}
     * @memberof TaggedObject
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TaggedObjectDto
 */
export interface TaggedObjectDto {
    /**
     * DTO type
     * @type {string}
     * @memberof TaggedObjectDto
     */
    'type'?: TaggedObjectDtoTypeV3;
    /**
     * ID of the object this reference applies to
     * @type {string}
     * @memberof TaggedObjectDto
     */
    'id'?: string;
    /**
     * Human-readable display name of the object this reference applies to
     * @type {string}
     * @memberof TaggedObjectDto
     */
    'name'?: string | null;
}

export const TaggedObjectDtoTypeV3 = {
    AccessProfile: 'ACCESS_PROFILE',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    Entitlement: 'ENTITLEMENT',
    Identity: 'IDENTITY',
    Role: 'ROLE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE'
} as const;

export type TaggedObjectDtoTypeV3 = typeof TaggedObjectDtoTypeV3[keyof typeof TaggedObjectDtoTypeV3];

/**
 * Details about job or task type, state and lifecycle.
 * @export
 * @interface TaskResultDetails
 */
export interface TaskResultDetails {
    /**
     * Type of the job or task underlying in the report processing. It could be a quartz task, QPOC or MENTOS jobs or a refresh/sync task.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'type'?: TaskResultDetailsTypeV3;
    /**
     * Unique task definition identifier.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'id'?: string;
    /**
     * Use this property to define what report should be processed in the RDE service.
     * @type {object}
     * @memberof TaskResultDetails
     */
    'reportType'?: TaskResultDetailsReportTypeV3;
    /**
     * Description of the report purpose and/or contents.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'description'?: string;
    /**
     * Name of the parent task/report if exists.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'parentName'?: string | null;
    /**
     * Name of the report processing initiator.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'launcher'?: string;
    /**
     * Report creation date
     * @type {string}
     * @memberof TaskResultDetails
     */
    'created'?: string;
    /**
     * Report start date
     * @type {string}
     * @memberof TaskResultDetails
     */
    'launched'?: string | null;
    /**
     * Report completion date
     * @type {string}
     * @memberof TaskResultDetails
     */
    'completed'?: string | null;
    /**
     * Report completion status.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'completionStatus'?: TaskResultDetailsCompletionStatusV3 | null;
    /**
     * List of the messages dedicated to the report.  From task definition perspective here usually should be warnings or errors.
     * @type {Array<TaskResultDetailsMessagesInner>}
     * @memberof TaskResultDetails
     */
    'messages'?: Array<TaskResultDetailsMessagesInner>;
    /**
     * Task definition results, if necessary.
     * @type {Array<TaskResultDetailsReturnsInner>}
     * @memberof TaskResultDetails
     */
    'returns'?: Array<TaskResultDetailsReturnsInner>;
    /**
     * Extra attributes map(dictionary) needed for the report.
     * @type {{ [key: string]: object; }}
     * @memberof TaskResultDetails
     */
    'attributes'?: { [key: string]: object; };
    /**
     * Current report state.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'progress'?: string | null;
}

export const TaskResultDetailsTypeV3 = {
    Quartz: 'QUARTZ',
    Qpoc: 'QPOC',
    Mentos: 'MENTOS',
    QueuedTask: 'QUEUED_TASK'
} as const;

export type TaskResultDetailsTypeV3 = typeof TaskResultDetailsTypeV3[keyof typeof TaskResultDetailsTypeV3];
export const TaskResultDetailsReportTypeV3 = {
    Accounts: 'ACCOUNTS',
    IdentitiesDetails: 'IDENTITIES_DETAILS',
    Identities: 'IDENTITIES',
    IdentityProfileIdentityError: 'IDENTITY_PROFILE_IDENTITY_ERROR',
    OrphanIdentities: 'ORPHAN_IDENTITIES',
    SearchExport: 'SEARCH_EXPORT',
    UncorrelatedAccounts: 'UNCORRELATED_ACCOUNTS'
} as const;

export type TaskResultDetailsReportTypeV3 = typeof TaskResultDetailsReportTypeV3[keyof typeof TaskResultDetailsReportTypeV3];
export const TaskResultDetailsCompletionStatusV3 = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR'
} as const;

export type TaskResultDetailsCompletionStatusV3 = typeof TaskResultDetailsCompletionStatusV3[keyof typeof TaskResultDetailsCompletionStatusV3];

/**
 * 
 * @export
 * @interface TaskResultDetailsMessagesInner
 */
export interface TaskResultDetailsMessagesInner {
    /**
     * Type of the message.
     * @type {string}
     * @memberof TaskResultDetailsMessagesInner
     */
    'type'?: TaskResultDetailsMessagesInnerTypeV3;
    /**
     * Flag whether message is an error.
     * @type {boolean}
     * @memberof TaskResultDetailsMessagesInner
     */
    'error'?: boolean;
    /**
     * Flag whether message is a warning.
     * @type {boolean}
     * @memberof TaskResultDetailsMessagesInner
     */
    'warning'?: boolean;
    /**
     * Message string identifier.
     * @type {string}
     * @memberof TaskResultDetailsMessagesInner
     */
    'key'?: string;
    /**
     * Message context with the locale based language.
     * @type {string}
     * @memberof TaskResultDetailsMessagesInner
     */
    'localizedText'?: string;
}

export const TaskResultDetailsMessagesInnerTypeV3 = {
    Info: 'INFO',
    Warn: 'WARN',
    Error: 'ERROR'
} as const;

export type TaskResultDetailsMessagesInnerTypeV3 = typeof TaskResultDetailsMessagesInnerTypeV3[keyof typeof TaskResultDetailsMessagesInnerTypeV3];

/**
 * 
 * @export
 * @interface TaskResultDetailsReturnsInner
 */
export interface TaskResultDetailsReturnsInner {
    /**
     * Attribute description.
     * @type {string}
     * @memberof TaskResultDetailsReturnsInner
     */
    'displayLabel'?: string;
    /**
     * System or database attribute name.
     * @type {string}
     * @memberof TaskResultDetailsReturnsInner
     */
    'attributeName'?: string;
}
/**
 * Task result.
 * @export
 * @interface TaskResultDto
 */
export interface TaskResultDto {
    /**
     * Task result DTO type.
     * @type {string}
     * @memberof TaskResultDto
     */
    'type'?: TaskResultDtoTypeV3;
    /**
     * Task result ID.
     * @type {string}
     * @memberof TaskResultDto
     */
    'id'?: string;
    /**
     * Task result display name.
     * @type {string}
     * @memberof TaskResultDto
     */
    'name'?: string | null;
}

export const TaskResultDtoTypeV3 = {
    TaskResult: 'TASK_RESULT'
} as const;

export type TaskResultDtoTypeV3 = typeof TaskResultDtoTypeV3[keyof typeof TaskResultDtoTypeV3];

/**
 * 
 * @export
 * @interface TaskResultSimplified
 */
export interface TaskResultSimplified {
    /**
     * Task identifier
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'id'?: string;
    /**
     * Task name
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'name'?: string;
    /**
     * Task description
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'description'?: string;
    /**
     * User or process who launched the task
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'launcher'?: string;
    /**
     * Date time of completion
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'completed'?: string;
    /**
     * Date time when the task was launched
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'launched'?: string;
    /**
     * Task result status
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'completionStatus'?: TaskResultSimplifiedCompletionStatusV3;
}

export const TaskResultSimplifiedCompletionStatusV3 = {
    Success: 'Success',
    Warning: 'Warning',
    Error: 'Error',
    Terminated: 'Terminated',
    TempError: 'TempError'
} as const;

export type TaskResultSimplifiedCompletionStatusV3 = typeof TaskResultSimplifiedCompletionStatusV3[keyof typeof TaskResultSimplifiedCompletionStatusV3];

/**
 * 
 * @export
 * @interface TestExternalExecuteWorkflow200Response
 */
export interface TestExternalExecuteWorkflow200Response {
    /**
     * The input that was received
     * @type {object}
     * @memberof TestExternalExecuteWorkflow200Response
     */
    'payload'?: object;
}
/**
 * 
 * @export
 * @interface TestExternalExecuteWorkflowRequest
 */
export interface TestExternalExecuteWorkflowRequest {
    /**
     * The test input for the workflow
     * @type {object}
     * @memberof TestExternalExecuteWorkflowRequest
     */
    'input'?: object;
}
/**
 * 
 * @export
 * @interface TestWorkflow200Response
 */
export interface TestWorkflow200Response {
    /**
     * The workflow execution id
     * @type {string}
     * @memberof TestWorkflow200Response
     */
    'workflowExecutionId'?: string;
}
/**
 * 
 * @export
 * @interface TestWorkflowRequest
 */
export interface TestWorkflowRequest {
    /**
     * The test input for the workflow.
     * @type {object}
     * @memberof TestWorkflowRequest
     */
    'input': object;
}
/**
 * Query parameters used to construct an Elasticsearch text query object.
 * @export
 * @interface TextQuery
 */
export interface TextQuery {
    /**
     * Words or characters that specify a particular thing to be searched for.
     * @type {Array<string>}
     * @memberof TextQuery
     */
    'terms': Array<string>;
    /**
     * The fields to be searched.
     * @type {Array<string>}
     * @memberof TextQuery
     */
    'fields': Array<string>;
    /**
     * Indicates that at least one of the terms must be found in the specified fields;  otherwise, all terms must be found.
     * @type {boolean}
     * @memberof TextQuery
     */
    'matchAny'?: boolean;
    /**
     * Indicates that the terms can be located anywhere in the specified fields;  otherwise, the fields must begin with the terms.
     * @type {boolean}
     * @memberof TextQuery
     */
    'contains'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenAuthRequest
 */
export interface TokenAuthRequest {
    /**
     * Token value
     * @type {string}
     * @memberof TokenAuthRequest
     */
    'token': string;
    /**
     * User alias from table spt_identity field named \'name\'
     * @type {string}
     * @memberof TokenAuthRequest
     */
    'userAlias': string;
    /**
     * Token delivery type
     * @type {string}
     * @memberof TokenAuthRequest
     */
    'deliveryType': TokenAuthRequestDeliveryTypeV3;
}

export const TokenAuthRequestDeliveryTypeV3 = {
    SmsPersonal: 'SMS_PERSONAL',
    VoicePersonal: 'VOICE_PERSONAL',
    SmsWork: 'SMS_WORK',
    VoiceWork: 'VOICE_WORK',
    EmailWork: 'EMAIL_WORK',
    EmailPersonal: 'EMAIL_PERSONAL'
} as const;

export type TokenAuthRequestDeliveryTypeV3 = typeof TokenAuthRequestDeliveryTypeV3[keyof typeof TokenAuthRequestDeliveryTypeV3];

/**
 * 
 * @export
 * @interface TokenAuthResponse
 */
export interface TokenAuthResponse {
    /**
     * MFA Authentication status
     * @type {string}
     * @memberof TokenAuthResponse
     */
    'status'?: TokenAuthResponseStatusV3;
}

export const TokenAuthResponseStatusV3 = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Lockout: 'LOCKOUT',
    NotEnoughData: 'NOT_ENOUGH_DATA'
} as const;

export type TokenAuthResponseStatusV3 = typeof TokenAuthResponseStatusV3[keyof typeof TokenAuthResponseStatusV3];

/**
 * The representation of an internally- or customer-defined transform.
 * @export
 * @interface Transform
 */
export interface Transform {
    /**
     * Unique name of this transform
     * @type {string}
     * @memberof Transform
     */
    'name': string;
    /**
     * The type of transform operation
     * @type {string}
     * @memberof Transform
     */
    'type': TransformTypeV3;
    /**
     * 
     * @type {TransformAttributes}
     * @memberof Transform
     */
    'attributes': TransformAttributes | null;
}

export const TransformTypeV3 = {
    AccountAttribute: 'accountAttribute',
    Base64Decode: 'base64Decode',
    Base64Encode: 'base64Encode',
    Concat: 'concat',
    Conditional: 'conditional',
    DateCompare: 'dateCompare',
    DateFormat: 'dateFormat',
    DateMath: 'dateMath',
    DecomposeDiacriticalMarks: 'decomposeDiacriticalMarks',
    E164phone: 'e164phone',
    FirstValid: 'firstValid',
    Rule: 'rule',
    IdentityAttribute: 'identityAttribute',
    IndexOf: 'indexOf',
    Iso3166: 'iso3166',
    LastIndexOf: 'lastIndexOf',
    LeftPad: 'leftPad',
    Lookup: 'lookup',
    Lower: 'lower',
    NormalizeNames: 'normalizeNames',
    RandomAlphaNumeric: 'randomAlphaNumeric',
    RandomNumeric: 'randomNumeric',
    Reference: 'reference',
    ReplaceAll: 'replaceAll',
    Replace: 'replace',
    RightPad: 'rightPad',
    Split: 'split',
    Static: 'static',
    Substring: 'substring',
    Trim: 'trim',
    Upper: 'upper',
    UsernameGenerator: 'usernameGenerator',
    Uuid: 'uuid',
    DisplayName: 'displayName',
    Rfc5646: 'rfc5646'
} as const;

export type TransformTypeV3 = typeof TransformTypeV3[keyof typeof TransformTypeV3];

/**
 * @type TransformAttributes
 * Meta-data about the transform. Values in this list are specific to the type of transform to be executed.
 * @export
 */
export type TransformAttributes = AccountAttribute | Base64Decode | Base64Encode | Concatenation | Conditional | DateCompare | DateFormat | DateMath | DecomposeDiacriticalMarks | E164phone | FirstValid | ISO3166 | IdentityAttribute | IndexOf | LeftPad | Lookup | Lower | NameNormalizer | RandomAlphaNumeric | RandomNumeric | Reference | Replace | ReplaceAll | RightPad | Rule | Split | Static | Substring | Trim | UUIDGenerator | Upper;

/**
 * 
 * @export
 * @interface TransformDefinition
 */
export interface TransformDefinition {
    /**
     * Transform definition type.
     * @type {string}
     * @memberof TransformDefinition
     */
    'type'?: string;
    /**
     * Arbitrary key-value pairs to store any metadata for the object
     * @type {{ [key: string]: any; }}
     * @memberof TransformDefinition
     */
    'attributes'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface TransformRead
 */
export interface TransformRead {
    /**
     * Unique name of this transform
     * @type {string}
     * @memberof TransformRead
     */
    'name': string;
    /**
     * The type of transform operation
     * @type {string}
     * @memberof TransformRead
     */
    'type': TransformReadTypeV3;
    /**
     * 
     * @type {TransformAttributes}
     * @memberof TransformRead
     */
    'attributes': TransformAttributes | null;
    /**
     * Unique ID of this transform
     * @type {string}
     * @memberof TransformRead
     */
    'id': string;
    /**
     * Indicates whether this is an internal SailPoint-created transform or a customer-created transform
     * @type {boolean}
     * @memberof TransformRead
     */
    'internal': boolean;
}

export const TransformReadTypeV3 = {
    AccountAttribute: 'accountAttribute',
    Base64Decode: 'base64Decode',
    Base64Encode: 'base64Encode',
    Concat: 'concat',
    Conditional: 'conditional',
    DateCompare: 'dateCompare',
    DateFormat: 'dateFormat',
    DateMath: 'dateMath',
    DecomposeDiacriticalMarks: 'decomposeDiacriticalMarks',
    E164phone: 'e164phone',
    FirstValid: 'firstValid',
    Rule: 'rule',
    IdentityAttribute: 'identityAttribute',
    IndexOf: 'indexOf',
    Iso3166: 'iso3166',
    LastIndexOf: 'lastIndexOf',
    LeftPad: 'leftPad',
    Lookup: 'lookup',
    Lower: 'lower',
    NormalizeNames: 'normalizeNames',
    RandomAlphaNumeric: 'randomAlphaNumeric',
    RandomNumeric: 'randomNumeric',
    Reference: 'reference',
    ReplaceAll: 'replaceAll',
    Replace: 'replace',
    RightPad: 'rightPad',
    Split: 'split',
    Static: 'static',
    Substring: 'substring',
    Trim: 'trim',
    Upper: 'upper',
    UsernameGenerator: 'usernameGenerator',
    Uuid: 'uuid',
    DisplayName: 'displayName',
    Rfc5646: 'rfc5646'
} as const;

export type TransformReadTypeV3 = typeof TransformReadTypeV3[keyof typeof TransformReadTypeV3];

/**
 * 
 * @export
 * @interface TransformRule
 */
export interface TransformRule {
    /**
     * This is the name of the Transform rule that needs to be invoked by the transform
     * @type {string}
     * @memberof TransformRule
     */
    'name': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof TransformRule
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface Trim
 */
export interface Trim {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Trim
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Trim
     */
    'input'?: { [key: string]: any; };
}
/**
 * Query parameters used to construct an Elasticsearch type ahead query object.  The typeAheadQuery performs a search for top values beginning with the typed values. For example, typing \"Jo\" results in top hits matching \"Jo.\" Typing \"Job\" results in top hits matching \"Job.\" 
 * @export
 * @interface TypeAheadQuery
 */
export interface TypeAheadQuery {
    /**
     * The type ahead query string used to construct a phrase prefix match query.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'query': string;
    /**
     * The field on which to perform the type ahead search.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'field': string;
    /**
     * The nested type.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'nestedType'?: string;
    /**
     * The number of suffixes the last term will be expanded into. Influences the performance of the query and the number results returned. Valid values: 1 to 1000.
     * @type {number}
     * @memberof TypeAheadQuery
     */
    'maxExpansions'?: number;
    /**
     * The max amount of records the search will return.
     * @type {number}
     * @memberof TypeAheadQuery
     */
    'size'?: number;
    /**
     * The sort order of the returned records.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'sort'?: string;
    /**
     * The flag that defines the sort type, by count or value.
     * @type {boolean}
     * @memberof TypeAheadQuery
     */
    'sortByValue'?: boolean;
}
/**
 * A typed reference to the object. 
 * @export
 * @interface TypedReference
 */
export interface TypedReference {
    /**
     * 
     * @type {DtoType}
     * @memberof TypedReference
     */
    'type': DtoType;
    /**
     * The id of the object. 
     * @type {string}
     * @memberof TypedReference
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface UUIDGenerator
 */
export interface UUIDGenerator {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof UUIDGenerator
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * Arguments for Uncorrelated Accounts report (UNCORRELATED_ACCOUNTS)
 * @export
 * @interface UncorrelatedAccountsReportArguments
 */
export interface UncorrelatedAccountsReportArguments {
    /**
     * Output report file formats. These are formats for calling GET endpoint as query parameter \'fileFormat\'.  In case report won\'t have this argument there will be [\'CSV\', \'PDF\'] as default.
     * @type {Array<string>}
     * @memberof UncorrelatedAccountsReportArguments
     */
    'selectedFormats'?: Array<UncorrelatedAccountsReportArgumentsSelectedFormatsV3>;
}

export const UncorrelatedAccountsReportArgumentsSelectedFormatsV3 = {
    Csv: 'CSV',
    Pdf: 'PDF'
} as const;

export type UncorrelatedAccountsReportArgumentsSelectedFormatsV3 = typeof UncorrelatedAccountsReportArgumentsSelectedFormatsV3[keyof typeof UncorrelatedAccountsReportArgumentsSelectedFormatsV3];

/**
 * 
 * @export
 * @interface UpdateDetail
 */
export interface UpdateDetail {
    /**
     * The detailed message for an update. Typically the relevent error message when status is error.
     * @type {string}
     * @memberof UpdateDetail
     */
    'message'?: string;
    /**
     * The connector script name
     * @type {string}
     * @memberof UpdateDetail
     */
    'scriptName'?: string;
    /**
     * The list of updated files supported by the connector
     * @type {Array<string>}
     * @memberof UpdateDetail
     */
    'updatedFiles'?: Array<string> | null;
    /**
     * The connector update status
     * @type {string}
     * @memberof UpdateDetail
     */
    'status'?: UpdateDetailStatusV3;
}

export const UpdateDetailStatusV3 = {
    Error: 'ERROR',
    Updated: 'UPDATED',
    Unchanged: 'UNCHANGED',
    Skipped: 'SKIPPED'
} as const;

export type UpdateDetailStatusV3 = typeof UpdateDetailStatusV3[keyof typeof UpdateDetailStatusV3];

/**
 * 
 * @export
 * @interface Upper
 */
export interface Upper {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Upper
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Upper
     */
    'input'?: { [key: string]: any; };
}
/**
 * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \'Create Account Profile\', the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \'Update Account Profile\', the provisioning template for the \'Update\' connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \'Enable Account Profile\', the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\'s account is created.  DISABLE - This usage type relates to \'Disable Account Profile\', the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
 * @export
 * @enum {string}
 */

export const UsageType = {
    Create: 'CREATE',
    Update: 'UPDATE',
    Enable: 'ENABLE',
    Disable: 'DISABLE',
    Delete: 'DELETE',
    Assign: 'ASSIGN',
    Unassign: 'UNASSIGN',
    CreateGroup: 'CREATE_GROUP',
    UpdateGroup: 'UPDATE_GROUP',
    DeleteGroup: 'DELETE_GROUP',
    Register: 'REGISTER',
    CreateIdentity: 'CREATE_IDENTITY',
    UpdateIdentity: 'UPDATE_IDENTITY',
    EditGroup: 'EDIT_GROUP',
    Unlock: 'UNLOCK',
    ChangePassword: 'CHANGE_PASSWORD'
} as const;

export type UsageType = typeof UsageType[keyof typeof UsageType];


/**
 * 
 * @export
 * @interface V3ConnectorDto
 */
export interface V3ConnectorDto {
    /**
     * The connector name
     * @type {string}
     * @memberof V3ConnectorDto
     */
    'name'?: string;
    /**
     * The connector type
     * @type {string}
     * @memberof V3ConnectorDto
     */
    'type'?: string;
    /**
     * The connector script name
     * @type {string}
     * @memberof V3ConnectorDto
     */
    'scriptName'?: string;
    /**
     * The connector class name.
     * @type {string}
     * @memberof V3ConnectorDto
     */
    'className'?: string | null;
    /**
     * The list of features supported by the connector
     * @type {Array<string>}
     * @memberof V3ConnectorDto
     */
    'features'?: Array<string> | null;
    /**
     * true if the source is a direct connect source
     * @type {boolean}
     * @memberof V3ConnectorDto
     */
    'directConnect'?: boolean;
    /**
     * A map containing metadata pertinent to the connector
     * @type {{ [key: string]: any; }}
     * @memberof V3ConnectorDto
     */
    'connectorMetadata'?: { [key: string]: any; };
    /**
     * The connector status
     * @type {string}
     * @memberof V3ConnectorDto
     */
    'status'?: V3ConnectorDtoStatusV3;
}

export const V3ConnectorDtoStatusV3 = {
    Deprecated: 'DEPRECATED',
    Development: 'DEVELOPMENT',
    Demo: 'DEMO',
    Released: 'RELEASED'
} as const;

export type V3ConnectorDtoStatusV3 = typeof V3ConnectorDtoStatusV3[keyof typeof V3ConnectorDtoStatusV3];

/**
 * 
 * @export
 * @interface V3CreateConnectorDto
 */
export interface V3CreateConnectorDto {
    /**
     * The connector name. Need to be unique per tenant. The name will able be used to derive a url friendly unique scriptname that will be in response. Script name can then be used for all update endpoints
     * @type {string}
     * @memberof V3CreateConnectorDto
     */
    'name': string;
    /**
     * The connector type. If not specified will be defaulted to \'custom \'+name
     * @type {string}
     * @memberof V3CreateConnectorDto
     */
    'type'?: string;
    /**
     * The connector class name. If you are implementing openconnector standard (what is recommended), then this need to be set to sailpoint.connector.OpenConnectorAdapter
     * @type {string}
     * @memberof V3CreateConnectorDto
     */
    'className': string;
    /**
     * true if the source is a direct connect source
     * @type {boolean}
     * @memberof V3CreateConnectorDto
     */
    'directConnect'?: boolean;
    /**
     * The connector status
     * @type {string}
     * @memberof V3CreateConnectorDto
     */
    'status'?: V3CreateConnectorDtoStatusV3;
}

export const V3CreateConnectorDtoStatusV3 = {
    Development: 'DEVELOPMENT',
    Demo: 'DEMO',
    Released: 'RELEASED'
} as const;

export type V3CreateConnectorDtoStatusV3 = typeof V3CreateConnectorDtoStatusV3[keyof typeof V3CreateConnectorDtoStatusV3];

/**
 * 
 * @export
 * @interface Value
 */
export interface Value {
    /**
     * The type of attribute value
     * @type {string}
     * @memberof Value
     */
    'type'?: string;
    /**
     * The attribute value
     * @type {string}
     * @memberof Value
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface VendorConnectorMapping
 */
export interface VendorConnectorMapping {
    /**
     * The unique identifier for the vendor-connector mapping.
     * @type {string}
     * @memberof VendorConnectorMapping
     */
    'id'?: string;
    /**
     * The name of the vendor.
     * @type {string}
     * @memberof VendorConnectorMapping
     */
    'vendor'?: string;
    /**
     * The name of the connector.
     * @type {string}
     * @memberof VendorConnectorMapping
     */
    'connector'?: string;
    /**
     * The creation timestamp of the mapping.
     * @type {string}
     * @memberof VendorConnectorMapping
     */
    'createdAt'?: string;
    /**
     * The identifier of the user who created the mapping.
     * @type {string}
     * @memberof VendorConnectorMapping
     */
    'createdBy'?: string;
    /**
     * 
     * @type {VendorConnectorMappingUpdatedAt}
     * @memberof VendorConnectorMapping
     */
    'updatedAt'?: VendorConnectorMappingUpdatedAt | null;
    /**
     * 
     * @type {VendorConnectorMappingUpdatedBy}
     * @memberof VendorConnectorMapping
     */
    'updatedBy'?: VendorConnectorMappingUpdatedBy | null;
    /**
     * 
     * @type {VendorConnectorMappingDeletedAt}
     * @memberof VendorConnectorMapping
     */
    'deletedAt'?: VendorConnectorMappingDeletedAt | null;
    /**
     * 
     * @type {VendorConnectorMappingDeletedBy}
     * @memberof VendorConnectorMapping
     */
    'deletedBy'?: VendorConnectorMappingDeletedBy | null;
}
/**
 * An object representing the nullable timestamp of when the mapping was deleted.
 * @export
 * @interface VendorConnectorMappingDeletedAt
 */
export interface VendorConnectorMappingDeletedAt {
    /**
     * The timestamp when the mapping was deleted, represented in ISO 8601 format, if applicable.
     * @type {string}
     * @memberof VendorConnectorMappingDeletedAt
     */
    'Time'?: string;
    /**
     * A flag indicating if the \'Time\' field is set and valid, i.e., if the mapping has been deleted.
     * @type {boolean}
     * @memberof VendorConnectorMappingDeletedAt
     */
    'Valid'?: boolean;
}
/**
 * An object representing the nullable identifier of the user who deleted the mapping.
 * @export
 * @interface VendorConnectorMappingDeletedBy
 */
export interface VendorConnectorMappingDeletedBy {
    /**
     * The identifier of the user who deleted the mapping, if applicable.
     * @type {string}
     * @memberof VendorConnectorMappingDeletedBy
     */
    'String'?: string;
    /**
     * A flag indicating if the \'String\' field is set and valid, i.e., if the mapping has been deleted.
     * @type {boolean}
     * @memberof VendorConnectorMappingDeletedBy
     */
    'Valid'?: boolean;
}
/**
 * An object representing the nullable timestamp of the last update.
 * @export
 * @interface VendorConnectorMappingUpdatedAt
 */
export interface VendorConnectorMappingUpdatedAt {
    /**
     * The timestamp when the mapping was last updated, represented in ISO 8601 format.
     * @type {string}
     * @memberof VendorConnectorMappingUpdatedAt
     */
    'Time'?: string;
    /**
     * A flag indicating if the \'Time\' field is set and valid.
     * @type {boolean}
     * @memberof VendorConnectorMappingUpdatedAt
     */
    'Valid'?: boolean;
}
/**
 * An object representing the nullable identifier of the user who last updated the mapping.
 * @export
 * @interface VendorConnectorMappingUpdatedBy
 */
export interface VendorConnectorMappingUpdatedBy {
    /**
     * The identifier of the user who last updated the mapping, if available.
     * @type {string}
     * @memberof VendorConnectorMappingUpdatedBy
     */
    'String'?: string;
    /**
     * A flag indicating if the \'String\' field is set and valid.
     * @type {boolean}
     * @memberof VendorConnectorMappingUpdatedBy
     */
    'Valid'?: boolean;
}
/**
 * 
 * @export
 * @interface VerificationPollRequest
 */
export interface VerificationPollRequest {
    /**
     * Verification request Id
     * @type {string}
     * @memberof VerificationPollRequest
     */
    'requestId': string;
}
/**
 * 
 * @export
 * @interface VerificationResponse
 */
export interface VerificationResponse {
    /**
     * The verificationPollRequest request ID
     * @type {string}
     * @memberof VerificationResponse
     */
    'requestId'?: string | null;
    /**
     * MFA Authentication status
     * @type {string}
     * @memberof VerificationResponse
     */
    'status'?: VerificationResponseStatusV3;
    /**
     * Error messages from MFA verification request
     * @type {string}
     * @memberof VerificationResponse
     */
    'error'?: string | null;
}

export const VerificationResponseStatusV3 = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Lockout: 'LOCKOUT',
    NotEnoughData: 'NOT_ENOUGH_DATA'
} as const;

export type VerificationResponseStatusV3 = typeof VerificationResponseStatusV3[keyof typeof VerificationResponseStatusV3];

/**
 * 
 * @export
 * @interface ViolationContext
 */
export interface ViolationContext {
    /**
     * 
     * @type {ViolationContextPolicy}
     * @memberof ViolationContext
     */
    'policy'?: ViolationContextPolicy;
    /**
     * 
     * @type {ExceptionAccessCriteria}
     * @memberof ViolationContext
     */
    'conflictingAccessCriteria'?: ExceptionAccessCriteria;
}
/**
 * The types of objects supported for SOD violations
 * @export
 * @interface ViolationContextPolicy
 */
export interface ViolationContextPolicy {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof ViolationContextPolicy
     */
    'type'?: ViolationContextPolicyTypeV3;
    /**
     * SOD policy ID.
     * @type {string}
     * @memberof ViolationContextPolicy
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViolationContextPolicy
     */
    'name'?: string;
}

export const ViolationContextPolicyTypeV3 = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type ViolationContextPolicyTypeV3 = typeof ViolationContextPolicyTypeV3[keyof typeof ViolationContextPolicyTypeV3];

/**
 * 
 * @export
 * @interface ViolationOwnerAssignmentConfig
 */
export interface ViolationOwnerAssignmentConfig {
    /**
     * Details about the violations owner. MANAGER - identity\'s manager STATIC - Governance Group or Identity
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfig
     */
    'assignmentRule'?: ViolationOwnerAssignmentConfigAssignmentRuleV3 | null;
    /**
     * 
     * @type {ViolationOwnerAssignmentConfigOwnerRef}
     * @memberof ViolationOwnerAssignmentConfig
     */
    'ownerRef'?: ViolationOwnerAssignmentConfigOwnerRef | null;
}

export const ViolationOwnerAssignmentConfigAssignmentRuleV3 = {
    Manager: 'MANAGER',
    Static: 'STATIC'
} as const;

export type ViolationOwnerAssignmentConfigAssignmentRuleV3 = typeof ViolationOwnerAssignmentConfigAssignmentRuleV3[keyof typeof ViolationOwnerAssignmentConfigAssignmentRuleV3];

/**
 * The owner of the violation assignment config.
 * @export
 * @interface ViolationOwnerAssignmentConfigOwnerRef
 */
export interface ViolationOwnerAssignmentConfigOwnerRef {
    /**
     * Owner type.
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigOwnerRef
     */
    'type'?: ViolationOwnerAssignmentConfigOwnerRefTypeV3 | null;
    /**
     * Owner\'s ID.
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigOwnerRef
     */
    'id'?: string;
    /**
     * Owner\'s name.
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigOwnerRef
     */
    'name'?: string;
}

export const ViolationOwnerAssignmentConfigOwnerRefTypeV3 = {
    Identity: 'IDENTITY',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Manager: 'MANAGER'
} as const;

export type ViolationOwnerAssignmentConfigOwnerRefTypeV3 = typeof ViolationOwnerAssignmentConfigOwnerRefTypeV3[keyof typeof ViolationOwnerAssignmentConfigOwnerRefTypeV3];

/**
 * An object containing a listing of the SOD violation reasons detected by this check.
 * @export
 * @interface ViolationPrediction
 */
export interface ViolationPrediction {
    /**
     * List of Violation Contexts
     * @type {Array<ViolationContext>}
     * @memberof ViolationPrediction
     */
    'violationContexts'?: Array<ViolationContext>;
}
/**
 * 
 * @export
 * @interface VisibilityCriteria
 */
export interface VisibilityCriteria {
    /**
     * 
     * @type {Expression}
     * @memberof VisibilityCriteria
     */
    'expression'?: Expression;
}
/**
 * 
 * @export
 * @interface WorkItemForward
 */
export interface WorkItemForward {
    /**
     * The ID of the identity to forward this work item to.
     * @type {string}
     * @memberof WorkItemForward
     */
    'targetOwnerId': string;
    /**
     * Comments to send to the target owner
     * @type {string}
     * @memberof WorkItemForward
     */
    'comment': string;
    /**
     * If true, send a notification to the target owner.
     * @type {boolean}
     * @memberof WorkItemForward
     */
    'sendNotifications'?: boolean;
}
/**
 * The state of a work item
 * @export
 * @enum {string}
 */

export const WorkItemState = {
    Finished: 'Finished',
    Rejected: 'Rejected',
    Returned: 'Returned',
    Expired: 'Expired',
    Pending: 'Pending',
    Canceled: 'Canceled'
} as const;

export type WorkItemState = typeof WorkItemState[keyof typeof WorkItemState];


/**
 * The state of a work item
 * @export
 * @enum {string}
 */

export const WorkItemStateManualWorkItems = {
    Finished: 'Finished',
    Rejected: 'Rejected',
    Returned: 'Returned',
    Expired: 'Expired',
    Pending: 'Pending',
    Canceled: 'Canceled'
} as const;

export type WorkItemStateManualWorkItems = typeof WorkItemStateManualWorkItems[keyof typeof WorkItemStateManualWorkItems];


/**
 * The type of the work item
 * @export
 * @enum {string}
 */

export const WorkItemTypeManualWorkItems = {
    Generic: 'Generic',
    Certification: 'Certification',
    Remediation: 'Remediation',
    Delegation: 'Delegation',
    Approval: 'Approval',
    ViolationReview: 'ViolationReview',
    Form: 'Form',
    PolicyVioloation: 'PolicyVioloation',
    Challenge: 'Challenge',
    ImpactAnalysis: 'ImpactAnalysis',
    Signoff: 'Signoff',
    Event: 'Event',
    ManualAction: 'ManualAction',
    Test: 'Test'
} as const;

export type WorkItemTypeManualWorkItems = typeof WorkItemTypeManualWorkItems[keyof typeof WorkItemTypeManualWorkItems];


/**
 * 
 * @export
 * @interface WorkItems
 */
export interface WorkItems {
    /**
     * ID of the work item
     * @type {string}
     * @memberof WorkItems
     */
    'id'?: string;
    /**
     * ID of the requester
     * @type {string}
     * @memberof WorkItems
     */
    'requesterId'?: string | null;
    /**
     * The displayname of the requester
     * @type {string}
     * @memberof WorkItems
     */
    'requesterDisplayName'?: string | null;
    /**
     * The ID of the owner
     * @type {string}
     * @memberof WorkItems
     */
    'ownerId'?: string | null;
    /**
     * The name of the owner
     * @type {string}
     * @memberof WorkItems
     */
    'ownerName'?: string;
    /**
     * Time when the work item was created
     * @type {string}
     * @memberof WorkItems
     */
    'created'?: string;
    /**
     * Time when the work item was last updated
     * @type {string}
     * @memberof WorkItems
     */
    'modified'?: string | null;
    /**
     * The description of the work item
     * @type {string}
     * @memberof WorkItems
     */
    'description'?: string;
    /**
     * 
     * @type {WorkItemStateManualWorkItems}
     * @memberof WorkItems
     */
    'state'?: WorkItemStateManualWorkItems;
    /**
     * 
     * @type {WorkItemTypeManualWorkItems}
     * @memberof WorkItems
     */
    'type'?: WorkItemTypeManualWorkItems;
    /**
     * A list of remediation items
     * @type {Array<RemediationItemDetails>}
     * @memberof WorkItems
     */
    'remediationItems'?: Array<RemediationItemDetails> | null;
    /**
     * A list of items that need to be approved
     * @type {Array<ApprovalItemDetails>}
     * @memberof WorkItems
     */
    'approvalItems'?: Array<ApprovalItemDetails> | null;
    /**
     * The work item name
     * @type {string}
     * @memberof WorkItems
     */
    'name'?: string | null;
    /**
     * The time at which the work item completed
     * @type {string}
     * @memberof WorkItems
     */
    'completed'?: string | null;
    /**
     * The number of items in the work item
     * @type {number}
     * @memberof WorkItems
     */
    'numItems'?: number | null;
    /**
     * 
     * @type {WorkItemsForm}
     * @memberof WorkItems
     */
    'form'?: WorkItemsForm;
    /**
     * An array of errors that ocurred during the work item
     * @type {Array<string>}
     * @memberof WorkItems
     */
    'errors'?: Array<string>;
}


/**
 * 
 * @export
 * @interface WorkItemsCount
 */
export interface WorkItemsCount {
    /**
     * The count of work items
     * @type {number}
     * @memberof WorkItemsCount
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface WorkItemsForm
 */
export interface WorkItemsForm {
    /**
     * ID of the form
     * @type {string}
     * @memberof WorkItemsForm
     */
    'id'?: string | null;
    /**
     * Name of the form
     * @type {string}
     * @memberof WorkItemsForm
     */
    'name'?: string | null;
    /**
     * The form title
     * @type {string}
     * @memberof WorkItemsForm
     */
    'title'?: string;
    /**
     * The form subtitle.
     * @type {string}
     * @memberof WorkItemsForm
     */
    'subtitle'?: string;
    /**
     * The name of the user that should be shown this form
     * @type {string}
     * @memberof WorkItemsForm
     */
    'targetUser'?: string;
    /**
     * Sections of the form
     * @type {Array<SectionDetails>}
     * @memberof WorkItemsForm
     */
    'sections'?: Array<SectionDetails>;
}
/**
 * 
 * @export
 * @interface WorkItemsSummary
 */
export interface WorkItemsSummary {
    /**
     * The count of open work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'open'?: number;
    /**
     * The count of completed work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'completed'?: number;
    /**
     * The count of total work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface Workflow
 */
export interface Workflow {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof Workflow
     */
    'name'?: string;
    /**
     * 
     * @type {WorkflowBodyOwner}
     * @memberof Workflow
     */
    'owner'?: WorkflowBodyOwner;
    /**
     * Description of what the workflow accomplishes
     * @type {string}
     * @memberof Workflow
     */
    'description'?: string;
    /**
     * 
     * @type {WorkflowDefinition}
     * @memberof Workflow
     */
    'definition'?: WorkflowDefinition;
    /**
     * Enable or disable the workflow.  Workflows cannot be created in an enabled state.
     * @type {boolean}
     * @memberof Workflow
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {WorkflowTrigger}
     * @memberof Workflow
     */
    'trigger'?: WorkflowTrigger;
    /**
     * Workflow ID. This is a UUID generated upon creation.
     * @type {string}
     * @memberof Workflow
     */
    'id'?: string;
    /**
     * The number of times this workflow has been executed.
     * @type {number}
     * @memberof Workflow
     */
    'executionCount'?: number;
    /**
     * The number of times this workflow has failed during execution.
     * @type {number}
     * @memberof Workflow
     */
    'failureCount'?: number;
    /**
     * The date and time the workflow was created.
     * @type {string}
     * @memberof Workflow
     */
    'created'?: string;
    /**
     * The date and time the workflow was modified.
     * @type {string}
     * @memberof Workflow
     */
    'modified'?: string;
    /**
     * 
     * @type {WorkflowModifiedBy}
     * @memberof Workflow
     */
    'modifiedBy'?: WorkflowModifiedBy;
    /**
     * 
     * @type {WorkflowAllOfCreator}
     * @memberof Workflow
     */
    'creator'?: WorkflowAllOfCreator;
}
/**
 * Workflow creator\'s identity.
 * @export
 * @interface WorkflowAllOfCreator
 */
export interface WorkflowAllOfCreator {
    /**
     * Workflow creator\'s DTO type.
     * @type {string}
     * @memberof WorkflowAllOfCreator
     */
    'type'?: WorkflowAllOfCreatorTypeV3;
    /**
     * Workflow creator\'s identity ID.
     * @type {string}
     * @memberof WorkflowAllOfCreator
     */
    'id'?: string;
    /**
     * Workflow creator\'s display name.
     * @type {string}
     * @memberof WorkflowAllOfCreator
     */
    'name'?: string;
}

export const WorkflowAllOfCreatorTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type WorkflowAllOfCreatorTypeV3 = typeof WorkflowAllOfCreatorTypeV3[keyof typeof WorkflowAllOfCreatorTypeV3];

/**
 * 
 * @export
 * @interface WorkflowBody
 */
export interface WorkflowBody {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof WorkflowBody
     */
    'name'?: string;
    /**
     * 
     * @type {WorkflowBodyOwner}
     * @memberof WorkflowBody
     */
    'owner'?: WorkflowBodyOwner;
    /**
     * Description of what the workflow accomplishes
     * @type {string}
     * @memberof WorkflowBody
     */
    'description'?: string;
    /**
     * 
     * @type {WorkflowDefinition}
     * @memberof WorkflowBody
     */
    'definition'?: WorkflowDefinition;
    /**
     * Enable or disable the workflow.  Workflows cannot be created in an enabled state.
     * @type {boolean}
     * @memberof WorkflowBody
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {WorkflowTrigger}
     * @memberof WorkflowBody
     */
    'trigger'?: WorkflowTrigger;
}
/**
 * The identity that owns the workflow.  The owner\'s permissions in IDN will determine what actions the workflow is allowed to perform.  Ownership can be changed by updating the owner in a PUT or PATCH request.
 * @export
 * @interface WorkflowBodyOwner
 */
export interface WorkflowBodyOwner {
    /**
     * The type of object that is referenced
     * @type {string}
     * @memberof WorkflowBodyOwner
     */
    'type'?: WorkflowBodyOwnerTypeV3;
    /**
     * The unique ID of the object
     * @type {string}
     * @memberof WorkflowBodyOwner
     */
    'id'?: string;
    /**
     * The name of the object
     * @type {string}
     * @memberof WorkflowBodyOwner
     */
    'name'?: string;
}

export const WorkflowBodyOwnerTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type WorkflowBodyOwnerTypeV3 = typeof WorkflowBodyOwnerTypeV3[keyof typeof WorkflowBodyOwnerTypeV3];

/**
 * The map of steps that the workflow will execute.
 * @export
 * @interface WorkflowDefinition
 */
export interface WorkflowDefinition {
    /**
     * The name of the starting step.
     * @type {string}
     * @memberof WorkflowDefinition
     */
    'start'?: string;
    /**
     * One or more step objects that comprise this workflow.  Please see the Workflow documentation to see the JSON schema for each step type.
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowDefinition
     */
    'steps'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface WorkflowExecution
 */
export interface WorkflowExecution {
    /**
     * Workflow execution ID.
     * @type {string}
     * @memberof WorkflowExecution
     */
    'id'?: string;
    /**
     * Workflow ID.
     * @type {string}
     * @memberof WorkflowExecution
     */
    'workflowId'?: string;
    /**
     * Backend ID that tracks a workflow request in the system. Provide this ID in a customer support ticket for debugging purposes.
     * @type {string}
     * @memberof WorkflowExecution
     */
    'requestId'?: string;
    /**
     * Date/time when the workflow started.
     * @type {string}
     * @memberof WorkflowExecution
     */
    'startTime'?: string;
    /**
     * Date/time when the workflow ended.
     * @type {string}
     * @memberof WorkflowExecution
     */
    'closeTime'?: string;
    /**
     * Workflow execution status.
     * @type {string}
     * @memberof WorkflowExecution
     */
    'status'?: WorkflowExecutionStatusV3;
}

export const WorkflowExecutionStatusV3 = {
    Completed: 'Completed',
    Failed: 'Failed',
    Canceled: 'Canceled',
    Running: 'Running'
} as const;

export type WorkflowExecutionStatusV3 = typeof WorkflowExecutionStatusV3[keyof typeof WorkflowExecutionStatusV3];

/**
 * 
 * @export
 * @interface WorkflowExecutionEvent
 */
export interface WorkflowExecutionEvent {
    /**
     * The type of event
     * @type {string}
     * @memberof WorkflowExecutionEvent
     */
    'type'?: WorkflowExecutionEventTypeV3;
    /**
     * The date-time when the event occurred
     * @type {string}
     * @memberof WorkflowExecutionEvent
     */
    'timestamp'?: string;
    /**
     * Additional attributes associated with the event
     * @type {object}
     * @memberof WorkflowExecutionEvent
     */
    'attributes'?: object;
}

export const WorkflowExecutionEventTypeV3 = {
    WorkflowExecutionScheduled: 'WorkflowExecutionScheduled',
    WorkflowExecutionStarted: 'WorkflowExecutionStarted',
    WorkflowExecutionCompleted: 'WorkflowExecutionCompleted',
    WorkflowExecutionFailed: 'WorkflowExecutionFailed',
    WorkflowTaskScheduled: 'WorkflowTaskScheduled',
    WorkflowTaskStarted: 'WorkflowTaskStarted',
    WorkflowTaskCompleted: 'WorkflowTaskCompleted',
    WorkflowTaskFailed: 'WorkflowTaskFailed',
    ActivityTaskScheduled: 'ActivityTaskScheduled',
    ActivityTaskStarted: 'ActivityTaskStarted',
    ActivityTaskCompleted: 'ActivityTaskCompleted',
    ActivityTaskFailed: 'ActivityTaskFailed',
    StartChildWorkflowExecutionInitiated: 'StartChildWorkflowExecutionInitiated',
    ChildWorkflowExecutionStarted: 'ChildWorkflowExecutionStarted',
    ChildWorkflowExecutionCompleted: 'ChildWorkflowExecutionCompleted',
    ChildWorkflowExecutionFailed: 'ChildWorkflowExecutionFailed'
} as const;

export type WorkflowExecutionEventTypeV3 = typeof WorkflowExecutionEventTypeV3[keyof typeof WorkflowExecutionEventTypeV3];

/**
 * 
 * @export
 * @interface WorkflowLibraryAction
 */
export interface WorkflowLibraryAction {
    /**
     * Action ID. This is a static namespaced ID for the action
     * @type {string}
     * @memberof WorkflowLibraryAction
     */
    'id'?: string;
    /**
     * Action Name
     * @type {string}
     * @memberof WorkflowLibraryAction
     */
    'name'?: string;
    /**
     * Action type
     * @type {string}
     * @memberof WorkflowLibraryAction
     */
    'type'?: string;
    /**
     * Action Description
     * @type {string}
     * @memberof WorkflowLibraryAction
     */
    'description'?: string;
    /**
     * One or more inputs that the action accepts
     * @type {Array<WorkflowLibraryFormFields>}
     * @memberof WorkflowLibraryAction
     */
    'formFields'?: Array<WorkflowLibraryFormFields> | null;
    /**
     * 
     * @type {WorkflowLibraryActionExampleOutput}
     * @memberof WorkflowLibraryAction
     */
    'exampleOutput'?: WorkflowLibraryActionExampleOutput;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowLibraryAction
     */
    'deprecated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkflowLibraryAction
     */
    'deprecatedBy'?: string;
    /**
     * Version number
     * @type {number}
     * @memberof WorkflowLibraryAction
     */
    'versionNumber'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowLibraryAction
     */
    'isSimulationEnabled'?: boolean;
    /**
     * Determines whether the dynamic output schema is returned in place of the action\'s output schema. The dynamic schema lists non-static properties, like properties of a workflow form where each form has different fields. These will be provided dynamically based on available form fields.
     * @type {boolean}
     * @memberof WorkflowLibraryAction
     */
    'isDynamicSchema'?: boolean;
    /**
     * Defines the output schema, if any, that this action produces.
     * @type {object}
     * @memberof WorkflowLibraryAction
     */
    'outputSchema'?: object;
}
/**
 * @type WorkflowLibraryActionExampleOutput
 * @export
 */
export type WorkflowLibraryActionExampleOutput = Array<object> | object;

/**
 * 
 * @export
 * @interface WorkflowLibraryFormFields
 */
export interface WorkflowLibraryFormFields {
    /**
     * Description of the form field
     * @type {string}
     * @memberof WorkflowLibraryFormFields
     */
    'description'?: string;
    /**
     * Describes the form field in the UI
     * @type {string}
     * @memberof WorkflowLibraryFormFields
     */
    'helpText'?: string;
    /**
     * A human readable name for this form field in the UI
     * @type {string}
     * @memberof WorkflowLibraryFormFields
     */
    'label'?: string;
    /**
     * The name of the input attribute
     * @type {string}
     * @memberof WorkflowLibraryFormFields
     */
    'name'?: string;
    /**
     * Denotes if this field is a required attribute
     * @type {boolean}
     * @memberof WorkflowLibraryFormFields
     */
    'required'?: boolean;
    /**
     * The type of the form field
     * @type {string}
     * @memberof WorkflowLibraryFormFields
     */
    'type'?: WorkflowLibraryFormFieldsTypeV3 | null;
}

export const WorkflowLibraryFormFieldsTypeV3 = {
    Text: 'text',
    Textarea: 'textarea',
    Boolean: 'boolean',
    Email: 'email',
    Url: 'url',
    Number: 'number',
    Json: 'json',
    Checkbox: 'checkbox',
    Jsonpath: 'jsonpath',
    Select: 'select',
    MultiType: 'multiType',
    Duration: 'duration',
    Toggle: 'toggle',
    FormPicker: 'formPicker',
    IdentityPicker: 'identityPicker',
    GovernanceGroupPicker: 'governanceGroupPicker',
    String: 'string',
    Object: 'object',
    Array: 'array',
    Secret: 'secret',
    KeyValuePairs: 'keyValuePairs',
    EmailPicker: 'emailPicker',
    AdvancedToggle: 'advancedToggle',
    VariableCreator: 'variableCreator',
    HtmlEditor: 'htmlEditor'
} as const;

export type WorkflowLibraryFormFieldsTypeV3 = typeof WorkflowLibraryFormFieldsTypeV3[keyof typeof WorkflowLibraryFormFieldsTypeV3];

/**
 * 
 * @export
 * @interface WorkflowLibraryOperator
 */
export interface WorkflowLibraryOperator {
    /**
     * Operator ID.
     * @type {string}
     * @memberof WorkflowLibraryOperator
     */
    'id'?: string;
    /**
     * Operator friendly name
     * @type {string}
     * @memberof WorkflowLibraryOperator
     */
    'name'?: string;
    /**
     * Operator type
     * @type {string}
     * @memberof WorkflowLibraryOperator
     */
    'type'?: string;
    /**
     * Description of the operator
     * @type {string}
     * @memberof WorkflowLibraryOperator
     */
    'description'?: string;
    /**
     * Determines whether the dynamic output schema is returned in place of the action\'s output schema. The dynamic schema lists non-static properties, like properties of a workflow form where each form has different fields. These will be provided dynamically based on available form fields.
     * @type {boolean}
     * @memberof WorkflowLibraryOperator
     */
    'isDynamicSchema'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowLibraryOperator
     */
    'deprecated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkflowLibraryOperator
     */
    'deprecatedBy'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowLibraryOperator
     */
    'isSimulationEnabled'?: boolean;
    /**
     * One or more inputs that the operator accepts
     * @type {Array<WorkflowLibraryFormFields>}
     * @memberof WorkflowLibraryOperator
     */
    'formFields'?: Array<WorkflowLibraryFormFields> | null;
}
/**
 * 
 * @export
 * @interface WorkflowLibraryTrigger
 */
export interface WorkflowLibraryTrigger {
    /**
     * Trigger ID. This is a static namespaced ID for the trigger.
     * @type {string}
     * @memberof WorkflowLibraryTrigger
     */
    'id'?: string;
    /**
     * Trigger type
     * @type {string}
     * @memberof WorkflowLibraryTrigger
     */
    'type'?: WorkflowLibraryTriggerTypeV3;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowLibraryTrigger
     */
    'deprecated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkflowLibraryTrigger
     */
    'deprecatedBy'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowLibraryTrigger
     */
    'isSimulationEnabled'?: boolean;
    /**
     * Example output schema
     * @type {object}
     * @memberof WorkflowLibraryTrigger
     */
    'outputSchema'?: object;
    /**
     * Trigger Name
     * @type {string}
     * @memberof WorkflowLibraryTrigger
     */
    'name'?: string;
    /**
     * Trigger Description
     * @type {string}
     * @memberof WorkflowLibraryTrigger
     */
    'description'?: string;
    /**
     * Determines whether the dynamic output schema is returned in place of the action\'s output schema. The dynamic schema lists non-static properties, like properties of a workflow form where each form has different fields. These will be provided dynamically based on available form fields.
     * @type {boolean}
     * @memberof WorkflowLibraryTrigger
     */
    'isDynamicSchema'?: boolean;
    /**
     * Example trigger payload if applicable
     * @type {object}
     * @memberof WorkflowLibraryTrigger
     */
    'inputExample'?: object | null;
    /**
     * One or more inputs that the trigger accepts
     * @type {Array<WorkflowLibraryFormFields>}
     * @memberof WorkflowLibraryTrigger
     */
    'formFields'?: Array<WorkflowLibraryFormFields> | null;
}

export const WorkflowLibraryTriggerTypeV3 = {
    Event: 'EVENT',
    Scheduled: 'SCHEDULED',
    External: 'EXTERNAL'
} as const;

export type WorkflowLibraryTriggerTypeV3 = typeof WorkflowLibraryTriggerTypeV3[keyof typeof WorkflowLibraryTriggerTypeV3];

/**
 * 
 * @export
 * @interface WorkflowModifiedBy
 */
export interface WorkflowModifiedBy {
    /**
     * 
     * @type {string}
     * @memberof WorkflowModifiedBy
     */
    'type'?: WorkflowModifiedByTypeV3;
    /**
     * Identity ID
     * @type {string}
     * @memberof WorkflowModifiedBy
     */
    'id'?: string;
    /**
     * Human-readable display name of identity.
     * @type {string}
     * @memberof WorkflowModifiedBy
     */
    'name'?: string;
}

export const WorkflowModifiedByTypeV3 = {
    Identity: 'IDENTITY'
} as const;

export type WorkflowModifiedByTypeV3 = typeof WorkflowModifiedByTypeV3[keyof typeof WorkflowModifiedByTypeV3];

/**
 * 
 * @export
 * @interface WorkflowOAuthClient
 */
export interface WorkflowOAuthClient {
    /**
     * OAuth client ID for the trigger. This is a UUID generated upon creation.
     * @type {string}
     * @memberof WorkflowOAuthClient
     */
    'id'?: string;
    /**
     * OAuthClient secret.
     * @type {string}
     * @memberof WorkflowOAuthClient
     */
    'secret'?: string;
    /**
     * URL for the external trigger to invoke
     * @type {string}
     * @memberof WorkflowOAuthClient
     */
    'url'?: string;
}
/**
 * The trigger that starts the workflow
 * @export
 * @interface WorkflowTrigger
 */
export interface WorkflowTrigger {
    /**
     * The trigger type
     * @type {string}
     * @memberof WorkflowTrigger
     */
    'type': WorkflowTriggerTypeV3;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTrigger
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {WorkflowTriggerAttributes}
     * @memberof WorkflowTrigger
     */
    'attributes': WorkflowTriggerAttributes | null;
}

export const WorkflowTriggerTypeV3 = {
    Event: 'EVENT',
    External: 'EXTERNAL',
    Scheduled: 'SCHEDULED',
    Empty: ''
} as const;

export type WorkflowTriggerTypeV3 = typeof WorkflowTriggerTypeV3[keyof typeof WorkflowTriggerTypeV3];

/**
 * Workflow Trigger Attributes.
 * @export
 * @interface WorkflowTriggerAttributes
 */
export interface WorkflowTriggerAttributes {
    /**
     * The unique ID of the trigger
     * @type {string}
     * @memberof WorkflowTriggerAttributes
     */
    'id': string;
    /**
     * JSON path expression that will limit which events the trigger will fire on
     * @type {string}
     * @memberof WorkflowTriggerAttributes
     */
    'filter.$'?: string;
    /**
     * Additonal context about the external trigger
     * @type {string}
     * @memberof WorkflowTriggerAttributes
     */
    'description'?: string;
    /**
     * The attribute to filter on
     * @type {string}
     * @memberof WorkflowTriggerAttributes
     */
    'attributeToFilter'?: string;
    /**
     * A unique name for the external trigger
     * @type {string}
     * @memberof WorkflowTriggerAttributes
     */
    'name'?: string;
    /**
     * OAuth Client ID to authenticate with this trigger
     * @type {string}
     * @memberof WorkflowTriggerAttributes
     */
    'clientId'?: string;
    /**
     * URL to invoke this workflow
     * @type {string}
     * @memberof WorkflowTriggerAttributes
     */
    'url'?: string;
    /**
     * A valid CRON expression
     * @type {string}
     * @memberof WorkflowTriggerAttributes
     */
    'cronString'?: string;
    /**
     * Frequency of execution
     * @type {string}
     * @memberof WorkflowTriggerAttributes
     */
    'frequency': WorkflowTriggerAttributesFrequencyV3;
    /**
     * Time zone identifier
     * @type {string}
     * @memberof WorkflowTriggerAttributes
     */
    'timeZone'?: string;
    /**
     * Scheduled days of the week for execution
     * @type {Array<string>}
     * @memberof WorkflowTriggerAttributes
     */
    'weeklyDays'?: Array<string>;
    /**
     * Scheduled execution times
     * @type {Array<string>}
     * @memberof WorkflowTriggerAttributes
     */
    'weeklyTimes'?: Array<string>;
}

export const WorkflowTriggerAttributesFrequencyV3 = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly',
    Yearly: 'yearly',
    CronSchedule: 'cronSchedule'
} as const;

export type WorkflowTriggerAttributesFrequencyV3 = typeof WorkflowTriggerAttributesFrequencyV3[keyof typeof WorkflowTriggerAttributesFrequencyV3];


/**
 * AccessProfilesApi - axios parameter creator
 * @export
 */
export const AccessProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to create an access profile. A user with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the access profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles. However, any new access profiles as well as any updates to existing descriptions are limited to 2000 characters.
         * @summary Create Access Profile
         * @param {AccessProfile} accessProfile 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessProfile: async (accessProfile: AccessProfile, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessProfile' is not null or undefined
            assertParamExists('createAccessProfile', 'accessProfile', accessProfile)
            const localVarPath = `/access-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessProfile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A user with SOURCE_SUBADMIN must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {string} id ID of the Access Profile to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfile: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAccessProfile', 'id', id)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint initiates a bulk deletion of one or more access profiles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 access profiles per request.  By default, if any of the indicated access profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated access profiles will be deleted. A SOURCE_SUBADMIN user can only use this endpoint to delete access profiles associated with sources they\'re able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequest} accessProfileBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfilesInBulk: async (accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessProfileBulkDeleteRequest' is not null or undefined
            assertParamExists('deleteAccessProfilesInBulk', 'accessProfileBulkDeleteRequest', accessProfileBulkDeleteRequest)
            const localVarPath = `/access-profiles/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessProfileBulkDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns an Access Profile by its ID.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfile: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccessProfile', 'id', id)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get a list of an access profile\'s entitlements.  A SOURCE_SUBADMIN user must have access to the source associated with the specified access profile. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank. 
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the access profile containing the entitlements.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names. 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfileEntitlements: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccessProfileEntitlements', 'id', id)
            const localVarPath = `/access-profiles/{id}/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get a list of access profiles. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank. 
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN identity. The value of the parameter is either an identity ID, or the special value **me**, which is shorthand for the calling identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*  Composite operators supported: *and, or*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names. 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters access profiles to those which are assigned to the segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Indicates whether the response list should contain unsegmented access profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessProfiles: async (forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSegmentIds !== undefined) {
                localVarQueryParameter['for-segment-ids'] = forSegmentIds;
            }

            if (includeUnsegmented !== undefined) {
                localVarQueryParameter['include-unsegmented'] = includeUnsegmented;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A user with SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessProfile: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchAccessProfile', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchAccessProfile', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessProfilesApi - functional programming interface
 * @export
 */
export const AccessProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to create an access profile. A user with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the access profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles. However, any new access profiles as well as any updates to existing descriptions are limited to 2000 characters.
         * @summary Create Access Profile
         * @param {AccessProfile} accessProfile 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessProfile(accessProfile: AccessProfile, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessProfile(accessProfile, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessProfilesApi.createAccessProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A user with SOURCE_SUBADMIN must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {string} id ID of the Access Profile to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccessProfile(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccessProfile(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessProfilesApi.deleteAccessProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint initiates a bulk deletion of one or more access profiles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 access profiles per request.  By default, if any of the indicated access profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated access profiles will be deleted. A SOURCE_SUBADMIN user can only use this endpoint to delete access profiles associated with sources they\'re able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequest} accessProfileBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfileBulkDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessProfilesApi.deleteAccessProfilesInBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns an Access Profile by its ID.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessProfile(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessProfile(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessProfilesApi.getAccessProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to get a list of an access profile\'s entitlements.  A SOURCE_SUBADMIN user must have access to the source associated with the specified access profile. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank. 
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the access profile containing the entitlements.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names. 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessProfileEntitlements(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Entitlement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessProfileEntitlements(id, limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessProfilesApi.getAccessProfileEntitlements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to get a list of access profiles. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank. 
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN identity. The value of the parameter is either an identity ID, or the special value **me**, which is shorthand for the calling identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*  Composite operators supported: *and, or*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names. 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters access profiles to those which are assigned to the segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Indicates whether the response list should contain unsegmented access profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessProfiles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessProfiles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessProfilesApi.listAccessProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A user with SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccessProfile(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAccessProfile(id, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessProfilesApi.patchAccessProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccessProfilesApi - factory interface
 * @export
 */
export const AccessProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessProfilesApiFp(configuration)
    return {
        /**
         * Use this API to create an access profile. A user with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the access profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles. However, any new access profiles as well as any updates to existing descriptions are limited to 2000 characters.
         * @summary Create Access Profile
         * @param {AccessProfilesApiCreateAccessProfileRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessProfile(requestParameters: AccessProfilesApiCreateAccessProfileRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccessProfile> {
            return localVarFp.createAccessProfile(requestParameters.accessProfile, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A user with SOURCE_SUBADMIN must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {AccessProfilesApiDeleteAccessProfileRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfile(requestParameters: AccessProfilesApiDeleteAccessProfileRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAccessProfile(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint initiates a bulk deletion of one or more access profiles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 access profiles per request.  By default, if any of the indicated access profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated access profiles will be deleted. A SOURCE_SUBADMIN user can only use this endpoint to delete access profiles associated with sources they\'re able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfilesApiDeleteAccessProfilesInBulkRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfilesInBulk(requestParameters: AccessProfilesApiDeleteAccessProfilesInBulkRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccessProfileBulkDeleteResponse> {
            return localVarFp.deleteAccessProfilesInBulk(requestParameters.accessProfileBulkDeleteRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns an Access Profile by its ID.
         * @summary Get an Access Profile
         * @param {AccessProfilesApiGetAccessProfileRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfile(requestParameters: AccessProfilesApiGetAccessProfileRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccessProfile> {
            return localVarFp.getAccessProfile(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get a list of an access profile\'s entitlements.  A SOURCE_SUBADMIN user must have access to the source associated with the specified access profile. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank. 
         * @summary List Access Profile\'s Entitlements
         * @param {AccessProfilesApiGetAccessProfileEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfileEntitlements(requestParameters: AccessProfilesApiGetAccessProfileEntitlementsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<Entitlement>> {
            return localVarFp.getAccessProfileEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get a list of access profiles. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank. 
         * @summary List Access Profiles
         * @param {AccessProfilesApiListAccessProfilesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessProfiles(requestParameters: AccessProfilesApiListAccessProfilesRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<AccessProfile>> {
            return localVarFp.listAccessProfiles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A user with SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.
         * @summary Patch a specified Access Profile
         * @param {AccessProfilesApiPatchAccessProfileRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessProfile(requestParameters: AccessProfilesApiPatchAccessProfileRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccessProfile> {
            return localVarFp.patchAccessProfile(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiCreateAccessProfileRequest
 */
export interface AccessProfilesApiCreateAccessProfileRequest {
    /**
     * 
     * @type {AccessProfile}
     * @memberof AccessProfilesApiCreateAccessProfile
     */
    readonly accessProfile: AccessProfile
}

/**
 * Request parameters for deleteAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiDeleteAccessProfileRequest
 */
export interface AccessProfilesApiDeleteAccessProfileRequest {
    /**
     * ID of the Access Profile to delete
     * @type {string}
     * @memberof AccessProfilesApiDeleteAccessProfile
     */
    readonly id: string
}

/**
 * Request parameters for deleteAccessProfilesInBulk operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiDeleteAccessProfilesInBulkRequest
 */
export interface AccessProfilesApiDeleteAccessProfilesInBulkRequest {
    /**
     * 
     * @type {AccessProfileBulkDeleteRequest}
     * @memberof AccessProfilesApiDeleteAccessProfilesInBulk
     */
    readonly accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest
}

/**
 * Request parameters for getAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiGetAccessProfileRequest
 */
export interface AccessProfilesApiGetAccessProfileRequest {
    /**
     * ID of the Access Profile
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfile
     */
    readonly id: string
}

/**
 * Request parameters for getAccessProfileEntitlements operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiGetAccessProfileEntitlementsRequest
 */
export interface AccessProfilesApiGetAccessProfileEntitlementsRequest {
    /**
     * ID of the access profile containing the entitlements.
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names. 
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly sorters?: string
}

/**
 * Request parameters for listAccessProfiles operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiListAccessProfilesRequest
 */
export interface AccessProfilesApiListAccessProfilesRequest {
    /**
     * If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN identity. The value of the parameter is either an identity ID, or the special value **me**, which is shorthand for the calling identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an identity that is not a subadmin.
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly forSubadmin?: string

    /**
     * Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*  Composite operators supported: *and, or*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names. 
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly sorters?: string

    /**
     * If present and not empty, additionally filters access profiles to those which are assigned to the segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly forSegmentIds?: string

    /**
     * Indicates whether the response list should contain unsegmented access profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
     * @type {boolean}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly includeUnsegmented?: boolean
}

/**
 * Request parameters for patchAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiPatchAccessProfileRequest
 */
export interface AccessProfilesApiPatchAccessProfileRequest {
    /**
     * ID of the Access Profile to patch
     * @type {string}
     * @memberof AccessProfilesApiPatchAccessProfile
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperation>}
     * @memberof AccessProfilesApiPatchAccessProfile
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * AccessProfilesApi - object-oriented interface
 * @export
 * @class AccessProfilesApi
 * @extends {BaseAPI}
 */
export class AccessProfilesApi extends BaseAPI {
    /**
     * Use this API to create an access profile. A user with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the access profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles. However, any new access profiles as well as any updates to existing descriptions are limited to 2000 characters.
     * @summary Create Access Profile
     * @param {AccessProfilesApiCreateAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public createAccessProfile(requestParameters: AccessProfilesApiCreateAccessProfileRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).createAccessProfile(requestParameters.accessProfile, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A user with SOURCE_SUBADMIN must be able to administer the Source associated with the Access Profile.
     * @summary Delete the specified Access Profile
     * @param {AccessProfilesApiDeleteAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public deleteAccessProfile(requestParameters: AccessProfilesApiDeleteAccessProfileRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).deleteAccessProfile(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint initiates a bulk deletion of one or more access profiles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 access profiles per request.  By default, if any of the indicated access profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated access profiles will be deleted. A SOURCE_SUBADMIN user can only use this endpoint to delete access profiles associated with sources they\'re able to administer.
     * @summary Delete Access Profile(s)
     * @param {AccessProfilesApiDeleteAccessProfilesInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public deleteAccessProfilesInBulk(requestParameters: AccessProfilesApiDeleteAccessProfilesInBulkRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).deleteAccessProfilesInBulk(requestParameters.accessProfileBulkDeleteRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns an Access Profile by its ID.
     * @summary Get an Access Profile
     * @param {AccessProfilesApiGetAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public getAccessProfile(requestParameters: AccessProfilesApiGetAccessProfileRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).getAccessProfile(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get a list of an access profile\'s entitlements.  A SOURCE_SUBADMIN user must have access to the source associated with the specified access profile. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank. 
     * @summary List Access Profile\'s Entitlements
     * @param {AccessProfilesApiGetAccessProfileEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public getAccessProfileEntitlements(requestParameters: AccessProfilesApiGetAccessProfileEntitlementsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).getAccessProfileEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get a list of access profiles. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank. 
     * @summary List Access Profiles
     * @param {AccessProfilesApiListAccessProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public listAccessProfiles(requestParameters: AccessProfilesApiListAccessProfilesRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).listAccessProfiles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A user with SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.
     * @summary Patch a specified Access Profile
     * @param {AccessProfilesApiPatchAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public patchAccessProfile(requestParameters: AccessProfilesApiPatchAccessProfileRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).patchAccessProfile(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccessRequestApprovalsApi - axios parameter creator
 * @export
 */
export const AccessRequestApprovalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to approve an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approve Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveAccessRequest: async (approvalId: string, commentDto?: CommentDto, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('approveAccessRequest', 'approvalId', approvalId)
            const localVarPath = `/access-request-approvals/{approvalId}/approve`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to forward an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forward Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardAccessRequest: async (approvalId: string, forwardApprovalDto: ForwardApprovalDto, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('forwardAccessRequest', 'approvalId', approvalId)
            // verify required parameter 'forwardApprovalDto' is not null or undefined
            assertParamExists('forwardAccessRequest', 'forwardApprovalDto', forwardApprovalDto)
            const localVarPath = `/access-request-approvals/{approvalId}/forward`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forwardApprovalDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to return the number of pending, approved and rejected access requests approvals. See the \"owner-id\" query parameter for authorization information. info.
         * @summary Get Access Requests Approvals Number
         * @param {string} [ownerId] The ID of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] This is the date and time the results will be shown from. It must be in a valid ISO-8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestApprovalSummary: async (ownerId?: string, fromDate?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/approval-summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = fromDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **requestedFor.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le, eq, in*  **accessRequestId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to reject an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Reject Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectAccessRequest: async (approvalId: string, commentDto: CommentDto, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('rejectAccessRequest', 'approvalId', approvalId)
            // verify required parameter 'commentDto' is not null or undefined
            assertParamExists('rejectAccessRequest', 'commentDto', commentDto)
            const localVarPath = `/access-request-approvals/{approvalId}/reject`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRequestApprovalsApi - functional programming interface
 * @export
 */
export const AccessRequestApprovalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessRequestApprovalsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to approve an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approve Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveAccessRequest(approvalId: string, commentDto?: CommentDto, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveAccessRequest(approvalId, commentDto, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessRequestApprovalsApi.approveAccessRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to forward an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forward Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async forwardAccessRequest(approvalId: string, forwardApprovalDto: ForwardApprovalDto, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forwardAccessRequest(approvalId, forwardApprovalDto, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessRequestApprovalsApi.forwardAccessRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to return the number of pending, approved and rejected access requests approvals. See the \"owner-id\" query parameter for authorization information. info.
         * @summary Get Access Requests Approvals Number
         * @param {string} [ownerId] The ID of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] This is the date and time the results will be shown from. It must be in a valid ISO-8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestApprovalSummary(ownerId?: string, fromDate?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestApprovalSummary(ownerId, fromDate, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessRequestApprovalsApi.getAccessRequestApprovalSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **requestedFor.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCompletedApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompletedApproval>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCompletedApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessRequestApprovalsApi.listCompletedApprovals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le, eq, in*  **accessRequestId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPendingApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PendingApproval>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPendingApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessRequestApprovalsApi.listPendingApprovals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to reject an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Reject Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectAccessRequest(approvalId: string, commentDto: CommentDto, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectAccessRequest(approvalId, commentDto, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessRequestApprovalsApi.rejectAccessRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccessRequestApprovalsApi - factory interface
 * @export
 */
export const AccessRequestApprovalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessRequestApprovalsApiFp(configuration)
    return {
        /**
         * Use this endpoint to approve an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approve Access Request Approval
         * @param {AccessRequestApprovalsApiApproveAccessRequestRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveAccessRequest(requestParameters: AccessRequestApprovalsApiApproveAccessRequestRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.approveAccessRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to forward an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forward Access Request Approval
         * @param {AccessRequestApprovalsApiForwardAccessRequestRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardAccessRequest(requestParameters: AccessRequestApprovalsApiForwardAccessRequestRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.forwardAccessRequest(requestParameters.approvalId, requestParameters.forwardApprovalDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to return the number of pending, approved and rejected access requests approvals. See the \"owner-id\" query parameter for authorization information. info.
         * @summary Get Access Requests Approvals Number
         * @param {AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestApprovalSummary(requestParameters: AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ApprovalSummary> {
            return localVarFp.getAccessRequestApprovalSummary(requestParameters.ownerId, requestParameters.fromDate, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {AccessRequestApprovalsApiListCompletedApprovalsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals(requestParameters: AccessRequestApprovalsApiListCompletedApprovalsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<CompletedApproval>> {
            return localVarFp.listCompletedApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {AccessRequestApprovalsApiListPendingApprovalsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals(requestParameters: AccessRequestApprovalsApiListPendingApprovalsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<PendingApproval>> {
            return localVarFp.listPendingApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to reject an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Reject Access Request Approval
         * @param {AccessRequestApprovalsApiRejectAccessRequestRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectAccessRequest(requestParameters: AccessRequestApprovalsApiRejectAccessRequestRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.rejectAccessRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveAccessRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiApproveAccessRequestRequest
 */
export interface AccessRequestApprovalsApiApproveAccessRequestRequest {
    /**
     * Approval ID.
     * @type {string}
     * @memberof AccessRequestApprovalsApiApproveAccessRequest
     */
    readonly approvalId: string

    /**
     * Reviewer\&#39;s comment.
     * @type {CommentDto}
     * @memberof AccessRequestApprovalsApiApproveAccessRequest
     */
    readonly commentDto?: CommentDto
}

/**
 * Request parameters for forwardAccessRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiForwardAccessRequestRequest
 */
export interface AccessRequestApprovalsApiForwardAccessRequestRequest {
    /**
     * Approval ID.
     * @type {string}
     * @memberof AccessRequestApprovalsApiForwardAccessRequest
     */
    readonly approvalId: string

    /**
     * Information about the forwarded approval.
     * @type {ForwardApprovalDto}
     * @memberof AccessRequestApprovalsApiForwardAccessRequest
     */
    readonly forwardApprovalDto: ForwardApprovalDto
}

/**
 * Request parameters for getAccessRequestApprovalSummary operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest
 */
export interface AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest {
    /**
     * The ID of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiGetAccessRequestApprovalSummary
     */
    readonly ownerId?: string

    /**
     * This is the date and time the results will be shown from. It must be in a valid ISO-8601 format.
     * @type {string}
     * @memberof AccessRequestApprovalsApiGetAccessRequestApprovalSummary
     */
    readonly fromDate?: string
}

/**
 * Request parameters for listCompletedApprovals operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiListCompletedApprovalsRequest
 */
export interface AccessRequestApprovalsApiListCompletedApprovalsRequest {
    /**
     * If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **requestedFor.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, sw*
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for listPendingApprovals operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiListPendingApprovalsRequest
 */
export interface AccessRequestApprovalsApiListPendingApprovalsRequest {
    /**
     * If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le, eq, in*  **accessRequestId**: *eq, in*
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for rejectAccessRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiRejectAccessRequestRequest
 */
export interface AccessRequestApprovalsApiRejectAccessRequestRequest {
    /**
     * Approval ID.
     * @type {string}
     * @memberof AccessRequestApprovalsApiRejectAccessRequest
     */
    readonly approvalId: string

    /**
     * Reviewer\&#39;s comment.
     * @type {CommentDto}
     * @memberof AccessRequestApprovalsApiRejectAccessRequest
     */
    readonly commentDto: CommentDto
}

/**
 * AccessRequestApprovalsApi - object-oriented interface
 * @export
 * @class AccessRequestApprovalsApi
 * @extends {BaseAPI}
 */
export class AccessRequestApprovalsApi extends BaseAPI {
    /**
     * Use this endpoint to approve an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Approve Access Request Approval
     * @param {AccessRequestApprovalsApiApproveAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public approveAccessRequest(requestParameters: AccessRequestApprovalsApiApproveAccessRequestRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).approveAccessRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to forward an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Forward Access Request Approval
     * @param {AccessRequestApprovalsApiForwardAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public forwardAccessRequest(requestParameters: AccessRequestApprovalsApiForwardAccessRequestRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).forwardAccessRequest(requestParameters.approvalId, requestParameters.forwardApprovalDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to return the number of pending, approved and rejected access requests approvals. See the \"owner-id\" query parameter for authorization information. info.
     * @summary Get Access Requests Approvals Number
     * @param {AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public getAccessRequestApprovalSummary(requestParameters: AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).getAccessRequestApprovalSummary(requestParameters.ownerId, requestParameters.fromDate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
     * @summary Completed Access Request Approvals List
     * @param {AccessRequestApprovalsApiListCompletedApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public listCompletedApprovals(requestParameters: AccessRequestApprovalsApiListCompletedApprovalsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).listCompletedApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
     * @summary Pending Access Request Approvals List
     * @param {AccessRequestApprovalsApiListPendingApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public listPendingApprovals(requestParameters: AccessRequestApprovalsApiListPendingApprovalsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).listPendingApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to reject an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
     * @summary Reject Access Request Approval
     * @param {AccessRequestApprovalsApiRejectAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public rejectAccessRequest(requestParameters: AccessRequestApprovalsApiRejectAccessRequestRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).rejectAccessRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccessRequestsApi - axios parameter creator
 * @export
 */
export const AccessRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. In addition to users with ORG_ADMIN, any user who originally submitted the access request may cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest: async (cancelAccessRequest: CancelAccessRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelAccessRequest' is not null or undefined
            assertParamExists('cancelAccessRequest', 'cancelAccessRequest', cancelAccessRequest)
            const localVarPath = `/access-requests/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelAccessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to submit an access request in Identity Security Cloud (ISC), where it follows any ISC approval processes.  Access requests are processed asynchronously by ISC. A successful response from this endpoint means that the request has been submitted to ISC and is queued for processing. Because this endpoint is asynchronous, it doesn\'t return an error if you submit duplicate access requests in quick succession or submit an access request for access that is already in progress, approved, or rejected.  It\'s best practice to check for any existing access requests that reference the same access items before submitting a new access request. This can be accomplished by using the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [Pending Access Request Approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) APIs. You can also use the [Search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items an identity has before submitting an access request to ensure that you aren\'t requesting access that is already granted. If you use this API to request access that an identity already has, the API will ignore the request.  These ignored requests do not display when you use the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) API.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * You cannot use an access request to revoke access from an identity if that access has been granted by role membership or by birthright provisioning.  * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles, access profiles and entitlements. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A user with ORG_ADMIN authority can also request to revoke access from anyone. 
         * @summary Submit Access Request
         * @param {AccessRequest} accessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest: async (accessRequest: AccessRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequest' is not null or undefined
            assertParamExists('createAccessRequest', 'accessRequest', accessRequest)
            const localVarPath = `/access-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to return a list of access request statuses based on the specified query parameters. If an access request was made for access that an identity already has, the API ignores the access request.  These ignored requests do not display in the list of access request statuses. Any user with any user level can get the status of their own access requests. A user with ORG_ADMIN is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity the requests were made for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity who made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity who is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {string} [assignedTo] Filter the results by the specified identity who is the owner of the Identity Request Work Item. *me* indicates the current user.
         * @param {boolean} [count] If this is true, the *X-Total-Count* response header populates with the number of results that would be returned if limit and offset were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accessRequestId**: *in*  **accountActivityItemId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **created**: *eq, in, ge, gt, le, lt, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId, name**
         * @param {string} [requestState] Filter the results by the state of the request. The only valid value is *EXECUTING*.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus: async (requestedFor?: string, requestedBy?: string, regardingIdentity?: string, assignedTo?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, requestState?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (requestedBy !== undefined) {
                localVarQueryParameter['requested-by'] = requestedBy;
            }

            if (regardingIdentity !== undefined) {
                localVarQueryParameter['regarding-identity'] = regardingIdentity;
            }

            if (assignedTo !== undefined) {
                localVarQueryParameter['assigned-to'] = assignedTo;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (requestState !== undefined) {
                localVarQueryParameter['request-state'] = requestState;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint replaces the current access-request configuration.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setAccessRequestConfig: async (accessRequestConfig: AccessRequestConfig, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequestConfig' is not null or undefined
            assertParamExists('setAccessRequestConfig', 'accessRequestConfig', accessRequestConfig)
            const localVarPath = `/access-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequestConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRequestsApi - functional programming interface
 * @export
 */
export const AccessRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. In addition to users with ORG_ADMIN, any user who originally submitted the access request may cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelAccessRequest(cancelAccessRequest: CancelAccessRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelAccessRequest(cancelAccessRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessRequestsApi.cancelAccessRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to submit an access request in Identity Security Cloud (ISC), where it follows any ISC approval processes.  Access requests are processed asynchronously by ISC. A successful response from this endpoint means that the request has been submitted to ISC and is queued for processing. Because this endpoint is asynchronous, it doesn\'t return an error if you submit duplicate access requests in quick succession or submit an access request for access that is already in progress, approved, or rejected.  It\'s best practice to check for any existing access requests that reference the same access items before submitting a new access request. This can be accomplished by using the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [Pending Access Request Approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) APIs. You can also use the [Search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items an identity has before submitting an access request to ensure that you aren\'t requesting access that is already granted. If you use this API to request access that an identity already has, the API will ignore the request.  These ignored requests do not display when you use the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) API.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * You cannot use an access request to revoke access from an identity if that access has been granted by role membership or by birthright provisioning.  * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles, access profiles and entitlements. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A user with ORG_ADMIN authority can also request to revoke access from anyone. 
         * @summary Submit Access Request
         * @param {AccessRequest} accessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessRequest(accessRequest: AccessRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessRequest(accessRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessRequestsApi.createAccessRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestConfig(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestConfig(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessRequestsApi.getAccessRequestConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to return a list of access request statuses based on the specified query parameters. If an access request was made for access that an identity already has, the API ignores the access request.  These ignored requests do not display in the list of access request statuses. Any user with any user level can get the status of their own access requests. A user with ORG_ADMIN is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity the requests were made for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity who made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity who is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {string} [assignedTo] Filter the results by the specified identity who is the owner of the Identity Request Work Item. *me* indicates the current user.
         * @param {boolean} [count] If this is true, the *X-Total-Count* response header populates with the number of results that would be returned if limit and offset were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accessRequestId**: *in*  **accountActivityItemId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **created**: *eq, in, ge, gt, le, lt, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId, name**
         * @param {string} [requestState] Filter the results by the state of the request. The only valid value is *EXECUTING*.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessRequestStatus(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, assignedTo?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, requestState?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RequestedItemStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessRequestStatus(requestedFor, requestedBy, regardingIdentity, assignedTo, count, limit, offset, filters, sorters, requestState, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessRequestsApi.listAccessRequestStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint replaces the current access-request configuration.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setAccessRequestConfig(accessRequestConfig: AccessRequestConfig, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAccessRequestConfig(accessRequestConfig, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessRequestsApi.setAccessRequestConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccessRequestsApi - factory interface
 * @export
 */
export const AccessRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessRequestsApiFp(configuration)
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. In addition to users with ORG_ADMIN, any user who originally submitted the access request may cancel it.
         * @summary Cancel Access Request
         * @param {AccessRequestsApiCancelAccessRequestRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest(requestParameters: AccessRequestsApiCancelAccessRequestRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.cancelAccessRequest(requestParameters.cancelAccessRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to submit an access request in Identity Security Cloud (ISC), where it follows any ISC approval processes.  Access requests are processed asynchronously by ISC. A successful response from this endpoint means that the request has been submitted to ISC and is queued for processing. Because this endpoint is asynchronous, it doesn\'t return an error if you submit duplicate access requests in quick succession or submit an access request for access that is already in progress, approved, or rejected.  It\'s best practice to check for any existing access requests that reference the same access items before submitting a new access request. This can be accomplished by using the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [Pending Access Request Approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) APIs. You can also use the [Search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items an identity has before submitting an access request to ensure that you aren\'t requesting access that is already granted. If you use this API to request access that an identity already has, the API will ignore the request.  These ignored requests do not display when you use the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) API.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * You cannot use an access request to revoke access from an identity if that access has been granted by role membership or by birthright provisioning.  * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles, access profiles and entitlements. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A user with ORG_ADMIN authority can also request to revoke access from anyone. 
         * @summary Submit Access Request
         * @param {AccessRequestsApiCreateAccessRequestRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest(requestParameters: AccessRequestsApiCreateAccessRequestRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccessRequestResponse> {
            return localVarFp.createAccessRequest(requestParameters.accessRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccessRequestConfig> {
            return localVarFp.getAccessRequestConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to return a list of access request statuses based on the specified query parameters. If an access request was made for access that an identity already has, the API ignores the access request.  These ignored requests do not display in the list of access request statuses. Any user with any user level can get the status of their own access requests. A user with ORG_ADMIN is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {AccessRequestsApiListAccessRequestStatusRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus(requestParameters: AccessRequestsApiListAccessRequestStatusRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<RequestedItemStatus>> {
            return localVarFp.listAccessRequestStatus(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.assignedTo, requestParameters.count, requestParameters.limit, requestParameters.offset, requestParameters.filters, requestParameters.sorters, requestParameters.requestState, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint replaces the current access-request configuration.
         * @summary Update Access Request Configuration
         * @param {AccessRequestsApiSetAccessRequestConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setAccessRequestConfig(requestParameters: AccessRequestsApiSetAccessRequestConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccessRequestConfig> {
            return localVarFp.setAccessRequestConfig(requestParameters.accessRequestConfig, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelAccessRequest operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiCancelAccessRequestRequest
 */
export interface AccessRequestsApiCancelAccessRequestRequest {
    /**
     * 
     * @type {CancelAccessRequest}
     * @memberof AccessRequestsApiCancelAccessRequest
     */
    readonly cancelAccessRequest: CancelAccessRequest
}

/**
 * Request parameters for createAccessRequest operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiCreateAccessRequestRequest
 */
export interface AccessRequestsApiCreateAccessRequestRequest {
    /**
     * 
     * @type {AccessRequest}
     * @memberof AccessRequestsApiCreateAccessRequest
     */
    readonly accessRequest: AccessRequest
}

/**
 * Request parameters for listAccessRequestStatus operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiListAccessRequestStatusRequest
 */
export interface AccessRequestsApiListAccessRequestStatusRequest {
    /**
     * Filter the results by the identity the requests were made for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly requestedFor?: string

    /**
     * Filter the results by the identity who made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly requestedBy?: string

    /**
     * Filter the results by the specified identity who is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly regardingIdentity?: string

    /**
     * Filter the results by the specified identity who is the owner of the Identity Request Work Item. *me* indicates the current user.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly assignedTo?: string

    /**
     * If this is true, the *X-Total-Count* response header populates with the number of results that would be returned if limit and offset were ignored.
     * @type {boolean}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly count?: boolean

    /**
     * Max number of results to return.
     * @type {number}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
     * @type {number}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accessRequestId**: *in*  **accountActivityItemId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **created**: *eq, in, ge, gt, le, lt, ne, isnull, sw*
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId, name**
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly sorters?: string

    /**
     * Filter the results by the state of the request. The only valid value is *EXECUTING*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly requestState?: string
}

/**
 * Request parameters for setAccessRequestConfig operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiSetAccessRequestConfigRequest
 */
export interface AccessRequestsApiSetAccessRequestConfigRequest {
    /**
     * 
     * @type {AccessRequestConfig}
     * @memberof AccessRequestsApiSetAccessRequestConfig
     */
    readonly accessRequestConfig: AccessRequestConfig
}

/**
 * AccessRequestsApi - object-oriented interface
 * @export
 * @class AccessRequestsApi
 * @extends {BaseAPI}
 */
export class AccessRequestsApi extends BaseAPI {
    /**
     * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. In addition to users with ORG_ADMIN, any user who originally submitted the access request may cancel it.
     * @summary Cancel Access Request
     * @param {AccessRequestsApiCancelAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public cancelAccessRequest(requestParameters: AccessRequestsApiCancelAccessRequestRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).cancelAccessRequest(requestParameters.cancelAccessRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to submit an access request in Identity Security Cloud (ISC), where it follows any ISC approval processes.  Access requests are processed asynchronously by ISC. A successful response from this endpoint means that the request has been submitted to ISC and is queued for processing. Because this endpoint is asynchronous, it doesn\'t return an error if you submit duplicate access requests in quick succession or submit an access request for access that is already in progress, approved, or rejected.  It\'s best practice to check for any existing access requests that reference the same access items before submitting a new access request. This can be accomplished by using the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [Pending Access Request Approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) APIs. You can also use the [Search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items an identity has before submitting an access request to ensure that you aren\'t requesting access that is already granted. If you use this API to request access that an identity already has, the API will ignore the request.  These ignored requests do not display when you use the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) API.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * You cannot use an access request to revoke access from an identity if that access has been granted by role membership or by birthright provisioning.  * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles, access profiles and entitlements. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A user with ORG_ADMIN authority can also request to revoke access from anyone. 
     * @summary Submit Access Request
     * @param {AccessRequestsApiCreateAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public createAccessRequest(requestParameters: AccessRequestsApiCreateAccessRequestRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).createAccessRequest(requestParameters.accessRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the current access-request configuration.
     * @summary Get Access Request Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public getAccessRequestConfig(axiosOptions?: RawAxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).getAccessRequestConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to return a list of access request statuses based on the specified query parameters. If an access request was made for access that an identity already has, the API ignores the access request.  These ignored requests do not display in the list of access request statuses. Any user with any user level can get the status of their own access requests. A user with ORG_ADMIN is required to call this API to get a list of statuses for other users.
     * @summary Access Request Status
     * @param {AccessRequestsApiListAccessRequestStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public listAccessRequestStatus(requestParameters: AccessRequestsApiListAccessRequestStatusRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).listAccessRequestStatus(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.assignedTo, requestParameters.count, requestParameters.limit, requestParameters.offset, requestParameters.filters, requestParameters.sorters, requestParameters.requestState, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint replaces the current access-request configuration.
     * @summary Update Access Request Configuration
     * @param {AccessRequestsApiSetAccessRequestConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public setAccessRequestConfig(requestParameters: AccessRequestsApiSetAccessRequestConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).setAccessRequestConfig(requestParameters.accessRequestConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountActivitiesApi - axios parameter creator
 * @export
 */
export const AccountActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountActivity', 'id', id)
            const localVarPath = `/account-activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in, ge, le, lt, ne, isnull, sw*  **created**: *gt, lt, ge, le, eq, in, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities: async (requestedFor?: string, requestedBy?: string, regardingIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account-activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (requestedBy !== undefined) {
                localVarQueryParameter['requested-by'] = requestedBy;
            }

            if (regardingIdentity !== undefined) {
                localVarQueryParameter['regarding-identity'] = regardingIdentity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountActivitiesApi - functional programming interface
 * @export
 */
export const AccountActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountActivity(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountActivity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountActivity(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountActivitiesApi.getAccountActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in, ge, le, lt, ne, isnull, sw*  **created**: *gt, lt, ge, le, eq, in, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountActivities(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountActivity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountActivities(requestedFor, requestedBy, regardingIdentity, limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountActivitiesApi.listAccountActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountActivitiesApi - factory interface
 * @export
 */
export const AccountActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountActivitiesApiFp(configuration)
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {AccountActivitiesApiGetAccountActivityRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity(requestParameters: AccountActivitiesApiGetAccountActivityRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccountActivity> {
            return localVarFp.getAccountActivity(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {AccountActivitiesApiListAccountActivitiesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities(requestParameters: AccountActivitiesApiListAccountActivitiesRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<AccountActivity>> {
            return localVarFp.listAccountActivities(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAccountActivity operation in AccountActivitiesApi.
 * @export
 * @interface AccountActivitiesApiGetAccountActivityRequest
 */
export interface AccountActivitiesApiGetAccountActivityRequest {
    /**
     * The account activity id
     * @type {string}
     * @memberof AccountActivitiesApiGetAccountActivity
     */
    readonly id: string
}

/**
 * Request parameters for listAccountActivities operation in AccountActivitiesApi.
 * @export
 * @interface AccountActivitiesApiListAccountActivitiesRequest
 */
export interface AccountActivitiesApiListAccountActivitiesRequest {
    /**
     * The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly requestedFor?: string

    /**
     * The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly requestedBy?: string

    /**
     * The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly regardingIdentity?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in, ge, le, lt, ne, isnull, sw*  **created**: *gt, lt, ge, le, eq, in, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, isnull, sw*
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly sorters?: string
}

/**
 * AccountActivitiesApi - object-oriented interface
 * @export
 * @class AccountActivitiesApi
 * @extends {BaseAPI}
 */
export class AccountActivitiesApi extends BaseAPI {
    /**
     * This gets a single account activity by its id.
     * @summary Get an Account Activity
     * @param {AccountActivitiesApiGetAccountActivityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesApi
     */
    public getAccountActivity(requestParameters: AccountActivitiesApiGetAccountActivityRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccountActivitiesApiFp(this.configuration).getAccountActivity(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of account activities that satisfy the given query parameters.
     * @summary List Account Activities
     * @param {AccountActivitiesApiListAccountActivitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesApi
     */
    public listAccountActivities(requestParameters: AccountActivitiesApiListAccountActivitiesRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return AccountActivitiesApiFp(this.configuration).listAccountActivities(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountUsagesApi - axios parameter creator
 * @export
 */
export const AccountUsagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns a summary of account usage insights for past 12 months.
         * @summary Returns account usage insights
         * @param {string} accountId ID of IDN account
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesByAccountId: async (accountId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getUsagesByAccountId', 'accountId', accountId)
            const localVarPath = `/account-usages/{accountId}/summaries`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountUsagesApi - functional programming interface
 * @export
 */
export const AccountUsagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountUsagesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns a summary of account usage insights for past 12 months.
         * @summary Returns account usage insights
         * @param {string} accountId ID of IDN account
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getUsagesByAccountId(accountId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountUsage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsagesByAccountId(accountId, limit, offset, count, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountUsagesApi.getUsagesByAccountId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountUsagesApi - factory interface
 * @export
 */
export const AccountUsagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountUsagesApiFp(configuration)
    return {
        /**
         * This API returns a summary of account usage insights for past 12 months.
         * @summary Returns account usage insights
         * @param {AccountUsagesApiGetUsagesByAccountIdRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesByAccountId(requestParameters: AccountUsagesApiGetUsagesByAccountIdRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<AccountUsage>> {
            return localVarFp.getUsagesByAccountId(requestParameters.accountId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUsagesByAccountId operation in AccountUsagesApi.
 * @export
 * @interface AccountUsagesApiGetUsagesByAccountIdRequest
 */
export interface AccountUsagesApiGetUsagesByAccountIdRequest {
    /**
     * ID of IDN account
     * @type {string}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly accountId: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
     * @type {string}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly sorters?: string
}

/**
 * AccountUsagesApi - object-oriented interface
 * @export
 * @class AccountUsagesApi
 * @extends {BaseAPI}
 */
export class AccountUsagesApi extends BaseAPI {
    /**
     * This API returns a summary of account usage insights for past 12 months.
     * @summary Returns account usage insights
     * @param {AccountUsagesApiGetUsagesByAccountIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsagesApi
     */
    public getUsagesByAccountId(requestParameters: AccountUsagesApiGetUsagesByAccountIdRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccountUsagesApiFp(this.configuration).getUsagesByAccountId(requestParameters.accountId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submit an account creation task - the API then returns the task ID.    You must include the `sourceId` where the account will be created in the `attributes` object.  This endpoint creates an account on the source record in your ISC tenant. This is useful for Flat File (`DelimitedFile`) type sources because it allows you to aggregate new accounts without needing to import a new CSV file every time.   However, if you use this endpoint to create an account for a Direct Connection type source, you must ensure that the account also exists on the target source.  The endpoint doesn\'t actually provision the account on the target source, which means that if the account doesn\'t also exist on the target source, an aggregation between the source and your tenant will remove it from your tenant.   By providing the account ID of an existing account in the request body, this API will function as a PATCH operation and update the account. 
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (accountAttributesCreate: AccountAttributesCreate, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountAttributesCreate' is not null or undefined
            assertParamExists('createAccount', 'accountAttributesCreate', accountAttributesCreate)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAttributesCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to delete an account.  This endpoint submits an account delete task and returns the task ID.  This endpoint only deletes the account from IdentityNow, not the source itself, which can result in the account\'s returning with the next aggregation between the source and IdentityNow.  To avoid this scenario, it is recommended that you [disable accounts](https://developer.sailpoint.com/idn/api/v3/disable-account) rather than delete them. This will also allow you to reenable the accounts in the future.  >**NOTE: You can only delete accounts from sources of the \"DelimitedFile\" type.**
         * @summary Delete Account
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAccount', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to disable the account and returns the task ID.      
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount: async (id: string, accountToggleRequest: AccountToggleRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('disableAccount', 'id', id)
            // verify required parameter 'accountToggleRequest' is not null or undefined
            assertParamExists('disableAccount', 'accountToggleRequest', accountToggleRequest)
            const localVarPath = `/accounts/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountToggleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to enable account and returns the task ID.      
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount: async (id: string, accountToggleRequest: AccountToggleRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enableAccount', 'id', id)
            // verify required parameter 'accountToggleRequest' is not null or undefined
            assertParamExists('enableAccount', 'accountToggleRequest', accountToggleRequest)
            const localVarPath = `/accounts/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountToggleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to return the details for a single account by its ID.  
         * @summary Account Details
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns entitlements of the account.      
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements: async (id: string, limit?: number, offset?: number, count?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountEntitlements', 'id', id)
            const localVarPath = `/accounts/{id}/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * List accounts. 
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {ListAccountsDetailLevelV3} [detailLevel] This value determines whether the API provides &#x60;SLIM&#x60; or increased level of detail (&#x60;FULL&#x60;) for each account in the returned list. &#x60;FULL&#x60; is the default behavior.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, sw*  **identityId**: *eq, in, sw*  **name**: *eq, in, sw*  **nativeIdentity**: *eq, in, sw*  **hasEntitlements**: *eq*  **sourceId**: *eq, in, sw*  **uncorrelated**: *eq*  **entitlements**: *eq*  **origin**: *eq, in*  **manuallyCorrelated**: *eq*  **identity.name**: *eq, in, sw*  **identity.correlated**: *eq*  **identity.identityState**: *eq, in*  **source.displayableName**: *eq, in*  **source.authoritative**: *eq*  **source.connectionType**: *eq, in*  **recommendation.method**: *eq, in, isnull*  **created**: *eq, ge, gt, le, lt*  **modified**: *eq, ge, gt, le, lt*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, sourceId, identityId, nativeIdentity, uuid, manuallyCorrelated, entitlements, origin, identity.name, identity.identityState, identity.correlated, source.displayableName, source.authoritative, source.connectionType**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (limit?: number, offset?: number, count?: boolean, detailLevel?: ListAccountsDetailLevelV3, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (detailLevel !== undefined) {
                localVarQueryParameter['detailLevel'] = detailLevel;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update an account with a PUT request.   This endpoint submits an account update task and returns the task ID.   >**Note: You can only use this PUT endpoint to update accounts from flat file sources.** 
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {AccountAttributes} accountAttributes 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount: async (id: string, accountAttributes: AccountAttributes, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putAccount', 'id', id)
            // verify required parameter 'accountAttributes' is not null or undefined
            assertParamExists('putAccount', 'accountAttributes', accountAttributes)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAttributes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.      
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReloadAccount: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitReloadAccount', 'id', id)
            const localVarPath = `/accounts/{id}/reload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   To use this endpoint to unlock an account that has the `forceProvisioning` option set to true, the `idn:accounts-provisioning:manage` scope is required. 
         * @summary Unlock Account
         * @param {string} id The account ID.
         * @param {AccountUnlockRequest} accountUnlockRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount: async (id: string, accountUnlockRequest: AccountUnlockRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlockAccount', 'id', id)
            // verify required parameter 'accountUnlockRequest' is not null or undefined
            assertParamExists('unlockAccount', 'accountUnlockRequest', accountUnlockRequest)
            const localVarPath = `/accounts/{id}/unlock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUnlockRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update account details.   This API supports updating an account\'s correlation by modifying the `identityId` and `manuallyCorrelated` fields.  To reassign an account from one identity to another, replace the current `identityId` with a new value.  If the account you\'re assigning was provisioned by Identity Security Cloud (ISC), it\'s possible for ISC to create a new account  for the previous identity as soon as the account is moved. If the account you\'re assigning is authoritative,  this causes the previous identity to become uncorrelated and can even result in its deletion. All accounts that are reassigned will be set to `manuallyCorrelated: true` unless you specify otherwise.  >**Note:** The `attributes` field can only be modified for flat file accounts.  
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {Array<object>} requestBody A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (id: string, requestBody: Array<object>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAccount', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateAccount', 'requestBody', requestBody)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Submit an account creation task - the API then returns the task ID.    You must include the `sourceId` where the account will be created in the `attributes` object.  This endpoint creates an account on the source record in your ISC tenant. This is useful for Flat File (`DelimitedFile`) type sources because it allows you to aggregate new accounts without needing to import a new CSV file every time.   However, if you use this endpoint to create an account for a Direct Connection type source, you must ensure that the account also exists on the target source.  The endpoint doesn\'t actually provision the account on the target source, which means that if the account doesn\'t also exist on the target source, an aggregation between the source and your tenant will remove it from your tenant.   By providing the account ID of an existing account in the request body, this API will function as a PATCH operation and update the account. 
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(accountAttributesCreate: AccountAttributesCreate, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(accountAttributesCreate, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.createAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to delete an account.  This endpoint submits an account delete task and returns the task ID.  This endpoint only deletes the account from IdentityNow, not the source itself, which can result in the account\'s returning with the next aggregation between the source and IdentityNow.  To avoid this scenario, it is recommended that you [disable accounts](https://developer.sailpoint.com/idn/api/v3/disable-account) rather than delete them. This will also allow you to reenable the accounts in the future.  >**NOTE: You can only delete accounts from sources of the \"DelimitedFile\" type.**
         * @summary Delete Account
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.deleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API submits a task to disable the account and returns the task ID.      
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async disableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableAccount(id, accountToggleRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.disableAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API submits a task to enable account and returns the task ID.      
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async enableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableAccount(id, accountToggleRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.enableAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to return the details for a single account by its ID.  
         * @summary Account Details
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns entitlements of the account.      
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountEntitlements(id: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Entitlement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountEntitlements(id, limit, offset, count, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccountEntitlements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List accounts. 
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {ListAccountsDetailLevelV3} [detailLevel] This value determines whether the API provides &#x60;SLIM&#x60; or increased level of detail (&#x60;FULL&#x60;) for each account in the returned list. &#x60;FULL&#x60; is the default behavior.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, sw*  **identityId**: *eq, in, sw*  **name**: *eq, in, sw*  **nativeIdentity**: *eq, in, sw*  **hasEntitlements**: *eq*  **sourceId**: *eq, in, sw*  **uncorrelated**: *eq*  **entitlements**: *eq*  **origin**: *eq, in*  **manuallyCorrelated**: *eq*  **identity.name**: *eq, in, sw*  **identity.correlated**: *eq*  **identity.identityState**: *eq, in*  **source.displayableName**: *eq, in*  **source.authoritative**: *eq*  **source.connectionType**: *eq, in*  **recommendation.method**: *eq, in, isnull*  **created**: *eq, ge, gt, le, lt*  **modified**: *eq, ge, gt, le, lt*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, sourceId, identityId, nativeIdentity, uuid, manuallyCorrelated, entitlements, origin, identity.name, identity.identityState, identity.correlated, source.displayableName, source.authoritative, source.connectionType**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(limit?: number, offset?: number, count?: boolean, detailLevel?: ListAccountsDetailLevelV3, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(limit, offset, count, detailLevel, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.listAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to update an account with a PUT request.   This endpoint submits an account update task and returns the task ID.   >**Note: You can only use this PUT endpoint to update accounts from flat file sources.** 
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {AccountAttributes} accountAttributes 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putAccount(id: string, accountAttributes: AccountAttributes, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAccount(id, accountAttributes, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.putAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.      
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async submitReloadAccount(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitReloadAccount(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.submitReloadAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   To use this endpoint to unlock an account that has the `forceProvisioning` option set to true, the `idn:accounts-provisioning:manage` scope is required. 
         * @summary Unlock Account
         * @param {string} id The account ID.
         * @param {AccountUnlockRequest} accountUnlockRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async unlockAccount(id: string, accountUnlockRequest: AccountUnlockRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockAccount(id, accountUnlockRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.unlockAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to update account details.   This API supports updating an account\'s correlation by modifying the `identityId` and `manuallyCorrelated` fields.  To reassign an account from one identity to another, replace the current `identityId` with a new value.  If the account you\'re assigning was provisioned by Identity Security Cloud (ISC), it\'s possible for ISC to create a new account  for the previous identity as soon as the account is moved. If the account you\'re assigning is authoritative,  this causes the previous identity to become uncorrelated and can even result in its deletion. All accounts that are reassigned will be set to `manuallyCorrelated: true` unless you specify otherwise.  >**Note:** The `attributes` field can only be modified for flat file accounts.  
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {Array<object>} requestBody A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(id: string, requestBody: Array<object>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(id, requestBody, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.updateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Submit an account creation task - the API then returns the task ID.    You must include the `sourceId` where the account will be created in the `attributes` object.  This endpoint creates an account on the source record in your ISC tenant. This is useful for Flat File (`DelimitedFile`) type sources because it allows you to aggregate new accounts without needing to import a new CSV file every time.   However, if you use this endpoint to create an account for a Direct Connection type source, you must ensure that the account also exists on the target source.  The endpoint doesn\'t actually provision the account on the target source, which means that if the account doesn\'t also exist on the target source, an aggregation between the source and your tenant will remove it from your tenant.   By providing the account ID of an existing account in the request body, this API will function as a PATCH operation and update the account. 
         * @summary Create Account
         * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(requestParameters: AccountsApiCreateAccountRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.createAccount(requestParameters.accountAttributesCreate, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to delete an account.  This endpoint submits an account delete task and returns the task ID.  This endpoint only deletes the account from IdentityNow, not the source itself, which can result in the account\'s returning with the next aggregation between the source and IdentityNow.  To avoid this scenario, it is recommended that you [disable accounts](https://developer.sailpoint.com/idn/api/v3/disable-account) rather than delete them. This will also allow you to reenable the accounts in the future.  >**NOTE: You can only delete accounts from sources of the \"DelimitedFile\" type.**
         * @summary Delete Account
         * @param {AccountsApiDeleteAccountRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(requestParameters: AccountsApiDeleteAccountRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.deleteAccount(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to disable the account and returns the task ID.      
         * @summary Disable Account
         * @param {AccountsApiDisableAccountRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount(requestParameters: AccountsApiDisableAccountRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.disableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to enable account and returns the task ID.      
         * @summary Enable Account
         * @param {AccountsApiEnableAccountRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount(requestParameters: AccountsApiEnableAccountRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.enableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to return the details for a single account by its ID.  
         * @summary Account Details
         * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(requestParameters: AccountsApiGetAccountRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.getAccount(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns entitlements of the account.      
         * @summary Account Entitlements
         * @param {AccountsApiGetAccountEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements(requestParameters: AccountsApiGetAccountEntitlementsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<Entitlement>> {
            return localVarFp.getAccountEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * List accounts. 
         * @summary Accounts List
         * @param {AccountsApiListAccountsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(requestParameters: AccountsApiListAccountsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<Account>> {
            return localVarFp.listAccounts(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.detailLevel, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to update an account with a PUT request.   This endpoint submits an account update task and returns the task ID.   >**Note: You can only use this PUT endpoint to update accounts from flat file sources.** 
         * @summary Update Account
         * @param {AccountsApiPutAccountRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount(requestParameters: AccountsApiPutAccountRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.putAccount(requestParameters.id, requestParameters.accountAttributes, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.      
         * @summary Reload Account
         * @param {AccountsApiSubmitReloadAccountRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReloadAccount(requestParameters: AccountsApiSubmitReloadAccountRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.submitReloadAccount(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   To use this endpoint to unlock an account that has the `forceProvisioning` option set to true, the `idn:accounts-provisioning:manage` scope is required. 
         * @summary Unlock Account
         * @param {AccountsApiUnlockAccountRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount(requestParameters: AccountsApiUnlockAccountRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.unlockAccount(requestParameters.id, requestParameters.accountUnlockRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to update account details.   This API supports updating an account\'s correlation by modifying the `identityId` and `manuallyCorrelated` fields.  To reassign an account from one identity to another, replace the current `identityId` with a new value.  If the account you\'re assigning was provisioned by Identity Security Cloud (ISC), it\'s possible for ISC to create a new account  for the previous identity as soon as the account is moved. If the account you\'re assigning is authoritative,  this causes the previous identity to become uncorrelated and can even result in its deletion. All accounts that are reassigned will be set to `manuallyCorrelated: true` unless you specify otherwise.  >**Note:** The `attributes` field can only be modified for flat file accounts.  
         * @summary Update Account
         * @param {AccountsApiUpdateAccountRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(requestParameters: AccountsApiUpdateAccountRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateAccount(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiCreateAccountRequest
 */
export interface AccountsApiCreateAccountRequest {
    /**
     * 
     * @type {AccountAttributesCreate}
     * @memberof AccountsApiCreateAccount
     */
    readonly accountAttributesCreate: AccountAttributesCreate
}

/**
 * Request parameters for deleteAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDeleteAccountRequest
 */
export interface AccountsApiDeleteAccountRequest {
    /**
     * Account ID.
     * @type {string}
     * @memberof AccountsApiDeleteAccount
     */
    readonly id: string
}

/**
 * Request parameters for disableAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDisableAccountRequest
 */
export interface AccountsApiDisableAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiDisableAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountToggleRequest}
     * @memberof AccountsApiDisableAccount
     */
    readonly accountToggleRequest: AccountToggleRequest
}

/**
 * Request parameters for enableAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiEnableAccountRequest
 */
export interface AccountsApiEnableAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiEnableAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountToggleRequest}
     * @memberof AccountsApiEnableAccount
     */
    readonly accountToggleRequest: AccountToggleRequest
}

/**
 * Request parameters for getAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountRequest
 */
export interface AccountsApiGetAccountRequest {
    /**
     * Account ID.
     * @type {string}
     * @memberof AccountsApiGetAccount
     */
    readonly id: string
}

/**
 * Request parameters for getAccountEntitlements operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountEntitlementsRequest
 */
export interface AccountsApiGetAccountEntitlementsRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly count?: boolean
}

/**
 * Request parameters for listAccounts operation in AccountsApi.
 * @export
 * @interface AccountsApiListAccountsRequest
 */
export interface AccountsApiListAccountsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiListAccounts
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiListAccounts
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountsApiListAccounts
     */
    readonly count?: boolean

    /**
     * This value determines whether the API provides &#x60;SLIM&#x60; or increased level of detail (&#x60;FULL&#x60;) for each account in the returned list. &#x60;FULL&#x60; is the default behavior.
     * @type {'SLIM' | 'FULL'}
     * @memberof AccountsApiListAccounts
     */
    readonly detailLevel?: ListAccountsDetailLevelV3

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, sw*  **identityId**: *eq, in, sw*  **name**: *eq, in, sw*  **nativeIdentity**: *eq, in, sw*  **hasEntitlements**: *eq*  **sourceId**: *eq, in, sw*  **uncorrelated**: *eq*  **entitlements**: *eq*  **origin**: *eq, in*  **manuallyCorrelated**: *eq*  **identity.name**: *eq, in, sw*  **identity.correlated**: *eq*  **identity.identityState**: *eq, in*  **source.displayableName**: *eq, in*  **source.authoritative**: *eq*  **source.connectionType**: *eq, in*  **recommendation.method**: *eq, in, isnull*  **created**: *eq, ge, gt, le, lt*  **modified**: *eq, ge, gt, le, lt*
     * @type {string}
     * @memberof AccountsApiListAccounts
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, sourceId, identityId, nativeIdentity, uuid, manuallyCorrelated, entitlements, origin, identity.name, identity.identityState, identity.correlated, source.displayableName, source.authoritative, source.connectionType**
     * @type {string}
     * @memberof AccountsApiListAccounts
     */
    readonly sorters?: string
}

/**
 * Request parameters for putAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiPutAccountRequest
 */
export interface AccountsApiPutAccountRequest {
    /**
     * Account ID.
     * @type {string}
     * @memberof AccountsApiPutAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountAttributes}
     * @memberof AccountsApiPutAccount
     */
    readonly accountAttributes: AccountAttributes
}

/**
 * Request parameters for submitReloadAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiSubmitReloadAccountRequest
 */
export interface AccountsApiSubmitReloadAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiSubmitReloadAccount
     */
    readonly id: string
}

/**
 * Request parameters for unlockAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiUnlockAccountRequest
 */
export interface AccountsApiUnlockAccountRequest {
    /**
     * The account ID.
     * @type {string}
     * @memberof AccountsApiUnlockAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountUnlockRequest}
     * @memberof AccountsApiUnlockAccount
     */
    readonly accountUnlockRequest: AccountUnlockRequest
}

/**
 * Request parameters for updateAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiUpdateAccountRequest
 */
export interface AccountsApiUpdateAccountRequest {
    /**
     * Account ID.
     * @type {string}
     * @memberof AccountsApiUpdateAccount
     */
    readonly id: string

    /**
     * A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<object>}
     * @memberof AccountsApiUpdateAccount
     */
    readonly requestBody: Array<object>
}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Submit an account creation task - the API then returns the task ID.    You must include the `sourceId` where the account will be created in the `attributes` object.  This endpoint creates an account on the source record in your ISC tenant. This is useful for Flat File (`DelimitedFile`) type sources because it allows you to aggregate new accounts without needing to import a new CSV file every time.   However, if you use this endpoint to create an account for a Direct Connection type source, you must ensure that the account also exists on the target source.  The endpoint doesn\'t actually provision the account on the target source, which means that if the account doesn\'t also exist on the target source, an aggregation between the source and your tenant will remove it from your tenant.   By providing the account ID of an existing account in the request body, this API will function as a PATCH operation and update the account. 
     * @summary Create Account
     * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(requestParameters: AccountsApiCreateAccountRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(requestParameters.accountAttributesCreate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to delete an account.  This endpoint submits an account delete task and returns the task ID.  This endpoint only deletes the account from IdentityNow, not the source itself, which can result in the account\'s returning with the next aggregation between the source and IdentityNow.  To avoid this scenario, it is recommended that you [disable accounts](https://developer.sailpoint.com/idn/api/v3/disable-account) rather than delete them. This will also allow you to reenable the accounts in the future.  >**NOTE: You can only delete accounts from sources of the \"DelimitedFile\" type.**
     * @summary Delete Account
     * @param {AccountsApiDeleteAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(requestParameters: AccountsApiDeleteAccountRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to disable the account and returns the task ID.      
     * @summary Disable Account
     * @param {AccountsApiDisableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public disableAccount(requestParameters: AccountsApiDisableAccountRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).disableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to enable account and returns the task ID.      
     * @summary Enable Account
     * @param {AccountsApiEnableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public enableAccount(requestParameters: AccountsApiEnableAccountRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).enableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to return the details for a single account by its ID.  
     * @summary Account Details
     * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(requestParameters: AccountsApiGetAccountRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns entitlements of the account.      
     * @summary Account Entitlements
     * @param {AccountsApiGetAccountEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountEntitlements(requestParameters: AccountsApiGetAccountEntitlementsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List accounts. 
     * @summary Accounts List
     * @param {AccountsApiListAccountsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccounts(requestParameters: AccountsApiListAccountsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccounts(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.detailLevel, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to update an account with a PUT request.   This endpoint submits an account update task and returns the task ID.   >**Note: You can only use this PUT endpoint to update accounts from flat file sources.** 
     * @summary Update Account
     * @param {AccountsApiPutAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public putAccount(requestParameters: AccountsApiPutAccountRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).putAccount(requestParameters.id, requestParameters.accountAttributes, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.      
     * @summary Reload Account
     * @param {AccountsApiSubmitReloadAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public submitReloadAccount(requestParameters: AccountsApiSubmitReloadAccountRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).submitReloadAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to unlock an account and returns the task ID.   To use this endpoint to unlock an account that has the `forceProvisioning` option set to true, the `idn:accounts-provisioning:manage` scope is required. 
     * @summary Unlock Account
     * @param {AccountsApiUnlockAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public unlockAccount(requestParameters: AccountsApiUnlockAccountRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).unlockAccount(requestParameters.id, requestParameters.accountUnlockRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to update account details.   This API supports updating an account\'s correlation by modifying the `identityId` and `manuallyCorrelated` fields.  To reassign an account from one identity to another, replace the current `identityId` with a new value.  If the account you\'re assigning was provisioned by Identity Security Cloud (ISC), it\'s possible for ISC to create a new account  for the previous identity as soon as the account is moved. If the account you\'re assigning is authoritative,  this causes the previous identity to become uncorrelated and can even result in its deletion. All accounts that are reassigned will be set to `manuallyCorrelated: true` unless you specify otherwise.  >**Note:** The `attributes` field can only be modified for flat file accounts.  
     * @summary Update Account
     * @param {AccountsApiUpdateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(requestParameters: AccountsApiUpdateAccountRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListAccountsDetailLevelV3 = {
    Slim: 'SLIM',
    Full: 'FULL'
} as const;
export type ListAccountsDetailLevelV3 = typeof ListAccountsDetailLevelV3[keyof typeof ListAccountsDetailLevelV3];


/**
 * ApplicationDiscoveryApi - axios parameter creator
 * @export
 */
export const ApplicationDiscoveryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of applications that have been identified within the environment. This includes details such as application names, discovery dates, potential correlated saas_vendors and related suggested connectors. 
         * @summary Get Discovered Applications for Tenant
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {GetDiscoveredApplicationsDetailV3} [detail] Determines whether slim, or increased level of detail is provided for each discovered application in the returned list. SLIM is the default behavior.
         * @param {string} [filter] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)       Filtering is supported for the following fields and operators:  **name**: *eq, sw, co*  **description**: *eq, sw, co*  **createdAtStart**: *eq, le, ge*  **createdAtEnd**: *eq, le, ge*  **discoveredAtStart**: *eq, le, ge*  **discoveredAtEnd**: *eq, le, ge*  **discoverySource**: *eq, in* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, description, discoveredAt, discoverySource**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDiscoveredApplications: async (limit?: number, offset?: number, detail?: GetDiscoveredApplicationsDetailV3, filter?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/discovered-applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (detail !== undefined) {
                localVarQueryParameter['detail'] = detail;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Download an example CSV file with two columns `application_name` and `description`.  The CSV file contains a single row with the values \'Example Application\' and \'Example Description\'.  The downloaded template is specifically designed for use with the `/manual-discover-applications` endpoint. 
         * @summary Download CSV Template for Discovery
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManualDiscoverApplicationsCsvTemplate: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manual-discover-applications-template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Uploading a CSV file with application data for manual correlation to specific ISC connectors.  If a suitable ISC connector is unavailable, the system will recommend generic connectors instead.
         * @summary Upload CSV to Discover Applications
         * @param {File} file The CSV file to upload containing &#x60;application_name&#x60; and &#x60;description&#x60; columns. Each row represents an application to be discovered.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendManualDiscoverApplicationsCsvTemplate: async (file: File, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('sendManualDiscoverApplicationsCsvTemplate', 'file', file)
            const localVarPath = `/manual-discover-applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationDiscoveryApi - functional programming interface
 * @export
 */
export const ApplicationDiscoveryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationDiscoveryApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of applications that have been identified within the environment. This includes details such as application names, discovery dates, potential correlated saas_vendors and related suggested connectors. 
         * @summary Get Discovered Applications for Tenant
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {GetDiscoveredApplicationsDetailV3} [detail] Determines whether slim, or increased level of detail is provided for each discovered application in the returned list. SLIM is the default behavior.
         * @param {string} [filter] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)       Filtering is supported for the following fields and operators:  **name**: *eq, sw, co*  **description**: *eq, sw, co*  **createdAtStart**: *eq, le, ge*  **createdAtEnd**: *eq, le, ge*  **discoveredAtStart**: *eq, le, ge*  **discoveredAtEnd**: *eq, le, ge*  **discoverySource**: *eq, in* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, description, discoveredAt, discoverySource**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDiscoveredApplications(limit?: number, offset?: number, detail?: GetDiscoveredApplicationsDetailV3, filter?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetDiscoveredApplications200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiscoveredApplications(limit, offset, detail, filter, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationDiscoveryApi.getDiscoveredApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download an example CSV file with two columns `application_name` and `description`.  The CSV file contains a single row with the values \'Example Application\' and \'Example Description\'.  The downloaded template is specifically designed for use with the `/manual-discover-applications` endpoint. 
         * @summary Download CSV Template for Discovery
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManualDiscoverApplicationsCsvTemplate(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManualDiscoverApplicationsTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManualDiscoverApplicationsCsvTemplate(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationDiscoveryApi.getManualDiscoverApplicationsCsvTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploading a CSV file with application data for manual correlation to specific ISC connectors.  If a suitable ISC connector is unavailable, the system will recommend generic connectors instead.
         * @summary Upload CSV to Discover Applications
         * @param {File} file The CSV file to upload containing &#x60;application_name&#x60; and &#x60;description&#x60; columns. Each row represents an application to be discovered.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async sendManualDiscoverApplicationsCsvTemplate(file: File, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendManualDiscoverApplicationsCsvTemplate(file, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationDiscoveryApi.sendManualDiscoverApplicationsCsvTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationDiscoveryApi - factory interface
 * @export
 */
export const ApplicationDiscoveryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationDiscoveryApiFp(configuration)
    return {
        /**
         * Get a list of applications that have been identified within the environment. This includes details such as application names, discovery dates, potential correlated saas_vendors and related suggested connectors. 
         * @summary Get Discovered Applications for Tenant
         * @param {ApplicationDiscoveryApiGetDiscoveredApplicationsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDiscoveredApplications(requestParameters: ApplicationDiscoveryApiGetDiscoveredApplicationsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<GetDiscoveredApplications200ResponseInner>> {
            return localVarFp.getDiscoveredApplications(requestParameters.limit, requestParameters.offset, requestParameters.detail, requestParameters.filter, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Download an example CSV file with two columns `application_name` and `description`.  The CSV file contains a single row with the values \'Example Application\' and \'Example Description\'.  The downloaded template is specifically designed for use with the `/manual-discover-applications` endpoint. 
         * @summary Download CSV Template for Discovery
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManualDiscoverApplicationsCsvTemplate(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ManualDiscoverApplicationsTemplate> {
            return localVarFp.getManualDiscoverApplicationsCsvTemplate(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Uploading a CSV file with application data for manual correlation to specific ISC connectors.  If a suitable ISC connector is unavailable, the system will recommend generic connectors instead.
         * @summary Upload CSV to Discover Applications
         * @param {ApplicationDiscoveryApiSendManualDiscoverApplicationsCsvTemplateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendManualDiscoverApplicationsCsvTemplate(requestParameters: ApplicationDiscoveryApiSendManualDiscoverApplicationsCsvTemplateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendManualDiscoverApplicationsCsvTemplate(requestParameters.file, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDiscoveredApplications operation in ApplicationDiscoveryApi.
 * @export
 * @interface ApplicationDiscoveryApiGetDiscoveredApplicationsRequest
 */
export interface ApplicationDiscoveryApiGetDiscoveredApplicationsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ApplicationDiscoveryApiGetDiscoveredApplications
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ApplicationDiscoveryApiGetDiscoveredApplications
     */
    readonly offset?: number

    /**
     * Determines whether slim, or increased level of detail is provided for each discovered application in the returned list. SLIM is the default behavior.
     * @type {'SLIM' | 'FULL'}
     * @memberof ApplicationDiscoveryApiGetDiscoveredApplications
     */
    readonly detail?: GetDiscoveredApplicationsDetailV3

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)       Filtering is supported for the following fields and operators:  **name**: *eq, sw, co*  **description**: *eq, sw, co*  **createdAtStart**: *eq, le, ge*  **createdAtEnd**: *eq, le, ge*  **discoveredAtStart**: *eq, le, ge*  **discoveredAtEnd**: *eq, le, ge*  **discoverySource**: *eq, in* 
     * @type {string}
     * @memberof ApplicationDiscoveryApiGetDiscoveredApplications
     */
    readonly filter?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, description, discoveredAt, discoverySource**
     * @type {string}
     * @memberof ApplicationDiscoveryApiGetDiscoveredApplications
     */
    readonly sorters?: string
}

/**
 * Request parameters for sendManualDiscoverApplicationsCsvTemplate operation in ApplicationDiscoveryApi.
 * @export
 * @interface ApplicationDiscoveryApiSendManualDiscoverApplicationsCsvTemplateRequest
 */
export interface ApplicationDiscoveryApiSendManualDiscoverApplicationsCsvTemplateRequest {
    /**
     * The CSV file to upload containing &#x60;application_name&#x60; and &#x60;description&#x60; columns. Each row represents an application to be discovered.
     * @type {File}
     * @memberof ApplicationDiscoveryApiSendManualDiscoverApplicationsCsvTemplate
     */
    readonly file: File
}

/**
 * ApplicationDiscoveryApi - object-oriented interface
 * @export
 * @class ApplicationDiscoveryApi
 * @extends {BaseAPI}
 */
export class ApplicationDiscoveryApi extends BaseAPI {
    /**
     * Get a list of applications that have been identified within the environment. This includes details such as application names, discovery dates, potential correlated saas_vendors and related suggested connectors. 
     * @summary Get Discovered Applications for Tenant
     * @param {ApplicationDiscoveryApiGetDiscoveredApplicationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDiscoveryApi
     */
    public getDiscoveredApplications(requestParameters: ApplicationDiscoveryApiGetDiscoveredApplicationsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return ApplicationDiscoveryApiFp(this.configuration).getDiscoveredApplications(requestParameters.limit, requestParameters.offset, requestParameters.detail, requestParameters.filter, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download an example CSV file with two columns `application_name` and `description`.  The CSV file contains a single row with the values \'Example Application\' and \'Example Description\'.  The downloaded template is specifically designed for use with the `/manual-discover-applications` endpoint. 
     * @summary Download CSV Template for Discovery
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDiscoveryApi
     */
    public getManualDiscoverApplicationsCsvTemplate(axiosOptions?: RawAxiosRequestConfig) {
        return ApplicationDiscoveryApiFp(this.configuration).getManualDiscoverApplicationsCsvTemplate(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploading a CSV file with application data for manual correlation to specific ISC connectors.  If a suitable ISC connector is unavailable, the system will recommend generic connectors instead.
     * @summary Upload CSV to Discover Applications
     * @param {ApplicationDiscoveryApiSendManualDiscoverApplicationsCsvTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDiscoveryApi
     */
    public sendManualDiscoverApplicationsCsvTemplate(requestParameters: ApplicationDiscoveryApiSendManualDiscoverApplicationsCsvTemplateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ApplicationDiscoveryApiFp(this.configuration).sendManualDiscoverApplicationsCsvTemplate(requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetDiscoveredApplicationsDetailV3 = {
    Slim: 'SLIM',
    Full: 'FULL'
} as const;
export type GetDiscoveredApplicationsDetailV3 = typeof GetDiscoveredApplicationsDetailV3[keyof typeof GetDiscoveredApplicationsDetailV3];


/**
 * AuthUsersApi - axios parameter creator
 * @export
 */
export const AuthUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the specified user\'s authentication system details.
         * @summary Auth User Details
         * @param {string} id Identity ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthUser: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAuthUser', 'id', id)
            const localVarPath = `/auth-users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use a PATCH request to update an existing user in the authentication system. Use this endpoint to modify these fields:    * `capabilities`  A \'400.1.1 Illegal update attempt\' detail code indicates that you attempted to PATCH a field that is not allowed.
         * @summary Auth User Update
         * @param {string} id Identity ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth user update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthUser: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchAuthUser', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchAuthUser', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/auth-users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthUsersApi - functional programming interface
 * @export
 */
export const AuthUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Return the specified user\'s authentication system details.
         * @summary Auth User Details
         * @param {string} id Identity ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthUser(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthUser(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthUsersApi.getAuthUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use a PATCH request to update an existing user in the authentication system. Use this endpoint to modify these fields:    * `capabilities`  A \'400.1.1 Illegal update attempt\' detail code indicates that you attempted to PATCH a field that is not allowed.
         * @summary Auth User Update
         * @param {string} id Identity ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth user update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAuthUser(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAuthUser(id, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthUsersApi.patchAuthUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthUsersApi - factory interface
 * @export
 */
export const AuthUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthUsersApiFp(configuration)
    return {
        /**
         * Return the specified user\'s authentication system details.
         * @summary Auth User Details
         * @param {AuthUsersApiGetAuthUserRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthUser(requestParameters: AuthUsersApiGetAuthUserRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AuthUser> {
            return localVarFp.getAuthUser(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use a PATCH request to update an existing user in the authentication system. Use this endpoint to modify these fields:    * `capabilities`  A \'400.1.1 Illegal update attempt\' detail code indicates that you attempted to PATCH a field that is not allowed.
         * @summary Auth User Update
         * @param {AuthUsersApiPatchAuthUserRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthUser(requestParameters: AuthUsersApiPatchAuthUserRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AuthUser> {
            return localVarFp.patchAuthUser(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAuthUser operation in AuthUsersApi.
 * @export
 * @interface AuthUsersApiGetAuthUserRequest
 */
export interface AuthUsersApiGetAuthUserRequest {
    /**
     * Identity ID
     * @type {string}
     * @memberof AuthUsersApiGetAuthUser
     */
    readonly id: string
}

/**
 * Request parameters for patchAuthUser operation in AuthUsersApi.
 * @export
 * @interface AuthUsersApiPatchAuthUserRequest
 */
export interface AuthUsersApiPatchAuthUserRequest {
    /**
     * Identity ID
     * @type {string}
     * @memberof AuthUsersApiPatchAuthUser
     */
    readonly id: string

    /**
     * A list of auth user update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperation>}
     * @memberof AuthUsersApiPatchAuthUser
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * AuthUsersApi - object-oriented interface
 * @export
 * @class AuthUsersApi
 * @extends {BaseAPI}
 */
export class AuthUsersApi extends BaseAPI {
    /**
     * Return the specified user\'s authentication system details.
     * @summary Auth User Details
     * @param {AuthUsersApiGetAuthUserRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthUsersApi
     */
    public getAuthUser(requestParameters: AuthUsersApiGetAuthUserRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AuthUsersApiFp(this.configuration).getAuthUser(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use a PATCH request to update an existing user in the authentication system. Use this endpoint to modify these fields:    * `capabilities`  A \'400.1.1 Illegal update attempt\' detail code indicates that you attempted to PATCH a field that is not allowed.
     * @summary Auth User Update
     * @param {AuthUsersApiPatchAuthUserRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthUsersApi
     */
    public patchAuthUser(requestParameters: AuthUsersApiPatchAuthUserRequest, axiosOptions?: RawAxiosRequestConfig) {
        return AuthUsersApiFp(this.configuration).patchAuthUser(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BrandingApi - axios parameter creator
 * @export
 */
export const BrandingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API endpoint creates a branding item.
         * @summary Create a branding item
         * @param {string} name name of branding item
         * @param {string | null} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {File} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createBrandingItem: async (name: string, productName: string | null, actionButtonColor?: string, activeLinkColor?: string, navigationColor?: string, emailFromAddress?: string, loginInformationalMessage?: string, fileStandard?: File, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createBrandingItem', 'name', name)
            // verify required parameter 'productName' is not null or undefined
            assertParamExists('createBrandingItem', 'productName', productName)
            const localVarPath = `/brandings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (productName !== undefined) { 
                localVarFormParams.append('productName', productName as any);
            }
    
            if (actionButtonColor !== undefined) { 
                localVarFormParams.append('actionButtonColor', actionButtonColor as any);
            }
    
            if (activeLinkColor !== undefined) { 
                localVarFormParams.append('activeLinkColor', activeLinkColor as any);
            }
    
            if (navigationColor !== undefined) { 
                localVarFormParams.append('navigationColor', navigationColor as any);
            }
    
            if (emailFromAddress !== undefined) { 
                localVarFormParams.append('emailFromAddress', emailFromAddress as any);
            }
    
            if (loginInformationalMessage !== undefined) { 
                localVarFormParams.append('loginInformationalMessage', loginInformationalMessage as any);
            }
    
            if (fileStandard !== undefined) { 
                localVarFormParams.append('fileStandard', fileStandard as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint delete information for an existing branding item by name.    
         * @summary Delete a branding item
         * @param {string} name The name of the branding item to be deleted
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranding: async (name: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteBranding', 'name', name)
            const localVarPath = `/brandings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint retrieves information for an existing branding item by name.    
         * @summary Get a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBranding: async (name: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getBranding', 'name', name)
            const localVarPath = `/brandings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns a list of branding items.
         * @summary List of branding items
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingList: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/brandings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint updates information for an existing branding item.
         * @summary Update a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {string} name2 name of branding item
         * @param {string | null} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {File} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setBrandingItem: async (name: string, name2: string, productName: string | null, actionButtonColor?: string, activeLinkColor?: string, navigationColor?: string, emailFromAddress?: string, loginInformationalMessage?: string, fileStandard?: File, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('setBrandingItem', 'name', name)
            // verify required parameter 'name2' is not null or undefined
            assertParamExists('setBrandingItem', 'name2', name2)
            // verify required parameter 'productName' is not null or undefined
            assertParamExists('setBrandingItem', 'productName', productName)
            const localVarPath = `/brandings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


            if (name2 !== undefined) { 
                localVarFormParams.append('name', name2 as any);
            }
    
            if (productName !== undefined) { 
                localVarFormParams.append('productName', productName as any);
            }
    
            if (actionButtonColor !== undefined) { 
                localVarFormParams.append('actionButtonColor', actionButtonColor as any);
            }
    
            if (activeLinkColor !== undefined) { 
                localVarFormParams.append('activeLinkColor', activeLinkColor as any);
            }
    
            if (navigationColor !== undefined) { 
                localVarFormParams.append('navigationColor', navigationColor as any);
            }
    
            if (emailFromAddress !== undefined) { 
                localVarFormParams.append('emailFromAddress', emailFromAddress as any);
            }
    
            if (loginInformationalMessage !== undefined) { 
                localVarFormParams.append('loginInformationalMessage', loginInformationalMessage as any);
            }
    
            if (fileStandard !== undefined) { 
                localVarFormParams.append('fileStandard', fileStandard as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrandingApi - functional programming interface
 * @export
 */
export const BrandingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrandingApiAxiosParamCreator(configuration)
    return {
        /**
         * This API endpoint creates a branding item.
         * @summary Create a branding item
         * @param {string} name name of branding item
         * @param {string | null} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {File} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createBrandingItem(name: string, productName: string | null, actionButtonColor?: string, activeLinkColor?: string, navigationColor?: string, emailFromAddress?: string, loginInformationalMessage?: string, fileStandard?: File, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandingItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBrandingItem(name, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.createBrandingItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API endpoint delete information for an existing branding item by name.    
         * @summary Delete a branding item
         * @param {string} name The name of the branding item to be deleted
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBranding(name: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBranding(name, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.deleteBranding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API endpoint retrieves information for an existing branding item by name.    
         * @summary Get a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getBranding(name: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandingItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranding(name, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.getBranding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API endpoint returns a list of branding items.
         * @summary List of branding items
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getBrandingList(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BrandingItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBrandingList(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.getBrandingList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API endpoint updates information for an existing branding item.
         * @summary Update a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {string} name2 name of branding item
         * @param {string | null} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {File} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setBrandingItem(name: string, name2: string, productName: string | null, actionButtonColor?: string, activeLinkColor?: string, navigationColor?: string, emailFromAddress?: string, loginInformationalMessage?: string, fileStandard?: File, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandingItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBrandingItem(name, name2, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.setBrandingItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrandingApi - factory interface
 * @export
 */
export const BrandingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrandingApiFp(configuration)
    return {
        /**
         * This API endpoint creates a branding item.
         * @summary Create a branding item
         * @param {BrandingApiCreateBrandingItemRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createBrandingItem(requestParameters: BrandingApiCreateBrandingItemRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<BrandingItem> {
            return localVarFp.createBrandingItem(requestParameters.name, requestParameters.productName, requestParameters.actionButtonColor, requestParameters.activeLinkColor, requestParameters.navigationColor, requestParameters.emailFromAddress, requestParameters.loginInformationalMessage, requestParameters.fileStandard, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint delete information for an existing branding item by name.    
         * @summary Delete a branding item
         * @param {BrandingApiDeleteBrandingRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranding(requestParameters: BrandingApiDeleteBrandingRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteBranding(requestParameters.name, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint retrieves information for an existing branding item by name.    
         * @summary Get a branding item
         * @param {BrandingApiGetBrandingRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBranding(requestParameters: BrandingApiGetBrandingRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<BrandingItem> {
            return localVarFp.getBranding(requestParameters.name, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns a list of branding items.
         * @summary List of branding items
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingList(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<BrandingItem>> {
            return localVarFp.getBrandingList(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint updates information for an existing branding item.
         * @summary Update a branding item
         * @param {BrandingApiSetBrandingItemRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setBrandingItem(requestParameters: BrandingApiSetBrandingItemRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<BrandingItem> {
            return localVarFp.setBrandingItem(requestParameters.name, requestParameters.name2, requestParameters.productName, requestParameters.actionButtonColor, requestParameters.activeLinkColor, requestParameters.navigationColor, requestParameters.emailFromAddress, requestParameters.loginInformationalMessage, requestParameters.fileStandard, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createBrandingItem operation in BrandingApi.
 * @export
 * @interface BrandingApiCreateBrandingItemRequest
 */
export interface BrandingApiCreateBrandingItemRequest {
    /**
     * name of branding item
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly name: string

    /**
     * product name
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly productName: string | null

    /**
     * hex value of color for action button
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly actionButtonColor?: string

    /**
     * hex value of color for link
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly activeLinkColor?: string

    /**
     * hex value of color for navigation bar
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly navigationColor?: string

    /**
     * email from address
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly emailFromAddress?: string

    /**
     * login information message
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly loginInformationalMessage?: string

    /**
     * png file with logo
     * @type {File}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly fileStandard?: File
}

/**
 * Request parameters for deleteBranding operation in BrandingApi.
 * @export
 * @interface BrandingApiDeleteBrandingRequest
 */
export interface BrandingApiDeleteBrandingRequest {
    /**
     * The name of the branding item to be deleted
     * @type {string}
     * @memberof BrandingApiDeleteBranding
     */
    readonly name: string
}

/**
 * Request parameters for getBranding operation in BrandingApi.
 * @export
 * @interface BrandingApiGetBrandingRequest
 */
export interface BrandingApiGetBrandingRequest {
    /**
     * The name of the branding item to be retrieved
     * @type {string}
     * @memberof BrandingApiGetBranding
     */
    readonly name: string
}

/**
 * Request parameters for setBrandingItem operation in BrandingApi.
 * @export
 * @interface BrandingApiSetBrandingItemRequest
 */
export interface BrandingApiSetBrandingItemRequest {
    /**
     * The name of the branding item to be retrieved
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly name: string

    /**
     * name of branding item
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly name2: string

    /**
     * product name
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly productName: string | null

    /**
     * hex value of color for action button
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly actionButtonColor?: string

    /**
     * hex value of color for link
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly activeLinkColor?: string

    /**
     * hex value of color for navigation bar
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly navigationColor?: string

    /**
     * email from address
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly emailFromAddress?: string

    /**
     * login information message
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly loginInformationalMessage?: string

    /**
     * png file with logo
     * @type {File}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly fileStandard?: File
}

/**
 * BrandingApi - object-oriented interface
 * @export
 * @class BrandingApi
 * @extends {BaseAPI}
 */
export class BrandingApi extends BaseAPI {
    /**
     * This API endpoint creates a branding item.
     * @summary Create a branding item
     * @param {BrandingApiCreateBrandingItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public createBrandingItem(requestParameters: BrandingApiCreateBrandingItemRequest, axiosOptions?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).createBrandingItem(requestParameters.name, requestParameters.productName, requestParameters.actionButtonColor, requestParameters.activeLinkColor, requestParameters.navigationColor, requestParameters.emailFromAddress, requestParameters.loginInformationalMessage, requestParameters.fileStandard, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint delete information for an existing branding item by name.    
     * @summary Delete a branding item
     * @param {BrandingApiDeleteBrandingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public deleteBranding(requestParameters: BrandingApiDeleteBrandingRequest, axiosOptions?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).deleteBranding(requestParameters.name, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint retrieves information for an existing branding item by name.    
     * @summary Get a branding item
     * @param {BrandingApiGetBrandingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public getBranding(requestParameters: BrandingApiGetBrandingRequest, axiosOptions?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).getBranding(requestParameters.name, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns a list of branding items.
     * @summary List of branding items
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public getBrandingList(axiosOptions?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).getBrandingList(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint updates information for an existing branding item.
     * @summary Update a branding item
     * @param {BrandingApiSetBrandingItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public setBrandingItem(requestParameters: BrandingApiSetBrandingItemRequest, axiosOptions?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).setBrandingItem(requestParameters.name, requestParameters.name2, requestParameters.productName, requestParameters.actionButtonColor, requestParameters.activeLinkColor, requestParameters.navigationColor, requestParameters.emailFromAddress, requestParameters.loginInformationalMessage, requestParameters.fileStandard, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CertificationCampaignFiltersApi - axios parameter creator
 * @export
 */
export const CertificationCampaignFiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to create a campaign filter based on filter details and criteria.
         * @summary Create Campaign Filter
         * @param {CampaignFilterDetails} campaignFilterDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignFilter: async (campaignFilterDetails: CampaignFilterDetails, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignFilterDetails' is not null or undefined
            assertParamExists('createCampaignFilter', 'campaignFilterDetails', campaignFilterDetails)
            const localVarPath = `/campaign-filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignFilterDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaign Filters
         * @param {Array<string>} requestBody A json list of IDs of campaign filters to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignFilters: async (requestBody: Array<string>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('deleteCampaignFilters', 'requestBody', requestBody)
            const localVarPath = `/campaign-filters/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information for an existing campaign filter using the filter\'s ID.
         * @summary Get Campaign Filter by ID
         * @param {string} id The ID of the campaign filter to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignFilterById: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignFilterById', 'id', id)
            const localVarPath = `/campaign-filters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to list all campaign filters. You can reduce scope with standard V3 query parameters.
         * @summary List Campaign Filters
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [start] Start/Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [includeSystemFilters] If this is true, the API includes system filters in the count and results. Otherwise it excludes them. If no value is provided, the default is true. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCampaignFilters: async (limit?: number, start?: number, includeSystemFilters?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaign-filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (includeSystemFilters !== undefined) {
                localVarQueryParameter['includeSystemFilters'] = includeSystemFilters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing campaign filter using the filter\'s ID.
         * @summary Updates a Campaign Filter
         * @param {string} filterId The ID of the campaign filter being modified.
         * @param {CampaignFilterDetails} campaignFilterDetails A campaign filter details with updated field values.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaignFilter: async (filterId: string, campaignFilterDetails: CampaignFilterDetails, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterId' is not null or undefined
            assertParamExists('updateCampaignFilter', 'filterId', filterId)
            // verify required parameter 'campaignFilterDetails' is not null or undefined
            assertParamExists('updateCampaignFilter', 'campaignFilterDetails', campaignFilterDetails)
            const localVarPath = `/campaign-filters/{id}`
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignFilterDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationCampaignFiltersApi - functional programming interface
 * @export
 */
export const CertificationCampaignFiltersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationCampaignFiltersApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to create a campaign filter based on filter details and criteria.
         * @summary Create Campaign Filter
         * @param {CampaignFilterDetails} campaignFilterDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaignFilter(campaignFilterDetails: CampaignFilterDetails, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignFilterDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaignFilter(campaignFilterDetails, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignFiltersApi.createCampaignFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaign Filters
         * @param {Array<string>} requestBody A json list of IDs of campaign filters to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaignFilters(requestBody: Array<string>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaignFilters(requestBody, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignFiltersApi.deleteCampaignFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves information for an existing campaign filter using the filter\'s ID.
         * @summary Get Campaign Filter by ID
         * @param {string} id The ID of the campaign filter to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignFilterById(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignFilterDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignFilterById(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignFiltersApi.getCampaignFilterById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to list all campaign filters. You can reduce scope with standard V3 query parameters.
         * @summary List Campaign Filters
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [start] Start/Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [includeSystemFilters] If this is true, the API includes system filters in the count and results. Otherwise it excludes them. If no value is provided, the default is true. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCampaignFilters(limit?: number, start?: number, includeSystemFilters?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCampaignFilters200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCampaignFilters(limit, start, includeSystemFilters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignFiltersApi.listCampaignFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing campaign filter using the filter\'s ID.
         * @summary Updates a Campaign Filter
         * @param {string} filterId The ID of the campaign filter being modified.
         * @param {CampaignFilterDetails} campaignFilterDetails A campaign filter details with updated field values.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateCampaignFilter(filterId: string, campaignFilterDetails: CampaignFilterDetails, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignFilterDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCampaignFilter(filterId, campaignFilterDetails, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignFiltersApi.updateCampaignFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CertificationCampaignFiltersApi - factory interface
 * @export
 */
export const CertificationCampaignFiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationCampaignFiltersApiFp(configuration)
    return {
        /**
         * Use this API to create a campaign filter based on filter details and criteria.
         * @summary Create Campaign Filter
         * @param {CertificationCampaignFiltersApiCreateCampaignFilterRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignFilter(requestParameters: CertificationCampaignFiltersApiCreateCampaignFilterRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CampaignFilterDetails> {
            return localVarFp.createCampaignFilter(requestParameters.campaignFilterDetails, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaign Filters
         * @param {CertificationCampaignFiltersApiDeleteCampaignFiltersRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignFilters(requestParameters: CertificationCampaignFiltersApiDeleteCampaignFiltersRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCampaignFilters(requestParameters.requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves information for an existing campaign filter using the filter\'s ID.
         * @summary Get Campaign Filter by ID
         * @param {CertificationCampaignFiltersApiGetCampaignFilterByIdRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignFilterById(requestParameters: CertificationCampaignFiltersApiGetCampaignFilterByIdRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CampaignFilterDetails> {
            return localVarFp.getCampaignFilterById(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to list all campaign filters. You can reduce scope with standard V3 query parameters.
         * @summary List Campaign Filters
         * @param {CertificationCampaignFiltersApiListCampaignFiltersRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCampaignFilters(requestParameters: CertificationCampaignFiltersApiListCampaignFiltersRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ListCampaignFilters200Response> {
            return localVarFp.listCampaignFilters(requestParameters.limit, requestParameters.start, requestParameters.includeSystemFilters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing campaign filter using the filter\'s ID.
         * @summary Updates a Campaign Filter
         * @param {CertificationCampaignFiltersApiUpdateCampaignFilterRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaignFilter(requestParameters: CertificationCampaignFiltersApiUpdateCampaignFilterRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CampaignFilterDetails> {
            return localVarFp.updateCampaignFilter(requestParameters.filterId, requestParameters.campaignFilterDetails, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCampaignFilter operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiCreateCampaignFilterRequest
 */
export interface CertificationCampaignFiltersApiCreateCampaignFilterRequest {
    /**
     * 
     * @type {CampaignFilterDetails}
     * @memberof CertificationCampaignFiltersApiCreateCampaignFilter
     */
    readonly campaignFilterDetails: CampaignFilterDetails
}

/**
 * Request parameters for deleteCampaignFilters operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiDeleteCampaignFiltersRequest
 */
export interface CertificationCampaignFiltersApiDeleteCampaignFiltersRequest {
    /**
     * A json list of IDs of campaign filters to delete.
     * @type {Array<string>}
     * @memberof CertificationCampaignFiltersApiDeleteCampaignFilters
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for getCampaignFilterById operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiGetCampaignFilterByIdRequest
 */
export interface CertificationCampaignFiltersApiGetCampaignFilterByIdRequest {
    /**
     * The ID of the campaign filter to be retrieved.
     * @type {string}
     * @memberof CertificationCampaignFiltersApiGetCampaignFilterById
     */
    readonly id: string
}

/**
 * Request parameters for listCampaignFilters operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiListCampaignFiltersRequest
 */
export interface CertificationCampaignFiltersApiListCampaignFiltersRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignFiltersApiListCampaignFilters
     */
    readonly limit?: number

    /**
     * Start/Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignFiltersApiListCampaignFilters
     */
    readonly start?: number

    /**
     * If this is true, the API includes system filters in the count and results. Otherwise it excludes them. If no value is provided, the default is true. 
     * @type {boolean}
     * @memberof CertificationCampaignFiltersApiListCampaignFilters
     */
    readonly includeSystemFilters?: boolean
}

/**
 * Request parameters for updateCampaignFilter operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiUpdateCampaignFilterRequest
 */
export interface CertificationCampaignFiltersApiUpdateCampaignFilterRequest {
    /**
     * The ID of the campaign filter being modified.
     * @type {string}
     * @memberof CertificationCampaignFiltersApiUpdateCampaignFilter
     */
    readonly filterId: string

    /**
     * A campaign filter details with updated field values.
     * @type {CampaignFilterDetails}
     * @memberof CertificationCampaignFiltersApiUpdateCampaignFilter
     */
    readonly campaignFilterDetails: CampaignFilterDetails
}

/**
 * CertificationCampaignFiltersApi - object-oriented interface
 * @export
 * @class CertificationCampaignFiltersApi
 * @extends {BaseAPI}
 */
export class CertificationCampaignFiltersApi extends BaseAPI {
    /**
     * Use this API to create a campaign filter based on filter details and criteria.
     * @summary Create Campaign Filter
     * @param {CertificationCampaignFiltersApiCreateCampaignFilterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public createCampaignFilter(requestParameters: CertificationCampaignFiltersApiCreateCampaignFilterRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).createCampaignFilter(requestParameters.campaignFilterDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
     * @summary Deletes Campaign Filters
     * @param {CertificationCampaignFiltersApiDeleteCampaignFiltersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public deleteCampaignFilters(requestParameters: CertificationCampaignFiltersApiDeleteCampaignFiltersRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).deleteCampaignFilters(requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves information for an existing campaign filter using the filter\'s ID.
     * @summary Get Campaign Filter by ID
     * @param {CertificationCampaignFiltersApiGetCampaignFilterByIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public getCampaignFilterById(requestParameters: CertificationCampaignFiltersApiGetCampaignFilterByIdRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).getCampaignFilterById(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to list all campaign filters. You can reduce scope with standard V3 query parameters.
     * @summary List Campaign Filters
     * @param {CertificationCampaignFiltersApiListCampaignFiltersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public listCampaignFilters(requestParameters: CertificationCampaignFiltersApiListCampaignFiltersRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).listCampaignFilters(requestParameters.limit, requestParameters.start, requestParameters.includeSystemFilters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing campaign filter using the filter\'s ID.
     * @summary Updates a Campaign Filter
     * @param {CertificationCampaignFiltersApiUpdateCampaignFilterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public updateCampaignFilter(requestParameters: CertificationCampaignFiltersApiUpdateCampaignFilterRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).updateCampaignFilter(requestParameters.filterId, requestParameters.campaignFilterDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CertificationCampaignsApi - axios parameter creator
 * @export
 */
export const CertificationCampaignsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Use this API to complete a certification campaign. This functionality is provided to admins so that they can complete a certification even if all items have not been completed. 
         * @summary Complete a Campaign
         * @param {string} id Campaign ID.
         * @param {CampaignCompleteOptions} [campaignCompleteOptions] Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeCampaign: async (id: string, campaignCompleteOptions?: CampaignCompleteOptions, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignCompleteOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to create a certification campaign with the information provided in the request body.     
         * @summary Create a campaign
         * @param {Campaign} campaign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign: async (campaign: Campaign, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaign' is not null or undefined
            assertParamExists('createCampaign', 'campaign', campaign)
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to create a certification campaign template based on campaign. 
         * @summary Create a Campaign Template
         * @param {CampaignTemplate} campaignTemplate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignTemplate: async (campaignTemplate: CampaignTemplate, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignTemplate' is not null or undefined
            assertParamExists('createCampaignTemplate', 'campaignTemplate', campaignTemplate)
            const localVarPath = `/campaign-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to delete a certification campaign template by ID. 
         * @summary Delete a Campaign Template
         * @param {string} id ID of the campaign template being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplate: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCampaignTemplate', 'id', id)
            const localVarPath = `/campaign-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to delete the schedule for a certification campaign template. The API returns a 404 if there is no schedule set. 
         * @summary Delete Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplateSchedule: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCampaignTemplateSchedule', 'id', id)
            const localVarPath = `/campaign-templates/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to delete certification campaigns whose IDs are specified in the provided list of campaign IDs. 
         * @summary Delete Campaigns
         * @param {CampaignsDeleteRequest} campaignsDeleteRequest IDs of the campaigns to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaigns: async (campaignsDeleteRequest: CampaignsDeleteRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignsDeleteRequest' is not null or undefined
            assertParamExists('deleteCampaigns', 'campaignsDeleteRequest', campaignsDeleteRequest)
            const localVarPath = `/campaigns/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignsDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get a list of campaigns. This API can provide increased level of detail for each campaign for the correct provided query. 
         * @summary List Campaigns
         * @param {GetActiveCampaignsDetailV3} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCampaigns: async (detail?: GetActiveCampaignsDetailV3, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (detail !== undefined) {
                localVarQueryParameter['detail'] = detail;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get information for an existing certification campaign by the campaign\'s ID. 
         * @summary Get Campaign
         * @param {string} id ID of the campaign to be retrieved.
         * @param {GetCampaignDetailV3} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign: async (id: string, detail?: GetCampaignDetailV3, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (detail !== undefined) {
                localVarQueryParameter['detail'] = detail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to fetch all reports for a certification campaign by campaign ID. 
         * @summary Get Campaign Reports
         * @param {string} id ID of the campaign whose reports are being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReports: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignReports', 'id', id)
            const localVarPath = `/campaigns/{id}/reports`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to fetch the configuration for certification campaign reports. The configuration includes only one element - identity attributes defined as custom report columns.  
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReportsConfig: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns/reports-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to fetch a certification campaign template by ID. 
         * @summary Get a Campaign Template
         * @param {string} id Requested campaign template\&#39;s ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplate: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignTemplate', 'id', id)
            const localVarPath = `/campaign-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get the schedule for a certification campaign template. The API returns a 404 if there is no schedule set. 
         * @summary Get Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplateSchedule: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignTemplateSchedule', 'id', id)
            const localVarPath = `/campaign-templates/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get a list of all campaign templates. Scope can be reduced through standard V3 query params.  The API returns all campaign templates matching the query parameters.  
         * @summary List Campaign Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *eq, ge, gt, in, le, lt, ne, sw*  **id**: *eq, ge, gt, in, le, lt, ne, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplates: async (limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaign-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API reassigns the specified certifications from one identity to another.     
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassign} adminReviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        move: async (id: string, adminReviewReassign: AdminReviewReassign, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('move', 'id', id)
            // verify required parameter 'adminReviewReassign' is not null or undefined
            assertParamExists('move', 'adminReviewReassign', adminReviewReassign)
            const localVarPath = `/campaigns/{id}/reassign`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminReviewReassign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update individual fields on a certification campaign template, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. 
         * @summary Update a Campaign Template
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchCampaignTemplate: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchCampaignTemplate', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchCampaignTemplate', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/campaign-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to overwrite the configuration for campaign reports.  
         * @summary Set Campaign Reports Configuration
         * @param {CampaignReportsConfig} campaignReportsConfig Campaign report configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignReportsConfig: async (campaignReportsConfig: CampaignReportsConfig, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignReportsConfig' is not null or undefined
            assertParamExists('setCampaignReportsConfig', 'campaignReportsConfig', campaignReportsConfig)
            const localVarPath = `/campaigns/reports-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignReportsConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to set the schedule for a certification campaign template. If a schedule already exists, the API overwrites it with the new one. 
         * @summary Set Campaign Template Schedule
         * @param {string} id ID of the campaign template being scheduled.
         * @param {Schedule} [schedule] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignTemplateSchedule: async (id: string, schedule?: Schedule, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setCampaignTemplateSchedule', 'id', id)
            const localVarPath = `/campaign-templates/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schedule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to submit a job to activate the certified campaign with the specified ID. The campaign must be staged. 
         * @summary Activate a Campaign
         * @param {string} id Campaign ID.
         * @param {ActivateCampaignOptions} [activateCampaignOptions] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign: async (id: string, activateCampaignOptions?: ActivateCampaignOptions, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activateCampaignOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to run a remediation scan task for a certification campaign. 
         * @summary Run Campaign Remediation Scan
         * @param {string} id ID of the campaign the remediation scan is being run for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignRemediationScan: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startCampaignRemediationScan', 'id', id)
            const localVarPath = `/campaigns/{id}/run-remediation-scan`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to run a report for a certification campaign. 
         * @summary Run Campaign Report
         * @param {string} id ID of the campaign the report is being run for.
         * @param {ReportType} type Type of the report to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignReport: async (id: string, type: ReportType, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startCampaignReport', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('startCampaignReport', 'type', type)
            const localVarPath = `/campaigns/{id}/run-report/{type}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to generate a new certification campaign from a campaign template.  The campaign object contained in the template has special formatting applied to its name and description fields that determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation.  Placeholders consist of a percent sign followed by a letter indicating what should be inserted. For example, \"%Y\" inserts the current year, and a campaign template named \"Campaign for %y\" generates a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020).  Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). 
         * @summary Generate a Campaign from Template
         * @param {string} id ID of the campaign template to use for generation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startGenerateCampaignTemplate: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startGenerateCampaignTemplate', 'id', id)
            const localVarPath = `/campaign-templates/{id}/generate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update individual fields on a certification campaign, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. 
         * @summary Update a Campaign
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  When the campaign is in the *STAGED* status, you can patch these fields: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  When the campaign is in the *ACTIVE* status, you can patch these fields: * deadline 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCampaign', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateCampaign', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/campaigns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationCampaignsApi - functional programming interface
 * @export
 */
export const CertificationCampaignsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationCampaignsApiAxiosParamCreator(configuration)
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Use this API to complete a certification campaign. This functionality is provided to admins so that they can complete a certification even if all items have not been completed. 
         * @summary Complete a Campaign
         * @param {string} id Campaign ID.
         * @param {CampaignCompleteOptions} [campaignCompleteOptions] Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async completeCampaign(id: string, campaignCompleteOptions?: CampaignCompleteOptions, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeCampaign(id, campaignCompleteOptions, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.completeCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to create a certification campaign with the information provided in the request body.     
         * @summary Create a campaign
         * @param {Campaign} campaign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaign(campaign: Campaign, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaign(campaign, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.createCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to create a certification campaign template based on campaign. 
         * @summary Create a Campaign Template
         * @param {CampaignTemplate} campaignTemplate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaignTemplate(campaignTemplate: CampaignTemplate, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaignTemplate(campaignTemplate, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.createCampaignTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to delete a certification campaign template by ID. 
         * @summary Delete a Campaign Template
         * @param {string} id ID of the campaign template being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaignTemplate(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaignTemplate(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.deleteCampaignTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to delete the schedule for a certification campaign template. The API returns a 404 if there is no schedule set. 
         * @summary Delete Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaignTemplateSchedule(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaignTemplateSchedule(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.deleteCampaignTemplateSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to delete certification campaigns whose IDs are specified in the provided list of campaign IDs. 
         * @summary Delete Campaigns
         * @param {CampaignsDeleteRequest} campaignsDeleteRequest IDs of the campaigns to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaigns(campaignsDeleteRequest: CampaignsDeleteRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaigns(campaignsDeleteRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.deleteCampaigns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to get a list of campaigns. This API can provide increased level of detail for each campaign for the correct provided query. 
         * @summary List Campaigns
         * @param {GetActiveCampaignsDetailV3} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveCampaigns(detail?: GetActiveCampaignsDetailV3, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetActiveCampaigns200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveCampaigns(detail, limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.getActiveCampaigns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to get information for an existing certification campaign by the campaign\'s ID. 
         * @summary Get Campaign
         * @param {string} id ID of the campaign to be retrieved.
         * @param {GetCampaignDetailV3} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaign(id: string, detail?: GetCampaignDetailV3, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetActiveCampaigns200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaign(id, detail, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.getCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to fetch all reports for a certification campaign by campaign ID. 
         * @summary Get Campaign Reports
         * @param {string} id ID of the campaign whose reports are being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignReports(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignReport>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignReports(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.getCampaignReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to fetch the configuration for certification campaign reports. The configuration includes only one element - identity attributes defined as custom report columns.  
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignReportsConfig(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignReportsConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignReportsConfig(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.getCampaignReportsConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to fetch a certification campaign template by ID. 
         * @summary Get a Campaign Template
         * @param {string} id Requested campaign template\&#39;s ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignTemplate(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignTemplate(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.getCampaignTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to get the schedule for a certification campaign template. The API returns a 404 if there is no schedule set. 
         * @summary Get Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignTemplateSchedule(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignTemplateSchedule(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.getCampaignTemplateSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to get a list of all campaign templates. Scope can be reduced through standard V3 query params.  The API returns all campaign templates matching the query parameters.  
         * @summary List Campaign Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *eq, ge, gt, in, le, lt, ne, sw*  **id**: *eq, ge, gt, in, le, lt, ne, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignTemplates(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignTemplates(limit, offset, count, sorters, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.getCampaignTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API reassigns the specified certifications from one identity to another.     
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassign} adminReviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async move(id: string, adminReviewReassign: AdminReviewReassign, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.move(id, adminReviewReassign, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.move']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to update individual fields on a certification campaign template, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. 
         * @summary Update a Campaign Template
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchCampaignTemplate(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCampaignTemplate(id, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.patchCampaignTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to overwrite the configuration for campaign reports.  
         * @summary Set Campaign Reports Configuration
         * @param {CampaignReportsConfig} campaignReportsConfig Campaign report configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setCampaignReportsConfig(campaignReportsConfig: CampaignReportsConfig, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignReportsConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCampaignReportsConfig(campaignReportsConfig, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.setCampaignReportsConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to set the schedule for a certification campaign template. If a schedule already exists, the API overwrites it with the new one. 
         * @summary Set Campaign Template Schedule
         * @param {string} id ID of the campaign template being scheduled.
         * @param {Schedule} [schedule] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setCampaignTemplateSchedule(id: string, schedule?: Schedule, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCampaignTemplateSchedule(id, schedule, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.setCampaignTemplateSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to submit a job to activate the certified campaign with the specified ID. The campaign must be staged. 
         * @summary Activate a Campaign
         * @param {string} id Campaign ID.
         * @param {ActivateCampaignOptions} [activateCampaignOptions] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startCampaign(id: string, activateCampaignOptions?: ActivateCampaignOptions, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCampaign(id, activateCampaignOptions, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.startCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to run a remediation scan task for a certification campaign. 
         * @summary Run Campaign Remediation Scan
         * @param {string} id ID of the campaign the remediation scan is being run for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startCampaignRemediationScan(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCampaignRemediationScan(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.startCampaignRemediationScan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to run a report for a certification campaign. 
         * @summary Run Campaign Report
         * @param {string} id ID of the campaign the report is being run for.
         * @param {ReportType} type Type of the report to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startCampaignReport(id: string, type: ReportType, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCampaignReport(id, type, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.startCampaignReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to generate a new certification campaign from a campaign template.  The campaign object contained in the template has special formatting applied to its name and description fields that determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation.  Placeholders consist of a percent sign followed by a letter indicating what should be inserted. For example, \"%Y\" inserts the current year, and a campaign template named \"Campaign for %y\" generates a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020).  Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). 
         * @summary Generate a Campaign from Template
         * @param {string} id ID of the campaign template to use for generation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startGenerateCampaignTemplate(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startGenerateCampaignTemplate(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.startGenerateCampaignTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to update individual fields on a certification campaign, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. 
         * @summary Update a Campaign
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  When the campaign is in the *STAGED* status, you can patch these fields: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  When the campaign is in the *ACTIVE* status, you can patch these fields: * deadline 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateCampaign(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlimCampaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCampaign(id, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationCampaignsApi.updateCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CertificationCampaignsApi - factory interface
 * @export
 */
export const CertificationCampaignsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationCampaignsApiFp(configuration)
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Use this API to complete a certification campaign. This functionality is provided to admins so that they can complete a certification even if all items have not been completed. 
         * @summary Complete a Campaign
         * @param {CertificationCampaignsApiCompleteCampaignRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeCampaign(requestParameters: CertificationCampaignsApiCompleteCampaignRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.completeCampaign(requestParameters.id, requestParameters.campaignCompleteOptions, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to create a certification campaign with the information provided in the request body.     
         * @summary Create a campaign
         * @param {CertificationCampaignsApiCreateCampaignRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign(requestParameters: CertificationCampaignsApiCreateCampaignRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.createCampaign(requestParameters.campaign, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to create a certification campaign template based on campaign. 
         * @summary Create a Campaign Template
         * @param {CertificationCampaignsApiCreateCampaignTemplateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignTemplate(requestParameters: CertificationCampaignsApiCreateCampaignTemplateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CampaignTemplate> {
            return localVarFp.createCampaignTemplate(requestParameters.campaignTemplate, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to delete a certification campaign template by ID. 
         * @summary Delete a Campaign Template
         * @param {CertificationCampaignsApiDeleteCampaignTemplateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplate(requestParameters: CertificationCampaignsApiDeleteCampaignTemplateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to delete the schedule for a certification campaign template. The API returns a 404 if there is no schedule set. 
         * @summary Delete Campaign Template Schedule
         * @param {CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCampaignTemplateSchedule(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to delete certification campaigns whose IDs are specified in the provided list of campaign IDs. 
         * @summary Delete Campaigns
         * @param {CertificationCampaignsApiDeleteCampaignsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaigns(requestParameters: CertificationCampaignsApiDeleteCampaignsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteCampaigns(requestParameters.campaignsDeleteRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get a list of campaigns. This API can provide increased level of detail for each campaign for the correct provided query. 
         * @summary List Campaigns
         * @param {CertificationCampaignsApiGetActiveCampaignsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCampaigns(requestParameters: CertificationCampaignsApiGetActiveCampaignsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<GetActiveCampaigns200ResponseInner>> {
            return localVarFp.getActiveCampaigns(requestParameters.detail, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get information for an existing certification campaign by the campaign\'s ID. 
         * @summary Get Campaign
         * @param {CertificationCampaignsApiGetCampaignRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign(requestParameters: CertificationCampaignsApiGetCampaignRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<GetActiveCampaigns200ResponseInner> {
            return localVarFp.getCampaign(requestParameters.id, requestParameters.detail, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to fetch all reports for a certification campaign by campaign ID. 
         * @summary Get Campaign Reports
         * @param {CertificationCampaignsApiGetCampaignReportsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReports(requestParameters: CertificationCampaignsApiGetCampaignReportsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<CampaignReport>> {
            return localVarFp.getCampaignReports(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to fetch the configuration for certification campaign reports. The configuration includes only one element - identity attributes defined as custom report columns.  
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReportsConfig(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CampaignReportsConfig> {
            return localVarFp.getCampaignReportsConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to fetch a certification campaign template by ID. 
         * @summary Get a Campaign Template
         * @param {CertificationCampaignsApiGetCampaignTemplateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplate(requestParameters: CertificationCampaignsApiGetCampaignTemplateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CampaignTemplate> {
            return localVarFp.getCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get the schedule for a certification campaign template. The API returns a 404 if there is no schedule set. 
         * @summary Get Campaign Template Schedule
         * @param {CertificationCampaignsApiGetCampaignTemplateScheduleRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiGetCampaignTemplateScheduleRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Schedule> {
            return localVarFp.getCampaignTemplateSchedule(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get a list of all campaign templates. Scope can be reduced through standard V3 query params.  The API returns all campaign templates matching the query parameters.  
         * @summary List Campaign Templates
         * @param {CertificationCampaignsApiGetCampaignTemplatesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplates(requestParameters: CertificationCampaignsApiGetCampaignTemplatesRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<CampaignTemplate>> {
            return localVarFp.getCampaignTemplates(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API reassigns the specified certifications from one identity to another.     
         * @summary Reassign Certifications
         * @param {CertificationCampaignsApiMoveRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        move(requestParameters: CertificationCampaignsApiMoveRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CertificationTask> {
            return localVarFp.move(requestParameters.id, requestParameters.adminReviewReassign, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to update individual fields on a certification campaign template, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. 
         * @summary Update a Campaign Template
         * @param {CertificationCampaignsApiPatchCampaignTemplateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchCampaignTemplate(requestParameters: CertificationCampaignsApiPatchCampaignTemplateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CampaignTemplate> {
            return localVarFp.patchCampaignTemplate(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to overwrite the configuration for campaign reports.  
         * @summary Set Campaign Reports Configuration
         * @param {CertificationCampaignsApiSetCampaignReportsConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignReportsConfig(requestParameters: CertificationCampaignsApiSetCampaignReportsConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CampaignReportsConfig> {
            return localVarFp.setCampaignReportsConfig(requestParameters.campaignReportsConfig, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to set the schedule for a certification campaign template. If a schedule already exists, the API overwrites it with the new one. 
         * @summary Set Campaign Template Schedule
         * @param {CertificationCampaignsApiSetCampaignTemplateScheduleRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiSetCampaignTemplateScheduleRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setCampaignTemplateSchedule(requestParameters.id, requestParameters.schedule, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to submit a job to activate the certified campaign with the specified ID. The campaign must be staged. 
         * @summary Activate a Campaign
         * @param {CertificationCampaignsApiStartCampaignRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign(requestParameters: CertificationCampaignsApiStartCampaignRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.startCampaign(requestParameters.id, requestParameters.activateCampaignOptions, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to run a remediation scan task for a certification campaign. 
         * @summary Run Campaign Remediation Scan
         * @param {CertificationCampaignsApiStartCampaignRemediationScanRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignRemediationScan(requestParameters: CertificationCampaignsApiStartCampaignRemediationScanRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.startCampaignRemediationScan(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to run a report for a certification campaign. 
         * @summary Run Campaign Report
         * @param {CertificationCampaignsApiStartCampaignReportRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignReport(requestParameters: CertificationCampaignsApiStartCampaignReportRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.startCampaignReport(requestParameters.id, requestParameters.type, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to generate a new certification campaign from a campaign template.  The campaign object contained in the template has special formatting applied to its name and description fields that determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation.  Placeholders consist of a percent sign followed by a letter indicating what should be inserted. For example, \"%Y\" inserts the current year, and a campaign template named \"Campaign for %y\" generates a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020).  Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). 
         * @summary Generate a Campaign from Template
         * @param {CertificationCampaignsApiStartGenerateCampaignTemplateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startGenerateCampaignTemplate(requestParameters: CertificationCampaignsApiStartGenerateCampaignTemplateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CampaignReference> {
            return localVarFp.startGenerateCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to update individual fields on a certification campaign, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. 
         * @summary Update a Campaign
         * @param {CertificationCampaignsApiUpdateCampaignRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign(requestParameters: CertificationCampaignsApiUpdateCampaignRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SlimCampaign> {
            return localVarFp.updateCampaign(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for completeCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiCompleteCampaignRequest
 */
export interface CertificationCampaignsApiCompleteCampaignRequest {
    /**
     * Campaign ID.
     * @type {string}
     * @memberof CertificationCampaignsApiCompleteCampaign
     */
    readonly id: string

    /**
     * Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
     * @type {CampaignCompleteOptions}
     * @memberof CertificationCampaignsApiCompleteCampaign
     */
    readonly campaignCompleteOptions?: CampaignCompleteOptions
}

/**
 * Request parameters for createCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiCreateCampaignRequest
 */
export interface CertificationCampaignsApiCreateCampaignRequest {
    /**
     * 
     * @type {Campaign}
     * @memberof CertificationCampaignsApiCreateCampaign
     */
    readonly campaign: Campaign
}

/**
 * Request parameters for createCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiCreateCampaignTemplateRequest
 */
export interface CertificationCampaignsApiCreateCampaignTemplateRequest {
    /**
     * 
     * @type {CampaignTemplate}
     * @memberof CertificationCampaignsApiCreateCampaignTemplate
     */
    readonly campaignTemplate: CampaignTemplate
}

/**
 * Request parameters for deleteCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiDeleteCampaignTemplateRequest
 */
export interface CertificationCampaignsApiDeleteCampaignTemplateRequest {
    /**
     * ID of the campaign template being deleted.
     * @type {string}
     * @memberof CertificationCampaignsApiDeleteCampaignTemplate
     */
    readonly id: string
}

/**
 * Request parameters for deleteCampaignTemplateSchedule operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest
 */
export interface CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest {
    /**
     * ID of the campaign template whose schedule is being deleted.
     * @type {string}
     * @memberof CertificationCampaignsApiDeleteCampaignTemplateSchedule
     */
    readonly id: string
}

/**
 * Request parameters for deleteCampaigns operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiDeleteCampaignsRequest
 */
export interface CertificationCampaignsApiDeleteCampaignsRequest {
    /**
     * IDs of the campaigns to delete.
     * @type {CampaignsDeleteRequest}
     * @memberof CertificationCampaignsApiDeleteCampaigns
     */
    readonly campaignsDeleteRequest: CampaignsDeleteRequest
}

/**
 * Request parameters for getActiveCampaigns operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetActiveCampaignsRequest
 */
export interface CertificationCampaignsApiGetActiveCampaignsRequest {
    /**
     * Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
     * @type {'SLIM' | 'FULL'}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly detail?: GetActiveCampaignsDetailV3

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
     * @type {string}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created**
     * @type {string}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly sorters?: string
}

/**
 * Request parameters for getCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignRequest
 */
export interface CertificationCampaignsApiGetCampaignRequest {
    /**
     * ID of the campaign to be retrieved.
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaign
     */
    readonly id: string

    /**
     * Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
     * @type {'SLIM' | 'FULL'}
     * @memberof CertificationCampaignsApiGetCampaign
     */
    readonly detail?: GetCampaignDetailV3
}

/**
 * Request parameters for getCampaignReports operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignReportsRequest
 */
export interface CertificationCampaignsApiGetCampaignReportsRequest {
    /**
     * ID of the campaign whose reports are being fetched.
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaignReports
     */
    readonly id: string
}

/**
 * Request parameters for getCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignTemplateRequest
 */
export interface CertificationCampaignsApiGetCampaignTemplateRequest {
    /**
     * Requested campaign template\&#39;s ID.
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaignTemplate
     */
    readonly id: string
}

/**
 * Request parameters for getCampaignTemplateSchedule operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignTemplateScheduleRequest
 */
export interface CertificationCampaignsApiGetCampaignTemplateScheduleRequest {
    /**
     * ID of the campaign template whose schedule is being fetched.
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaignTemplateSchedule
     */
    readonly id: string
}

/**
 * Request parameters for getCampaignTemplates operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignTemplatesRequest
 */
export interface CertificationCampaignsApiGetCampaignTemplatesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiGetCampaignTemplates
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiGetCampaignTemplates
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationCampaignsApiGetCampaignTemplates
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaignTemplates
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *eq, ge, gt, in, le, lt, ne, sw*  **id**: *eq, ge, gt, in, le, lt, ne, sw*
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaignTemplates
     */
    readonly filters?: string
}

/**
 * Request parameters for move operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiMoveRequest
 */
export interface CertificationCampaignsApiMoveRequest {
    /**
     * The certification campaign ID
     * @type {string}
     * @memberof CertificationCampaignsApiMove
     */
    readonly id: string

    /**
     * 
     * @type {AdminReviewReassign}
     * @memberof CertificationCampaignsApiMove
     */
    readonly adminReviewReassign: AdminReviewReassign
}

/**
 * Request parameters for patchCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiPatchCampaignTemplateRequest
 */
export interface CertificationCampaignsApiPatchCampaignTemplateRequest {
    /**
     * ID of the campaign template being modified.
     * @type {string}
     * @memberof CertificationCampaignsApiPatchCampaignTemplate
     */
    readonly id: string

    /**
     * A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
     * @type {Array<JsonPatchOperation>}
     * @memberof CertificationCampaignsApiPatchCampaignTemplate
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for setCampaignReportsConfig operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiSetCampaignReportsConfigRequest
 */
export interface CertificationCampaignsApiSetCampaignReportsConfigRequest {
    /**
     * Campaign report configuration.
     * @type {CampaignReportsConfig}
     * @memberof CertificationCampaignsApiSetCampaignReportsConfig
     */
    readonly campaignReportsConfig: CampaignReportsConfig
}

/**
 * Request parameters for setCampaignTemplateSchedule operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiSetCampaignTemplateScheduleRequest
 */
export interface CertificationCampaignsApiSetCampaignTemplateScheduleRequest {
    /**
     * ID of the campaign template being scheduled.
     * @type {string}
     * @memberof CertificationCampaignsApiSetCampaignTemplateSchedule
     */
    readonly id: string

    /**
     * 
     * @type {Schedule}
     * @memberof CertificationCampaignsApiSetCampaignTemplateSchedule
     */
    readonly schedule?: Schedule
}

/**
 * Request parameters for startCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiStartCampaignRequest
 */
export interface CertificationCampaignsApiStartCampaignRequest {
    /**
     * Campaign ID.
     * @type {string}
     * @memberof CertificationCampaignsApiStartCampaign
     */
    readonly id: string

    /**
     * Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
     * @type {ActivateCampaignOptions}
     * @memberof CertificationCampaignsApiStartCampaign
     */
    readonly activateCampaignOptions?: ActivateCampaignOptions
}

/**
 * Request parameters for startCampaignRemediationScan operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiStartCampaignRemediationScanRequest
 */
export interface CertificationCampaignsApiStartCampaignRemediationScanRequest {
    /**
     * ID of the campaign the remediation scan is being run for.
     * @type {string}
     * @memberof CertificationCampaignsApiStartCampaignRemediationScan
     */
    readonly id: string
}

/**
 * Request parameters for startCampaignReport operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiStartCampaignReportRequest
 */
export interface CertificationCampaignsApiStartCampaignReportRequest {
    /**
     * ID of the campaign the report is being run for.
     * @type {string}
     * @memberof CertificationCampaignsApiStartCampaignReport
     */
    readonly id: string

    /**
     * Type of the report to run.
     * @type {ReportType}
     * @memberof CertificationCampaignsApiStartCampaignReport
     */
    readonly type: ReportType
}

/**
 * Request parameters for startGenerateCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiStartGenerateCampaignTemplateRequest
 */
export interface CertificationCampaignsApiStartGenerateCampaignTemplateRequest {
    /**
     * ID of the campaign template to use for generation.
     * @type {string}
     * @memberof CertificationCampaignsApiStartGenerateCampaignTemplate
     */
    readonly id: string
}

/**
 * Request parameters for updateCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiUpdateCampaignRequest
 */
export interface CertificationCampaignsApiUpdateCampaignRequest {
    /**
     * ID of the campaign template being modified.
     * @type {string}
     * @memberof CertificationCampaignsApiUpdateCampaign
     */
    readonly id: string

    /**
     * A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  When the campaign is in the *STAGED* status, you can patch these fields: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  When the campaign is in the *ACTIVE* status, you can patch these fields: * deadline 
     * @type {Array<JsonPatchOperation>}
     * @memberof CertificationCampaignsApiUpdateCampaign
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * CertificationCampaignsApi - object-oriented interface
 * @export
 * @class CertificationCampaignsApi
 * @extends {BaseAPI}
 */
export class CertificationCampaignsApi extends BaseAPI {
    /**
     * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Use this API to complete a certification campaign. This functionality is provided to admins so that they can complete a certification even if all items have not been completed. 
     * @summary Complete a Campaign
     * @param {CertificationCampaignsApiCompleteCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public completeCampaign(requestParameters: CertificationCampaignsApiCompleteCampaignRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).completeCampaign(requestParameters.id, requestParameters.campaignCompleteOptions, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to create a certification campaign with the information provided in the request body.     
     * @summary Create a campaign
     * @param {CertificationCampaignsApiCreateCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public createCampaign(requestParameters: CertificationCampaignsApiCreateCampaignRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).createCampaign(requestParameters.campaign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to create a certification campaign template based on campaign. 
     * @summary Create a Campaign Template
     * @param {CertificationCampaignsApiCreateCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public createCampaignTemplate(requestParameters: CertificationCampaignsApiCreateCampaignTemplateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).createCampaignTemplate(requestParameters.campaignTemplate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to delete a certification campaign template by ID. 
     * @summary Delete a Campaign Template
     * @param {CertificationCampaignsApiDeleteCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public deleteCampaignTemplate(requestParameters: CertificationCampaignsApiDeleteCampaignTemplateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).deleteCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to delete the schedule for a certification campaign template. The API returns a 404 if there is no schedule set. 
     * @summary Delete Campaign Template Schedule
     * @param {CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public deleteCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).deleteCampaignTemplateSchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to delete certification campaigns whose IDs are specified in the provided list of campaign IDs. 
     * @summary Delete Campaigns
     * @param {CertificationCampaignsApiDeleteCampaignsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public deleteCampaigns(requestParameters: CertificationCampaignsApiDeleteCampaignsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).deleteCampaigns(requestParameters.campaignsDeleteRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get a list of campaigns. This API can provide increased level of detail for each campaign for the correct provided query. 
     * @summary List Campaigns
     * @param {CertificationCampaignsApiGetActiveCampaignsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getActiveCampaigns(requestParameters: CertificationCampaignsApiGetActiveCampaignsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getActiveCampaigns(requestParameters.detail, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get information for an existing certification campaign by the campaign\'s ID. 
     * @summary Get Campaign
     * @param {CertificationCampaignsApiGetCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaign(requestParameters: CertificationCampaignsApiGetCampaignRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaign(requestParameters.id, requestParameters.detail, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to fetch all reports for a certification campaign by campaign ID. 
     * @summary Get Campaign Reports
     * @param {CertificationCampaignsApiGetCampaignReportsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignReports(requestParameters: CertificationCampaignsApiGetCampaignReportsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignReports(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to fetch the configuration for certification campaign reports. The configuration includes only one element - identity attributes defined as custom report columns.  
     * @summary Get Campaign Reports Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignReportsConfig(axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignReportsConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to fetch a certification campaign template by ID. 
     * @summary Get a Campaign Template
     * @param {CertificationCampaignsApiGetCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignTemplate(requestParameters: CertificationCampaignsApiGetCampaignTemplateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get the schedule for a certification campaign template. The API returns a 404 if there is no schedule set. 
     * @summary Get Campaign Template Schedule
     * @param {CertificationCampaignsApiGetCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiGetCampaignTemplateScheduleRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignTemplateSchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get a list of all campaign templates. Scope can be reduced through standard V3 query params.  The API returns all campaign templates matching the query parameters.  
     * @summary List Campaign Templates
     * @param {CertificationCampaignsApiGetCampaignTemplatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignTemplates(requestParameters: CertificationCampaignsApiGetCampaignTemplatesRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignTemplates(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API reassigns the specified certifications from one identity to another.     
     * @summary Reassign Certifications
     * @param {CertificationCampaignsApiMoveRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public move(requestParameters: CertificationCampaignsApiMoveRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).move(requestParameters.id, requestParameters.adminReviewReassign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to update individual fields on a certification campaign template, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. 
     * @summary Update a Campaign Template
     * @param {CertificationCampaignsApiPatchCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public patchCampaignTemplate(requestParameters: CertificationCampaignsApiPatchCampaignTemplateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).patchCampaignTemplate(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to overwrite the configuration for campaign reports.  
     * @summary Set Campaign Reports Configuration
     * @param {CertificationCampaignsApiSetCampaignReportsConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public setCampaignReportsConfig(requestParameters: CertificationCampaignsApiSetCampaignReportsConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).setCampaignReportsConfig(requestParameters.campaignReportsConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to set the schedule for a certification campaign template. If a schedule already exists, the API overwrites it with the new one. 
     * @summary Set Campaign Template Schedule
     * @param {CertificationCampaignsApiSetCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public setCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiSetCampaignTemplateScheduleRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).setCampaignTemplateSchedule(requestParameters.id, requestParameters.schedule, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to submit a job to activate the certified campaign with the specified ID. The campaign must be staged. 
     * @summary Activate a Campaign
     * @param {CertificationCampaignsApiStartCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public startCampaign(requestParameters: CertificationCampaignsApiStartCampaignRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).startCampaign(requestParameters.id, requestParameters.activateCampaignOptions, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to run a remediation scan task for a certification campaign. 
     * @summary Run Campaign Remediation Scan
     * @param {CertificationCampaignsApiStartCampaignRemediationScanRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public startCampaignRemediationScan(requestParameters: CertificationCampaignsApiStartCampaignRemediationScanRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).startCampaignRemediationScan(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to run a report for a certification campaign. 
     * @summary Run Campaign Report
     * @param {CertificationCampaignsApiStartCampaignReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public startCampaignReport(requestParameters: CertificationCampaignsApiStartCampaignReportRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).startCampaignReport(requestParameters.id, requestParameters.type, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to generate a new certification campaign from a campaign template.  The campaign object contained in the template has special formatting applied to its name and description fields that determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation.  Placeholders consist of a percent sign followed by a letter indicating what should be inserted. For example, \"%Y\" inserts the current year, and a campaign template named \"Campaign for %y\" generates a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020).  Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). 
     * @summary Generate a Campaign from Template
     * @param {CertificationCampaignsApiStartGenerateCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public startGenerateCampaignTemplate(requestParameters: CertificationCampaignsApiStartGenerateCampaignTemplateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).startGenerateCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to update individual fields on a certification campaign, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. 
     * @summary Update a Campaign
     * @param {CertificationCampaignsApiUpdateCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public updateCampaign(requestParameters: CertificationCampaignsApiUpdateCampaignRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).updateCampaign(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetActiveCampaignsDetailV3 = {
    Slim: 'SLIM',
    Full: 'FULL'
} as const;
export type GetActiveCampaignsDetailV3 = typeof GetActiveCampaignsDetailV3[keyof typeof GetActiveCampaignsDetailV3];
/**
 * @export
 */
export const GetCampaignDetailV3 = {
    Slim: 'SLIM',
    Full: 'FULL'
} as const;
export type GetCampaignDetailV3 = typeof GetCampaignDetailV3[keyof typeof GetCampaignDetailV3];


/**
 * CertificationSummariesApi - axios parameter creator
 * @export
 */
export const CertificationSummariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {GetIdentityAccessSummariesTypeV3} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityAccessSummaries: async (id: string, type: GetIdentityAccessSummariesTypeV3, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityAccessSummaries', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getIdentityAccessSummaries', 'type', type)
            const localVarPath = `/certifications/{id}/access-summaries/{type}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityDecisionSummary: async (id: string, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityDecisionSummary', 'id', id)
            const localVarPath = `/certifications/{id}/decision-summary`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummaries: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentitySummaries', 'id', id)
            const localVarPath = `/certifications/{id}/identity-summaries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummary: async (id: string, identitySummaryId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentitySummary', 'id', id)
            // verify required parameter 'identitySummaryId' is not null or undefined
            assertParamExists('getIdentitySummary', 'identitySummaryId', identitySummaryId)
            const localVarPath = `/certifications/{id}/identity-summaries/{identitySummaryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"identitySummaryId"}}`, encodeURIComponent(String(identitySummaryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationSummariesApi - functional programming interface
 * @export
 */
export const CertificationSummariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationSummariesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {GetIdentityAccessSummariesTypeV3} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityAccessSummaries(id: string, type: GetIdentityAccessSummariesTypeV3, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityAccessSummaries(id, type, limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationSummariesApi.getIdentityAccessSummaries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityDecisionSummary(id: string, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertDecisionSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityDecisionSummary(id, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationSummariesApi.getIdentityDecisionSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentitySummaries(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CertificationIdentitySummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentitySummaries(id, limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationSummariesApi.getIdentitySummaries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentitySummary(id: string, identitySummaryId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationIdentitySummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentitySummary(id, identitySummaryId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationSummariesApi.getIdentitySummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CertificationSummariesApi - factory interface
 * @export
 */
export const CertificationSummariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationSummariesApiFp(configuration)
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {CertificationSummariesApiGetIdentityAccessSummariesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityAccessSummaries(requestParameters: CertificationSummariesApiGetIdentityAccessSummariesRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<AccessSummary>> {
            return localVarFp.getIdentityAccessSummaries(requestParameters.id, requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {CertificationSummariesApiGetIdentityDecisionSummaryRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityDecisionSummary(requestParameters: CertificationSummariesApiGetIdentityDecisionSummaryRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<IdentityCertDecisionSummary> {
            return localVarFp.getIdentityDecisionSummary(requestParameters.id, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {CertificationSummariesApiGetIdentitySummariesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummaries(requestParameters: CertificationSummariesApiGetIdentitySummariesRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<CertificationIdentitySummary>> {
            return localVarFp.getIdentitySummaries(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {CertificationSummariesApiGetIdentitySummaryRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummary(requestParameters: CertificationSummariesApiGetIdentitySummaryRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CertificationIdentitySummary> {
            return localVarFp.getIdentitySummary(requestParameters.id, requestParameters.identitySummaryId, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getIdentityAccessSummaries operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentityAccessSummariesRequest
 */
export interface CertificationSummariesApiGetIdentityAccessSummariesRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly id: string

    /**
     * The type of access review item to retrieve summaries for
     * @type {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly type: GetIdentityAccessSummariesTypeV3

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly sorters?: string
}

/**
 * Request parameters for getIdentityDecisionSummary operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentityDecisionSummaryRequest
 */
export interface CertificationSummariesApiGetIdentityDecisionSummaryRequest {
    /**
     * The certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityDecisionSummary
     */
    readonly id: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityDecisionSummary
     */
    readonly filters?: string
}

/**
 * Request parameters for getIdentitySummaries operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentitySummariesRequest
 */
export interface CertificationSummariesApiGetIdentitySummariesRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly sorters?: string
}

/**
 * Request parameters for getIdentitySummary operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentitySummaryRequest
 */
export interface CertificationSummariesApiGetIdentitySummaryRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummary
     */
    readonly id: string

    /**
     * The identity summary ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummary
     */
    readonly identitySummaryId: string
}

/**
 * CertificationSummariesApi - object-oriented interface
 * @export
 * @class CertificationSummariesApi
 * @extends {BaseAPI}
 */
export class CertificationSummariesApi extends BaseAPI {
    /**
     * This API returns a list of access summaries for the specified identity campaign certification and type. Reviewers for this certification can also call this API.
     * @summary Access Summaries
     * @param {CertificationSummariesApiGetIdentityAccessSummariesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentityAccessSummaries(requestParameters: CertificationSummariesApiGetIdentityAccessSummariesRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentityAccessSummaries(requestParameters.id, requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. Reviewers for this certification can also call this API.
     * @summary Summary of Certification Decisions
     * @param {CertificationSummariesApiGetIdentityDecisionSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentityDecisionSummary(requestParameters: CertificationSummariesApiGetIdentityDecisionSummaryRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentityDecisionSummary(requestParameters.id, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of the identity summaries for a specific identity campaign certification. Reviewers for this certification can also call this API.
     * @summary Identity Summaries for Campaign Certification
     * @param {CertificationSummariesApiGetIdentitySummariesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentitySummaries(requestParameters: CertificationSummariesApiGetIdentitySummariesRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentitySummaries(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the summary for an identity on a specified identity campaign certification. Reviewers for this certification can also call this API.
     * @summary Summary for Identity
     * @param {CertificationSummariesApiGetIdentitySummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentitySummary(requestParameters: CertificationSummariesApiGetIdentitySummaryRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentitySummary(requestParameters.id, requestParameters.identitySummaryId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetIdentityAccessSummariesTypeV3 = {
    Role: 'ROLE',
    AccessProfile: 'ACCESS_PROFILE',
    Entitlement: 'ENTITLEMENT'
} as const;
export type GetIdentityAccessSummariesTypeV3 = typeof GetIdentityAccessSummariesTypeV3[keyof typeof GetIdentityAccessSummariesTypeV3];


/**
 * CertificationsApi - axios parameter creator
 * @export
 */
export const CertificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the certification task for the specified ID. Reviewers for the specified certification can also call this API.
         * @summary Certification Task by ID
         * @param {string} id The task ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCertificationTask: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCertificationTask', 'id', id)
            const localVarPath = `/certification-tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a single identity campaign certification by its ID. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertification: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityCertification', 'id', id)
            const localVarPath = `/certifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {string} certificationId The certification ID
         * @param {string} itemId The certification item ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators: *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field.  For example, the following is valid: &#x60;?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22&#x60;  The following is invalid: 1?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)1
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationItemPermissions: async (certificationId: string, itemId: string, filters?: string, limit?: number, offset?: number, count?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificationId' is not null or undefined
            assertParamExists('getIdentityCertificationItemPermissions', 'certificationId', certificationId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getIdentityCertificationItemPermissions', 'itemId', itemId)
            const localVarPath = `/certifications/{certificationId}/access-review-items/{itemId}/permissions`
                .replace(`{${"certificationId"}}`, encodeURIComponent(String(certificationId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
         * @summary List of Pending Certification Tasks
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **targetId**: *eq, in*  **type**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPendingCertificationTasks: async (reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/certification-tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (reviewerIdentity !== undefined) {
                localVarQueryParameter['reviewer-identity'] = reviewerIdentity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of reviewers for the certification. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for certification
         * @param {string} id The certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCertificationReviewers: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listCertificationReviewers', 'id', id)
            const localVarPath = `/certifications/{id}/reviewers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type**: *eq*  **access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessReviewItems: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, entitlements?: string, accessProfiles?: string, roles?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listIdentityAccessReviewItems', 'id', id)
            const localVarPath = `/certifications/{id}/access-review-items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (entitlements !== undefined) {
                localVarQueryParameter['entitlements'] = entitlements;
            }

            if (accessProfiles !== undefined) {
                localVarQueryParameter['access-profiles'] = accessProfiles;
            }

            if (roles !== undefined) {
                localVarQueryParameter['roles'] = roles;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get a list of identity campaign certifications for the specified query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to governance groups.
         * @summary List Identity Campaign Certifications
         * @param {string} [reviewerIdentity] Reviewer\&#39;s identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **campaign.id**: *eq, in*  **phase**: *eq*  **completed**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityCertifications: async (reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/certifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            if (reviewerIdentity !== undefined) {
                localVarQueryParameter['reviewer-identity'] = reviewerIdentity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        makeIdentityDecision: async (id: string, reviewDecision: Array<ReviewDecision>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('makeIdentityDecision', 'id', id)
            // verify required parameter 'reviewDecision' is not null or undefined
            assertParamExists('makeIdentityDecision', 'reviewDecision', reviewDecision)
            const localVarPath = `/certifications/{id}/decide`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertifications: async (id: string, reviewReassign: ReviewReassign, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reassignIdentityCertifications', 'id', id)
            // verify required parameter 'reviewReassign' is not null or undefined
            assertParamExists('reassignIdentityCertifications', 'reviewReassign', reviewReassign)
            const localVarPath = `/certifications/{id}/reassign`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewReassign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        signOffIdentityCertification: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signOffIdentityCertification', 'id', id)
            const localVarPath = `/certifications/{id}/sign-off`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete.   Reviewers for this certification can also call this API. 
         * @summary Reassign Certifications Asynchronously
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReassignCertsAsync: async (id: string, reviewReassign: ReviewReassign, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitReassignCertsAsync', 'id', id)
            // verify required parameter 'reviewReassign' is not null or undefined
            assertParamExists('submitReassignCertsAsync', 'reviewReassign', reviewReassign)
            const localVarPath = `/certifications/{id}/reassign-async`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewReassign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationsApi - functional programming interface
 * @export
 */
export const CertificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the certification task for the specified ID. Reviewers for the specified certification can also call this API.
         * @summary Certification Task by ID
         * @param {string} id The task ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCertificationTask(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCertificationTask(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationsApi.getCertificationTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns a single identity campaign certification by its ID. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityCertification(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityCertification(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationsApi.getIdentityCertification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {string} certificationId The certification ID
         * @param {string} itemId The certification item ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators: *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field.  For example, the following is valid: &#x60;?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22&#x60;  The following is invalid: 1?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)1
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityCertificationItemPermissions(certificationId: string, itemId: string, filters?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityCertificationItemPermissions(certificationId, itemId, filters, limit, offset, count, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationsApi.getIdentityCertificationItemPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
         * @summary List of Pending Certification Tasks
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **targetId**: *eq, in*  **type**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingCertificationTasks(reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CertificationTask>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingCertificationTasks(reviewerIdentity, limit, offset, count, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationsApi.getPendingCertificationTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns a list of reviewers for the certification. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for certification
         * @param {string} id The certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCertificationReviewers(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityReferenceWithNameAndEmail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCertificationReviewers(id, limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationsApi.listCertificationReviewers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type**: *eq*  **access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityAccessReviewItems(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, entitlements?: string, accessProfiles?: string, roles?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessReviewItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityAccessReviewItems(id, limit, offset, count, filters, sorters, entitlements, accessProfiles, roles, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationsApi.listIdentityAccessReviewItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to get a list of identity campaign certifications for the specified query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to governance groups.
         * @summary List Identity Campaign Certifications
         * @param {string} [reviewerIdentity] Reviewer\&#39;s identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **campaign.id**: *eq, in*  **phase**: *eq*  **completed**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityCertifications(reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityCertificationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityCertifications(reviewerIdentity, limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationsApi.listIdentityCertifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async makeIdentityDecision(id: string, reviewDecision: Array<ReviewDecision>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.makeIdentityDecision(id, reviewDecision, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationsApi.makeIdentityDecision']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async reassignIdentityCertifications(id: string, reviewReassign: ReviewReassign, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reassignIdentityCertifications(id, reviewReassign, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationsApi.reassignIdentityCertifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async signOffIdentityCertification(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signOffIdentityCertification(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationsApi.signOffIdentityCertification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete.   Reviewers for this certification can also call this API. 
         * @summary Reassign Certifications Asynchronously
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async submitReassignCertsAsync(id: string, reviewReassign: ReviewReassign, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitReassignCertsAsync(id, reviewReassign, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CertificationsApi.submitReassignCertsAsync']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CertificationsApi - factory interface
 * @export
 */
export const CertificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationsApiFp(configuration)
    return {
        /**
         * This API returns the certification task for the specified ID. Reviewers for the specified certification can also call this API.
         * @summary Certification Task by ID
         * @param {CertificationsApiGetCertificationTaskRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCertificationTask(requestParameters: CertificationsApiGetCertificationTaskRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CertificationTask> {
            return localVarFp.getCertificationTask(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a single identity campaign certification by its ID. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {CertificationsApiGetIdentityCertificationRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertification(requestParameters: CertificationsApiGetIdentityCertificationRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.getIdentityCertification(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {CertificationsApiGetIdentityCertificationItemPermissionsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationItemPermissions(requestParameters: CertificationsApiGetIdentityCertificationItemPermissionsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<PermissionDto>> {
            return localVarFp.getIdentityCertificationItemPermissions(requestParameters.certificationId, requestParameters.itemId, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
         * @summary List of Pending Certification Tasks
         * @param {CertificationsApiGetPendingCertificationTasksRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPendingCertificationTasks(requestParameters: CertificationsApiGetPendingCertificationTasksRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<CertificationTask>> {
            return localVarFp.getPendingCertificationTasks(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of reviewers for the certification. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for certification
         * @param {CertificationsApiListCertificationReviewersRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCertificationReviewers(requestParameters: CertificationsApiListCertificationReviewersRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<IdentityReferenceWithNameAndEmail>> {
            return localVarFp.listCertificationReviewers(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {CertificationsApiListIdentityAccessReviewItemsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessReviewItems(requestParameters: CertificationsApiListIdentityAccessReviewItemsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<AccessReviewItem>> {
            return localVarFp.listIdentityAccessReviewItems(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.entitlements, requestParameters.accessProfiles, requestParameters.roles, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get a list of identity campaign certifications for the specified query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to governance groups.
         * @summary List Identity Campaign Certifications
         * @param {CertificationsApiListIdentityCertificationsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityCertifications(requestParameters: CertificationsApiListIdentityCertificationsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<IdentityCertificationDto>> {
            return localVarFp.listIdentityCertifications(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {CertificationsApiMakeIdentityDecisionRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        makeIdentityDecision(requestParameters: CertificationsApiMakeIdentityDecisionRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.makeIdentityDecision(requestParameters.id, requestParameters.reviewDecision, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {CertificationsApiReassignIdentityCertificationsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertifications(requestParameters: CertificationsApiReassignIdentityCertificationsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.reassignIdentityCertifications(requestParameters.id, requestParameters.reviewReassign, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {CertificationsApiSignOffIdentityCertificationRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        signOffIdentityCertification(requestParameters: CertificationsApiSignOffIdentityCertificationRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.signOffIdentityCertification(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete.   Reviewers for this certification can also call this API. 
         * @summary Reassign Certifications Asynchronously
         * @param {CertificationsApiSubmitReassignCertsAsyncRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReassignCertsAsync(requestParameters: CertificationsApiSubmitReassignCertsAsyncRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CertificationTask> {
            return localVarFp.submitReassignCertsAsync(requestParameters.id, requestParameters.reviewReassign, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCertificationTask operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetCertificationTaskRequest
 */
export interface CertificationsApiGetCertificationTaskRequest {
    /**
     * The task ID
     * @type {string}
     * @memberof CertificationsApiGetCertificationTask
     */
    readonly id: string
}

/**
 * Request parameters for getIdentityCertification operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetIdentityCertificationRequest
 */
export interface CertificationsApiGetIdentityCertificationRequest {
    /**
     * The certification id
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertification
     */
    readonly id: string
}

/**
 * Request parameters for getIdentityCertificationItemPermissions operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetIdentityCertificationItemPermissionsRequest
 */
export interface CertificationsApiGetIdentityCertificationItemPermissionsRequest {
    /**
     * The certification ID
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly certificationId: string

    /**
     * The certification item ID
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly itemId: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators: *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field.  For example, the following is valid: &#x60;?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22&#x60;  The following is invalid: 1?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)1
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly filters?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly count?: boolean
}

/**
 * Request parameters for getPendingCertificationTasks operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetPendingCertificationTasksRequest
 */
export interface CertificationsApiGetPendingCertificationTasksRequest {
    /**
     * The ID of reviewer identity. *me* indicates the current user.
     * @type {string}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly reviewerIdentity?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **targetId**: *eq, in*  **type**: *eq, in*
     * @type {string}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly filters?: string
}

/**
 * Request parameters for listCertificationReviewers operation in CertificationsApi.
 * @export
 * @interface CertificationsApiListCertificationReviewersRequest
 */
export interface CertificationsApiListCertificationReviewersRequest {
    /**
     * The certification ID
     * @type {string}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
     * @type {string}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
     * @type {string}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly sorters?: string
}

/**
 * Request parameters for listIdentityAccessReviewItems operation in CertificationsApi.
 * @export
 * @interface CertificationsApiListIdentityAccessReviewItemsRequest
 */
export interface CertificationsApiListIdentityAccessReviewItemsRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type**: *eq*  **access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly sorters?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly entitlements?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly accessProfiles?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly roles?: string
}

/**
 * Request parameters for listIdentityCertifications operation in CertificationsApi.
 * @export
 * @interface CertificationsApiListIdentityCertificationsRequest
 */
export interface CertificationsApiListIdentityCertificationsRequest {
    /**
     * Reviewer\&#39;s identity. *me* indicates the current user.
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly reviewerIdentity?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **campaign.id**: *eq, in*  **phase**: *eq*  **completed**: *eq*
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, due, signed**
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly sorters?: string
}

/**
 * Request parameters for makeIdentityDecision operation in CertificationsApi.
 * @export
 * @interface CertificationsApiMakeIdentityDecisionRequest
 */
export interface CertificationsApiMakeIdentityDecisionRequest {
    /**
     * The ID of the identity campaign certification on which to make decisions
     * @type {string}
     * @memberof CertificationsApiMakeIdentityDecision
     */
    readonly id: string

    /**
     * A non-empty array of decisions to be made.
     * @type {Array<ReviewDecision>}
     * @memberof CertificationsApiMakeIdentityDecision
     */
    readonly reviewDecision: Array<ReviewDecision>
}

/**
 * Request parameters for reassignIdentityCertifications operation in CertificationsApi.
 * @export
 * @interface CertificationsApiReassignIdentityCertificationsRequest
 */
export interface CertificationsApiReassignIdentityCertificationsRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiReassignIdentityCertifications
     */
    readonly id: string

    /**
     * 
     * @type {ReviewReassign}
     * @memberof CertificationsApiReassignIdentityCertifications
     */
    readonly reviewReassign: ReviewReassign
}

/**
 * Request parameters for signOffIdentityCertification operation in CertificationsApi.
 * @export
 * @interface CertificationsApiSignOffIdentityCertificationRequest
 */
export interface CertificationsApiSignOffIdentityCertificationRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiSignOffIdentityCertification
     */
    readonly id: string
}

/**
 * Request parameters for submitReassignCertsAsync operation in CertificationsApi.
 * @export
 * @interface CertificationsApiSubmitReassignCertsAsyncRequest
 */
export interface CertificationsApiSubmitReassignCertsAsyncRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiSubmitReassignCertsAsync
     */
    readonly id: string

    /**
     * 
     * @type {ReviewReassign}
     * @memberof CertificationsApiSubmitReassignCertsAsync
     */
    readonly reviewReassign: ReviewReassign
}

/**
 * CertificationsApi - object-oriented interface
 * @export
 * @class CertificationsApi
 * @extends {BaseAPI}
 */
export class CertificationsApi extends BaseAPI {
    /**
     * This API returns the certification task for the specified ID. Reviewers for the specified certification can also call this API.
     * @summary Certification Task by ID
     * @param {CertificationsApiGetCertificationTaskRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getCertificationTask(requestParameters: CertificationsApiGetCertificationTaskRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getCertificationTask(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a single identity campaign certification by its ID. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Identity Certification by ID
     * @param {CertificationsApiGetIdentityCertificationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getIdentityCertification(requestParameters: CertificationsApiGetIdentityCertificationRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getIdentityCertification(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. Reviewers for this certification can also call this API.
     * @summary Permissions for Entitlement Certification Item
     * @param {CertificationsApiGetIdentityCertificationItemPermissionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getIdentityCertificationItemPermissions(requestParameters: CertificationsApiGetIdentityCertificationItemPermissionsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getIdentityCertificationItemPermissions(requestParameters.certificationId, requestParameters.itemId, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
     * @summary List of Pending Certification Tasks
     * @param {CertificationsApiGetPendingCertificationTasksRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getPendingCertificationTasks(requestParameters: CertificationsApiGetPendingCertificationTasksRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getPendingCertificationTasks(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of reviewers for the certification. Reviewers for this certification can also call this API.
     * @summary List of Reviewers for certification
     * @param {CertificationsApiListCertificationReviewersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public listCertificationReviewers(requestParameters: CertificationsApiListCertificationReviewersRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).listCertificationReviewers(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of access review items for an identity campaign certification. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary List of Access Review Items
     * @param {CertificationsApiListIdentityAccessReviewItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public listIdentityAccessReviewItems(requestParameters: CertificationsApiListIdentityAccessReviewItemsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).listIdentityAccessReviewItems(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.entitlements, requestParameters.accessProfiles, requestParameters.roles, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get a list of identity campaign certifications for the specified query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to governance groups.
     * @summary List Identity Campaign Certifications
     * @param {CertificationsApiListIdentityCertificationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public listIdentityCertifications(requestParameters: CertificationsApiListIdentityCertificationsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).listIdentityCertifications(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The API makes a decision to approve or revoke one or more identity campaign certification items. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Decide on a Certification Item
     * @param {CertificationsApiMakeIdentityDecisionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public makeIdentityDecision(requestParameters: CertificationsApiMakeIdentityDecisionRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).makeIdentityDecision(requestParameters.id, requestParameters.reviewDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Reassign Identities or Items
     * @param {CertificationsApiReassignIdentityCertificationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public reassignIdentityCertifications(requestParameters: CertificationsApiReassignIdentityCertificationsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).reassignIdentityCertifications(requestParameters.id, requestParameters.reviewReassign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Finalize Identity Certification Decisions
     * @param {CertificationsApiSignOffIdentityCertificationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public signOffIdentityCertification(requestParameters: CertificationsApiSignOffIdentityCertificationRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).signOffIdentityCertification(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete.   Reviewers for this certification can also call this API. 
     * @summary Reassign Certifications Asynchronously
     * @param {CertificationsApiSubmitReassignCertsAsyncRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public submitReassignCertsAsync(requestParameters: CertificationsApiSubmitReassignCertsAsyncRequest, axiosOptions?: RawAxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).submitReassignCertsAsync(requestParameters.id, requestParameters.reviewReassign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConfigurationHubApi - axios parameter creator
 * @export
 */
export const ConfigurationHubApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates an object mapping between current org and source org. Source org should be \"default\" when creating an object mapping that is not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Creates an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingRequest} objectMappingRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMapping: async (sourceOrg: string, objectMappingRequest: ObjectMappingRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceOrg' is not null or undefined
            assertParamExists('createObjectMapping', 'sourceOrg', sourceOrg)
            // verify required parameter 'objectMappingRequest' is not null or undefined
            assertParamExists('createObjectMapping', 'objectMappingRequest', objectMappingRequest)
            const localVarPath = `/configuration-hub/object-mappings/{sourceOrg}`
                .replace(`{${"sourceOrg"}}`, encodeURIComponent(String(sourceOrg)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(objectMappingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This creates a set of object mappings (Max 25) between current org and source org. Source org should be \"default\" when creating object mappings that are not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk creates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkCreateRequest} objectMappingBulkCreateRequest The bulk create object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMappings: async (sourceOrg: string, objectMappingBulkCreateRequest: ObjectMappingBulkCreateRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceOrg' is not null or undefined
            assertParamExists('createObjectMappings', 'sourceOrg', sourceOrg)
            // verify required parameter 'objectMappingBulkCreateRequest' is not null or undefined
            assertParamExists('createObjectMappings', 'objectMappingBulkCreateRequest', objectMappingBulkCreateRequest)
            const localVarPath = `/configuration-hub/object-mappings/{sourceOrg}/bulk-create`
                .replace(`{${"sourceOrg"}}`, encodeURIComponent(String(sourceOrg)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(objectMappingBulkCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API uploads a JSON configuration file into a tenant.  Configuration files can be managed and deployed via Configuration Hub by uploading a json file which contains configuration data. The JSON file should be the same as the one used by our import endpoints. The object types supported by upload configuration file functionality are the same as the ones supported by our regular backup functionality.  Refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects) for more information about supported objects.
         * @summary Upload a Configuration
         * @param {File} data JSON file containing the objects to be imported.
         * @param {string} name Name that will be assigned to the uploaded configuration file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createUploadedConfiguration: async (data: File, name: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('createUploadedConfiguration', 'data', data)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createUploadedConfiguration', 'name', name)
            const localVarPath = `/configuration-hub/backups/uploads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes an existing object mapping. Source org should be \"default\" when deleting an object mapping that is not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Deletes an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {string} objectMappingId The id of the object mapping to be deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectMapping: async (sourceOrg: string, objectMappingId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceOrg' is not null or undefined
            assertParamExists('deleteObjectMapping', 'sourceOrg', sourceOrg)
            // verify required parameter 'objectMappingId' is not null or undefined
            assertParamExists('deleteObjectMapping', 'objectMappingId', objectMappingId)
            const localVarPath = `/configuration-hub/object-mappings/{sourceOrg}/{objectMappingId}`
                .replace(`{${"sourceOrg"}}`, encodeURIComponent(String(sourceOrg)))
                .replace(`{${"objectMappingId"}}`, encodeURIComponent(String(objectMappingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes an uploaded configuration based on Id.  On success, this endpoint will return an empty response.  The uploaded configuration id can be obtained from the response after a successful upload, or the list uploaded configurations endpoint.
         * @summary Delete an Uploaded Configuration
         * @param {string} id The id of the uploaded configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadedConfiguration: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUploadedConfiguration', 'id', id)
            const localVarPath = `/configuration-hub/backups/uploads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of existing object mappings between current org and source org. Source org should be \"default\" when getting object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:read
         * @summary Gets list of object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getObjectMappings: async (sourceOrg: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceOrg' is not null or undefined
            assertParamExists('getObjectMappings', 'sourceOrg', sourceOrg)
            const localVarPath = `/configuration-hub/object-mappings/{sourceOrg}`
                .replace(`{${"sourceOrg"}}`, encodeURIComponent(String(sourceOrg)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets an existing uploaded configuration for the current tenant.
         * @summary Get an Uploaded Configuration
         * @param {string} id The id of the uploaded configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedConfiguration: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUploadedConfiguration', 'id', id)
            const localVarPath = `/configuration-hub/backups/uploads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets a list of existing uploaded configurations for the current tenant.
         * @summary List Uploaded Configurations
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **status**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listUploadedConfigurations: async (filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/configuration-hub/backups/uploads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates a set of object mappings, only enabled and targetValue fields can be updated. Source org should be \"default\" when updating object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk updates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkPatchRequest} objectMappingBulkPatchRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectMappings: async (sourceOrg: string, objectMappingBulkPatchRequest: ObjectMappingBulkPatchRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceOrg' is not null or undefined
            assertParamExists('updateObjectMappings', 'sourceOrg', sourceOrg)
            // verify required parameter 'objectMappingBulkPatchRequest' is not null or undefined
            assertParamExists('updateObjectMappings', 'objectMappingBulkPatchRequest', objectMappingBulkPatchRequest)
            const localVarPath = `/configuration-hub/object-mappings/{sourceOrg}/bulk-patch`
                .replace(`{${"sourceOrg"}}`, encodeURIComponent(String(sourceOrg)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(objectMappingBulkPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationHubApi - functional programming interface
 * @export
 */
export const ConfigurationHubApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigurationHubApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates an object mapping between current org and source org. Source org should be \"default\" when creating an object mapping that is not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Creates an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingRequest} objectMappingRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createObjectMapping(sourceOrg: string, objectMappingRequest: ObjectMappingRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectMappingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createObjectMapping(sourceOrg, objectMappingRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationHubApi.createObjectMapping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This creates a set of object mappings (Max 25) between current org and source org. Source org should be \"default\" when creating object mappings that are not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk creates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkCreateRequest} objectMappingBulkCreateRequest The bulk create object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createObjectMappings(sourceOrg: string, objectMappingBulkCreateRequest: ObjectMappingBulkCreateRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectMappingBulkCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createObjectMappings(sourceOrg, objectMappingBulkCreateRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationHubApi.createObjectMappings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API uploads a JSON configuration file into a tenant.  Configuration files can be managed and deployed via Configuration Hub by uploading a json file which contains configuration data. The JSON file should be the same as the one used by our import endpoints. The object types supported by upload configuration file functionality are the same as the ones supported by our regular backup functionality.  Refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects) for more information about supported objects.
         * @summary Upload a Configuration
         * @param {File} data JSON file containing the objects to be imported.
         * @param {string} name Name that will be assigned to the uploaded configuration file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createUploadedConfiguration(data: File, name: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUploadedConfiguration(data, name, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationHubApi.createUploadedConfiguration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This deletes an existing object mapping. Source org should be \"default\" when deleting an object mapping that is not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Deletes an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {string} objectMappingId The id of the object mapping to be deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteObjectMapping(sourceOrg: string, objectMappingId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteObjectMapping(sourceOrg, objectMappingId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationHubApi.deleteObjectMapping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API deletes an uploaded configuration based on Id.  On success, this endpoint will return an empty response.  The uploaded configuration id can be obtained from the response after a successful upload, or the list uploaded configurations endpoint.
         * @summary Delete an Uploaded Configuration
         * @param {string} id The id of the uploaded configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUploadedConfiguration(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUploadedConfiguration(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationHubApi.deleteUploadedConfiguration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a list of existing object mappings between current org and source org. Source org should be \"default\" when getting object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:read
         * @summary Gets list of object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getObjectMappings(sourceOrg: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ObjectMappingResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObjectMappings(sourceOrg, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationHubApi.getObjectMappings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API gets an existing uploaded configuration for the current tenant.
         * @summary Get an Uploaded Configuration
         * @param {string} id The id of the uploaded configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getUploadedConfiguration(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUploadedConfiguration(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationHubApi.getUploadedConfiguration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API gets a list of existing uploaded configurations for the current tenant.
         * @summary List Uploaded Configurations
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **status**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listUploadedConfigurations(filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BackupResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUploadedConfigurations(filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationHubApi.listUploadedConfigurations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This updates a set of object mappings, only enabled and targetValue fields can be updated. Source org should be \"default\" when updating object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk updates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkPatchRequest} objectMappingBulkPatchRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateObjectMappings(sourceOrg: string, objectMappingBulkPatchRequest: ObjectMappingBulkPatchRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectMappingBulkPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateObjectMappings(sourceOrg, objectMappingBulkPatchRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationHubApi.updateObjectMappings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConfigurationHubApi - factory interface
 * @export
 */
export const ConfigurationHubApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigurationHubApiFp(configuration)
    return {
        /**
         * This creates an object mapping between current org and source org. Source org should be \"default\" when creating an object mapping that is not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Creates an object mapping
         * @param {ConfigurationHubApiCreateObjectMappingRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMapping(requestParameters: ConfigurationHubApiCreateObjectMappingRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ObjectMappingResponse> {
            return localVarFp.createObjectMapping(requestParameters.sourceOrg, requestParameters.objectMappingRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This creates a set of object mappings (Max 25) between current org and source org. Source org should be \"default\" when creating object mappings that are not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk creates object mappings
         * @param {ConfigurationHubApiCreateObjectMappingsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMappings(requestParameters: ConfigurationHubApiCreateObjectMappingsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ObjectMappingBulkCreateResponse> {
            return localVarFp.createObjectMappings(requestParameters.sourceOrg, requestParameters.objectMappingBulkCreateRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API uploads a JSON configuration file into a tenant.  Configuration files can be managed and deployed via Configuration Hub by uploading a json file which contains configuration data. The JSON file should be the same as the one used by our import endpoints. The object types supported by upload configuration file functionality are the same as the ones supported by our regular backup functionality.  Refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects) for more information about supported objects.
         * @summary Upload a Configuration
         * @param {ConfigurationHubApiCreateUploadedConfigurationRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createUploadedConfiguration(requestParameters: ConfigurationHubApiCreateUploadedConfigurationRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<BackupResponse> {
            return localVarFp.createUploadedConfiguration(requestParameters.data, requestParameters.name, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes an existing object mapping. Source org should be \"default\" when deleting an object mapping that is not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Deletes an object mapping
         * @param {ConfigurationHubApiDeleteObjectMappingRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectMapping(requestParameters: ConfigurationHubApiDeleteObjectMappingRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteObjectMapping(requestParameters.sourceOrg, requestParameters.objectMappingId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes an uploaded configuration based on Id.  On success, this endpoint will return an empty response.  The uploaded configuration id can be obtained from the response after a successful upload, or the list uploaded configurations endpoint.
         * @summary Delete an Uploaded Configuration
         * @param {ConfigurationHubApiDeleteUploadedConfigurationRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadedConfiguration(requestParameters: ConfigurationHubApiDeleteUploadedConfigurationRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUploadedConfiguration(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of existing object mappings between current org and source org. Source org should be \"default\" when getting object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:read
         * @summary Gets list of object mappings
         * @param {ConfigurationHubApiGetObjectMappingsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getObjectMappings(requestParameters: ConfigurationHubApiGetObjectMappingsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<ObjectMappingResponse>> {
            return localVarFp.getObjectMappings(requestParameters.sourceOrg, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API gets an existing uploaded configuration for the current tenant.
         * @summary Get an Uploaded Configuration
         * @param {ConfigurationHubApiGetUploadedConfigurationRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedConfiguration(requestParameters: ConfigurationHubApiGetUploadedConfigurationRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<BackupResponse> {
            return localVarFp.getUploadedConfiguration(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API gets a list of existing uploaded configurations for the current tenant.
         * @summary List Uploaded Configurations
         * @param {ConfigurationHubApiListUploadedConfigurationsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listUploadedConfigurations(requestParameters: ConfigurationHubApiListUploadedConfigurationsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<BackupResponse>> {
            return localVarFp.listUploadedConfigurations(requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates a set of object mappings, only enabled and targetValue fields can be updated. Source org should be \"default\" when updating object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk updates object mappings
         * @param {ConfigurationHubApiUpdateObjectMappingsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectMappings(requestParameters: ConfigurationHubApiUpdateObjectMappingsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ObjectMappingBulkPatchResponse> {
            return localVarFp.updateObjectMappings(requestParameters.sourceOrg, requestParameters.objectMappingBulkPatchRequest, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createObjectMapping operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiCreateObjectMappingRequest
 */
export interface ConfigurationHubApiCreateObjectMappingRequest {
    /**
     * The name of the source org.
     * @type {string}
     * @memberof ConfigurationHubApiCreateObjectMapping
     */
    readonly sourceOrg: string

    /**
     * The object mapping request body.
     * @type {ObjectMappingRequest}
     * @memberof ConfigurationHubApiCreateObjectMapping
     */
    readonly objectMappingRequest: ObjectMappingRequest
}

/**
 * Request parameters for createObjectMappings operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiCreateObjectMappingsRequest
 */
export interface ConfigurationHubApiCreateObjectMappingsRequest {
    /**
     * The name of the source org.
     * @type {string}
     * @memberof ConfigurationHubApiCreateObjectMappings
     */
    readonly sourceOrg: string

    /**
     * The bulk create object mapping request body.
     * @type {ObjectMappingBulkCreateRequest}
     * @memberof ConfigurationHubApiCreateObjectMappings
     */
    readonly objectMappingBulkCreateRequest: ObjectMappingBulkCreateRequest
}

/**
 * Request parameters for createUploadedConfiguration operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiCreateUploadedConfigurationRequest
 */
export interface ConfigurationHubApiCreateUploadedConfigurationRequest {
    /**
     * JSON file containing the objects to be imported.
     * @type {File}
     * @memberof ConfigurationHubApiCreateUploadedConfiguration
     */
    readonly data: File

    /**
     * Name that will be assigned to the uploaded configuration file.
     * @type {string}
     * @memberof ConfigurationHubApiCreateUploadedConfiguration
     */
    readonly name: string
}

/**
 * Request parameters for deleteObjectMapping operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiDeleteObjectMappingRequest
 */
export interface ConfigurationHubApiDeleteObjectMappingRequest {
    /**
     * The name of the source org.
     * @type {string}
     * @memberof ConfigurationHubApiDeleteObjectMapping
     */
    readonly sourceOrg: string

    /**
     * The id of the object mapping to be deleted.
     * @type {string}
     * @memberof ConfigurationHubApiDeleteObjectMapping
     */
    readonly objectMappingId: string
}

/**
 * Request parameters for deleteUploadedConfiguration operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiDeleteUploadedConfigurationRequest
 */
export interface ConfigurationHubApiDeleteUploadedConfigurationRequest {
    /**
     * The id of the uploaded configuration.
     * @type {string}
     * @memberof ConfigurationHubApiDeleteUploadedConfiguration
     */
    readonly id: string
}

/**
 * Request parameters for getObjectMappings operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiGetObjectMappingsRequest
 */
export interface ConfigurationHubApiGetObjectMappingsRequest {
    /**
     * The name of the source org.
     * @type {string}
     * @memberof ConfigurationHubApiGetObjectMappings
     */
    readonly sourceOrg: string
}

/**
 * Request parameters for getUploadedConfiguration operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiGetUploadedConfigurationRequest
 */
export interface ConfigurationHubApiGetUploadedConfigurationRequest {
    /**
     * The id of the uploaded configuration.
     * @type {string}
     * @memberof ConfigurationHubApiGetUploadedConfiguration
     */
    readonly id: string
}

/**
 * Request parameters for listUploadedConfigurations operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiListUploadedConfigurationsRequest
 */
export interface ConfigurationHubApiListUploadedConfigurationsRequest {
    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **status**: *eq*
     * @type {string}
     * @memberof ConfigurationHubApiListUploadedConfigurations
     */
    readonly filters?: string
}

/**
 * Request parameters for updateObjectMappings operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiUpdateObjectMappingsRequest
 */
export interface ConfigurationHubApiUpdateObjectMappingsRequest {
    /**
     * The name of the source org.
     * @type {string}
     * @memberof ConfigurationHubApiUpdateObjectMappings
     */
    readonly sourceOrg: string

    /**
     * The object mapping request body.
     * @type {ObjectMappingBulkPatchRequest}
     * @memberof ConfigurationHubApiUpdateObjectMappings
     */
    readonly objectMappingBulkPatchRequest: ObjectMappingBulkPatchRequest
}

/**
 * ConfigurationHubApi - object-oriented interface
 * @export
 * @class ConfigurationHubApi
 * @extends {BaseAPI}
 */
export class ConfigurationHubApi extends BaseAPI {
    /**
     * This creates an object mapping between current org and source org. Source org should be \"default\" when creating an object mapping that is not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
     * @summary Creates an object mapping
     * @param {ConfigurationHubApiCreateObjectMappingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public createObjectMapping(requestParameters: ConfigurationHubApiCreateObjectMappingRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).createObjectMapping(requestParameters.sourceOrg, requestParameters.objectMappingRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This creates a set of object mappings (Max 25) between current org and source org. Source org should be \"default\" when creating object mappings that are not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
     * @summary Bulk creates object mappings
     * @param {ConfigurationHubApiCreateObjectMappingsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public createObjectMappings(requestParameters: ConfigurationHubApiCreateObjectMappingsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).createObjectMappings(requestParameters.sourceOrg, requestParameters.objectMappingBulkCreateRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API uploads a JSON configuration file into a tenant.  Configuration files can be managed and deployed via Configuration Hub by uploading a json file which contains configuration data. The JSON file should be the same as the one used by our import endpoints. The object types supported by upload configuration file functionality are the same as the ones supported by our regular backup functionality.  Refer to [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects) for more information about supported objects.
     * @summary Upload a Configuration
     * @param {ConfigurationHubApiCreateUploadedConfigurationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public createUploadedConfiguration(requestParameters: ConfigurationHubApiCreateUploadedConfigurationRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).createUploadedConfiguration(requestParameters.data, requestParameters.name, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes an existing object mapping. Source org should be \"default\" when deleting an object mapping that is not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
     * @summary Deletes an object mapping
     * @param {ConfigurationHubApiDeleteObjectMappingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public deleteObjectMapping(requestParameters: ConfigurationHubApiDeleteObjectMappingRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).deleteObjectMapping(requestParameters.sourceOrg, requestParameters.objectMappingId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes an uploaded configuration based on Id.  On success, this endpoint will return an empty response.  The uploaded configuration id can be obtained from the response after a successful upload, or the list uploaded configurations endpoint.
     * @summary Delete an Uploaded Configuration
     * @param {ConfigurationHubApiDeleteUploadedConfigurationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public deleteUploadedConfiguration(requestParameters: ConfigurationHubApiDeleteUploadedConfigurationRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).deleteUploadedConfiguration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of existing object mappings between current org and source org. Source org should be \"default\" when getting object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:read
     * @summary Gets list of object mappings
     * @param {ConfigurationHubApiGetObjectMappingsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public getObjectMappings(requestParameters: ConfigurationHubApiGetObjectMappingsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).getObjectMappings(requestParameters.sourceOrg, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets an existing uploaded configuration for the current tenant.
     * @summary Get an Uploaded Configuration
     * @param {ConfigurationHubApiGetUploadedConfigurationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public getUploadedConfiguration(requestParameters: ConfigurationHubApiGetUploadedConfigurationRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).getUploadedConfiguration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets a list of existing uploaded configurations for the current tenant.
     * @summary List Uploaded Configurations
     * @param {ConfigurationHubApiListUploadedConfigurationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public listUploadedConfigurations(requestParameters: ConfigurationHubApiListUploadedConfigurationsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).listUploadedConfigurations(requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates a set of object mappings, only enabled and targetValue fields can be updated. Source org should be \"default\" when updating object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
     * @summary Bulk updates object mappings
     * @param {ConfigurationHubApiUpdateObjectMappingsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public updateObjectMappings(requestParameters: ConfigurationHubApiUpdateObjectMappingsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).updateObjectMappings(requestParameters.sourceOrg, requestParameters.objectMappingBulkPatchRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConnectorsApi - axios parameter creator
 * @export
 */
export const ConnectorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create custom connector.    
         * @summary Create Custom Connector
         * @param {V3CreateConnectorDto} v3CreateConnectorDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCustomConnector: async (v3CreateConnectorDto: V3CreateConnectorDto, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v3CreateConnectorDto' is not null or undefined
            assertParamExists('createCustomConnector', 'v3CreateConnectorDto', v3CreateConnectorDto)
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v3CreateConnectorDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete a custom connector that using its script name.
         * @summary Delete Connector by Script Name
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomConnector: async (scriptName: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('deleteCustomConnector', 'scriptName', scriptName)
            const localVarPath = `/connectors/{scriptName}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a connector that using its script name.    
         * @summary Get Connector by Script Name
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {GetConnectorLocaleV3} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnector: async (scriptName: string, locale?: GetConnectorLocaleV3, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getConnector', 'scriptName', scriptName)
            const localVarPath = `/connectors/{scriptName}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination.
         * @summary Get Connector List
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *sw, co*  **type**: *sw, co, eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*  **labels**: *ca*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {GetConnectorListLocaleV3} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorList: async (filters?: string, limit?: number, offset?: number, count?: boolean, locale?: GetConnectorListLocaleV3, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a connector\'s source config using its script name.    
         * @summary Get Connector Source Configuration
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceConfig: async (scriptName: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getConnectorSourceConfig', 'scriptName', scriptName)
            const localVarPath = `/connectors/{scriptName}/source-config`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a connector\'s source template using its script name.    
         * @summary Get Connector Source Template
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceTemplate: async (scriptName: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getConnectorSourceTemplate', 'scriptName', scriptName)
            const localVarPath = `/connectors/{scriptName}/source-template`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a connector\'s translations using its script name.    
         * @summary Get Connector Translations
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {GetConnectorTranslationsLocaleV3} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorTranslations: async (scriptName: string, locale: GetConnectorTranslationsLocaleV3, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getConnectorTranslations', 'scriptName', scriptName)
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('getConnectorTranslations', 'locale', locale)
            const localVarPath = `/connectors/{scriptName}/translations/{locale}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)))
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update a connector\'s source config using its script name.    
         * @summary Update Connector Source Configuration
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {File} file connector source config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putConnectorSourceConfig: async (scriptName: string, file: File, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('putConnectorSourceConfig', 'scriptName', scriptName)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('putConnectorSourceConfig', 'file', file)
            const localVarPath = `/connectors/{scriptName}/source-config`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update a connector\'s source template using its script name.    
         * @summary Update Connector Source Template
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {File} file connector source template xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putConnectorSourceTemplate: async (scriptName: string, file: File, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('putConnectorSourceTemplate', 'scriptName', scriptName)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('putConnectorSourceTemplate', 'file', file)
            const localVarPath = `/connectors/{scriptName}/source-template`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update a connector\'s translations using its script name.    
         * @summary Update Connector Translations
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {PutConnectorTranslationsLocaleV3} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putConnectorTranslations: async (scriptName: string, locale: PutConnectorTranslationsLocaleV3, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('putConnectorTranslations', 'scriptName', scriptName)
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('putConnectorTranslations', 'locale', locale)
            const localVarPath = `/connectors/{scriptName}/translations/{locale}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)))
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates a custom connector by script name using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable:   * connectorMetadata  * applicationXml  * correlationConfigXml  * sourceConfigXml 
         * @summary Update Connector by Script Name
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of connector detail update operations 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector: async (scriptName: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('updateConnector', 'scriptName', scriptName)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateConnector', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/connectors/{scriptName}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorsApi - functional programming interface
 * @export
 */
export const ConnectorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create custom connector.    
         * @summary Create Custom Connector
         * @param {V3CreateConnectorDto} v3CreateConnectorDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomConnector(v3CreateConnectorDto: V3CreateConnectorDto, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V3ConnectorDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomConnector(v3CreateConnectorDto, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.createCustomConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a custom connector that using its script name.
         * @summary Delete Connector by Script Name
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomConnector(scriptName: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomConnector(scriptName, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.deleteCustomConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a connector that using its script name.    
         * @summary Get Connector by Script Name
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {GetConnectorLocaleV3} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnector(scriptName: string, locale?: GetConnectorLocaleV3, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnector(scriptName, locale, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination.
         * @summary Get Connector List
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *sw, co*  **type**: *sw, co, eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*  **labels**: *ca*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {GetConnectorListLocaleV3} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorList(filters?: string, limit?: number, offset?: number, count?: boolean, locale?: GetConnectorListLocaleV3, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V3ConnectorDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorList(filters, limit, offset, count, locale, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnectorList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a connector\'s source config using its script name.    
         * @summary Get Connector Source Configuration
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorSourceConfig(scriptName: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorSourceConfig(scriptName, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnectorSourceConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a connector\'s source template using its script name.    
         * @summary Get Connector Source Template
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorSourceTemplate(scriptName: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorSourceTemplate(scriptName, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnectorSourceTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a connector\'s translations using its script name.    
         * @summary Get Connector Translations
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {GetConnectorTranslationsLocaleV3} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorTranslations(scriptName: string, locale: GetConnectorTranslationsLocaleV3, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorTranslations(scriptName, locale, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnectorTranslations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a connector\'s source config using its script name.    
         * @summary Update Connector Source Configuration
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {File} file connector source config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putConnectorSourceConfig(scriptName: string, file: File, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putConnectorSourceConfig(scriptName, file, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.putConnectorSourceConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a connector\'s source template using its script name.    
         * @summary Update Connector Source Template
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {File} file connector source template xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putConnectorSourceTemplate(scriptName: string, file: File, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putConnectorSourceTemplate(scriptName, file, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.putConnectorSourceTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a connector\'s translations using its script name.    
         * @summary Update Connector Translations
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {PutConnectorTranslationsLocaleV3} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putConnectorTranslations(scriptName: string, locale: PutConnectorTranslationsLocaleV3, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putConnectorTranslations(scriptName, locale, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.putConnectorTranslations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API updates a custom connector by script name using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable:   * connectorMetadata  * applicationXml  * correlationConfigXml  * sourceConfigXml 
         * @summary Update Connector by Script Name
         * @param {string} scriptName The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of connector detail update operations 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateConnector(scriptName: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConnector(scriptName, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.updateConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectorsApi - factory interface
 * @export
 */
export const ConnectorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorsApiFp(configuration)
    return {
        /**
         * Create custom connector.    
         * @summary Create Custom Connector
         * @param {ConnectorsApiCreateCustomConnectorRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCustomConnector(requestParameters: ConnectorsApiCreateCustomConnectorRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<V3ConnectorDto> {
            return localVarFp.createCustomConnector(requestParameters.v3CreateConnectorDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete a custom connector that using its script name.
         * @summary Delete Connector by Script Name
         * @param {ConnectorsApiDeleteCustomConnectorRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomConnector(requestParameters: ConnectorsApiDeleteCustomConnectorRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCustomConnector(requestParameters.scriptName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a connector that using its script name.    
         * @summary Get Connector by Script Name
         * @param {ConnectorsApiGetConnectorRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnector(requestParameters: ConnectorsApiGetConnectorRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ConnectorDetail> {
            return localVarFp.getConnector(requestParameters.scriptName, requestParameters.locale, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination.
         * @summary Get Connector List
         * @param {ConnectorsApiGetConnectorListRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorList(requestParameters: ConnectorsApiGetConnectorListRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<V3ConnectorDto>> {
            return localVarFp.getConnectorList(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.locale, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a connector\'s source config using its script name.    
         * @summary Get Connector Source Configuration
         * @param {ConnectorsApiGetConnectorSourceConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceConfig(requestParameters: ConnectorsApiGetConnectorSourceConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getConnectorSourceConfig(requestParameters.scriptName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a connector\'s source template using its script name.    
         * @summary Get Connector Source Template
         * @param {ConnectorsApiGetConnectorSourceTemplateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceTemplate(requestParameters: ConnectorsApiGetConnectorSourceTemplateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getConnectorSourceTemplate(requestParameters.scriptName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a connector\'s translations using its script name.    
         * @summary Get Connector Translations
         * @param {ConnectorsApiGetConnectorTranslationsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorTranslations(requestParameters: ConnectorsApiGetConnectorTranslationsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getConnectorTranslations(requestParameters.scriptName, requestParameters.locale, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update a connector\'s source config using its script name.    
         * @summary Update Connector Source Configuration
         * @param {ConnectorsApiPutConnectorSourceConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putConnectorSourceConfig(requestParameters: ConnectorsApiPutConnectorSourceConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<UpdateDetail> {
            return localVarFp.putConnectorSourceConfig(requestParameters.scriptName, requestParameters.file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update a connector\'s source template using its script name.    
         * @summary Update Connector Source Template
         * @param {ConnectorsApiPutConnectorSourceTemplateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putConnectorSourceTemplate(requestParameters: ConnectorsApiPutConnectorSourceTemplateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<UpdateDetail> {
            return localVarFp.putConnectorSourceTemplate(requestParameters.scriptName, requestParameters.file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update a connector\'s translations using its script name.    
         * @summary Update Connector Translations
         * @param {ConnectorsApiPutConnectorTranslationsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putConnectorTranslations(requestParameters: ConnectorsApiPutConnectorTranslationsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<UpdateDetail> {
            return localVarFp.putConnectorTranslations(requestParameters.scriptName, requestParameters.locale, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates a custom connector by script name using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable:   * connectorMetadata  * applicationXml  * correlationConfigXml  * sourceConfigXml 
         * @summary Update Connector by Script Name
         * @param {ConnectorsApiUpdateConnectorRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector(requestParameters: ConnectorsApiUpdateConnectorRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ConnectorDetail> {
            return localVarFp.updateConnector(requestParameters.scriptName, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCustomConnector operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiCreateCustomConnectorRequest
 */
export interface ConnectorsApiCreateCustomConnectorRequest {
    /**
     * 
     * @type {V3CreateConnectorDto}
     * @memberof ConnectorsApiCreateCustomConnector
     */
    readonly v3CreateConnectorDto: V3CreateConnectorDto
}

/**
 * Request parameters for deleteCustomConnector operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiDeleteCustomConnectorRequest
 */
export interface ConnectorsApiDeleteCustomConnectorRequest {
    /**
     * The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiDeleteCustomConnector
     */
    readonly scriptName: string
}

/**
 * Request parameters for getConnector operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiGetConnectorRequest
 */
export interface ConnectorsApiGetConnectorRequest {
    /**
     * The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiGetConnector
     */
    readonly scriptName: string

    /**
     * The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
     * @type {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'}
     * @memberof ConnectorsApiGetConnector
     */
    readonly locale?: GetConnectorLocaleV3
}

/**
 * Request parameters for getConnectorList operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiGetConnectorListRequest
 */
export interface ConnectorsApiGetConnectorListRequest {
    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *sw, co*  **type**: *sw, co, eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*  **labels**: *ca*
     * @type {string}
     * @memberof ConnectorsApiGetConnectorList
     */
    readonly filters?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ConnectorsApiGetConnectorList
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ConnectorsApiGetConnectorList
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ConnectorsApiGetConnectorList
     */
    readonly count?: boolean

    /**
     * The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
     * @type {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'}
     * @memberof ConnectorsApiGetConnectorList
     */
    readonly locale?: GetConnectorListLocaleV3
}

/**
 * Request parameters for getConnectorSourceConfig operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiGetConnectorSourceConfigRequest
 */
export interface ConnectorsApiGetConnectorSourceConfigRequest {
    /**
     * The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiGetConnectorSourceConfig
     */
    readonly scriptName: string
}

/**
 * Request parameters for getConnectorSourceTemplate operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiGetConnectorSourceTemplateRequest
 */
export interface ConnectorsApiGetConnectorSourceTemplateRequest {
    /**
     * The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiGetConnectorSourceTemplate
     */
    readonly scriptName: string
}

/**
 * Request parameters for getConnectorTranslations operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiGetConnectorTranslationsRequest
 */
export interface ConnectorsApiGetConnectorTranslationsRequest {
    /**
     * The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiGetConnectorTranslations
     */
    readonly scriptName: string

    /**
     * The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
     * @type {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'}
     * @memberof ConnectorsApiGetConnectorTranslations
     */
    readonly locale: GetConnectorTranslationsLocaleV3
}

/**
 * Request parameters for putConnectorSourceConfig operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiPutConnectorSourceConfigRequest
 */
export interface ConnectorsApiPutConnectorSourceConfigRequest {
    /**
     * The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiPutConnectorSourceConfig
     */
    readonly scriptName: string

    /**
     * connector source config xml file
     * @type {File}
     * @memberof ConnectorsApiPutConnectorSourceConfig
     */
    readonly file: File
}

/**
 * Request parameters for putConnectorSourceTemplate operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiPutConnectorSourceTemplateRequest
 */
export interface ConnectorsApiPutConnectorSourceTemplateRequest {
    /**
     * The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiPutConnectorSourceTemplate
     */
    readonly scriptName: string

    /**
     * connector source template xml file
     * @type {File}
     * @memberof ConnectorsApiPutConnectorSourceTemplate
     */
    readonly file: File
}

/**
 * Request parameters for putConnectorTranslations operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiPutConnectorTranslationsRequest
 */
export interface ConnectorsApiPutConnectorTranslationsRequest {
    /**
     * The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiPutConnectorTranslations
     */
    readonly scriptName: string

    /**
     * The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
     * @type {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'}
     * @memberof ConnectorsApiPutConnectorTranslations
     */
    readonly locale: PutConnectorTranslationsLocaleV3
}

/**
 * Request parameters for updateConnector operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiUpdateConnectorRequest
 */
export interface ConnectorsApiUpdateConnectorRequest {
    /**
     * The scriptName value of the connector. ScriptName is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiUpdateConnector
     */
    readonly scriptName: string

    /**
     * A list of connector detail update operations 
     * @type {Array<JsonPatchOperation>}
     * @memberof ConnectorsApiUpdateConnector
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * ConnectorsApi - object-oriented interface
 * @export
 * @class ConnectorsApi
 * @extends {BaseAPI}
 */
export class ConnectorsApi extends BaseAPI {
    /**
     * Create custom connector.    
     * @summary Create Custom Connector
     * @param {ConnectorsApiCreateCustomConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public createCustomConnector(requestParameters: ConnectorsApiCreateCustomConnectorRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).createCustomConnector(requestParameters.v3CreateConnectorDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a custom connector that using its script name.
     * @summary Delete Connector by Script Name
     * @param {ConnectorsApiDeleteCustomConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public deleteCustomConnector(requestParameters: ConnectorsApiDeleteCustomConnectorRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).deleteCustomConnector(requestParameters.scriptName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a connector that using its script name.    
     * @summary Get Connector by Script Name
     * @param {ConnectorsApiGetConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnector(requestParameters: ConnectorsApiGetConnectorRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnector(requestParameters.scriptName, requestParameters.locale, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination.
     * @summary Get Connector List
     * @param {ConnectorsApiGetConnectorListRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnectorList(requestParameters: ConnectorsApiGetConnectorListRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectorList(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.locale, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a connector\'s source config using its script name.    
     * @summary Get Connector Source Configuration
     * @param {ConnectorsApiGetConnectorSourceConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnectorSourceConfig(requestParameters: ConnectorsApiGetConnectorSourceConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectorSourceConfig(requestParameters.scriptName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a connector\'s source template using its script name.    
     * @summary Get Connector Source Template
     * @param {ConnectorsApiGetConnectorSourceTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnectorSourceTemplate(requestParameters: ConnectorsApiGetConnectorSourceTemplateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectorSourceTemplate(requestParameters.scriptName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a connector\'s translations using its script name.    
     * @summary Get Connector Translations
     * @param {ConnectorsApiGetConnectorTranslationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnectorTranslations(requestParameters: ConnectorsApiGetConnectorTranslationsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectorTranslations(requestParameters.scriptName, requestParameters.locale, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a connector\'s source config using its script name.    
     * @summary Update Connector Source Configuration
     * @param {ConnectorsApiPutConnectorSourceConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public putConnectorSourceConfig(requestParameters: ConnectorsApiPutConnectorSourceConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).putConnectorSourceConfig(requestParameters.scriptName, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a connector\'s source template using its script name.    
     * @summary Update Connector Source Template
     * @param {ConnectorsApiPutConnectorSourceTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public putConnectorSourceTemplate(requestParameters: ConnectorsApiPutConnectorSourceTemplateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).putConnectorSourceTemplate(requestParameters.scriptName, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a connector\'s translations using its script name.    
     * @summary Update Connector Translations
     * @param {ConnectorsApiPutConnectorTranslationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public putConnectorTranslations(requestParameters: ConnectorsApiPutConnectorTranslationsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).putConnectorTranslations(requestParameters.scriptName, requestParameters.locale, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates a custom connector by script name using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable:   * connectorMetadata  * applicationXml  * correlationConfigXml  * sourceConfigXml 
     * @summary Update Connector by Script Name
     * @param {ConnectorsApiUpdateConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public updateConnector(requestParameters: ConnectorsApiUpdateConnectorRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).updateConnector(requestParameters.scriptName, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetConnectorLocaleV3 = {
    De: 'de',
    False: 'false',
    Fi: 'fi',
    Sv: 'sv',
    Ru: 'ru',
    Pt: 'pt',
    Ko: 'ko',
    ZhTw: 'zh-TW',
    En: 'en',
    It: 'it',
    Fr: 'fr',
    ZhCn: 'zh-CN',
    Hu: 'hu',
    Es: 'es',
    Cs: 'cs',
    Ja: 'ja',
    Pl: 'pl',
    Da: 'da',
    Nl: 'nl'
} as const;
export type GetConnectorLocaleV3 = typeof GetConnectorLocaleV3[keyof typeof GetConnectorLocaleV3];
/**
 * @export
 */
export const GetConnectorListLocaleV3 = {
    De: 'de',
    False: 'false',
    Fi: 'fi',
    Sv: 'sv',
    Ru: 'ru',
    Pt: 'pt',
    Ko: 'ko',
    ZhTw: 'zh-TW',
    En: 'en',
    It: 'it',
    Fr: 'fr',
    ZhCn: 'zh-CN',
    Hu: 'hu',
    Es: 'es',
    Cs: 'cs',
    Ja: 'ja',
    Pl: 'pl',
    Da: 'da',
    Nl: 'nl'
} as const;
export type GetConnectorListLocaleV3 = typeof GetConnectorListLocaleV3[keyof typeof GetConnectorListLocaleV3];
/**
 * @export
 */
export const GetConnectorTranslationsLocaleV3 = {
    De: 'de',
    False: 'false',
    Fi: 'fi',
    Sv: 'sv',
    Ru: 'ru',
    Pt: 'pt',
    Ko: 'ko',
    ZhTw: 'zh-TW',
    En: 'en',
    It: 'it',
    Fr: 'fr',
    ZhCn: 'zh-CN',
    Hu: 'hu',
    Es: 'es',
    Cs: 'cs',
    Ja: 'ja',
    Pl: 'pl',
    Da: 'da',
    Nl: 'nl'
} as const;
export type GetConnectorTranslationsLocaleV3 = typeof GetConnectorTranslationsLocaleV3[keyof typeof GetConnectorTranslationsLocaleV3];
/**
 * @export
 */
export const PutConnectorTranslationsLocaleV3 = {
    De: 'de',
    False: 'false',
    Fi: 'fi',
    Sv: 'sv',
    Ru: 'ru',
    Pt: 'pt',
    Ko: 'ko',
    ZhTw: 'zh-TW',
    En: 'en',
    It: 'it',
    Fr: 'fr',
    ZhCn: 'zh-CN',
    Hu: 'hu',
    Es: 'es',
    Cs: 'cs',
    Ja: 'ja',
    Pl: 'pl',
    Da: 'da',
    Nl: 'nl'
} as const;
export type PutConnectorTranslationsLocaleV3 = typeof PutConnectorTranslationsLocaleV3[keyof typeof PutConnectorTranslationsLocaleV3];


/**
 * GlobalTenantSecuritySettingsApi - axios parameter creator
 * @export
 */
export const GlobalTenantSecuritySettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:manage\'
         * @summary Create security network configuration.
         * @param {NetworkConfiguration} networkConfiguration Network configuration creation request body.   The following constraints ensure the request body conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAuthOrgNetworkConfig: async (networkConfiguration: NetworkConfiguration, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkConfiguration' is not null or undefined
            assertParamExists('createAuthOrgNetworkConfig', 'networkConfiguration', networkConfiguration)
            const localVarPath = `/auth-org/network-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the details of an org\'s lockout auth configuration.
         * @summary Get Auth Org Lockout Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgLockoutConfig: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth-org/lockout-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the details of an org\'s network auth configuration.
         * @summary Get security network configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgNetworkConfig: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth-org/network-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the details of an org\'s service provider auth configuration.
         * @summary Get Service Provider Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgServiceProviderConfig: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth-org/service-provider-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the details of an org\'s session auth configuration.
         * @summary Get Auth Org Session Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgSessionConfig: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth-org/session-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing lockout configuration for an org using PATCH 
         * @summary Update Auth Org Lockout Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org lockout configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Lockout Config conforms to certain logical guidelines, which are:   &#x60;1. maximumAttempts &gt;&#x3D; 1 &amp;&amp; maximumAttempts &lt;&#x3D; 15   2. lockoutDuration &gt;&#x3D; 5 &amp;&amp; lockoutDuration &lt;&#x3D; 60   3. lockoutWindow &gt;&#x3D; 5 &amp;&amp; lockoutDuration &lt;&#x3D; 60&#x60;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgLockoutConfig: async (jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchAuthOrgLockoutConfig', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/auth-org/lockout-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:manage\'
         * @summary Update security network configuration.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org network configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Network Config conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgNetworkConfig: async (jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchAuthOrgNetworkConfig', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/auth-org/network-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing service provider configuration for an org using PATCH.
         * @summary Update Service Provider Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org service provider configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Note: /federationProtocolDetails/0 is IdpDetails /federationProtocolDetails/1 is SpDetails Ensures that the patched ServiceProviderConfig conforms to certain logical guidelines, which are:   1. Do not add or remove any elements in the federation protocol details in the service provider configuration.   2. Do not modify, add, or delete the service provider details element in the federation protocol details.   3. If this is the first time the patched ServiceProviderConfig enables Remote IDP sign-in, it must also include IDPDetails.   4. If the patch enables Remote IDP sign in, the entityID in the IDPDetails cannot be null. IDPDetails must include an entityID.   5. Any JIT configuration update must be valid.  Just in time configuration update must be valid when enabled. This includes:   - A Source ID   - Source attribute mappings   - Source attribute maps have all the required key values (firstName, lastName, email)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgServiceProviderConfig: async (jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchAuthOrgServiceProviderConfig', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/auth-org/service-provider-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing session configuration for an org using PATCH.
         * @summary Update Auth Org Session Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org session configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Ensures that the patched Session Config conforms to certain logical guidelines, which are:   &#x60;1. maxSessionTime &gt;&#x3D; 1 &amp;&amp; maxSessionTime &lt;&#x3D; 10080 (1 week)   2. maxIdleTime &gt;&#x3D; 1 &amp;&amp; maxIdleTime &lt;&#x3D; 1440 (1 day)   3. maxSessionTime must have a greater duration than maxIdleTime.&#x60; 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgSessionConfig: async (jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchAuthOrgSessionConfig', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/auth-org/session-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlobalTenantSecuritySettingsApi - functional programming interface
 * @export
 */
export const GlobalTenantSecuritySettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GlobalTenantSecuritySettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:manage\'
         * @summary Create security network configuration.
         * @param {NetworkConfiguration} networkConfiguration Network configuration creation request body.   The following constraints ensure the request body conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthOrgNetworkConfig(networkConfiguration: NetworkConfiguration, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthOrgNetworkConfig(networkConfiguration, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalTenantSecuritySettingsApi.createAuthOrgNetworkConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the details of an org\'s lockout auth configuration.
         * @summary Get Auth Org Lockout Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthOrgLockoutConfig(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LockoutConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthOrgLockoutConfig(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalTenantSecuritySettingsApi.getAuthOrgLockoutConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the details of an org\'s network auth configuration.
         * @summary Get security network configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthOrgNetworkConfig(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthOrgNetworkConfig(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalTenantSecuritySettingsApi.getAuthOrgNetworkConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the details of an org\'s service provider auth configuration.
         * @summary Get Service Provider Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthOrgServiceProviderConfig(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthOrgServiceProviderConfig(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalTenantSecuritySettingsApi.getAuthOrgServiceProviderConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the details of an org\'s session auth configuration.
         * @summary Get Auth Org Session Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthOrgSessionConfig(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthOrgSessionConfig(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalTenantSecuritySettingsApi.getAuthOrgSessionConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API updates an existing lockout configuration for an org using PATCH 
         * @summary Update Auth Org Lockout Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org lockout configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Lockout Config conforms to certain logical guidelines, which are:   &#x60;1. maximumAttempts &gt;&#x3D; 1 &amp;&amp; maximumAttempts &lt;&#x3D; 15   2. lockoutDuration &gt;&#x3D; 5 &amp;&amp; lockoutDuration &lt;&#x3D; 60   3. lockoutWindow &gt;&#x3D; 5 &amp;&amp; lockoutDuration &lt;&#x3D; 60&#x60;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAuthOrgLockoutConfig(jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LockoutConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAuthOrgLockoutConfig(jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalTenantSecuritySettingsApi.patchAuthOrgLockoutConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:manage\'
         * @summary Update security network configuration.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org network configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Network Config conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAuthOrgNetworkConfig(jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAuthOrgNetworkConfig(jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalTenantSecuritySettingsApi.patchAuthOrgNetworkConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API updates an existing service provider configuration for an org using PATCH.
         * @summary Update Service Provider Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org service provider configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Note: /federationProtocolDetails/0 is IdpDetails /federationProtocolDetails/1 is SpDetails Ensures that the patched ServiceProviderConfig conforms to certain logical guidelines, which are:   1. Do not add or remove any elements in the federation protocol details in the service provider configuration.   2. Do not modify, add, or delete the service provider details element in the federation protocol details.   3. If this is the first time the patched ServiceProviderConfig enables Remote IDP sign-in, it must also include IDPDetails.   4. If the patch enables Remote IDP sign in, the entityID in the IDPDetails cannot be null. IDPDetails must include an entityID.   5. Any JIT configuration update must be valid.  Just in time configuration update must be valid when enabled. This includes:   - A Source ID   - Source attribute mappings   - Source attribute maps have all the required key values (firstName, lastName, email)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAuthOrgServiceProviderConfig(jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAuthOrgServiceProviderConfig(jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalTenantSecuritySettingsApi.patchAuthOrgServiceProviderConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API updates an existing session configuration for an org using PATCH.
         * @summary Update Auth Org Session Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org session configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Ensures that the patched Session Config conforms to certain logical guidelines, which are:   &#x60;1. maxSessionTime &gt;&#x3D; 1 &amp;&amp; maxSessionTime &lt;&#x3D; 10080 (1 week)   2. maxIdleTime &gt;&#x3D; 1 &amp;&amp; maxIdleTime &lt;&#x3D; 1440 (1 day)   3. maxSessionTime must have a greater duration than maxIdleTime.&#x60; 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAuthOrgSessionConfig(jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAuthOrgSessionConfig(jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalTenantSecuritySettingsApi.patchAuthOrgSessionConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GlobalTenantSecuritySettingsApi - factory interface
 * @export
 */
export const GlobalTenantSecuritySettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GlobalTenantSecuritySettingsApiFp(configuration)
    return {
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:manage\'
         * @summary Create security network configuration.
         * @param {GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAuthOrgNetworkConfig(requestParameters: GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NetworkConfiguration> {
            return localVarFp.createAuthOrgNetworkConfig(requestParameters.networkConfiguration, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the details of an org\'s lockout auth configuration.
         * @summary Get Auth Org Lockout Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgLockoutConfig(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<LockoutConfiguration> {
            return localVarFp.getAuthOrgLockoutConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the details of an org\'s network auth configuration.
         * @summary Get security network configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgNetworkConfig(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NetworkConfiguration> {
            return localVarFp.getAuthOrgNetworkConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the details of an org\'s service provider auth configuration.
         * @summary Get Service Provider Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgServiceProviderConfig(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ServiceProviderConfiguration> {
            return localVarFp.getAuthOrgServiceProviderConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the details of an org\'s session auth configuration.
         * @summary Get Auth Org Session Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgSessionConfig(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SessionConfiguration> {
            return localVarFp.getAuthOrgSessionConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing lockout configuration for an org using PATCH 
         * @summary Update Auth Org Lockout Configuration
         * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgLockoutConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgLockoutConfig(requestParameters: GlobalTenantSecuritySettingsApiPatchAuthOrgLockoutConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<LockoutConfiguration> {
            return localVarFp.patchAuthOrgLockoutConfig(requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:manage\'
         * @summary Update security network configuration.
         * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgNetworkConfig(requestParameters: GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NetworkConfiguration> {
            return localVarFp.patchAuthOrgNetworkConfig(requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing service provider configuration for an org using PATCH.
         * @summary Update Service Provider Configuration
         * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgServiceProviderConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgServiceProviderConfig(requestParameters: GlobalTenantSecuritySettingsApiPatchAuthOrgServiceProviderConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ServiceProviderConfiguration> {
            return localVarFp.patchAuthOrgServiceProviderConfig(requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing session configuration for an org using PATCH.
         * @summary Update Auth Org Session Configuration
         * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgSessionConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgSessionConfig(requestParameters: GlobalTenantSecuritySettingsApiPatchAuthOrgSessionConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SessionConfiguration> {
            return localVarFp.patchAuthOrgSessionConfig(requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAuthOrgNetworkConfig operation in GlobalTenantSecuritySettingsApi.
 * @export
 * @interface GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest
 */
export interface GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest {
    /**
     * Network configuration creation request body.   The following constraints ensure the request body conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
     * @type {NetworkConfiguration}
     * @memberof GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfig
     */
    readonly networkConfiguration: NetworkConfiguration
}

/**
 * Request parameters for patchAuthOrgLockoutConfig operation in GlobalTenantSecuritySettingsApi.
 * @export
 * @interface GlobalTenantSecuritySettingsApiPatchAuthOrgLockoutConfigRequest
 */
export interface GlobalTenantSecuritySettingsApiPatchAuthOrgLockoutConfigRequest {
    /**
     * A list of auth org lockout configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Lockout Config conforms to certain logical guidelines, which are:   &#x60;1. maximumAttempts &gt;&#x3D; 1 &amp;&amp; maximumAttempts &lt;&#x3D; 15   2. lockoutDuration &gt;&#x3D; 5 &amp;&amp; lockoutDuration &lt;&#x3D; 60   3. lockoutWindow &gt;&#x3D; 5 &amp;&amp; lockoutDuration &lt;&#x3D; 60&#x60;
     * @type {Array<JsonPatchOperation>}
     * @memberof GlobalTenantSecuritySettingsApiPatchAuthOrgLockoutConfig
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for patchAuthOrgNetworkConfig operation in GlobalTenantSecuritySettingsApi.
 * @export
 * @interface GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest
 */
export interface GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest {
    /**
     * A list of auth org network configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Network Config conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
     * @type {Array<JsonPatchOperation>}
     * @memberof GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfig
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for patchAuthOrgServiceProviderConfig operation in GlobalTenantSecuritySettingsApi.
 * @export
 * @interface GlobalTenantSecuritySettingsApiPatchAuthOrgServiceProviderConfigRequest
 */
export interface GlobalTenantSecuritySettingsApiPatchAuthOrgServiceProviderConfigRequest {
    /**
     * A list of auth org service provider configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Note: /federationProtocolDetails/0 is IdpDetails /federationProtocolDetails/1 is SpDetails Ensures that the patched ServiceProviderConfig conforms to certain logical guidelines, which are:   1. Do not add or remove any elements in the federation protocol details in the service provider configuration.   2. Do not modify, add, or delete the service provider details element in the federation protocol details.   3. If this is the first time the patched ServiceProviderConfig enables Remote IDP sign-in, it must also include IDPDetails.   4. If the patch enables Remote IDP sign in, the entityID in the IDPDetails cannot be null. IDPDetails must include an entityID.   5. Any JIT configuration update must be valid.  Just in time configuration update must be valid when enabled. This includes:   - A Source ID   - Source attribute mappings   - Source attribute maps have all the required key values (firstName, lastName, email)
     * @type {Array<JsonPatchOperation>}
     * @memberof GlobalTenantSecuritySettingsApiPatchAuthOrgServiceProviderConfig
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for patchAuthOrgSessionConfig operation in GlobalTenantSecuritySettingsApi.
 * @export
 * @interface GlobalTenantSecuritySettingsApiPatchAuthOrgSessionConfigRequest
 */
export interface GlobalTenantSecuritySettingsApiPatchAuthOrgSessionConfigRequest {
    /**
     * A list of auth org session configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Ensures that the patched Session Config conforms to certain logical guidelines, which are:   &#x60;1. maxSessionTime &gt;&#x3D; 1 &amp;&amp; maxSessionTime &lt;&#x3D; 10080 (1 week)   2. maxIdleTime &gt;&#x3D; 1 &amp;&amp; maxIdleTime &lt;&#x3D; 1440 (1 day)   3. maxSessionTime must have a greater duration than maxIdleTime.&#x60; 
     * @type {Array<JsonPatchOperation>}
     * @memberof GlobalTenantSecuritySettingsApiPatchAuthOrgSessionConfig
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * GlobalTenantSecuritySettingsApi - object-oriented interface
 * @export
 * @class GlobalTenantSecuritySettingsApi
 * @extends {BaseAPI}
 */
export class GlobalTenantSecuritySettingsApi extends BaseAPI {
    /**
     * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:manage\'
     * @summary Create security network configuration.
     * @param {GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public createAuthOrgNetworkConfig(requestParameters: GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).createAuthOrgNetworkConfig(requestParameters.networkConfiguration, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the details of an org\'s lockout auth configuration.
     * @summary Get Auth Org Lockout Configuration.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public getAuthOrgLockoutConfig(axiosOptions?: RawAxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).getAuthOrgLockoutConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the details of an org\'s network auth configuration.
     * @summary Get security network configuration.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public getAuthOrgNetworkConfig(axiosOptions?: RawAxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).getAuthOrgNetworkConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the details of an org\'s service provider auth configuration.
     * @summary Get Service Provider Configuration.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public getAuthOrgServiceProviderConfig(axiosOptions?: RawAxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).getAuthOrgServiceProviderConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the details of an org\'s session auth configuration.
     * @summary Get Auth Org Session Configuration.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public getAuthOrgSessionConfig(axiosOptions?: RawAxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).getAuthOrgSessionConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing lockout configuration for an org using PATCH 
     * @summary Update Auth Org Lockout Configuration
     * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgLockoutConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public patchAuthOrgLockoutConfig(requestParameters: GlobalTenantSecuritySettingsApiPatchAuthOrgLockoutConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).patchAuthOrgLockoutConfig(requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:manage\'
     * @summary Update security network configuration.
     * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public patchAuthOrgNetworkConfig(requestParameters: GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).patchAuthOrgNetworkConfig(requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing service provider configuration for an org using PATCH.
     * @summary Update Service Provider Configuration
     * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgServiceProviderConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public patchAuthOrgServiceProviderConfig(requestParameters: GlobalTenantSecuritySettingsApiPatchAuthOrgServiceProviderConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).patchAuthOrgServiceProviderConfig(requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing session configuration for an org using PATCH.
     * @summary Update Auth Org Session Configuration
     * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgSessionConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public patchAuthOrgSessionConfig(requestParameters: GlobalTenantSecuritySettingsApiPatchAuthOrgSessionConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).patchAuthOrgSessionConfig(requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdentityProfilesApi - axios parameter creator
 * @export
 */
export const IdentityProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an identity profile.    
         * @summary Create Identity Profile
         * @param {IdentityProfile} identityProfile 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createIdentityProfile: async (identityProfile: IdentityProfile, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfile' is not null or undefined
            assertParamExists('createIdentityProfile', 'identityProfile', identityProfile)
            const localVarPath = `/identity-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProfile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete an identity profile by ID. On success, this endpoint will return a reference to the bulk delete task result.
         * @summary Delete Identity Profile
         * @param {string} identityProfileId Identity profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfile: async (identityProfileId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('deleteIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete Identity Profiles
         * @param {Array<string>} requestBody Identity Profile bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfiles: async (requestBody: Array<string>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('deleteIdentityProfiles', 'requestBody', requestBody)
            const localVarPath = `/identity-profiles/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-profiles/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig: async (identityProfileId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getDefaultIdentityAttributeConfig', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/default-identity-attribute-config`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a single identity profile by ID.
         * @summary Get Identity Profile
         * @param {string} identityProfileId Identity profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile: async (identityProfileId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles: async (identityProfileExportedObject: Array<IdentityProfileExportedObject>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileExportedObject' is not null or undefined
            assertParamExists('importIdentityProfiles', 'identityProfileExportedObject', identityProfileExportedObject)
            const localVarPath = `/identity-profiles/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProfileExportedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a list of identity profiles, based on the specified query parameters.
         * @summary List Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne, ge, gt, in, le, sw*  **name**: *eq, ne, ge, gt, in, le, sw*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority, created, modified, owner.id, owner.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to generate a non-persisted preview of the identity object after applying `IdentityAttributeConfig` sent in request body. This API only allows `accountAttribute`, `reference` and `rule` transform types in the `IdentityAttributeConfig` sent in the request body.
         * @summary Generate Identity Profile Preview
         * @param {IdentityPreviewRequest} identityPreviewRequest Identity Preview request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        showIdentityPreview: async (identityPreviewRequest: IdentityPreviewRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityPreviewRequest' is not null or undefined
            assertParamExists('showIdentityPreview', 'identityPreviewRequest', identityPreviewRequest)
            const localVarPath = `/identity-profiles/identity-preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityPreviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Process identities under the profile This operation should not be used to schedule your own identity processing or to perform system wide identity refreshes. The system will use a combination of [event-based processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#event-based-processing) and [scheduled processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#scheduled-processing) that runs every day at 8:00 AM and 8:00 PM in the tenant\'s timezone to keep your identities synchronized.  This should only be run on identity profiles that have the `identityRefreshRequired` attribute set to `true`. If `identityRefreshRequired` is false, then there is no benefit to running this operation. Typically, this operation is performed when a change is made to the identity profile or its related lifecycle states that requires a refresh. This operation will perform the following activities on all identities under the identity profile. 1. Updates identity attribute according to the identity profile mappings. 2. Determines the identity\'s correct manager through manager correlation. 3. Updates the identity\'s access according to their assigned lifecycle state. 4. Updates the identity\'s access based on role assignment criteria.
         * @summary Process identities under profile
         * @param {string} identityProfileId The Identity Profile ID to be processed
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        syncIdentityProfile: async (identityProfileId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('syncIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/process-identities`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update a specified identity profile with this PATCH request.    You cannot update these fields: * id * created * modified * identityCount * identityRefreshRequired * Authoritative Source and Identity Attribute Configuration cannot be modified at the same time.
         * @summary Update Identity Profile
         * @param {string} identityProfileId Identity profile ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation List of identity profile update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentityProfile: async (identityProfileId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('updateIdentityProfile', 'identityProfileId', identityProfileId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateIdentityProfile', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/identity-profiles/{identity-profile-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityProfilesApi - functional programming interface
 * @export
 */
export const IdentityProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an identity profile.    
         * @summary Create Identity Profile
         * @param {IdentityProfile} identityProfile 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createIdentityProfile(identityProfile: IdentityProfile, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIdentityProfile(identityProfile, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityProfilesApi.createIdentityProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an identity profile by ID. On success, this endpoint will return a reference to the bulk delete task result.
         * @summary Delete Identity Profile
         * @param {string} identityProfileId Identity profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityProfile(identityProfileId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResultSimplified>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityProfile(identityProfileId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityProfilesApi.deleteIdentityProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete Identity Profiles
         * @param {Array<string>} requestBody Identity Profile bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityProfiles(requestBody: Array<string>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResultSimplified>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityProfiles(requestBody, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityProfilesApi.deleteIdentityProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProfileExportedObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityProfilesApi.exportIdentityProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This returns the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultIdentityAttributeConfig(identityProfileId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityAttributeConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultIdentityAttributeConfig(identityProfileId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityProfilesApi.getDefaultIdentityAttributeConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a single identity profile by ID.
         * @summary Get Identity Profile
         * @param {string} identityProfileId Identity profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityProfile(identityProfileId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityProfile(identityProfileId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityProfilesApi.getIdentityProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importIdentityProfiles(identityProfileExportedObject: Array<IdentityProfileExportedObject>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectImportResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importIdentityProfiles(identityProfileExportedObject, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityProfilesApi.importIdentityProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of identity profiles, based on the specified query parameters.
         * @summary List Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne, ge, gt, in, le, sw*  **name**: *eq, ne, ge, gt, in, le, sw*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority, created, modified, owner.id, owner.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityProfilesApi.listIdentityProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to generate a non-persisted preview of the identity object after applying `IdentityAttributeConfig` sent in request body. This API only allows `accountAttribute`, `reference` and `rule` transform types in the `IdentityAttributeConfig` sent in the request body.
         * @summary Generate Identity Profile Preview
         * @param {IdentityPreviewRequest} identityPreviewRequest Identity Preview request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async showIdentityPreview(identityPreviewRequest: IdentityPreviewRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityPreviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showIdentityPreview(identityPreviewRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityProfilesApi.showIdentityPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Process identities under the profile This operation should not be used to schedule your own identity processing or to perform system wide identity refreshes. The system will use a combination of [event-based processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#event-based-processing) and [scheduled processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#scheduled-processing) that runs every day at 8:00 AM and 8:00 PM in the tenant\'s timezone to keep your identities synchronized.  This should only be run on identity profiles that have the `identityRefreshRequired` attribute set to `true`. If `identityRefreshRequired` is false, then there is no benefit to running this operation. Typically, this operation is performed when a change is made to the identity profile or its related lifecycle states that requires a refresh. This operation will perform the following activities on all identities under the identity profile. 1. Updates identity attribute according to the identity profile mappings. 2. Determines the identity\'s correct manager through manager correlation. 3. Updates the identity\'s access according to their assigned lifecycle state. 4. Updates the identity\'s access based on role assignment criteria.
         * @summary Process identities under profile
         * @param {string} identityProfileId The Identity Profile ID to be processed
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async syncIdentityProfile(identityProfileId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncIdentityProfile(identityProfileId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityProfilesApi.syncIdentityProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specified identity profile with this PATCH request.    You cannot update these fields: * id * created * modified * identityCount * identityRefreshRequired * Authoritative Source and Identity Attribute Configuration cannot be modified at the same time.
         * @summary Update Identity Profile
         * @param {string} identityProfileId Identity profile ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation List of identity profile update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateIdentityProfile(identityProfileId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIdentityProfile(identityProfileId, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityProfilesApi.updateIdentityProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdentityProfilesApi - factory interface
 * @export
 */
export const IdentityProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityProfilesApiFp(configuration)
    return {
        /**
         * Creates an identity profile.    
         * @summary Create Identity Profile
         * @param {IdentityProfilesApiCreateIdentityProfileRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createIdentityProfile(requestParameters: IdentityProfilesApiCreateIdentityProfileRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<IdentityProfile> {
            return localVarFp.createIdentityProfile(requestParameters.identityProfile, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete an identity profile by ID. On success, this endpoint will return a reference to the bulk delete task result.
         * @summary Delete Identity Profile
         * @param {IdentityProfilesApiDeleteIdentityProfileRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfile(requestParameters: IdentityProfilesApiDeleteIdentityProfileRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<TaskResultSimplified> {
            return localVarFp.deleteIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete Identity Profiles
         * @param {IdentityProfilesApiDeleteIdentityProfilesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfiles(requestParameters: IdentityProfilesApiDeleteIdentityProfilesRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<TaskResultSimplified> {
            return localVarFp.deleteIdentityProfiles(requestParameters.requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {IdentityProfilesApiExportIdentityProfilesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles(requestParameters: IdentityProfilesApiExportIdentityProfilesRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<IdentityProfileExportedObject>> {
            return localVarFp.exportIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig(requestParameters: IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<IdentityAttributeConfig> {
            return localVarFp.getDefaultIdentityAttributeConfig(requestParameters.identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a single identity profile by ID.
         * @summary Get Identity Profile
         * @param {IdentityProfilesApiGetIdentityProfileRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile(requestParameters: IdentityProfilesApiGetIdentityProfileRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<IdentityProfile> {
            return localVarFp.getIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {IdentityProfilesApiImportIdentityProfilesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles(requestParameters: IdentityProfilesApiImportIdentityProfilesRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ObjectImportResult> {
            return localVarFp.importIdentityProfiles(requestParameters.identityProfileExportedObject, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of identity profiles, based on the specified query parameters.
         * @summary List Identity Profiles
         * @param {IdentityProfilesApiListIdentityProfilesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles(requestParameters: IdentityProfilesApiListIdentityProfilesRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<IdentityProfile>> {
            return localVarFp.listIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to generate a non-persisted preview of the identity object after applying `IdentityAttributeConfig` sent in request body. This API only allows `accountAttribute`, `reference` and `rule` transform types in the `IdentityAttributeConfig` sent in the request body.
         * @summary Generate Identity Profile Preview
         * @param {IdentityProfilesApiShowIdentityPreviewRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        showIdentityPreview(requestParameters: IdentityProfilesApiShowIdentityPreviewRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<IdentityPreviewResponse> {
            return localVarFp.showIdentityPreview(requestParameters.identityPreviewRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Process identities under the profile This operation should not be used to schedule your own identity processing or to perform system wide identity refreshes. The system will use a combination of [event-based processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#event-based-processing) and [scheduled processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#scheduled-processing) that runs every day at 8:00 AM and 8:00 PM in the tenant\'s timezone to keep your identities synchronized.  This should only be run on identity profiles that have the `identityRefreshRequired` attribute set to `true`. If `identityRefreshRequired` is false, then there is no benefit to running this operation. Typically, this operation is performed when a change is made to the identity profile or its related lifecycle states that requires a refresh. This operation will perform the following activities on all identities under the identity profile. 1. Updates identity attribute according to the identity profile mappings. 2. Determines the identity\'s correct manager through manager correlation. 3. Updates the identity\'s access according to their assigned lifecycle state. 4. Updates the identity\'s access based on role assignment criteria.
         * @summary Process identities under profile
         * @param {IdentityProfilesApiSyncIdentityProfileRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        syncIdentityProfile(requestParameters: IdentityProfilesApiSyncIdentityProfileRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.syncIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update a specified identity profile with this PATCH request.    You cannot update these fields: * id * created * modified * identityCount * identityRefreshRequired * Authoritative Source and Identity Attribute Configuration cannot be modified at the same time.
         * @summary Update Identity Profile
         * @param {IdentityProfilesApiUpdateIdentityProfileRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentityProfile(requestParameters: IdentityProfilesApiUpdateIdentityProfileRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<IdentityProfile> {
            return localVarFp.updateIdentityProfile(requestParameters.identityProfileId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createIdentityProfile operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiCreateIdentityProfileRequest
 */
export interface IdentityProfilesApiCreateIdentityProfileRequest {
    /**
     * 
     * @type {IdentityProfile}
     * @memberof IdentityProfilesApiCreateIdentityProfile
     */
    readonly identityProfile: IdentityProfile
}

/**
 * Request parameters for deleteIdentityProfile operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiDeleteIdentityProfileRequest
 */
export interface IdentityProfilesApiDeleteIdentityProfileRequest {
    /**
     * Identity profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiDeleteIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for deleteIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiDeleteIdentityProfilesRequest
 */
export interface IdentityProfilesApiDeleteIdentityProfilesRequest {
    /**
     * Identity Profile bulk delete request body.
     * @type {Array<string>}
     * @memberof IdentityProfilesApiDeleteIdentityProfiles
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for exportIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiExportIdentityProfilesRequest
 */
export interface IdentityProfilesApiExportIdentityProfilesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
     * @type {string}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority**
     * @type {string}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly sorters?: string
}

/**
 * Request parameters for getDefaultIdentityAttributeConfig operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest
 */
export interface IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest {
    /**
     * The Identity Profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiGetDefaultIdentityAttributeConfig
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for getIdentityProfile operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiGetIdentityProfileRequest
 */
export interface IdentityProfilesApiGetIdentityProfileRequest {
    /**
     * Identity profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiGetIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for importIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiImportIdentityProfilesRequest
 */
export interface IdentityProfilesApiImportIdentityProfilesRequest {
    /**
     * Previously exported Identity Profiles.
     * @type {Array<IdentityProfileExportedObject>}
     * @memberof IdentityProfilesApiImportIdentityProfiles
     */
    readonly identityProfileExportedObject: Array<IdentityProfileExportedObject>
}

/**
 * Request parameters for listIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiListIdentityProfilesRequest
 */
export interface IdentityProfilesApiListIdentityProfilesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne, ge, gt, in, le, sw*  **name**: *eq, ne, ge, gt, in, le, sw*  **priority**: *eq, ne*
     * @type {string}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority, created, modified, owner.id, owner.name**
     * @type {string}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly sorters?: string
}

/**
 * Request parameters for showIdentityPreview operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiShowIdentityPreviewRequest
 */
export interface IdentityProfilesApiShowIdentityPreviewRequest {
    /**
     * Identity Preview request body.
     * @type {IdentityPreviewRequest}
     * @memberof IdentityProfilesApiShowIdentityPreview
     */
    readonly identityPreviewRequest: IdentityPreviewRequest
}

/**
 * Request parameters for syncIdentityProfile operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiSyncIdentityProfileRequest
 */
export interface IdentityProfilesApiSyncIdentityProfileRequest {
    /**
     * The Identity Profile ID to be processed
     * @type {string}
     * @memberof IdentityProfilesApiSyncIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for updateIdentityProfile operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiUpdateIdentityProfileRequest
 */
export interface IdentityProfilesApiUpdateIdentityProfileRequest {
    /**
     * Identity profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiUpdateIdentityProfile
     */
    readonly identityProfileId: string

    /**
     * List of identity profile update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperation>}
     * @memberof IdentityProfilesApiUpdateIdentityProfile
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * IdentityProfilesApi - object-oriented interface
 * @export
 * @class IdentityProfilesApi
 * @extends {BaseAPI}
 */
export class IdentityProfilesApi extends BaseAPI {
    /**
     * Creates an identity profile.    
     * @summary Create Identity Profile
     * @param {IdentityProfilesApiCreateIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public createIdentityProfile(requestParameters: IdentityProfilesApiCreateIdentityProfileRequest, axiosOptions?: RawAxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).createIdentityProfile(requestParameters.identityProfile, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an identity profile by ID. On success, this endpoint will return a reference to the bulk delete task result.
     * @summary Delete Identity Profile
     * @param {IdentityProfilesApiDeleteIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public deleteIdentityProfile(requestParameters: IdentityProfilesApiDeleteIdentityProfileRequest, axiosOptions?: RawAxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).deleteIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  The following rights are required to access this endpoint: idn:identity-profile:delete
     * @summary Delete Identity Profiles
     * @param {IdentityProfilesApiDeleteIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public deleteIdentityProfiles(requestParameters: IdentityProfilesApiDeleteIdentityProfilesRequest, axiosOptions?: RawAxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).deleteIdentityProfiles(requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This exports existing identity profiles in the format specified by the sp-config service.
     * @summary Export Identity Profiles
     * @param {IdentityProfilesApiExportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public exportIdentityProfiles(requestParameters: IdentityProfilesApiExportIdentityProfilesRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).exportIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns the default identity attribute config.
     * @summary Get default Identity Attribute Config
     * @param {IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public getDefaultIdentityAttributeConfig(requestParameters: IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).getDefaultIdentityAttributeConfig(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single identity profile by ID.
     * @summary Get Identity Profile
     * @param {IdentityProfilesApiGetIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public getIdentityProfile(requestParameters: IdentityProfilesApiGetIdentityProfileRequest, axiosOptions?: RawAxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).getIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This imports previously exported identity profiles.
     * @summary Import Identity Profiles
     * @param {IdentityProfilesApiImportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public importIdentityProfiles(requestParameters: IdentityProfilesApiImportIdentityProfilesRequest, axiosOptions?: RawAxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).importIdentityProfiles(requestParameters.identityProfileExportedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of identity profiles, based on the specified query parameters.
     * @summary List Identity Profiles
     * @param {IdentityProfilesApiListIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public listIdentityProfiles(requestParameters: IdentityProfilesApiListIdentityProfilesRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).listIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to generate a non-persisted preview of the identity object after applying `IdentityAttributeConfig` sent in request body. This API only allows `accountAttribute`, `reference` and `rule` transform types in the `IdentityAttributeConfig` sent in the request body.
     * @summary Generate Identity Profile Preview
     * @param {IdentityProfilesApiShowIdentityPreviewRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public showIdentityPreview(requestParameters: IdentityProfilesApiShowIdentityPreviewRequest, axiosOptions?: RawAxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).showIdentityPreview(requestParameters.identityPreviewRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process identities under the profile This operation should not be used to schedule your own identity processing or to perform system wide identity refreshes. The system will use a combination of [event-based processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#event-based-processing) and [scheduled processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#scheduled-processing) that runs every day at 8:00 AM and 8:00 PM in the tenant\'s timezone to keep your identities synchronized.  This should only be run on identity profiles that have the `identityRefreshRequired` attribute set to `true`. If `identityRefreshRequired` is false, then there is no benefit to running this operation. Typically, this operation is performed when a change is made to the identity profile or its related lifecycle states that requires a refresh. This operation will perform the following activities on all identities under the identity profile. 1. Updates identity attribute according to the identity profile mappings. 2. Determines the identity\'s correct manager through manager correlation. 3. Updates the identity\'s access according to their assigned lifecycle state. 4. Updates the identity\'s access based on role assignment criteria.
     * @summary Process identities under profile
     * @param {IdentityProfilesApiSyncIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public syncIdentityProfile(requestParameters: IdentityProfilesApiSyncIdentityProfileRequest, axiosOptions?: RawAxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).syncIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specified identity profile with this PATCH request.    You cannot update these fields: * id * created * modified * identityCount * identityRefreshRequired * Authoritative Source and Identity Attribute Configuration cannot be modified at the same time.
     * @summary Update Identity Profile
     * @param {IdentityProfilesApiUpdateIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public updateIdentityProfile(requestParameters: IdentityProfilesApiUpdateIdentityProfileRequest, axiosOptions?: RawAxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).updateIdentityProfile(requestParameters.identityProfileId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LifecycleStatesApi - axios parameter creator
 * @export
 */
export const LifecycleStatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create a lifecycle state.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {LifecycleState} lifecycleState Lifecycle state to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createLifecycleState: async (identityProfileId: string, lifecycleState: LifecycleState, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('createLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleState' is not null or undefined
            assertParamExists('createLifecycleState', 'lifecycleState', lifecycleState)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lifecycleState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete the lifecycle state by its ID. 
         * @summary Delete Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteLifecycleState: async (identityProfileId: string, lifecycleStateId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('deleteLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('deleteLifecycleState', 'lifecycleStateId', lifecycleStateId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to get a lifecycle state by its ID and its associated identity profile ID. 
         * @summary Get Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleState: async (identityProfileId: string, lifecycleStateId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('getLifecycleState', 'lifecycleStateId', lifecycleStateId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all lifecycle states by their associated identity profiles. 
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId Identity profile ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleStates: async (identityProfileId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getLifecycleStates', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to set/update an identity\'s lifecycle state to the one provided and update the corresponding identity profile.
         * @summary Set Lifecycle State
         * @param {string} identityId ID of the identity to update.
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setLifecycleState: async (identityId: string, setLifecycleStateRequest: SetLifecycleStateRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('setLifecycleState', 'identityId', identityId)
            // verify required parameter 'setLifecycleStateRequest' is not null or undefined
            assertParamExists('setLifecycleState', 'setLifecycleStateRequest', setLifecycleStateRequest)
            const localVarPath = `/identities/{identity-id}/set-lifecycle-state`
                .replace(`{${"identity-id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setLifecycleStateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update individual lifecycle state fields, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates: async (identityProfileId: string, lifecycleStateId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('updateLifecycleStates', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('updateLifecycleStates', 'lifecycleStateId', lifecycleStateId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateLifecycleStates', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * LifecycleStatesApi - functional programming interface
 * @export
 */
export const LifecycleStatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LifecycleStatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create a lifecycle state.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {LifecycleState} lifecycleState Lifecycle state to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createLifecycleState(identityProfileId: string, lifecycleState: LifecycleState, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLifecycleState(identityProfileId, lifecycleState, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LifecycleStatesApi.createLifecycleState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to delete the lifecycle state by its ID. 
         * @summary Delete Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecyclestateDeleted>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLifecycleState(identityProfileId, lifecycleStateId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LifecycleStatesApi.deleteLifecycleState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to get a lifecycle state by its ID and its associated identity profile ID. 
         * @summary Get Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLifecycleState(identityProfileId, lifecycleStateId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LifecycleStatesApi.getLifecycleState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to list all lifecycle states by their associated identity profiles. 
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId Identity profile ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLifecycleStates(identityProfileId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifecycleState>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLifecycleStates(identityProfileId, limit, offset, count, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LifecycleStatesApi.getLifecycleStates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to set/update an identity\'s lifecycle state to the one provided and update the corresponding identity profile.
         * @summary Set Lifecycle State
         * @param {string} identityId ID of the identity to update.
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setLifecycleState(identityId: string, setLifecycleStateRequest: SetLifecycleStateRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetLifecycleState200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setLifecycleState(identityId, setLifecycleStateRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LifecycleStatesApi.setLifecycleState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to update individual lifecycle state fields, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateLifecycleStates(identityProfileId: string, lifecycleStateId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLifecycleStates(identityProfileId, lifecycleStateId, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LifecycleStatesApi.updateLifecycleStates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LifecycleStatesApi - factory interface
 * @export
 */
export const LifecycleStatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LifecycleStatesApiFp(configuration)
    return {
        /**
         * Use this endpoint to create a lifecycle state.
         * @summary Create Lifecycle State
         * @param {LifecycleStatesApiCreateLifecycleStateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createLifecycleState(requestParameters: LifecycleStatesApiCreateLifecycleStateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<LifecycleState> {
            return localVarFp.createLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleState, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete the lifecycle state by its ID. 
         * @summary Delete Lifecycle State
         * @param {LifecycleStatesApiDeleteLifecycleStateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteLifecycleState(requestParameters: LifecycleStatesApiDeleteLifecycleStateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<LifecyclestateDeleted> {
            return localVarFp.deleteLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to get a lifecycle state by its ID and its associated identity profile ID. 
         * @summary Get Lifecycle State
         * @param {LifecycleStatesApiGetLifecycleStateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleState(requestParameters: LifecycleStatesApiGetLifecycleStateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<LifecycleState> {
            return localVarFp.getLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all lifecycle states by their associated identity profiles. 
         * @summary Lists LifecycleStates
         * @param {LifecycleStatesApiGetLifecycleStatesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleStates(requestParameters: LifecycleStatesApiGetLifecycleStatesRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<LifecycleState>> {
            return localVarFp.getLifecycleStates(requestParameters.identityProfileId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to set/update an identity\'s lifecycle state to the one provided and update the corresponding identity profile.
         * @summary Set Lifecycle State
         * @param {LifecycleStatesApiSetLifecycleStateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setLifecycleState(requestParameters: LifecycleStatesApiSetLifecycleStateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SetLifecycleState200Response> {
            return localVarFp.setLifecycleState(requestParameters.identityId, requestParameters.setLifecycleStateRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update individual lifecycle state fields, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update Lifecycle State
         * @param {LifecycleStatesApiUpdateLifecycleStatesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates(requestParameters: LifecycleStatesApiUpdateLifecycleStatesRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<LifecycleState> {
            return localVarFp.updateLifecycleStates(requestParameters.identityProfileId, requestParameters.lifecycleStateId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiCreateLifecycleStateRequest
 */
export interface LifecycleStatesApiCreateLifecycleStateRequest {
    /**
     * Identity profile ID.
     * @type {string}
     * @memberof LifecycleStatesApiCreateLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle state to be created.
     * @type {LifecycleState}
     * @memberof LifecycleStatesApiCreateLifecycleState
     */
    readonly lifecycleState: LifecycleState
}

/**
 * Request parameters for deleteLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiDeleteLifecycleStateRequest
 */
export interface LifecycleStatesApiDeleteLifecycleStateRequest {
    /**
     * Identity profile ID.
     * @type {string}
     * @memberof LifecycleStatesApiDeleteLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle state ID.
     * @type {string}
     * @memberof LifecycleStatesApiDeleteLifecycleState
     */
    readonly lifecycleStateId: string
}

/**
 * Request parameters for getLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiGetLifecycleStateRequest
 */
export interface LifecycleStatesApiGetLifecycleStateRequest {
    /**
     * Identity profile ID.
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle state ID.
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleState
     */
    readonly lifecycleStateId: string
}

/**
 * Request parameters for getLifecycleStates operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiGetLifecycleStatesRequest
 */
export interface LifecycleStatesApiGetLifecycleStatesRequest {
    /**
     * Identity profile ID.
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleStates
     */
    readonly identityProfileId: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof LifecycleStatesApiGetLifecycleStates
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof LifecycleStatesApiGetLifecycleStates
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof LifecycleStatesApiGetLifecycleStates
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleStates
     */
    readonly sorters?: string
}

/**
 * Request parameters for setLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiSetLifecycleStateRequest
 */
export interface LifecycleStatesApiSetLifecycleStateRequest {
    /**
     * ID of the identity to update.
     * @type {string}
     * @memberof LifecycleStatesApiSetLifecycleState
     */
    readonly identityId: string

    /**
     * 
     * @type {SetLifecycleStateRequest}
     * @memberof LifecycleStatesApiSetLifecycleState
     */
    readonly setLifecycleStateRequest: SetLifecycleStateRequest
}

/**
 * Request parameters for updateLifecycleStates operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiUpdateLifecycleStatesRequest
 */
export interface LifecycleStatesApiUpdateLifecycleStatesRequest {
    /**
     * Identity profile ID.
     * @type {string}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly identityProfileId: string

    /**
     * Lifecycle state ID.
     * @type {string}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly lifecycleStateId: string

    /**
     * A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
     * @type {Array<JsonPatchOperation>}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * LifecycleStatesApi - object-oriented interface
 * @export
 * @class LifecycleStatesApi
 * @extends {BaseAPI}
 */
export class LifecycleStatesApi extends BaseAPI {
    /**
     * Use this endpoint to create a lifecycle state.
     * @summary Create Lifecycle State
     * @param {LifecycleStatesApiCreateLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public createLifecycleState(requestParameters: LifecycleStatesApiCreateLifecycleStateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).createLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleState, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete the lifecycle state by its ID. 
     * @summary Delete Lifecycle State
     * @param {LifecycleStatesApiDeleteLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public deleteLifecycleState(requestParameters: LifecycleStatesApiDeleteLifecycleStateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).deleteLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to get a lifecycle state by its ID and its associated identity profile ID. 
     * @summary Get Lifecycle State
     * @param {LifecycleStatesApiGetLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public getLifecycleState(requestParameters: LifecycleStatesApiGetLifecycleStateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).getLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all lifecycle states by their associated identity profiles. 
     * @summary Lists LifecycleStates
     * @param {LifecycleStatesApiGetLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public getLifecycleStates(requestParameters: LifecycleStatesApiGetLifecycleStatesRequest, axiosOptions?: RawAxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).getLifecycleStates(requestParameters.identityProfileId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to set/update an identity\'s lifecycle state to the one provided and update the corresponding identity profile.
     * @summary Set Lifecycle State
     * @param {LifecycleStatesApiSetLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public setLifecycleState(requestParameters: LifecycleStatesApiSetLifecycleStateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).setLifecycleState(requestParameters.identityId, requestParameters.setLifecycleStateRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update individual lifecycle state fields, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @summary Update Lifecycle State
     * @param {LifecycleStatesApiUpdateLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public updateLifecycleStates(requestParameters: LifecycleStatesApiUpdateLifecycleStatesRequest, axiosOptions?: RawAxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).updateLifecycleStates(requestParameters.identityProfileId, requestParameters.lifecycleStateId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MFAConfigurationApi - axios parameter creator
 * @export
 */
export const MFAConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API removes the configuration for the specified MFA method.
         * @summary Delete MFA method configuration
         * @param {DeleteMFAConfigMethodV3} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteMFAConfig: async (method: DeleteMFAConfigMethodV3, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'method' is not null or undefined
            assertParamExists('deleteMFAConfig', 'method', method)
            const localVarPath = `/mfa/{method}/delete`
                .replace(`{${"method"}}`, encodeURIComponent(String(method)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the configuration of an Duo MFA method.
         * @summary Configuration of Duo MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFADuoConfig: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mfa/duo-web/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the KBA configuration for MFA.
         * @summary Configuration of KBA MFA method
         * @param {boolean} [allLanguages] Indicator whether the question text should be returned in all configured languages    * If true, the question text is returned in all languages that it is configured in.    * If false, the question text is returned in the user locale if available, else for the default locale.     * If not passed, it behaves the same way as passing this parameter as false
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAKbaConfig: async (allLanguages?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mfa/kba/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (allLanguages !== undefined) {
                localVarQueryParameter['allLanguages'] = allLanguages;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the configuration of an Okta MFA method.
         * @summary Configuration of Okta MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAOktaConfig: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mfa/okta-verify/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API sets the configuration of an Duo MFA method.
         * @summary Set Duo MFA configuration
         * @param {MfaDuoConfig} mfaDuoConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFADuoConfig: async (mfaDuoConfig: MfaDuoConfig, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mfaDuoConfig' is not null or undefined
            assertParamExists('setMFADuoConfig', 'mfaDuoConfig', mfaDuoConfig)
            const localVarPath = `/mfa/duo-web/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaDuoConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API sets answers to challenge questions.  Any configured questions omitted from the request are removed from user KBA configuration.    
         * @summary Set MFA KBA configuration
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAKBAConfig: async (kbaAnswerRequestItem: Array<KbaAnswerRequestItem>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'kbaAnswerRequestItem' is not null or undefined
            assertParamExists('setMFAKBAConfig', 'kbaAnswerRequestItem', kbaAnswerRequestItem)
            const localVarPath = `/mfa/kba/config/answers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kbaAnswerRequestItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API sets the configuration of an Okta MFA method.
         * @summary Set Okta MFA configuration
         * @param {MfaOktaConfig} mfaOktaConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAOktaConfig: async (mfaOktaConfig: MfaOktaConfig, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mfaOktaConfig' is not null or undefined
            assertParamExists('setMFAOktaConfig', 'mfaOktaConfig', mfaOktaConfig)
            const localVarPath = `/mfa/okta-verify/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaOktaConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter.
         * @summary MFA method\'s test configuration
         * @param {TestMFAConfigMethodV3} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testMFAConfig: async (method: TestMFAConfigMethodV3, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'method' is not null or undefined
            assertParamExists('testMFAConfig', 'method', method)
            const localVarPath = `/mfa/{method}/test`
                .replace(`{${"method"}}`, encodeURIComponent(String(method)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * MFAConfigurationApi - functional programming interface
 * @export
 */
export const MFAConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MFAConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * This API removes the configuration for the specified MFA method.
         * @summary Delete MFA method configuration
         * @param {DeleteMFAConfigMethodV3} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMFAConfig(method: DeleteMFAConfigMethodV3, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaOktaConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMFAConfig(method, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAConfigurationApi.deleteMFAConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the configuration of an Duo MFA method.
         * @summary Configuration of Duo MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getMFADuoConfig(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaDuoConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMFADuoConfig(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAConfigurationApi.getMFADuoConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the KBA configuration for MFA.
         * @summary Configuration of KBA MFA method
         * @param {boolean} [allLanguages] Indicator whether the question text should be returned in all configured languages    * If true, the question text is returned in all languages that it is configured in.    * If false, the question text is returned in the user locale if available, else for the default locale.     * If not passed, it behaves the same way as passing this parameter as false
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getMFAKbaConfig(allLanguages?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KbaQuestion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMFAKbaConfig(allLanguages, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAConfigurationApi.getMFAKbaConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the configuration of an Okta MFA method.
         * @summary Configuration of Okta MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getMFAOktaConfig(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaOktaConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMFAOktaConfig(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAConfigurationApi.getMFAOktaConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API sets the configuration of an Duo MFA method.
         * @summary Set Duo MFA configuration
         * @param {MfaDuoConfig} mfaDuoConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setMFADuoConfig(mfaDuoConfig: MfaDuoConfig, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaDuoConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMFADuoConfig(mfaDuoConfig, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAConfigurationApi.setMFADuoConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API sets answers to challenge questions.  Any configured questions omitted from the request are removed from user KBA configuration.    
         * @summary Set MFA KBA configuration
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setMFAKBAConfig(kbaAnswerRequestItem: Array<KbaAnswerRequestItem>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KbaAnswerResponseItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMFAKBAConfig(kbaAnswerRequestItem, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAConfigurationApi.setMFAKBAConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API sets the configuration of an Okta MFA method.
         * @summary Set Okta MFA configuration
         * @param {MfaOktaConfig} mfaOktaConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setMFAOktaConfig(mfaOktaConfig: MfaOktaConfig, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaOktaConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMFAOktaConfig(mfaOktaConfig, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAConfigurationApi.setMFAOktaConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter.
         * @summary MFA method\'s test configuration
         * @param {TestMFAConfigMethodV3} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async testMFAConfig(method: TestMFAConfigMethodV3, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaConfigTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testMFAConfig(method, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAConfigurationApi.testMFAConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MFAConfigurationApi - factory interface
 * @export
 */
export const MFAConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MFAConfigurationApiFp(configuration)
    return {
        /**
         * This API removes the configuration for the specified MFA method.
         * @summary Delete MFA method configuration
         * @param {MFAConfigurationApiDeleteMFAConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteMFAConfig(requestParameters: MFAConfigurationApiDeleteMFAConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<MfaOktaConfig> {
            return localVarFp.deleteMFAConfig(requestParameters.method, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the configuration of an Duo MFA method.
         * @summary Configuration of Duo MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFADuoConfig(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<MfaDuoConfig> {
            return localVarFp.getMFADuoConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the KBA configuration for MFA.
         * @summary Configuration of KBA MFA method
         * @param {MFAConfigurationApiGetMFAKbaConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAKbaConfig(requestParameters: MFAConfigurationApiGetMFAKbaConfigRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<KbaQuestion>> {
            return localVarFp.getMFAKbaConfig(requestParameters.allLanguages, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the configuration of an Okta MFA method.
         * @summary Configuration of Okta MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAOktaConfig(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<MfaOktaConfig> {
            return localVarFp.getMFAOktaConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API sets the configuration of an Duo MFA method.
         * @summary Set Duo MFA configuration
         * @param {MFAConfigurationApiSetMFADuoConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFADuoConfig(requestParameters: MFAConfigurationApiSetMFADuoConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<MfaDuoConfig> {
            return localVarFp.setMFADuoConfig(requestParameters.mfaDuoConfig, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API sets answers to challenge questions.  Any configured questions omitted from the request are removed from user KBA configuration.    
         * @summary Set MFA KBA configuration
         * @param {MFAConfigurationApiSetMFAKBAConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAKBAConfig(requestParameters: MFAConfigurationApiSetMFAKBAConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<KbaAnswerResponseItem>> {
            return localVarFp.setMFAKBAConfig(requestParameters.kbaAnswerRequestItem, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API sets the configuration of an Okta MFA method.
         * @summary Set Okta MFA configuration
         * @param {MFAConfigurationApiSetMFAOktaConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAOktaConfig(requestParameters: MFAConfigurationApiSetMFAOktaConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<MfaOktaConfig> {
            return localVarFp.setMFAOktaConfig(requestParameters.mfaOktaConfig, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter.
         * @summary MFA method\'s test configuration
         * @param {MFAConfigurationApiTestMFAConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testMFAConfig(requestParameters: MFAConfigurationApiTestMFAConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<MfaConfigTestResponse> {
            return localVarFp.testMFAConfig(requestParameters.method, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteMFAConfig operation in MFAConfigurationApi.
 * @export
 * @interface MFAConfigurationApiDeleteMFAConfigRequest
 */
export interface MFAConfigurationApiDeleteMFAConfigRequest {
    /**
     * The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
     * @type {'okta-verify' | 'duo-web'}
     * @memberof MFAConfigurationApiDeleteMFAConfig
     */
    readonly method: DeleteMFAConfigMethodV3
}

/**
 * Request parameters for getMFAKbaConfig operation in MFAConfigurationApi.
 * @export
 * @interface MFAConfigurationApiGetMFAKbaConfigRequest
 */
export interface MFAConfigurationApiGetMFAKbaConfigRequest {
    /**
     * Indicator whether the question text should be returned in all configured languages    * If true, the question text is returned in all languages that it is configured in.    * If false, the question text is returned in the user locale if available, else for the default locale.     * If not passed, it behaves the same way as passing this parameter as false
     * @type {boolean}
     * @memberof MFAConfigurationApiGetMFAKbaConfig
     */
    readonly allLanguages?: boolean
}

/**
 * Request parameters for setMFADuoConfig operation in MFAConfigurationApi.
 * @export
 * @interface MFAConfigurationApiSetMFADuoConfigRequest
 */
export interface MFAConfigurationApiSetMFADuoConfigRequest {
    /**
     * 
     * @type {MfaDuoConfig}
     * @memberof MFAConfigurationApiSetMFADuoConfig
     */
    readonly mfaDuoConfig: MfaDuoConfig
}

/**
 * Request parameters for setMFAKBAConfig operation in MFAConfigurationApi.
 * @export
 * @interface MFAConfigurationApiSetMFAKBAConfigRequest
 */
export interface MFAConfigurationApiSetMFAKBAConfigRequest {
    /**
     * 
     * @type {Array<KbaAnswerRequestItem>}
     * @memberof MFAConfigurationApiSetMFAKBAConfig
     */
    readonly kbaAnswerRequestItem: Array<KbaAnswerRequestItem>
}

/**
 * Request parameters for setMFAOktaConfig operation in MFAConfigurationApi.
 * @export
 * @interface MFAConfigurationApiSetMFAOktaConfigRequest
 */
export interface MFAConfigurationApiSetMFAOktaConfigRequest {
    /**
     * 
     * @type {MfaOktaConfig}
     * @memberof MFAConfigurationApiSetMFAOktaConfig
     */
    readonly mfaOktaConfig: MfaOktaConfig
}

/**
 * Request parameters for testMFAConfig operation in MFAConfigurationApi.
 * @export
 * @interface MFAConfigurationApiTestMFAConfigRequest
 */
export interface MFAConfigurationApiTestMFAConfigRequest {
    /**
     * The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
     * @type {'okta-verify' | 'duo-web'}
     * @memberof MFAConfigurationApiTestMFAConfig
     */
    readonly method: TestMFAConfigMethodV3
}

/**
 * MFAConfigurationApi - object-oriented interface
 * @export
 * @class MFAConfigurationApi
 * @extends {BaseAPI}
 */
export class MFAConfigurationApi extends BaseAPI {
    /**
     * This API removes the configuration for the specified MFA method.
     * @summary Delete MFA method configuration
     * @param {MFAConfigurationApiDeleteMFAConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public deleteMFAConfig(requestParameters: MFAConfigurationApiDeleteMFAConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).deleteMFAConfig(requestParameters.method, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the configuration of an Duo MFA method.
     * @summary Configuration of Duo MFA method
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public getMFADuoConfig(axiosOptions?: RawAxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).getMFADuoConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the KBA configuration for MFA.
     * @summary Configuration of KBA MFA method
     * @param {MFAConfigurationApiGetMFAKbaConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public getMFAKbaConfig(requestParameters: MFAConfigurationApiGetMFAKbaConfigRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).getMFAKbaConfig(requestParameters.allLanguages, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the configuration of an Okta MFA method.
     * @summary Configuration of Okta MFA method
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public getMFAOktaConfig(axiosOptions?: RawAxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).getMFAOktaConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API sets the configuration of an Duo MFA method.
     * @summary Set Duo MFA configuration
     * @param {MFAConfigurationApiSetMFADuoConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public setMFADuoConfig(requestParameters: MFAConfigurationApiSetMFADuoConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).setMFADuoConfig(requestParameters.mfaDuoConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API sets answers to challenge questions.  Any configured questions omitted from the request are removed from user KBA configuration.    
     * @summary Set MFA KBA configuration
     * @param {MFAConfigurationApiSetMFAKBAConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public setMFAKBAConfig(requestParameters: MFAConfigurationApiSetMFAKBAConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).setMFAKBAConfig(requestParameters.kbaAnswerRequestItem, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API sets the configuration of an Okta MFA method.
     * @summary Set Okta MFA configuration
     * @param {MFAConfigurationApiSetMFAOktaConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public setMFAOktaConfig(requestParameters: MFAConfigurationApiSetMFAOktaConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).setMFAOktaConfig(requestParameters.mfaOktaConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter.
     * @summary MFA method\'s test configuration
     * @param {MFAConfigurationApiTestMFAConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public testMFAConfig(requestParameters: MFAConfigurationApiTestMFAConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).testMFAConfig(requestParameters.method, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteMFAConfigMethodV3 = {
    OktaVerify: 'okta-verify',
    DuoWeb: 'duo-web'
} as const;
export type DeleteMFAConfigMethodV3 = typeof DeleteMFAConfigMethodV3[keyof typeof DeleteMFAConfigMethodV3];
/**
 * @export
 */
export const TestMFAConfigMethodV3 = {
    OktaVerify: 'okta-verify',
    DuoWeb: 'duo-web'
} as const;
export type TestMFAConfigMethodV3 = typeof TestMFAConfigMethodV3[keyof typeof TestMFAConfigMethodV3];


/**
 * MFAControllerApi - axios parameter creator
 * @export
 */
export const MFAControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API send token request.
         * @summary Create and send user token
         * @param {SendTokenRequest} sendTokenRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSendToken: async (sendTokenRequest: SendTokenRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendTokenRequest' is not null or undefined
            assertParamExists('createSendToken', 'sendTokenRequest', sendTokenRequest)
            const localVarPath = `/mfa/token/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API poll the VerificationPollRequest for the specified MFA method.
         * @summary Polling MFA method by VerificationPollRequest
         * @param {PingVerificationStatusMethodV3} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39;, \&#39;duo-web\&#39;, \&#39;kba\&#39;,\&#39;token\&#39;, \&#39;rsa\&#39;
         * @param {VerificationPollRequest} verificationPollRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        pingVerificationStatus: async (method: PingVerificationStatusMethodV3, verificationPollRequest: VerificationPollRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'method' is not null or undefined
            assertParamExists('pingVerificationStatus', 'method', method)
            // verify required parameter 'verificationPollRequest' is not null or undefined
            assertParamExists('pingVerificationStatus', 'verificationPollRequest', verificationPollRequest)
            const localVarPath = `/mfa/{method}/poll`
                .replace(`{${"method"}}`, encodeURIComponent(String(method)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verificationPollRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API Authenticates the user via Duo-Web MFA method.
         * @summary Verifying authentication via Duo method
         * @param {DuoVerificationRequest} duoVerificationRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendDuoVerifyRequest: async (duoVerificationRequest: DuoVerificationRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'duoVerificationRequest' is not null or undefined
            assertParamExists('sendDuoVerifyRequest', 'duoVerificationRequest', duoVerificationRequest)
            const localVarPath = `/mfa/duo-web/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(duoVerificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API Authenticate user in KBA MFA method.
         * @summary Authenticate KBA provided MFA method
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendKbaAnswers: async (kbaAnswerRequestItem: Array<KbaAnswerRequestItem>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'kbaAnswerRequestItem' is not null or undefined
            assertParamExists('sendKbaAnswers', 'kbaAnswerRequestItem', kbaAnswerRequestItem)
            const localVarPath = `/mfa/kba/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kbaAnswerRequestItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API Authenticates the user via Okta-Verify MFA method. Request requires a header called \'slpt-forwarding\', and it must contain a remote IP Address of caller.
         * @summary Verifying authentication via Okta method
         * @param {OktaVerificationRequest} oktaVerificationRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendOktaVerifyRequest: async (oktaVerificationRequest: OktaVerificationRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oktaVerificationRequest' is not null or undefined
            assertParamExists('sendOktaVerifyRequest', 'oktaVerificationRequest', oktaVerificationRequest)
            const localVarPath = `/mfa/okta-verify/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oktaVerificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API Authenticate user in Token MFA method.
         * @summary Authenticate Token provided MFA method
         * @param {TokenAuthRequest} tokenAuthRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendTokenAuthRequest: async (tokenAuthRequest: TokenAuthRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenAuthRequest' is not null or undefined
            assertParamExists('sendTokenAuthRequest', 'tokenAuthRequest', tokenAuthRequest)
            const localVarPath = `/mfa/token/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * MFAControllerApi - functional programming interface
 * @export
 */
export const MFAControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MFAControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * This API send token request.
         * @summary Create and send user token
         * @param {SendTokenRequest} sendTokenRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSendToken(sendTokenRequest: SendTokenRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSendToken(sendTokenRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAControllerApi.createSendToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API poll the VerificationPollRequest for the specified MFA method.
         * @summary Polling MFA method by VerificationPollRequest
         * @param {PingVerificationStatusMethodV3} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39;, \&#39;duo-web\&#39;, \&#39;kba\&#39;,\&#39;token\&#39;, \&#39;rsa\&#39;
         * @param {VerificationPollRequest} verificationPollRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async pingVerificationStatus(method: PingVerificationStatusMethodV3, verificationPollRequest: VerificationPollRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingVerificationStatus(method, verificationPollRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAControllerApi.pingVerificationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API Authenticates the user via Duo-Web MFA method.
         * @summary Verifying authentication via Duo method
         * @param {DuoVerificationRequest} duoVerificationRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async sendDuoVerifyRequest(duoVerificationRequest: DuoVerificationRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendDuoVerifyRequest(duoVerificationRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAControllerApi.sendDuoVerifyRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API Authenticate user in KBA MFA method.
         * @summary Authenticate KBA provided MFA method
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async sendKbaAnswers(kbaAnswerRequestItem: Array<KbaAnswerRequestItem>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KbaAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendKbaAnswers(kbaAnswerRequestItem, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAControllerApi.sendKbaAnswers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API Authenticates the user via Okta-Verify MFA method. Request requires a header called \'slpt-forwarding\', and it must contain a remote IP Address of caller.
         * @summary Verifying authentication via Okta method
         * @param {OktaVerificationRequest} oktaVerificationRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async sendOktaVerifyRequest(oktaVerificationRequest: OktaVerificationRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendOktaVerifyRequest(oktaVerificationRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAControllerApi.sendOktaVerifyRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API Authenticate user in Token MFA method.
         * @summary Authenticate Token provided MFA method
         * @param {TokenAuthRequest} tokenAuthRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async sendTokenAuthRequest(tokenAuthRequest: TokenAuthRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTokenAuthRequest(tokenAuthRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MFAControllerApi.sendTokenAuthRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MFAControllerApi - factory interface
 * @export
 */
export const MFAControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MFAControllerApiFp(configuration)
    return {
        /**
         * This API send token request.
         * @summary Create and send user token
         * @param {MFAControllerApiCreateSendTokenRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSendToken(requestParameters: MFAControllerApiCreateSendTokenRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SendTokenResponse> {
            return localVarFp.createSendToken(requestParameters.sendTokenRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API poll the VerificationPollRequest for the specified MFA method.
         * @summary Polling MFA method by VerificationPollRequest
         * @param {MFAControllerApiPingVerificationStatusRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        pingVerificationStatus(requestParameters: MFAControllerApiPingVerificationStatusRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<VerificationResponse> {
            return localVarFp.pingVerificationStatus(requestParameters.method, requestParameters.verificationPollRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API Authenticates the user via Duo-Web MFA method.
         * @summary Verifying authentication via Duo method
         * @param {MFAControllerApiSendDuoVerifyRequestRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendDuoVerifyRequest(requestParameters: MFAControllerApiSendDuoVerifyRequestRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<VerificationResponse> {
            return localVarFp.sendDuoVerifyRequest(requestParameters.duoVerificationRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API Authenticate user in KBA MFA method.
         * @summary Authenticate KBA provided MFA method
         * @param {MFAControllerApiSendKbaAnswersRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendKbaAnswers(requestParameters: MFAControllerApiSendKbaAnswersRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<KbaAuthResponse> {
            return localVarFp.sendKbaAnswers(requestParameters.kbaAnswerRequestItem, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API Authenticates the user via Okta-Verify MFA method. Request requires a header called \'slpt-forwarding\', and it must contain a remote IP Address of caller.
         * @summary Verifying authentication via Okta method
         * @param {MFAControllerApiSendOktaVerifyRequestRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendOktaVerifyRequest(requestParameters: MFAControllerApiSendOktaVerifyRequestRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<VerificationResponse> {
            return localVarFp.sendOktaVerifyRequest(requestParameters.oktaVerificationRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API Authenticate user in Token MFA method.
         * @summary Authenticate Token provided MFA method
         * @param {MFAControllerApiSendTokenAuthRequestRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendTokenAuthRequest(requestParameters: MFAControllerApiSendTokenAuthRequestRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<TokenAuthResponse> {
            return localVarFp.sendTokenAuthRequest(requestParameters.tokenAuthRequest, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSendToken operation in MFAControllerApi.
 * @export
 * @interface MFAControllerApiCreateSendTokenRequest
 */
export interface MFAControllerApiCreateSendTokenRequest {
    /**
     * 
     * @type {SendTokenRequest}
     * @memberof MFAControllerApiCreateSendToken
     */
    readonly sendTokenRequest: SendTokenRequest
}

/**
 * Request parameters for pingVerificationStatus operation in MFAControllerApi.
 * @export
 * @interface MFAControllerApiPingVerificationStatusRequest
 */
export interface MFAControllerApiPingVerificationStatusRequest {
    /**
     * The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39;, \&#39;duo-web\&#39;, \&#39;kba\&#39;,\&#39;token\&#39;, \&#39;rsa\&#39;
     * @type {'okta-verify' | 'duo-web' | 'kba' | 'token' | 'rsa'}
     * @memberof MFAControllerApiPingVerificationStatus
     */
    readonly method: PingVerificationStatusMethodV3

    /**
     * 
     * @type {VerificationPollRequest}
     * @memberof MFAControllerApiPingVerificationStatus
     */
    readonly verificationPollRequest: VerificationPollRequest
}

/**
 * Request parameters for sendDuoVerifyRequest operation in MFAControllerApi.
 * @export
 * @interface MFAControllerApiSendDuoVerifyRequestRequest
 */
export interface MFAControllerApiSendDuoVerifyRequestRequest {
    /**
     * 
     * @type {DuoVerificationRequest}
     * @memberof MFAControllerApiSendDuoVerifyRequest
     */
    readonly duoVerificationRequest: DuoVerificationRequest
}

/**
 * Request parameters for sendKbaAnswers operation in MFAControllerApi.
 * @export
 * @interface MFAControllerApiSendKbaAnswersRequest
 */
export interface MFAControllerApiSendKbaAnswersRequest {
    /**
     * 
     * @type {Array<KbaAnswerRequestItem>}
     * @memberof MFAControllerApiSendKbaAnswers
     */
    readonly kbaAnswerRequestItem: Array<KbaAnswerRequestItem>
}

/**
 * Request parameters for sendOktaVerifyRequest operation in MFAControllerApi.
 * @export
 * @interface MFAControllerApiSendOktaVerifyRequestRequest
 */
export interface MFAControllerApiSendOktaVerifyRequestRequest {
    /**
     * 
     * @type {OktaVerificationRequest}
     * @memberof MFAControllerApiSendOktaVerifyRequest
     */
    readonly oktaVerificationRequest: OktaVerificationRequest
}

/**
 * Request parameters for sendTokenAuthRequest operation in MFAControllerApi.
 * @export
 * @interface MFAControllerApiSendTokenAuthRequestRequest
 */
export interface MFAControllerApiSendTokenAuthRequestRequest {
    /**
     * 
     * @type {TokenAuthRequest}
     * @memberof MFAControllerApiSendTokenAuthRequest
     */
    readonly tokenAuthRequest: TokenAuthRequest
}

/**
 * MFAControllerApi - object-oriented interface
 * @export
 * @class MFAControllerApi
 * @extends {BaseAPI}
 */
export class MFAControllerApi extends BaseAPI {
    /**
     * This API send token request.
     * @summary Create and send user token
     * @param {MFAControllerApiCreateSendTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    public createSendToken(requestParameters: MFAControllerApiCreateSendTokenRequest, axiosOptions?: RawAxiosRequestConfig) {
        return MFAControllerApiFp(this.configuration).createSendToken(requestParameters.sendTokenRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API poll the VerificationPollRequest for the specified MFA method.
     * @summary Polling MFA method by VerificationPollRequest
     * @param {MFAControllerApiPingVerificationStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    public pingVerificationStatus(requestParameters: MFAControllerApiPingVerificationStatusRequest, axiosOptions?: RawAxiosRequestConfig) {
        return MFAControllerApiFp(this.configuration).pingVerificationStatus(requestParameters.method, requestParameters.verificationPollRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API Authenticates the user via Duo-Web MFA method.
     * @summary Verifying authentication via Duo method
     * @param {MFAControllerApiSendDuoVerifyRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    public sendDuoVerifyRequest(requestParameters: MFAControllerApiSendDuoVerifyRequestRequest, axiosOptions?: RawAxiosRequestConfig) {
        return MFAControllerApiFp(this.configuration).sendDuoVerifyRequest(requestParameters.duoVerificationRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API Authenticate user in KBA MFA method.
     * @summary Authenticate KBA provided MFA method
     * @param {MFAControllerApiSendKbaAnswersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    public sendKbaAnswers(requestParameters: MFAControllerApiSendKbaAnswersRequest, axiosOptions?: RawAxiosRequestConfig) {
        return MFAControllerApiFp(this.configuration).sendKbaAnswers(requestParameters.kbaAnswerRequestItem, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API Authenticates the user via Okta-Verify MFA method. Request requires a header called \'slpt-forwarding\', and it must contain a remote IP Address of caller.
     * @summary Verifying authentication via Okta method
     * @param {MFAControllerApiSendOktaVerifyRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    public sendOktaVerifyRequest(requestParameters: MFAControllerApiSendOktaVerifyRequestRequest, axiosOptions?: RawAxiosRequestConfig) {
        return MFAControllerApiFp(this.configuration).sendOktaVerifyRequest(requestParameters.oktaVerificationRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API Authenticate user in Token MFA method.
     * @summary Authenticate Token provided MFA method
     * @param {MFAControllerApiSendTokenAuthRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    public sendTokenAuthRequest(requestParameters: MFAControllerApiSendTokenAuthRequestRequest, axiosOptions?: RawAxiosRequestConfig) {
        return MFAControllerApiFp(this.configuration).sendTokenAuthRequest(requestParameters.tokenAuthRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PingVerificationStatusMethodV3 = {
    OktaVerify: 'okta-verify',
    DuoWeb: 'duo-web',
    Kba: 'kba',
    Token: 'token',
    Rsa: 'rsa'
} as const;
export type PingVerificationStatusMethodV3 = typeof PingVerificationStatusMethodV3[keyof typeof PingVerificationStatusMethodV3];


/**
 * ManagedClientsApi - axios parameter creator
 * @export
 */
export const ManagedClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new managed client. The API returns a result that includes the managed client ID.
         * @summary Create Managed Client
         * @param {ManagedClientRequest} managedClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedClient: async (managedClientRequest: ManagedClientRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'managedClientRequest' is not null or undefined
            assertParamExists('createManagedClient', 'managedClientRequest', managedClientRequest)
            const localVarPath = `/managed-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(managedClientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing managed client.
         * @summary Delete Managed Client
         * @param {string} id Managed client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedClient: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteManagedClient', 'id', id)
            const localVarPath = `/managed-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get managed client by ID. 
         * @summary Get Managed Client
         * @param {string} id Managed client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClient: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getManagedClient', 'id', id)
            const localVarPath = `/managed-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a managed client\'s status, using its ID.
         * @summary Get Managed Client Status
         * @param {string} id Managed client ID to get status for.
         * @param {ManagedClientType} type Managed client type to get status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClientStatus: async (id: string, type: ManagedClientType, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getManagedClientStatus', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getManagedClientStatus', 'type', type)
            const localVarPath = `/managed-clients/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * List managed clients.
         * @summary Get Managed Clients
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **clientId**: *eq*  **clusterId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClients: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/managed-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing managed client.
         * @summary Update Managed Client
         * @param {string} id Managed client ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedClient: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateManagedClient', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateManagedClient', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/managed-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagedClientsApi - functional programming interface
 * @export
 */
export const ManagedClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagedClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new managed client. The API returns a result that includes the managed client ID.
         * @summary Create Managed Client
         * @param {ManagedClientRequest} managedClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createManagedClient(managedClientRequest: ManagedClientRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManagedClient(managedClientRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagedClientsApi.createManagedClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing managed client.
         * @summary Delete Managed Client
         * @param {string} id Managed client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteManagedClient(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManagedClient(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagedClientsApi.deleteManagedClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get managed client by ID. 
         * @summary Get Managed Client
         * @param {string} id Managed client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManagedClient(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagedClient(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagedClientsApi.getManagedClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a managed client\'s status, using its ID.
         * @summary Get Managed Client Status
         * @param {string} id Managed client ID to get status for.
         * @param {ManagedClientType} type Managed client type to get status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManagedClientStatus(id: string, type: ManagedClientType, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedClientStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagedClientStatus(id, type, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagedClientsApi.getManagedClientStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List managed clients.
         * @summary Get Managed Clients
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **clientId**: *eq*  **clusterId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManagedClients(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ManagedClient>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagedClients(offset, limit, count, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagedClientsApi.getManagedClients']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing managed client.
         * @summary Update Managed Client
         * @param {string} id Managed client ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateManagedClient(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateManagedClient(id, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagedClientsApi.updateManagedClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManagedClientsApi - factory interface
 * @export
 */
export const ManagedClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManagedClientsApiFp(configuration)
    return {
        /**
         * Create a new managed client. The API returns a result that includes the managed client ID.
         * @summary Create Managed Client
         * @param {ManagedClientsApiCreateManagedClientRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedClient(requestParameters: ManagedClientsApiCreateManagedClientRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ManagedClient> {
            return localVarFp.createManagedClient(requestParameters.managedClientRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing managed client.
         * @summary Delete Managed Client
         * @param {ManagedClientsApiDeleteManagedClientRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedClient(requestParameters: ManagedClientsApiDeleteManagedClientRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteManagedClient(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get managed client by ID. 
         * @summary Get Managed Client
         * @param {ManagedClientsApiGetManagedClientRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClient(requestParameters: ManagedClientsApiGetManagedClientRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ManagedClient> {
            return localVarFp.getManagedClient(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a managed client\'s status, using its ID.
         * @summary Get Managed Client Status
         * @param {ManagedClientsApiGetManagedClientStatusRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClientStatus(requestParameters: ManagedClientsApiGetManagedClientStatusRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ManagedClientStatus> {
            return localVarFp.getManagedClientStatus(requestParameters.id, requestParameters.type, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * List managed clients.
         * @summary Get Managed Clients
         * @param {ManagedClientsApiGetManagedClientsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClients(requestParameters: ManagedClientsApiGetManagedClientsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<ManagedClient>> {
            return localVarFp.getManagedClients(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing managed client.
         * @summary Update Managed Client
         * @param {ManagedClientsApiUpdateManagedClientRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedClient(requestParameters: ManagedClientsApiUpdateManagedClientRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ManagedClient> {
            return localVarFp.updateManagedClient(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createManagedClient operation in ManagedClientsApi.
 * @export
 * @interface ManagedClientsApiCreateManagedClientRequest
 */
export interface ManagedClientsApiCreateManagedClientRequest {
    /**
     * 
     * @type {ManagedClientRequest}
     * @memberof ManagedClientsApiCreateManagedClient
     */
    readonly managedClientRequest: ManagedClientRequest
}

/**
 * Request parameters for deleteManagedClient operation in ManagedClientsApi.
 * @export
 * @interface ManagedClientsApiDeleteManagedClientRequest
 */
export interface ManagedClientsApiDeleteManagedClientRequest {
    /**
     * Managed client ID.
     * @type {string}
     * @memberof ManagedClientsApiDeleteManagedClient
     */
    readonly id: string
}

/**
 * Request parameters for getManagedClient operation in ManagedClientsApi.
 * @export
 * @interface ManagedClientsApiGetManagedClientRequest
 */
export interface ManagedClientsApiGetManagedClientRequest {
    /**
     * Managed client ID.
     * @type {string}
     * @memberof ManagedClientsApiGetManagedClient
     */
    readonly id: string
}

/**
 * Request parameters for getManagedClientStatus operation in ManagedClientsApi.
 * @export
 * @interface ManagedClientsApiGetManagedClientStatusRequest
 */
export interface ManagedClientsApiGetManagedClientStatusRequest {
    /**
     * Managed client ID to get status for.
     * @type {string}
     * @memberof ManagedClientsApiGetManagedClientStatus
     */
    readonly id: string

    /**
     * Managed client type to get status for.
     * @type {ManagedClientType}
     * @memberof ManagedClientsApiGetManagedClientStatus
     */
    readonly type: ManagedClientType
}

/**
 * Request parameters for getManagedClients operation in ManagedClientsApi.
 * @export
 * @interface ManagedClientsApiGetManagedClientsRequest
 */
export interface ManagedClientsApiGetManagedClientsRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ManagedClientsApiGetManagedClients
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ManagedClientsApiGetManagedClients
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ManagedClientsApiGetManagedClients
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **clientId**: *eq*  **clusterId**: *eq*
     * @type {string}
     * @memberof ManagedClientsApiGetManagedClients
     */
    readonly filters?: string
}

/**
 * Request parameters for updateManagedClient operation in ManagedClientsApi.
 * @export
 * @interface ManagedClientsApiUpdateManagedClientRequest
 */
export interface ManagedClientsApiUpdateManagedClientRequest {
    /**
     * Managed client ID.
     * @type {string}
     * @memberof ManagedClientsApiUpdateManagedClient
     */
    readonly id: string

    /**
     * JSONPatch payload used to update the object.
     * @type {Array<JsonPatchOperation>}
     * @memberof ManagedClientsApiUpdateManagedClient
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * ManagedClientsApi - object-oriented interface
 * @export
 * @class ManagedClientsApi
 * @extends {BaseAPI}
 */
export class ManagedClientsApi extends BaseAPI {
    /**
     * Create a new managed client. The API returns a result that includes the managed client ID.
     * @summary Create Managed Client
     * @param {ManagedClientsApiCreateManagedClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    public createManagedClient(requestParameters: ManagedClientsApiCreateManagedClientRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ManagedClientsApiFp(this.configuration).createManagedClient(requestParameters.managedClientRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing managed client.
     * @summary Delete Managed Client
     * @param {ManagedClientsApiDeleteManagedClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    public deleteManagedClient(requestParameters: ManagedClientsApiDeleteManagedClientRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ManagedClientsApiFp(this.configuration).deleteManagedClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get managed client by ID. 
     * @summary Get Managed Client
     * @param {ManagedClientsApiGetManagedClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    public getManagedClient(requestParameters: ManagedClientsApiGetManagedClientRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ManagedClientsApiFp(this.configuration).getManagedClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a managed client\'s status, using its ID.
     * @summary Get Managed Client Status
     * @param {ManagedClientsApiGetManagedClientStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    public getManagedClientStatus(requestParameters: ManagedClientsApiGetManagedClientStatusRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ManagedClientsApiFp(this.configuration).getManagedClientStatus(requestParameters.id, requestParameters.type, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List managed clients.
     * @summary Get Managed Clients
     * @param {ManagedClientsApiGetManagedClientsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    public getManagedClients(requestParameters: ManagedClientsApiGetManagedClientsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return ManagedClientsApiFp(this.configuration).getManagedClients(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing managed client.
     * @summary Update Managed Client
     * @param {ManagedClientsApiUpdateManagedClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    public updateManagedClient(requestParameters: ManagedClientsApiUpdateManagedClientRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ManagedClientsApiFp(this.configuration).updateManagedClient(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManagedClustersApi - axios parameter creator
 * @export
 */
export const ManagedClustersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Managed Cluster. The API returns a result that includes the managed cluster ID.
         * @summary Create Create Managed Cluster
         * @param {ManagedClusterRequest} managedClusterRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedCluster: async (managedClusterRequest: ManagedClusterRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'managedClusterRequest' is not null or undefined
            assertParamExists('createManagedCluster', 'managedClusterRequest', managedClusterRequest)
            const localVarPath = `/managed-clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(managedClusterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing managed cluster.
         * @summary Delete Managed Cluster
         * @param {string} id Managed cluster ID.
         * @param {boolean} [removeClients] Flag to determine the need to delete a cluster with clients.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedCluster: async (id: string, removeClients?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteManagedCluster', 'id', id)
            const localVarPath = `/managed-clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (removeClients !== undefined) {
                localVarQueryParameter['removeClients'] = removeClients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a managed cluster\'s log configuration.
         * @summary Get Managed Cluster Log Configuration
         * @param {string} id ID of managed cluster to get log configuration for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getClientLogConfiguration: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getClientLogConfiguration', 'id', id)
            const localVarPath = `/managed-clusters/{id}/log-config`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a managed cluster by ID.
         * @summary Get Managed Cluster
         * @param {string} id Managed cluster ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedCluster: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getManagedCluster', 'id', id)
            const localVarPath = `/managed-clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * List current organization\'s managed clusters, based on request context.
         * @summary Get Managed Clusters
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **operational**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClusters: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/managed-clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update a managed cluster\'s log configuration. You may only specify one of `durationMinutes` or `expiration`, up to 1440 minutes (24 hours) in the future. If neither is specified, the default value for `durationMinutes` is 240.
         * @summary Update Managed Cluster Log Configuration
         * @param {string} id ID of the managed cluster to update the log configuration for.
         * @param {PutClientLogConfigurationRequest} putClientLogConfigurationRequest Client log configuration for the given managed cluster.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putClientLogConfiguration: async (id: string, putClientLogConfigurationRequest: PutClientLogConfigurationRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putClientLogConfiguration', 'id', id)
            // verify required parameter 'putClientLogConfigurationRequest' is not null or undefined
            assertParamExists('putClientLogConfiguration', 'putClientLogConfigurationRequest', putClientLogConfigurationRequest)
            const localVarPath = `/managed-clusters/{id}/log-config`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putClientLogConfigurationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing managed cluster.
         * @summary Update Managed Cluster
         * @param {string} id Managed cluster ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedCluster: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateManagedCluster', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateManagedCluster', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/managed-clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagedClustersApi - functional programming interface
 * @export
 */
export const ManagedClustersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagedClustersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Managed Cluster. The API returns a result that includes the managed cluster ID.
         * @summary Create Create Managed Cluster
         * @param {ManagedClusterRequest} managedClusterRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createManagedCluster(managedClusterRequest: ManagedClusterRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedCluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManagedCluster(managedClusterRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagedClustersApi.createManagedCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing managed cluster.
         * @summary Delete Managed Cluster
         * @param {string} id Managed cluster ID.
         * @param {boolean} [removeClients] Flag to determine the need to delete a cluster with clients.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteManagedCluster(id: string, removeClients?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManagedCluster(id, removeClients, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagedClustersApi.deleteManagedCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a managed cluster\'s log configuration.
         * @summary Get Managed Cluster Log Configuration
         * @param {string} id ID of managed cluster to get log configuration for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getClientLogConfiguration(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientLogConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientLogConfiguration(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagedClustersApi.getClientLogConfiguration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a managed cluster by ID.
         * @summary Get Managed Cluster
         * @param {string} id Managed cluster ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManagedCluster(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedCluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagedCluster(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagedClustersApi.getManagedCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List current organization\'s managed clusters, based on request context.
         * @summary Get Managed Clusters
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **operational**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManagedClusters(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ManagedCluster>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagedClusters(offset, limit, count, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagedClustersApi.getManagedClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a managed cluster\'s log configuration. You may only specify one of `durationMinutes` or `expiration`, up to 1440 minutes (24 hours) in the future. If neither is specified, the default value for `durationMinutes` is 240.
         * @summary Update Managed Cluster Log Configuration
         * @param {string} id ID of the managed cluster to update the log configuration for.
         * @param {PutClientLogConfigurationRequest} putClientLogConfigurationRequest Client log configuration for the given managed cluster.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putClientLogConfiguration(id: string, putClientLogConfigurationRequest: PutClientLogConfigurationRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientLogConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putClientLogConfiguration(id, putClientLogConfigurationRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagedClustersApi.putClientLogConfiguration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing managed cluster.
         * @summary Update Managed Cluster
         * @param {string} id Managed cluster ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateManagedCluster(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedCluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateManagedCluster(id, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagedClustersApi.updateManagedCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManagedClustersApi - factory interface
 * @export
 */
export const ManagedClustersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManagedClustersApiFp(configuration)
    return {
        /**
         * Create a new Managed Cluster. The API returns a result that includes the managed cluster ID.
         * @summary Create Create Managed Cluster
         * @param {ManagedClustersApiCreateManagedClusterRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedCluster(requestParameters: ManagedClustersApiCreateManagedClusterRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ManagedCluster> {
            return localVarFp.createManagedCluster(requestParameters.managedClusterRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing managed cluster.
         * @summary Delete Managed Cluster
         * @param {ManagedClustersApiDeleteManagedClusterRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedCluster(requestParameters: ManagedClustersApiDeleteManagedClusterRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteManagedCluster(requestParameters.id, requestParameters.removeClients, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a managed cluster\'s log configuration.
         * @summary Get Managed Cluster Log Configuration
         * @param {ManagedClustersApiGetClientLogConfigurationRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getClientLogConfiguration(requestParameters: ManagedClustersApiGetClientLogConfigurationRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ClientLogConfiguration> {
            return localVarFp.getClientLogConfiguration(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a managed cluster by ID.
         * @summary Get Managed Cluster
         * @param {ManagedClustersApiGetManagedClusterRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedCluster(requestParameters: ManagedClustersApiGetManagedClusterRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ManagedCluster> {
            return localVarFp.getManagedCluster(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * List current organization\'s managed clusters, based on request context.
         * @summary Get Managed Clusters
         * @param {ManagedClustersApiGetManagedClustersRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClusters(requestParameters: ManagedClustersApiGetManagedClustersRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<ManagedCluster>> {
            return localVarFp.getManagedClusters(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update a managed cluster\'s log configuration. You may only specify one of `durationMinutes` or `expiration`, up to 1440 minutes (24 hours) in the future. If neither is specified, the default value for `durationMinutes` is 240.
         * @summary Update Managed Cluster Log Configuration
         * @param {ManagedClustersApiPutClientLogConfigurationRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putClientLogConfiguration(requestParameters: ManagedClustersApiPutClientLogConfigurationRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ClientLogConfiguration> {
            return localVarFp.putClientLogConfiguration(requestParameters.id, requestParameters.putClientLogConfigurationRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing managed cluster.
         * @summary Update Managed Cluster
         * @param {ManagedClustersApiUpdateManagedClusterRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedCluster(requestParameters: ManagedClustersApiUpdateManagedClusterRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ManagedCluster> {
            return localVarFp.updateManagedCluster(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createManagedCluster operation in ManagedClustersApi.
 * @export
 * @interface ManagedClustersApiCreateManagedClusterRequest
 */
export interface ManagedClustersApiCreateManagedClusterRequest {
    /**
     * 
     * @type {ManagedClusterRequest}
     * @memberof ManagedClustersApiCreateManagedCluster
     */
    readonly managedClusterRequest: ManagedClusterRequest
}

/**
 * Request parameters for deleteManagedCluster operation in ManagedClustersApi.
 * @export
 * @interface ManagedClustersApiDeleteManagedClusterRequest
 */
export interface ManagedClustersApiDeleteManagedClusterRequest {
    /**
     * Managed cluster ID.
     * @type {string}
     * @memberof ManagedClustersApiDeleteManagedCluster
     */
    readonly id: string

    /**
     * Flag to determine the need to delete a cluster with clients.
     * @type {boolean}
     * @memberof ManagedClustersApiDeleteManagedCluster
     */
    readonly removeClients?: boolean
}

/**
 * Request parameters for getClientLogConfiguration operation in ManagedClustersApi.
 * @export
 * @interface ManagedClustersApiGetClientLogConfigurationRequest
 */
export interface ManagedClustersApiGetClientLogConfigurationRequest {
    /**
     * ID of managed cluster to get log configuration for.
     * @type {string}
     * @memberof ManagedClustersApiGetClientLogConfiguration
     */
    readonly id: string
}

/**
 * Request parameters for getManagedCluster operation in ManagedClustersApi.
 * @export
 * @interface ManagedClustersApiGetManagedClusterRequest
 */
export interface ManagedClustersApiGetManagedClusterRequest {
    /**
     * Managed cluster ID.
     * @type {string}
     * @memberof ManagedClustersApiGetManagedCluster
     */
    readonly id: string
}

/**
 * Request parameters for getManagedClusters operation in ManagedClustersApi.
 * @export
 * @interface ManagedClustersApiGetManagedClustersRequest
 */
export interface ManagedClustersApiGetManagedClustersRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ManagedClustersApiGetManagedClusters
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ManagedClustersApiGetManagedClusters
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ManagedClustersApiGetManagedClusters
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **operational**: *eq*
     * @type {string}
     * @memberof ManagedClustersApiGetManagedClusters
     */
    readonly filters?: string
}

/**
 * Request parameters for putClientLogConfiguration operation in ManagedClustersApi.
 * @export
 * @interface ManagedClustersApiPutClientLogConfigurationRequest
 */
export interface ManagedClustersApiPutClientLogConfigurationRequest {
    /**
     * ID of the managed cluster to update the log configuration for.
     * @type {string}
     * @memberof ManagedClustersApiPutClientLogConfiguration
     */
    readonly id: string

    /**
     * Client log configuration for the given managed cluster.
     * @type {PutClientLogConfigurationRequest}
     * @memberof ManagedClustersApiPutClientLogConfiguration
     */
    readonly putClientLogConfigurationRequest: PutClientLogConfigurationRequest
}

/**
 * Request parameters for updateManagedCluster operation in ManagedClustersApi.
 * @export
 * @interface ManagedClustersApiUpdateManagedClusterRequest
 */
export interface ManagedClustersApiUpdateManagedClusterRequest {
    /**
     * Managed cluster ID.
     * @type {string}
     * @memberof ManagedClustersApiUpdateManagedCluster
     */
    readonly id: string

    /**
     * JSONPatch payload used to update the object.
     * @type {Array<JsonPatchOperation>}
     * @memberof ManagedClustersApiUpdateManagedCluster
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * ManagedClustersApi - object-oriented interface
 * @export
 * @class ManagedClustersApi
 * @extends {BaseAPI}
 */
export class ManagedClustersApi extends BaseAPI {
    /**
     * Create a new Managed Cluster. The API returns a result that includes the managed cluster ID.
     * @summary Create Create Managed Cluster
     * @param {ManagedClustersApiCreateManagedClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    public createManagedCluster(requestParameters: ManagedClustersApiCreateManagedClusterRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ManagedClustersApiFp(this.configuration).createManagedCluster(requestParameters.managedClusterRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing managed cluster.
     * @summary Delete Managed Cluster
     * @param {ManagedClustersApiDeleteManagedClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    public deleteManagedCluster(requestParameters: ManagedClustersApiDeleteManagedClusterRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ManagedClustersApiFp(this.configuration).deleteManagedCluster(requestParameters.id, requestParameters.removeClients, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a managed cluster\'s log configuration.
     * @summary Get Managed Cluster Log Configuration
     * @param {ManagedClustersApiGetClientLogConfigurationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    public getClientLogConfiguration(requestParameters: ManagedClustersApiGetClientLogConfigurationRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ManagedClustersApiFp(this.configuration).getClientLogConfiguration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a managed cluster by ID.
     * @summary Get Managed Cluster
     * @param {ManagedClustersApiGetManagedClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    public getManagedCluster(requestParameters: ManagedClustersApiGetManagedClusterRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ManagedClustersApiFp(this.configuration).getManagedCluster(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List current organization\'s managed clusters, based on request context.
     * @summary Get Managed Clusters
     * @param {ManagedClustersApiGetManagedClustersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    public getManagedClusters(requestParameters: ManagedClustersApiGetManagedClustersRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return ManagedClustersApiFp(this.configuration).getManagedClusters(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a managed cluster\'s log configuration. You may only specify one of `durationMinutes` or `expiration`, up to 1440 minutes (24 hours) in the future. If neither is specified, the default value for `durationMinutes` is 240.
     * @summary Update Managed Cluster Log Configuration
     * @param {ManagedClustersApiPutClientLogConfigurationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    public putClientLogConfiguration(requestParameters: ManagedClustersApiPutClientLogConfigurationRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ManagedClustersApiFp(this.configuration).putClientLogConfiguration(requestParameters.id, requestParameters.putClientLogConfigurationRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing managed cluster.
     * @summary Update Managed Cluster
     * @param {ManagedClustersApiUpdateManagedClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    public updateManagedCluster(requestParameters: ManagedClustersApiUpdateManagedClusterRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ManagedClustersApiFp(this.configuration).updateManagedCluster(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NonEmployeeLifecycleManagementApi - axios parameter creator
 * @export
 */
export const NonEmployeeLifecycleManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveNonEmployeeRequest: async (id: string, nonEmployeeApprovalDecision: NonEmployeeApprovalDecision, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveNonEmployeeRequest', 'id', id)
            // verify required parameter 'nonEmployeeApprovalDecision' is not null or undefined
            assertParamExists('approveNonEmployeeRequest', 'nonEmployeeApprovalDecision', nonEmployeeApprovalDecision)
            const localVarPath = `/non-employee-approvals/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeApprovalDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRecord: async (nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('createNonEmployeeRecord', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRequest: async (nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('createNonEmployeeRequest', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Create a non-employee source. 
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSource: async (nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeSourceRequestBody' is not null or undefined
            assertParamExists('createNonEmployeeSource', 'nonEmployeeSourceRequestBody', nonEmployeeSourceRequestBody)
            const localVarPath = `/non-employee-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeSourceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSourceSchemaAttributes: async (sourceId: string, nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            // verify required parameter 'nonEmployeeSchemaAttributeBody' is not null or undefined
            assertParamExists('createNonEmployeeSourceSchemaAttributes', 'nonEmployeeSchemaAttributeBody', nonEmployeeSchemaAttributeBody)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeSchemaAttributeBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecord: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNonEmployeeRecord', 'id', id)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordsInBulkRequest} deleteNonEmployeeRecordsInBulkRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecordsInBulk: async (deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteNonEmployeeRecordsInBulkRequest' is not null or undefined
            assertParamExists('deleteNonEmployeeRecordsInBulk', 'deleteNonEmployeeRecordsInBulkRequest', deleteNonEmployeeRecordsInBulkRequest)
            const localVarPath = `/non-employee-records/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteNonEmployeeRecordsInBulkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRequest: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNonEmployeeRequest', 'id', id)
            const localVarPath = `/non-employee-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('deleteNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSource: async (sourceId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSource', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSourceSchemaAttributes: async (sourceId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeRecords: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportNonEmployeeRecords', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/non-employees/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeSourceSchemaTemplate: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportNonEmployeeSourceSchemaTemplate', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/schema-attributes-template/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApproval: async (id: string, includeDetail?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeApproval', 'id', id)
            const localVarPath = `/non-employee-approvals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (includeDetail !== undefined) {
                localVarQueryParameter['include-detail'] = includeDetail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApprovalSummary: async (requestedFor: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('getNonEmployeeApprovalSummary', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-approvals/summary/{requested-for}`
                .replace(`{${"requested-for"}}`, encodeURIComponent(String(requestedFor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeBulkUploadStatus: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeBulkUploadStatus', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/non-employee-bulk-upload/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRecord: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeRecord', 'id', id)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequest: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeRequest', 'id', id)
            const localVarPath = `/non-employee-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequestSummary: async (requestedFor: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('getNonEmployeeRequestSummary', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-requests/summary/{requested-for}`
                .replace(`{${"requested-for"}}`, encodeURIComponent(String(requestedFor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('getNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSource: async (sourceId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSource', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSourceSchemaAttributes: async (sourceId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {File} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importNonEmployeeRecordsInBulk: async (id: string, data: File, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importNonEmployeeRecordsInBulk', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('importNonEmployeeRecordsInBulk', 'data', data)
            const localVarPath = `/non-employee-sources/{id}/non-employee-bulk-upload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **approvalStatus**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeApprovals: async (requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/non-employee-approvals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRecords: async (limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/non-employee-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq* 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRequests: async (requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('listNonEmployeeRequests', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a list of non-employee sources. There are two contextual uses for the `requested-for` path parameter:    1. If the user has the role context of `idn:nesr:read`, he or she may request a list sources assigned to a particular account manager by passing in that manager\'s `id`.   2. If the current user is an account manager, the user should provide \'me\' as the `requested-for` value. Doing so provide the user with a list of the sources he or she owns.
         * @summary List Non-Employee Sources
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [requestedFor] Identity the request was made for. Use \&#39;me\&#39; to indicate the current user.
         * @param {boolean} [nonEmployeeCount] Flag that determines whether the API will return a non-employee count associated with the source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, sourceId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeSources: async (limit?: number, offset?: number, count?: boolean, requestedFor?: string, nonEmployeeCount?: boolean, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/non-employee-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (nonEmployeeCount !== undefined) {
                localVarQueryParameter['non-employee-count'] = nonEmployeeCount;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeRecord: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchNonEmployeeRecord', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchNonEmployeeRecord', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSource: async (sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('patchNonEmployeeSource', 'sourceId', sourceId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchNonEmployeeSource', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectNonEmployeeRequest: async (id: string, nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectNonEmployeeRequest', 'id', id)
            // verify required parameter 'nonEmployeeRejectApprovalDecision' is not null or undefined
            assertParamExists('rejectNonEmployeeRequest', 'nonEmployeeRejectApprovalDecision', nonEmployeeRejectApprovalDecision)
            const localVarPath = `/non-employee-approvals/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRejectApprovalDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateNonEmployeeRecord: async (id: string, nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateNonEmployeeRecord', 'id', id)
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('updateNonEmployeeRecord', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * NonEmployeeLifecycleManagementApi - functional programming interface
 * @export
 */
export const NonEmployeeLifecycleManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NonEmployeeLifecycleManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveNonEmployeeRequest(id: string, nonEmployeeApprovalDecision: NonEmployeeApprovalDecision, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveNonEmployeeRequest(id, nonEmployeeApprovalDecision, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.approveNonEmployeeRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeRecord(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeRecord(nonEmployeeRequestBody, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.createNonEmployeeRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeRequest(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeRequest(nonEmployeeRequestBody, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.createNonEmployeeRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a non-employee source. 
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeSource(nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSourceWithCloudExternalId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeSource(nonEmployeeSourceRequestBody, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.createNonEmployeeSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeSourceSchemaAttributes(sourceId: string, nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeSourceSchemaAttributes(sourceId, nonEmployeeSchemaAttributeBody, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.createNonEmployeeSourceSchemaAttributes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRecord(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRecord(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.deleteNonEmployeeRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordsInBulkRequest} deleteNonEmployeeRecordsInBulkRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.deleteNonEmployeeRecordsInBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRequest(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRequest(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.deleteNonEmployeeRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.deleteNonEmployeeSchemaAttribute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSource(sourceId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSource(sourceId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.deleteNonEmployeeSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.deleteNonEmployeeSourceSchemaAttributes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportNonEmployeeRecords(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNonEmployeeRecords(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.exportNonEmployeeRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportNonEmployeeSourceSchemaTemplate(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNonEmployeeSourceSchemaTemplate(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.exportNonEmployeeSourceSchemaTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeApproval(id: string, includeDetail?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeApproval(id, includeDetail, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeApproval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeApprovalSummary(requestedFor: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeApprovalSummary(requestedFor, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeApprovalSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeBulkUploadStatus(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeBulkUploadStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeBulkUploadStatus(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeBulkUploadStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRecord(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRecord(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRequest(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRequest(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRequestSummary(requestedFor: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequestSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRequestSummary(requestedFor, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeRequestSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeSchemaAttribute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSource(sourceId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSource(sourceId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeSchemaAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.getNonEmployeeSourceSchemaAttributes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {File} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importNonEmployeeRecordsInBulk(id: string, data: File, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeBulkUploadJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importNonEmployeeRecordsInBulk(id, data, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.importNonEmployeeRecordsInBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **approvalStatus**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeApprovals(requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeApprovalItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeApprovals(requestedFor, limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.listNonEmployeeApprovals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeRecords(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeRecords(limit, offset, count, sorters, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.listNonEmployeeRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq* 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeRequests(requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeRequest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeRequests(requestedFor, limit, offset, count, sorters, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.listNonEmployeeRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of non-employee sources. There are two contextual uses for the `requested-for` path parameter:    1. If the user has the role context of `idn:nesr:read`, he or she may request a list sources assigned to a particular account manager by passing in that manager\'s `id`.   2. If the current user is an account manager, the user should provide \'me\' as the `requested-for` value. Doing so provide the user with a list of the sources he or she owns.
         * @summary List Non-Employee Sources
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [requestedFor] Identity the request was made for. Use \&#39;me\&#39; to indicate the current user.
         * @param {boolean} [nonEmployeeCount] Flag that determines whether the API will return a non-employee count associated with the source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, sourceId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeSources(limit?: number, offset?: number, count?: boolean, requestedFor?: string, nonEmployeeCount?: boolean, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeSourceWithNECount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeSources(limit, offset, count, requestedFor, nonEmployeeCount, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.listNonEmployeeSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeRecord(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeRecord(id, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.patchNonEmployeeRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeSchemaAttribute(attributeId, sourceId, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.patchNonEmployeeSchemaAttribute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeSource(sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeSource(sourceId, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.patchNonEmployeeSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectNonEmployeeRequest(id: string, nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectNonEmployeeRequest(id, nonEmployeeRejectApprovalDecision, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.rejectNonEmployeeRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateNonEmployeeRecord(id: string, nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNonEmployeeRecord(id, nonEmployeeRequestBody, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NonEmployeeLifecycleManagementApi.updateNonEmployeeRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NonEmployeeLifecycleManagementApi - factory interface
 * @export
 */
export const NonEmployeeLifecycleManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NonEmployeeLifecycleManagementApiFp(configuration)
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeApprovalItem> {
            return localVarFp.approveNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeApprovalDecision, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.createNonEmployeeRecord(requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeRequest> {
            return localVarFp.createNonEmployeeRequest(requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Create a non-employee source. 
         * @summary Create Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeSourceWithCloudExternalId> {
            return localVarFp.createNonEmployeeSource(requestParameters.nonEmployeeSourceRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.createNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, requestParameters.nonEmployeeSchemaAttributeBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRecord(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecordsInBulk(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRecordsInBulk(requestParameters.deleteNonEmployeeRecordsInBulkRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRequest(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSource(requestParameters.sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.exportNonEmployeeRecords(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeSourceSchemaTemplate(requestParameters: NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.exportNonEmployeeSourceSchemaTemplate(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApproval(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeApprovalItemDetail> {
            return localVarFp.getNonEmployeeApproval(requestParameters.id, requestParameters.includeDetail, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApprovalSummary(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeApprovalSummary> {
            return localVarFp.getNonEmployeeApprovalSummary(requestParameters.requestedFor, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeBulkUploadStatus(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeBulkUploadStatus> {
            return localVarFp.getNonEmployeeBulkUploadStatus(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.getNonEmployeeRecord(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeRequest> {
            return localVarFp.getNonEmployeeRequest(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequestSummary(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeRequestSummary> {
            return localVarFp.getNonEmployeeRequestSummary(requestParameters.requestedFor, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.getNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeSource> {
            return localVarFp.getNonEmployeeSource(requestParameters.sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<NonEmployeeSchemaAttribute>> {
            return localVarFp.getNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importNonEmployeeRecordsInBulk(requestParameters: NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeBulkUploadJob> {
            return localVarFp.importNonEmployeeRecordsInBulk(requestParameters.id, requestParameters.data, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeApprovals(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<NonEmployeeApprovalItem>> {
            return localVarFp.listNonEmployeeApprovals(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<NonEmployeeRecord>> {
            return localVarFp.listNonEmployeeRecords(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRequests(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<NonEmployeeRequest>> {
            return localVarFp.listNonEmployeeRequests(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of non-employee sources. There are two contextual uses for the `requested-for` path parameter:    1. If the user has the role context of `idn:nesr:read`, he or she may request a list sources assigned to a particular account manager by passing in that manager\'s `id`.   2. If the current user is an account manager, the user should provide \'me\' as the `requested-for` value. Doing so provide the user with a list of the sources he or she owns.
         * @summary List Non-Employee Sources
         * @param {NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeSources(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<NonEmployeeSourceWithNECount>> {
            return localVarFp.listNonEmployeeSources(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.requestedFor, requestParameters.nonEmployeeCount, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.patchNonEmployeeRecord(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.patchNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeSource> {
            return localVarFp.patchNonEmployeeSource(requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeApprovalItem> {
            return localVarFp.rejectNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeRejectApprovalDecision, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.updateNonEmployeeRecord(requestParameters.id, requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiApproveNonEmployeeRequest
     */
    readonly id: string

    /**
     * 
     * @type {NonEmployeeApprovalDecision}
     * @memberof NonEmployeeLifecycleManagementApiApproveNonEmployeeRequest
     */
    readonly nonEmployeeApprovalDecision: NonEmployeeApprovalDecision
}

/**
 * Request parameters for createNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest {
    /**
     * Non-Employee record creation request body.
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeRecord
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * Request parameters for createNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest {
    /**
     * Non-Employee creation request body
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeRequest
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * Request parameters for createNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest {
    /**
     * Non-Employee source creation request body.
     * @type {NonEmployeeSourceRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeSource
     */
    readonly nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody
}

/**
 * Request parameters for createNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string

    /**
     * 
     * @type {NonEmployeeSchemaAttributeBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributes
     */
    readonly nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody
}

/**
 * Request parameters for deleteNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest {
    /**
     * Non-Employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecord
     */
    readonly id: string
}

/**
 * Request parameters for deleteNonEmployeeRecordsInBulk operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest {
    /**
     * Non-Employee bulk delete request body.
     * @type {DeleteNonEmployeeRecordsInBulkRequest}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulk
     */
    readonly deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest
}

/**
 * Request parameters for deleteNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest {
    /**
     * Non-Employee request id in the UUID format
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequest
     */
    readonly id: string
}

/**
 * Request parameters for deleteNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttribute
     */
    readonly sourceId: string
}

/**
 * Request parameters for deleteNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSource
     */
    readonly sourceId: string
}

/**
 * Request parameters for deleteNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string
}

/**
 * Request parameters for exportNonEmployeeRecords operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest
 */
export interface NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiExportNonEmployeeRecords
     */
    readonly id: string
}

/**
 * Request parameters for exportNonEmployeeSourceSchemaTemplate operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest
 */
export interface NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplate
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeApproval operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeApproval
     */
    readonly id: string

    /**
     * The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeApproval
     */
    readonly includeDetail?: boolean
}

/**
 * Request parameters for getNonEmployeeApprovalSummary operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest {
    /**
     * The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummary
     */
    readonly requestedFor: string
}

/**
 * Request parameters for getNonEmployeeBulkUploadStatus operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest {
    /**
     * Source ID (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatus
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest {
    /**
     * Non-Employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeRecord
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest {
    /**
     * Non-Employee request id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeRequest
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRequestSummary operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest {
    /**
     * The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummary
     */
    readonly requestedFor: string
}

/**
 * Request parameters for getNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttribute
     */
    readonly sourceId: string
}

/**
 * Request parameters for getNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSource
     */
    readonly sourceId: string
}

/**
 * Request parameters for getNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string
}

/**
 * Request parameters for importNonEmployeeRecordsInBulk operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest
 */
export interface NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulk
     */
    readonly id: string

    /**
     * 
     * @type {File}
     * @memberof NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulk
     */
    readonly data: File
}

/**
 * Request parameters for listNonEmployeeApprovals operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly requestedFor?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **approvalStatus**: *eq*
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for listNonEmployeeRecords operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly filters?: string
}

/**
 * Request parameters for listNonEmployeeRequests operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly requestedFor: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq* 
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly filters?: string
}

/**
 * Request parameters for listNonEmployeeSources operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly count?: boolean

    /**
     * Identity the request was made for. Use \&#39;me\&#39; to indicate the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly requestedFor?: string

    /**
     * Flag that determines whether the API will return a non-employee count associated with the source.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly nonEmployeeCount?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, sourceId**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly sorters?: string
}

/**
 * Request parameters for patchNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest {
    /**
     * Non-employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeRecord
     */
    readonly id: string

    /**
     * A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeRecord
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for patchNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttribute
     */
    readonly sourceId: string

    /**
     * A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttribute
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for patchNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSource
     */
    readonly sourceId: string

    /**
     * A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSource
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for rejectNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiRejectNonEmployeeRequest
     */
    readonly id: string

    /**
     * 
     * @type {NonEmployeeRejectApprovalDecision}
     * @memberof NonEmployeeLifecycleManagementApiRejectNonEmployeeRequest
     */
    readonly nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision
}

/**
 * Request parameters for updateNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest {
    /**
     * Non-employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecord
     */
    readonly id: string

    /**
     * Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecord
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * NonEmployeeLifecycleManagementApi - object-oriented interface
 * @export
 * @class NonEmployeeLifecycleManagementApi
 * @extends {BaseAPI}
 */
export class NonEmployeeLifecycleManagementApi extends BaseAPI {
    /**
     * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
     * @summary Approve a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public approveNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).approveNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeApprovalDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee record. Requires role context of `idn:nesr:create`
     * @summary Create Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeRecord(requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
     * @summary Create Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeRequest(requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a non-employee source. 
     * @summary Create Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeSource(requestParameters.nonEmployeeSourceRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
     * @summary Create a new Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, requestParameters.nonEmployeeSchemaAttributeBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
     * @summary Delete Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeRecord(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
     * @summary Delete Multiple Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeRecordsInBulk(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeRecordsInBulk(requestParameters.deleteNonEmployeeRecordsInBulkRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
     * @summary Delete Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeRequest(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
     * @summary Delete a Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
     * @summary Delete Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeSource(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
     * @summary Delete all custom schema attributes for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
     * @summary Exports Non-Employee Records to CSV
     * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public exportNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).exportNonEmployeeRecords(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
     * @summary Exports Source Schema Template
     * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public exportNonEmployeeSourceSchemaTemplate(requestParameters: NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).exportNonEmployeeSourceSchemaTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
     * @summary Get a non-employee approval item detail
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeApproval(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeApproval(requestParameters.id, requestParameters.includeDetail, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
     * @summary Get Summary of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeApprovalSummary(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeApprovalSummary(requestParameters.requestedFor, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
     * @summary Obtain the status of bulk upload on the source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeBulkUploadStatus(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeBulkUploadStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee record. Requires role context of `idn:nesr:read`
     * @summary Get a Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeRecord(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
     * @summary Get a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeRequest(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
     * @summary Get Summary of Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeRequestSummary(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeRequestSummary(requestParameters.requestedFor, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
     * @summary Get Schema Attribute Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
     * @summary Get a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeSource(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
     * @summary List Schema Attributes Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
     * @summary Imports, or Updates, Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public importNonEmployeeRecordsInBulk(requestParameters: NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).importNonEmployeeRecordsInBulk(requestParameters.id, requestParameters.data, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
     * @summary Get List of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeApprovals(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeApprovals(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
     * @summary List Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeRecords(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
     * @summary List Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeRequests(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeRequests(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of non-employee sources. There are two contextual uses for the `requested-for` path parameter:    1. If the user has the role context of `idn:nesr:read`, he or she may request a list sources assigned to a particular account manager by passing in that manager\'s `id`.   2. If the current user is an account manager, the user should provide \'me\' as the `requested-for` value. Doing so provide the user with a list of the sources he or she owns.
     * @summary List Non-Employee Sources
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeSources(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeSources(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.requestedFor, requestParameters.nonEmployeeCount, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
     * @summary Patch Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public patchNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).patchNonEmployeeRecord(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
     * @summary Patch a Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public patchNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).patchNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
     * @summary Patch a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public patchNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).patchNonEmployeeSource(requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
     * @summary Reject a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public rejectNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).rejectNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeRejectApprovalDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
     * @summary Update Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public updateNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest, axiosOptions?: RawAxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).updateNonEmployeeRecord(requestParameters.id, requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OAuthClientsApi - axios parameter creator
 * @export
 */
export const OAuthClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient: async (createOAuthClientRequest: CreateOAuthClientRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOAuthClientRequest' is not null or undefined
            assertParamExists('createOauthClient', 'createOAuthClientRequest', createOAuthClientRequest)
            const localVarPath = `/oauth-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOAuthClientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOauthClient', 'id', id)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOauthClient', 'id', id)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients: async (filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchOauthClient', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchOauthClient', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthClientsApi - functional programming interface
 * @export
 */
export const OAuthClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createOauthClient(createOAuthClientRequest: CreateOAuthClientRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOauthClient(createOAuthClientRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthClientsApi.createOauthClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOauthClient(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOauthClient(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthClientsApi.deleteOauthClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getOauthClient(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOauthClient(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthClientsApi.getOauthClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listOauthClients(filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOAuthClientResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOauthClients(filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthClientsApi.listOauthClients']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchOauthClient(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOauthClient(id, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthClientsApi.patchOauthClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OAuthClientsApi - factory interface
 * @export
 */
export const OAuthClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthClientsApiFp(configuration)
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {OAuthClientsApiCreateOauthClientRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient(requestParameters: OAuthClientsApiCreateOauthClientRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CreateOAuthClientResponse> {
            return localVarFp.createOauthClient(requestParameters.createOAuthClientRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {OAuthClientsApiDeleteOauthClientRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient(requestParameters: OAuthClientsApiDeleteOauthClientRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOauthClient(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {OAuthClientsApiGetOauthClientRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient(requestParameters: OAuthClientsApiGetOauthClientRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<GetOAuthClientResponse> {
            return localVarFp.getOauthClient(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {OAuthClientsApiListOauthClientsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients(requestParameters: OAuthClientsApiListOauthClientsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<GetOAuthClientResponse>> {
            return localVarFp.listOauthClients(requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {OAuthClientsApiPatchOauthClientRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient(requestParameters: OAuthClientsApiPatchOauthClientRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<GetOAuthClientResponse> {
            return localVarFp.patchOauthClient(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiCreateOauthClientRequest
 */
export interface OAuthClientsApiCreateOauthClientRequest {
    /**
     * 
     * @type {CreateOAuthClientRequest}
     * @memberof OAuthClientsApiCreateOauthClient
     */
    readonly createOAuthClientRequest: CreateOAuthClientRequest
}

/**
 * Request parameters for deleteOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiDeleteOauthClientRequest
 */
export interface OAuthClientsApiDeleteOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiDeleteOauthClient
     */
    readonly id: string
}

/**
 * Request parameters for getOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiGetOauthClientRequest
 */
export interface OAuthClientsApiGetOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiGetOauthClient
     */
    readonly id: string
}

/**
 * Request parameters for listOauthClients operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiListOauthClientsRequest
 */
export interface OAuthClientsApiListOauthClientsRequest {
    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
     * @type {string}
     * @memberof OAuthClientsApiListOauthClients
     */
    readonly filters?: string
}

/**
 * Request parameters for patchOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiPatchOauthClientRequest
 */
export interface OAuthClientsApiPatchOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiPatchOauthClient
     */
    readonly id: string

    /**
     * A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
     * @type {Array<JsonPatchOperation>}
     * @memberof OAuthClientsApiPatchOauthClient
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * OAuthClientsApi - object-oriented interface
 * @export
 * @class OAuthClientsApi
 * @extends {BaseAPI}
 */
export class OAuthClientsApi extends BaseAPI {
    /**
     * This creates an OAuth client.
     * @summary Create OAuth Client
     * @param {OAuthClientsApiCreateOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public createOauthClient(requestParameters: OAuthClientsApiCreateOauthClientRequest, axiosOptions?: RawAxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).createOauthClient(requestParameters.createOAuthClientRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes an OAuth client.
     * @summary Delete OAuth Client
     * @param {OAuthClientsApiDeleteOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public deleteOauthClient(requestParameters: OAuthClientsApiDeleteOauthClientRequest, axiosOptions?: RawAxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).deleteOauthClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets details of an OAuth client.
     * @summary Get OAuth Client
     * @param {OAuthClientsApiGetOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public getOauthClient(requestParameters: OAuthClientsApiGetOauthClientRequest, axiosOptions?: RawAxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).getOauthClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of OAuth clients.
     * @summary List OAuth Clients
     * @param {OAuthClientsApiListOauthClientsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public listOauthClients(requestParameters: OAuthClientsApiListOauthClientsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).listOauthClients(requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This performs a targeted update to the field(s) of an OAuth client.
     * @summary Patch OAuth Client
     * @param {OAuthClientsApiPatchOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public patchOauthClient(requestParameters: OAuthClientsApiPatchOauthClientRequest, axiosOptions?: RawAxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).patchOauthClient(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasswordConfigurationApi - axios parameter creator
 * @export
 */
export const PasswordConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordOrgConfig: async (passwordOrgConfig: PasswordOrgConfig, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordOrgConfig' is not null or undefined
            assertParamExists('createPasswordOrgConfig', 'passwordOrgConfig', passwordOrgConfig)
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordOrgConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordOrgConfig: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordOrgConfig: async (passwordOrgConfig: PasswordOrgConfig, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordOrgConfig' is not null or undefined
            assertParamExists('putPasswordOrgConfig', 'passwordOrgConfig', passwordOrgConfig)
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordOrgConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordConfigurationApi - functional programming interface
 * @export
 */
export const PasswordConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPasswordOrgConfig(passwordOrgConfig: PasswordOrgConfig, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPasswordOrgConfig(passwordOrgConfig, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordConfigurationApi.createPasswordOrgConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordOrgConfig(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordOrgConfig(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordConfigurationApi.getPasswordOrgConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putPasswordOrgConfig(passwordOrgConfig: PasswordOrgConfig, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPasswordOrgConfig(passwordOrgConfig, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordConfigurationApi.putPasswordOrgConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PasswordConfigurationApi - factory interface
 * @export
 */
export const PasswordConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordConfigurationApiFp(configuration)
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordConfigurationApiCreatePasswordOrgConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordOrgConfig(requestParameters: PasswordConfigurationApiCreatePasswordOrgConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PasswordOrgConfig> {
            return localVarFp.createPasswordOrgConfig(requestParameters.passwordOrgConfig, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordOrgConfig(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PasswordOrgConfig> {
            return localVarFp.getPasswordOrgConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordConfigurationApiPutPasswordOrgConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordOrgConfig(requestParameters: PasswordConfigurationApiPutPasswordOrgConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PasswordOrgConfig> {
            return localVarFp.putPasswordOrgConfig(requestParameters.passwordOrgConfig, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPasswordOrgConfig operation in PasswordConfigurationApi.
 * @export
 * @interface PasswordConfigurationApiCreatePasswordOrgConfigRequest
 */
export interface PasswordConfigurationApiCreatePasswordOrgConfigRequest {
    /**
     * 
     * @type {PasswordOrgConfig}
     * @memberof PasswordConfigurationApiCreatePasswordOrgConfig
     */
    readonly passwordOrgConfig: PasswordOrgConfig
}

/**
 * Request parameters for putPasswordOrgConfig operation in PasswordConfigurationApi.
 * @export
 * @interface PasswordConfigurationApiPutPasswordOrgConfigRequest
 */
export interface PasswordConfigurationApiPutPasswordOrgConfigRequest {
    /**
     * 
     * @type {PasswordOrgConfig}
     * @memberof PasswordConfigurationApiPutPasswordOrgConfig
     */
    readonly passwordOrgConfig: PasswordOrgConfig
}

/**
 * PasswordConfigurationApi - object-oriented interface
 * @export
 * @class PasswordConfigurationApi
 * @extends {BaseAPI}
 */
export class PasswordConfigurationApi extends BaseAPI {
    /**
     * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
     * @summary Create Password Org Config
     * @param {PasswordConfigurationApiCreatePasswordOrgConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    public createPasswordOrgConfig(requestParameters: PasswordConfigurationApiCreatePasswordOrgConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordConfigurationApiFp(this.configuration).createPasswordOrgConfig(requestParameters.passwordOrgConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
     * @summary Get Password Org Config
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    public getPasswordOrgConfig(axiosOptions?: RawAxiosRequestConfig) {
        return PasswordConfigurationApiFp(this.configuration).getPasswordOrgConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
     * @summary Update Password Org Config
     * @param {PasswordConfigurationApiPutPasswordOrgConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    public putPasswordOrgConfig(requestParameters: PasswordConfigurationApiPutPasswordOrgConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordConfigurationApiFp(this.configuration).putPasswordOrgConfig(requestParameters.passwordOrgConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasswordDictionaryApi - axios parameter creator
 * @export
 */
export const PasswordDictionaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This gets password dictionary for the organization. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordDictionary: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-dictionary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates password dictionary for the organization. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Update Password Dictionary
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordDictionary: async (file?: File, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-dictionary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordDictionaryApi - functional programming interface
 * @export
 */
export const PasswordDictionaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordDictionaryApiAxiosParamCreator(configuration)
    return {
        /**
         * This gets password dictionary for the organization. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordDictionary(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordDictionary(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordDictionaryApi.getPasswordDictionary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This updates password dictionary for the organization. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Update Password Dictionary
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putPasswordDictionary(file?: File, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPasswordDictionary(file, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordDictionaryApi.putPasswordDictionary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PasswordDictionaryApi - factory interface
 * @export
 */
export const PasswordDictionaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordDictionaryApiFp(configuration)
    return {
        /**
         * This gets password dictionary for the organization. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordDictionary(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getPasswordDictionary(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates password dictionary for the organization. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Update Password Dictionary
         * @param {PasswordDictionaryApiPutPasswordDictionaryRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordDictionary(requestParameters: PasswordDictionaryApiPutPasswordDictionaryRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putPasswordDictionary(requestParameters.file, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for putPasswordDictionary operation in PasswordDictionaryApi.
 * @export
 * @interface PasswordDictionaryApiPutPasswordDictionaryRequest
 */
export interface PasswordDictionaryApiPutPasswordDictionaryRequest {
    /**
     * 
     * @type {File}
     * @memberof PasswordDictionaryApiPutPasswordDictionary
     */
    readonly file?: File
}

/**
 * PasswordDictionaryApi - object-oriented interface
 * @export
 * @class PasswordDictionaryApi
 * @extends {BaseAPI}
 */
export class PasswordDictionaryApi extends BaseAPI {
    /**
     * This gets password dictionary for the organization. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
     * @summary Get Password Dictionary
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordDictionaryApi
     */
    public getPasswordDictionary(axiosOptions?: RawAxiosRequestConfig) {
        return PasswordDictionaryApiFp(this.configuration).getPasswordDictionary(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates password dictionary for the organization. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
     * @summary Update Password Dictionary
     * @param {PasswordDictionaryApiPutPasswordDictionaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordDictionaryApi
     */
    public putPasswordDictionary(requestParameters: PasswordDictionaryApiPutPasswordDictionaryRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordDictionaryApiFp(this.configuration).putPasswordDictionary(requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasswordManagementApi - axios parameter creator
 * @export
 */
export const PasswordManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the status of a password change request.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordChangeStatus: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPasswordChangeStatus', 'id', id)
            const localVarPath = `/password-change-status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API is used to query password related information.  
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo: async (passwordInfoQueryDTO: PasswordInfoQueryDTO, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordInfoQueryDTO' is not null or undefined
            assertParamExists('queryPasswordInfo', 'passwordInfoQueryDTO', passwordInfoQueryDTO)
            const localVarPath = `/query-password-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordInfoQueryDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their ISC user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  >**Note: If you want to set an identity\'s source account password, you must enable `PASSWORD` as one of the source\'s features. You can use the [PATCH Source endpoint](https://developer.sailpoint.com/docs/api/v3/update-source) to add the `PASSWORD` feature.**  To generate the encryptedPassword (RSA encrypted using publicKey) for the request body, run the following command:  ```bash echo -n \"myPassword\" | openssl pkeyutl -encrypt -inkey public_key.pem -pubin | base64 ```  In this example, myPassword is the plain text password being set and encrypted, and public_key.pem is the path to the public key file. You can retrieve the required publicKey, along with other information like identityId, sourceId, publicKeyId, accounts, and policies, using the Query Password Info endpoint.  To successfully run this command, you must have OpenSSL installed on your machine. If OpenSSL is unavailable, consider using the Virtual Appliance (VA), which has OpenSSL pre-installed and configured.  If you are using a Windows machine, refer to this [guide](https://tecadmin.net/install-openssl-on-windows/) for instructions on installing OpenSSL.  You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPassword: async (passwordChangeRequest: PasswordChangeRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChangeRequest' is not null or undefined
            assertParamExists('setPassword', 'passwordChangeRequest', passwordChangeRequest)
            const localVarPath = `/set-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordManagementApi - functional programming interface
 * @export
 */
export const PasswordManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the status of a password change request.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordChangeStatus(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordChangeStatus(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordManagementApi.getPasswordChangeStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API is used to query password related information.  
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async queryPasswordInfo(passwordInfoQueryDTO: PasswordInfoQueryDTO, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryPasswordInfo(passwordInfoQueryDTO, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordManagementApi.queryPasswordInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their ISC user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  >**Note: If you want to set an identity\'s source account password, you must enable `PASSWORD` as one of the source\'s features. You can use the [PATCH Source endpoint](https://developer.sailpoint.com/docs/api/v3/update-source) to add the `PASSWORD` feature.**  To generate the encryptedPassword (RSA encrypted using publicKey) for the request body, run the following command:  ```bash echo -n \"myPassword\" | openssl pkeyutl -encrypt -inkey public_key.pem -pubin | base64 ```  In this example, myPassword is the plain text password being set and encrypted, and public_key.pem is the path to the public key file. You can retrieve the required publicKey, along with other information like identityId, sourceId, publicKeyId, accounts, and policies, using the Query Password Info endpoint.  To successfully run this command, you must have OpenSSL installed on your machine. If OpenSSL is unavailable, consider using the Virtual Appliance (VA), which has OpenSSL pre-installed and configured.  If you are using a Windows machine, refer to this [guide](https://tecadmin.net/install-openssl-on-windows/) for instructions on installing OpenSSL.  You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setPassword(passwordChangeRequest: PasswordChangeRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordChangeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPassword(passwordChangeRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordManagementApi.setPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PasswordManagementApi - factory interface
 * @export
 */
export const PasswordManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordManagementApiFp(configuration)
    return {
        /**
         * This API returns the status of a password change request.
         * @summary Get Password Change Request Status
         * @param {PasswordManagementApiGetPasswordChangeStatusRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordChangeStatus(requestParameters: PasswordManagementApiGetPasswordChangeStatusRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PasswordStatus> {
            return localVarFp.getPasswordChangeStatus(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to query password related information.  
         * @summary Query Password Info
         * @param {PasswordManagementApiQueryPasswordInfoRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo(requestParameters: PasswordManagementApiQueryPasswordInfoRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PasswordInfo> {
            return localVarFp.queryPasswordInfo(requestParameters.passwordInfoQueryDTO, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their ISC user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  >**Note: If you want to set an identity\'s source account password, you must enable `PASSWORD` as one of the source\'s features. You can use the [PATCH Source endpoint](https://developer.sailpoint.com/docs/api/v3/update-source) to add the `PASSWORD` feature.**  To generate the encryptedPassword (RSA encrypted using publicKey) for the request body, run the following command:  ```bash echo -n \"myPassword\" | openssl pkeyutl -encrypt -inkey public_key.pem -pubin | base64 ```  In this example, myPassword is the plain text password being set and encrypted, and public_key.pem is the path to the public key file. You can retrieve the required publicKey, along with other information like identityId, sourceId, publicKeyId, accounts, and policies, using the Query Password Info endpoint.  To successfully run this command, you must have OpenSSL installed on your machine. If OpenSSL is unavailable, consider using the Virtual Appliance (VA), which has OpenSSL pre-installed and configured.  If you are using a Windows machine, refer to this [guide](https://tecadmin.net/install-openssl-on-windows/) for instructions on installing OpenSSL.  You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordManagementApiSetPasswordRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPassword(requestParameters: PasswordManagementApiSetPasswordRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PasswordChangeResponse> {
            return localVarFp.setPassword(requestParameters.passwordChangeRequest, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPasswordChangeStatus operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiGetPasswordChangeStatusRequest
 */
export interface PasswordManagementApiGetPasswordChangeStatusRequest {
    /**
     * Password change request ID
     * @type {string}
     * @memberof PasswordManagementApiGetPasswordChangeStatus
     */
    readonly id: string
}

/**
 * Request parameters for queryPasswordInfo operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiQueryPasswordInfoRequest
 */
export interface PasswordManagementApiQueryPasswordInfoRequest {
    /**
     * 
     * @type {PasswordInfoQueryDTO}
     * @memberof PasswordManagementApiQueryPasswordInfo
     */
    readonly passwordInfoQueryDTO: PasswordInfoQueryDTO
}

/**
 * Request parameters for setPassword operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiSetPasswordRequest
 */
export interface PasswordManagementApiSetPasswordRequest {
    /**
     * 
     * @type {PasswordChangeRequest}
     * @memberof PasswordManagementApiSetPassword
     */
    readonly passwordChangeRequest: PasswordChangeRequest
}

/**
 * PasswordManagementApi - object-oriented interface
 * @export
 * @class PasswordManagementApi
 * @extends {BaseAPI}
 */
export class PasswordManagementApi extends BaseAPI {
    /**
     * This API returns the status of a password change request.
     * @summary Get Password Change Request Status
     * @param {PasswordManagementApiGetPasswordChangeStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public getPasswordChangeStatus(requestParameters: PasswordManagementApiGetPasswordChangeStatusRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).getPasswordChangeStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to query password related information.  
     * @summary Query Password Info
     * @param {PasswordManagementApiQueryPasswordInfoRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public queryPasswordInfo(requestParameters: PasswordManagementApiQueryPasswordInfoRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).queryPasswordInfo(requestParameters.passwordInfoQueryDTO, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their ISC user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  >**Note: If you want to set an identity\'s source account password, you must enable `PASSWORD` as one of the source\'s features. You can use the [PATCH Source endpoint](https://developer.sailpoint.com/docs/api/v3/update-source) to add the `PASSWORD` feature.**  To generate the encryptedPassword (RSA encrypted using publicKey) for the request body, run the following command:  ```bash echo -n \"myPassword\" | openssl pkeyutl -encrypt -inkey public_key.pem -pubin | base64 ```  In this example, myPassword is the plain text password being set and encrypted, and public_key.pem is the path to the public key file. You can retrieve the required publicKey, along with other information like identityId, sourceId, publicKeyId, accounts, and policies, using the Query Password Info endpoint.  To successfully run this command, you must have OpenSSL installed on your machine. If OpenSSL is unavailable, consider using the Virtual Appliance (VA), which has OpenSSL pre-installed and configured.  If you are using a Windows machine, refer to this [guide](https://tecadmin.net/install-openssl-on-windows/) for instructions on installing OpenSSL.  You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
     * @summary Set Identity\'s Password
     * @param {PasswordManagementApiSetPasswordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public setPassword(requestParameters: PasswordManagementApiSetPasswordRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).setPassword(requestParameters.passwordChangeRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasswordPoliciesApi - axios parameter creator
 * @export
 */
export const PasswordPoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates the specified password policy.
         * @summary Create Password Policy
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordPolicy: async (passwordPolicyV3Dto: PasswordPolicyV3Dto, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordPolicyV3Dto' is not null or undefined
            assertParamExists('createPasswordPolicy', 'passwordPolicyV3Dto', passwordPolicyV3Dto)
            const localVarPath = `/password-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordPolicyV3Dto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes the specified password policy.
         * @summary Delete Password Policy by ID
         * @param {string} id The ID of password policy to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordPolicy: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePasswordPolicy', 'id', id)
            const localVarPath = `/password-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the password policy for the specified ID.
         * @summary Get Password Policy by ID
         * @param {string} id The ID of password policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordPolicyById: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPasswordPolicyById', 'id', id)
            const localVarPath = `/password-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets list of all Password Policies. Requires role of ORG_ADMIN
         * @summary List Password Policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPasswordPolicies: async (limit?: number, offset?: number, count?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates the specified password policy.
         * @summary Update Password Policy by ID
         * @param {string} id The ID of password policy to update.
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPasswordPolicy: async (id: string, passwordPolicyV3Dto: PasswordPolicyV3Dto, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setPasswordPolicy', 'id', id)
            // verify required parameter 'passwordPolicyV3Dto' is not null or undefined
            assertParamExists('setPasswordPolicy', 'passwordPolicyV3Dto', passwordPolicyV3Dto)
            const localVarPath = `/password-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordPolicyV3Dto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordPoliciesApi - functional programming interface
 * @export
 */
export const PasswordPoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordPoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates the specified password policy.
         * @summary Create Password Policy
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPasswordPolicy(passwordPolicyV3Dto: PasswordPolicyV3Dto, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordPolicyV3Dto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPasswordPolicy(passwordPolicyV3Dto, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordPoliciesApi.createPasswordPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API deletes the specified password policy.
         * @summary Delete Password Policy by ID
         * @param {string} id The ID of password policy to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePasswordPolicy(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePasswordPolicy(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordPoliciesApi.deletePasswordPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the password policy for the specified ID.
         * @summary Get Password Policy by ID
         * @param {string} id The ID of password policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordPolicyById(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordPolicyV3Dto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordPolicyById(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordPoliciesApi.getPasswordPolicyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets list of all Password Policies. Requires role of ORG_ADMIN
         * @summary List Password Policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPasswordPolicies(limit?: number, offset?: number, count?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PasswordPolicyV3Dto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPasswordPolicies(limit, offset, count, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordPoliciesApi.listPasswordPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API updates the specified password policy.
         * @summary Update Password Policy by ID
         * @param {string} id The ID of password policy to update.
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setPasswordPolicy(id: string, passwordPolicyV3Dto: PasswordPolicyV3Dto, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordPolicyV3Dto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPasswordPolicy(id, passwordPolicyV3Dto, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordPoliciesApi.setPasswordPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PasswordPoliciesApi - factory interface
 * @export
 */
export const PasswordPoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordPoliciesApiFp(configuration)
    return {
        /**
         * This API creates the specified password policy.
         * @summary Create Password Policy
         * @param {PasswordPoliciesApiCreatePasswordPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordPolicy(requestParameters: PasswordPoliciesApiCreatePasswordPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PasswordPolicyV3Dto> {
            return localVarFp.createPasswordPolicy(requestParameters.passwordPolicyV3Dto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes the specified password policy.
         * @summary Delete Password Policy by ID
         * @param {PasswordPoliciesApiDeletePasswordPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordPolicy(requestParameters: PasswordPoliciesApiDeletePasswordPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePasswordPolicy(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the password policy for the specified ID.
         * @summary Get Password Policy by ID
         * @param {PasswordPoliciesApiGetPasswordPolicyByIdRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordPolicyById(requestParameters: PasswordPoliciesApiGetPasswordPolicyByIdRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PasswordPolicyV3Dto> {
            return localVarFp.getPasswordPolicyById(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets list of all Password Policies. Requires role of ORG_ADMIN
         * @summary List Password Policies
         * @param {PasswordPoliciesApiListPasswordPoliciesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPasswordPolicies(requestParameters: PasswordPoliciesApiListPasswordPoliciesRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<PasswordPolicyV3Dto>> {
            return localVarFp.listPasswordPolicies(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates the specified password policy.
         * @summary Update Password Policy by ID
         * @param {PasswordPoliciesApiSetPasswordPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPasswordPolicy(requestParameters: PasswordPoliciesApiSetPasswordPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PasswordPolicyV3Dto> {
            return localVarFp.setPasswordPolicy(requestParameters.id, requestParameters.passwordPolicyV3Dto, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPasswordPolicy operation in PasswordPoliciesApi.
 * @export
 * @interface PasswordPoliciesApiCreatePasswordPolicyRequest
 */
export interface PasswordPoliciesApiCreatePasswordPolicyRequest {
    /**
     * 
     * @type {PasswordPolicyV3Dto}
     * @memberof PasswordPoliciesApiCreatePasswordPolicy
     */
    readonly passwordPolicyV3Dto: PasswordPolicyV3Dto
}

/**
 * Request parameters for deletePasswordPolicy operation in PasswordPoliciesApi.
 * @export
 * @interface PasswordPoliciesApiDeletePasswordPolicyRequest
 */
export interface PasswordPoliciesApiDeletePasswordPolicyRequest {
    /**
     * The ID of password policy to delete.
     * @type {string}
     * @memberof PasswordPoliciesApiDeletePasswordPolicy
     */
    readonly id: string
}

/**
 * Request parameters for getPasswordPolicyById operation in PasswordPoliciesApi.
 * @export
 * @interface PasswordPoliciesApiGetPasswordPolicyByIdRequest
 */
export interface PasswordPoliciesApiGetPasswordPolicyByIdRequest {
    /**
     * The ID of password policy to retrieve.
     * @type {string}
     * @memberof PasswordPoliciesApiGetPasswordPolicyById
     */
    readonly id: string
}

/**
 * Request parameters for listPasswordPolicies operation in PasswordPoliciesApi.
 * @export
 * @interface PasswordPoliciesApiListPasswordPoliciesRequest
 */
export interface PasswordPoliciesApiListPasswordPoliciesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordPoliciesApiListPasswordPolicies
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordPoliciesApiListPasswordPolicies
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof PasswordPoliciesApiListPasswordPolicies
     */
    readonly count?: boolean
}

/**
 * Request parameters for setPasswordPolicy operation in PasswordPoliciesApi.
 * @export
 * @interface PasswordPoliciesApiSetPasswordPolicyRequest
 */
export interface PasswordPoliciesApiSetPasswordPolicyRequest {
    /**
     * The ID of password policy to update.
     * @type {string}
     * @memberof PasswordPoliciesApiSetPasswordPolicy
     */
    readonly id: string

    /**
     * 
     * @type {PasswordPolicyV3Dto}
     * @memberof PasswordPoliciesApiSetPasswordPolicy
     */
    readonly passwordPolicyV3Dto: PasswordPolicyV3Dto
}

/**
 * PasswordPoliciesApi - object-oriented interface
 * @export
 * @class PasswordPoliciesApi
 * @extends {BaseAPI}
 */
export class PasswordPoliciesApi extends BaseAPI {
    /**
     * This API creates the specified password policy.
     * @summary Create Password Policy
     * @param {PasswordPoliciesApiCreatePasswordPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    public createPasswordPolicy(requestParameters: PasswordPoliciesApiCreatePasswordPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordPoliciesApiFp(this.configuration).createPasswordPolicy(requestParameters.passwordPolicyV3Dto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes the specified password policy.
     * @summary Delete Password Policy by ID
     * @param {PasswordPoliciesApiDeletePasswordPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    public deletePasswordPolicy(requestParameters: PasswordPoliciesApiDeletePasswordPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordPoliciesApiFp(this.configuration).deletePasswordPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the password policy for the specified ID.
     * @summary Get Password Policy by ID
     * @param {PasswordPoliciesApiGetPasswordPolicyByIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    public getPasswordPolicyById(requestParameters: PasswordPoliciesApiGetPasswordPolicyByIdRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordPoliciesApiFp(this.configuration).getPasswordPolicyById(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets list of all Password Policies. Requires role of ORG_ADMIN
     * @summary List Password Policies
     * @param {PasswordPoliciesApiListPasswordPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    public listPasswordPolicies(requestParameters: PasswordPoliciesApiListPasswordPoliciesRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordPoliciesApiFp(this.configuration).listPasswordPolicies(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates the specified password policy.
     * @summary Update Password Policy by ID
     * @param {PasswordPoliciesApiSetPasswordPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    public setPasswordPolicy(requestParameters: PasswordPoliciesApiSetPasswordPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordPoliciesApiFp(this.configuration).setPasswordPolicy(requestParameters.id, requestParameters.passwordPolicyV3Dto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasswordSyncGroupsApi - axios parameter creator
 * @export
 */
export const PasswordSyncGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a password sync group based on the specifications provided.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordSyncGroup: async (passwordSyncGroup: PasswordSyncGroup, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordSyncGroup' is not null or undefined
            assertParamExists('createPasswordSyncGroup', 'passwordSyncGroup', passwordSyncGroup)
            const localVarPath = `/password-sync-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordSyncGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes the specified password sync group.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordSyncGroup: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePasswordSyncGroup', 'id', id)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the sync group for the specified ID.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroup: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPasswordSyncGroup', 'id', id)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of password sync groups.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroups: async (limit?: number, offset?: number, count?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-sync-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates the specified password sync group.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSyncGroup: async (id: string, passwordSyncGroup: PasswordSyncGroup, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePasswordSyncGroup', 'id', id)
            // verify required parameter 'passwordSyncGroup' is not null or undefined
            assertParamExists('updatePasswordSyncGroup', 'passwordSyncGroup', passwordSyncGroup)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordSyncGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordSyncGroupsApi - functional programming interface
 * @export
 */
export const PasswordSyncGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordSyncGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a password sync group based on the specifications provided.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPasswordSyncGroup(passwordSyncGroup: PasswordSyncGroup, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPasswordSyncGroup(passwordSyncGroup, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordSyncGroupsApi.createPasswordSyncGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API deletes the specified password sync group.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePasswordSyncGroup(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePasswordSyncGroup(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordSyncGroupsApi.deletePasswordSyncGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the sync group for the specified ID.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordSyncGroup(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordSyncGroup(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordSyncGroupsApi.getPasswordSyncGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns a list of password sync groups.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordSyncGroups(limit?: number, offset?: number, count?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PasswordSyncGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordSyncGroups(limit, offset, count, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordSyncGroupsApi.getPasswordSyncGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API updates the specified password sync group.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasswordSyncGroup(id: string, passwordSyncGroup: PasswordSyncGroup, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasswordSyncGroup(id, passwordSyncGroup, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordSyncGroupsApi.updatePasswordSyncGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PasswordSyncGroupsApi - factory interface
 * @export
 */
export const PasswordSyncGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordSyncGroupsApiFp(configuration)
    return {
        /**
         * This API creates a password sync group based on the specifications provided.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroupsApiCreatePasswordSyncGroupRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordSyncGroup(requestParameters: PasswordSyncGroupsApiCreatePasswordSyncGroupRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PasswordSyncGroup> {
            return localVarFp.createPasswordSyncGroup(requestParameters.passwordSyncGroup, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes the specified password sync group.
         * @summary Delete Password Sync Group by ID
         * @param {PasswordSyncGroupsApiDeletePasswordSyncGroupRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordSyncGroup(requestParameters: PasswordSyncGroupsApiDeletePasswordSyncGroupRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePasswordSyncGroup(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the sync group for the specified ID.
         * @summary Get Password Sync Group by ID
         * @param {PasswordSyncGroupsApiGetPasswordSyncGroupRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroup(requestParameters: PasswordSyncGroupsApiGetPasswordSyncGroupRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PasswordSyncGroup> {
            return localVarFp.getPasswordSyncGroup(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of password sync groups.
         * @summary Get Password Sync Group List
         * @param {PasswordSyncGroupsApiGetPasswordSyncGroupsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroups(requestParameters: PasswordSyncGroupsApiGetPasswordSyncGroupsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<PasswordSyncGroup>> {
            return localVarFp.getPasswordSyncGroups(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates the specified password sync group.
         * @summary Update Password Sync Group by ID
         * @param {PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSyncGroup(requestParameters: PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PasswordSyncGroup> {
            return localVarFp.updatePasswordSyncGroup(requestParameters.id, requestParameters.passwordSyncGroup, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiCreatePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiCreatePasswordSyncGroupRequest {
    /**
     * 
     * @type {PasswordSyncGroup}
     * @memberof PasswordSyncGroupsApiCreatePasswordSyncGroup
     */
    readonly passwordSyncGroup: PasswordSyncGroup
}

/**
 * Request parameters for deletePasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiDeletePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiDeletePasswordSyncGroupRequest {
    /**
     * The ID of password sync group to delete.
     * @type {string}
     * @memberof PasswordSyncGroupsApiDeletePasswordSyncGroup
     */
    readonly id: string
}

/**
 * Request parameters for getPasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiGetPasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiGetPasswordSyncGroupRequest {
    /**
     * The ID of password sync group to retrieve.
     * @type {string}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroup
     */
    readonly id: string
}

/**
 * Request parameters for getPasswordSyncGroups operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiGetPasswordSyncGroupsRequest
 */
export interface PasswordSyncGroupsApiGetPasswordSyncGroupsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroups
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroups
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroups
     */
    readonly count?: boolean
}

/**
 * Request parameters for updatePasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest {
    /**
     * The ID of password sync group to update.
     * @type {string}
     * @memberof PasswordSyncGroupsApiUpdatePasswordSyncGroup
     */
    readonly id: string

    /**
     * 
     * @type {PasswordSyncGroup}
     * @memberof PasswordSyncGroupsApiUpdatePasswordSyncGroup
     */
    readonly passwordSyncGroup: PasswordSyncGroup
}

/**
 * PasswordSyncGroupsApi - object-oriented interface
 * @export
 * @class PasswordSyncGroupsApi
 * @extends {BaseAPI}
 */
export class PasswordSyncGroupsApi extends BaseAPI {
    /**
     * This API creates a password sync group based on the specifications provided.
     * @summary Create Password Sync Group
     * @param {PasswordSyncGroupsApiCreatePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public createPasswordSyncGroup(requestParameters: PasswordSyncGroupsApiCreatePasswordSyncGroupRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).createPasswordSyncGroup(requestParameters.passwordSyncGroup, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes the specified password sync group.
     * @summary Delete Password Sync Group by ID
     * @param {PasswordSyncGroupsApiDeletePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public deletePasswordSyncGroup(requestParameters: PasswordSyncGroupsApiDeletePasswordSyncGroupRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).deletePasswordSyncGroup(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the sync group for the specified ID.
     * @summary Get Password Sync Group by ID
     * @param {PasswordSyncGroupsApiGetPasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public getPasswordSyncGroup(requestParameters: PasswordSyncGroupsApiGetPasswordSyncGroupRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).getPasswordSyncGroup(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of password sync groups.
     * @summary Get Password Sync Group List
     * @param {PasswordSyncGroupsApiGetPasswordSyncGroupsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public getPasswordSyncGroups(requestParameters: PasswordSyncGroupsApiGetPasswordSyncGroupsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).getPasswordSyncGroups(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates the specified password sync group.
     * @summary Update Password Sync Group by ID
     * @param {PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public updatePasswordSyncGroup(requestParameters: PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).updatePasswordSyncGroup(requestParameters.id, requestParameters.passwordSyncGroup, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonalAccessTokensApi - axios parameter creator
 * @export
 */
export const PersonalAccessTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken: async (createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonalAccessTokenRequest' is not null or undefined
            assertParamExists('createPersonalAccessToken', 'createPersonalAccessTokenRequest', createPersonalAccessTokenRequest)
            const localVarPath = `/personal-access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonalAccessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePersonalAccessToken', 'id', id)
            const localVarPath = `/personal-access-tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens: async (ownerId?: string, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personal-access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token. Changing scopes for a Personal Access Token does not impact existing bearer tokens. You will need to create a new bearer token to have the new scopes. Please note that it can take up to 20 minutes for scope changes to be seen on new bearer tokens.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchPersonalAccessToken', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchPersonalAccessToken', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/personal-access-tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonalAccessTokensApi - functional programming interface
 * @export
 */
export const PersonalAccessTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonalAccessTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPersonalAccessToken(createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersonalAccessToken(createPersonalAccessTokenRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalAccessTokensApi.createPersonalAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePersonalAccessToken(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonalAccessToken(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalAccessTokensApi.deletePersonalAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonalAccessTokens(ownerId?: string, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPersonalAccessTokenResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonalAccessTokens(ownerId, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalAccessTokensApi.listPersonalAccessTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token. Changing scopes for a Personal Access Token does not impact existing bearer tokens. You will need to create a new bearer token to have the new scopes. Please note that it can take up to 20 minutes for scope changes to be seen on new bearer tokens.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchPersonalAccessToken(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchPersonalAccessToken(id, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalAccessTokensApi.patchPersonalAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonalAccessTokensApi - factory interface
 * @export
 */
export const PersonalAccessTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonalAccessTokensApiFp(configuration)
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {PersonalAccessTokensApiCreatePersonalAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken(requestParameters: PersonalAccessTokensApiCreatePersonalAccessTokenRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CreatePersonalAccessTokenResponse> {
            return localVarFp.createPersonalAccessToken(requestParameters.createPersonalAccessTokenRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {PersonalAccessTokensApiDeletePersonalAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken(requestParameters: PersonalAccessTokensApiDeletePersonalAccessTokenRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePersonalAccessToken(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {PersonalAccessTokensApiListPersonalAccessTokensRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens(requestParameters: PersonalAccessTokensApiListPersonalAccessTokensRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<GetPersonalAccessTokenResponse>> {
            return localVarFp.listPersonalAccessTokens(requestParameters.ownerId, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token. Changing scopes for a Personal Access Token does not impact existing bearer tokens. You will need to create a new bearer token to have the new scopes. Please note that it can take up to 20 minutes for scope changes to be seen on new bearer tokens.
         * @summary Patch Personal Access Token
         * @param {PersonalAccessTokensApiPatchPersonalAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken(requestParameters: PersonalAccessTokensApiPatchPersonalAccessTokenRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<GetPersonalAccessTokenResponse> {
            return localVarFp.patchPersonalAccessToken(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiCreatePersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiCreatePersonalAccessTokenRequest {
    /**
     * Name and scope of personal access token.
     * @type {CreatePersonalAccessTokenRequest}
     * @memberof PersonalAccessTokensApiCreatePersonalAccessToken
     */
    readonly createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest
}

/**
 * Request parameters for deletePersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiDeletePersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiDeletePersonalAccessTokenRequest {
    /**
     * The personal access token id
     * @type {string}
     * @memberof PersonalAccessTokensApiDeletePersonalAccessToken
     */
    readonly id: string
}

/**
 * Request parameters for listPersonalAccessTokens operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiListPersonalAccessTokensRequest
 */
export interface PersonalAccessTokensApiListPersonalAccessTokensRequest {
    /**
     * The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
     * @type {string}
     * @memberof PersonalAccessTokensApiListPersonalAccessTokens
     */
    readonly ownerId?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
     * @type {string}
     * @memberof PersonalAccessTokensApiListPersonalAccessTokens
     */
    readonly filters?: string
}

/**
 * Request parameters for patchPersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiPatchPersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiPatchPersonalAccessTokenRequest {
    /**
     * The Personal Access Token id
     * @type {string}
     * @memberof PersonalAccessTokensApiPatchPersonalAccessToken
     */
    readonly id: string

    /**
     * A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
     * @type {Array<JsonPatchOperation>}
     * @memberof PersonalAccessTokensApiPatchPersonalAccessToken
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * PersonalAccessTokensApi - object-oriented interface
 * @export
 * @class PersonalAccessTokensApi
 * @extends {BaseAPI}
 */
export class PersonalAccessTokensApi extends BaseAPI {
    /**
     * This creates a personal access token.
     * @summary Create Personal Access Token
     * @param {PersonalAccessTokensApiCreatePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public createPersonalAccessToken(requestParameters: PersonalAccessTokensApiCreatePersonalAccessTokenRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).createPersonalAccessToken(requestParameters.createPersonalAccessTokenRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a personal access token.
     * @summary Delete Personal Access Token
     * @param {PersonalAccessTokensApiDeletePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public deletePersonalAccessToken(requestParameters: PersonalAccessTokensApiDeletePersonalAccessTokenRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).deletePersonalAccessToken(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
     * @summary List Personal Access Tokens
     * @param {PersonalAccessTokensApiListPersonalAccessTokensRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public listPersonalAccessTokens(requestParameters: PersonalAccessTokensApiListPersonalAccessTokensRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).listPersonalAccessTokens(requestParameters.ownerId, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This performs a targeted update to the field(s) of a Personal Access Token. Changing scopes for a Personal Access Token does not impact existing bearer tokens. You will need to create a new bearer token to have the new scopes. Please note that it can take up to 20 minutes for scope changes to be seen on new bearer tokens.
     * @summary Patch Personal Access Token
     * @param {PersonalAccessTokensApiPatchPersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public patchPersonalAccessToken(requestParameters: PersonalAccessTokensApiPatchPersonalAccessTokenRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).patchPersonalAccessToken(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicIdentitiesApi - axios parameter creator
 * @export
 */
export const PublicIdentitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of public identities.  Set `add-core-filters` to `true` to exclude incomplete identities and uncorrelated accounts.
         * @summary Get list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentities: async (limit?: number, offset?: number, count?: boolean, filters?: string, addCoreFilters?: boolean, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public-identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:default"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:default"], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (addCoreFilters !== undefined) {
                localVarQueryParameter['add-core-filters'] = addCoreFilters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicIdentitiesApi - functional programming interface
 * @export
 */
export const PublicIdentitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicIdentitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of public identities.  Set `add-core-filters` to `true` to exclude incomplete identities and uncorrelated accounts.
         * @summary Get list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicIdentities(limit?: number, offset?: number, count?: boolean, filters?: string, addCoreFilters?: boolean, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicIdentity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicIdentities(limit, offset, count, filters, addCoreFilters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicIdentitiesApi.getPublicIdentities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicIdentitiesApi - factory interface
 * @export
 */
export const PublicIdentitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicIdentitiesApiFp(configuration)
    return {
        /**
         * Get a list of public identities.  Set `add-core-filters` to `true` to exclude incomplete identities and uncorrelated accounts.
         * @summary Get list of public identities
         * @param {PublicIdentitiesApiGetPublicIdentitiesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentities(requestParameters: PublicIdentitiesApiGetPublicIdentitiesRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<PublicIdentity>> {
            return localVarFp.getPublicIdentities(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.addCoreFilters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPublicIdentities operation in PublicIdentitiesApi.
 * @export
 * @interface PublicIdentitiesApiGetPublicIdentitiesRequest
 */
export interface PublicIdentitiesApiGetPublicIdentitiesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
     * @type {string}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly filters?: string

    /**
     * If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
     * @type {boolean}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly addCoreFilters?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly sorters?: string
}

/**
 * PublicIdentitiesApi - object-oriented interface
 * @export
 * @class PublicIdentitiesApi
 * @extends {BaseAPI}
 */
export class PublicIdentitiesApi extends BaseAPI {
    /**
     * Get a list of public identities.  Set `add-core-filters` to `true` to exclude incomplete identities and uncorrelated accounts.
     * @summary Get list of public identities
     * @param {PublicIdentitiesApiGetPublicIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesApi
     */
    public getPublicIdentities(requestParameters: PublicIdentitiesApiGetPublicIdentitiesRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return PublicIdentitiesApiFp(this.configuration).getPublicIdentities(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.addCoreFilters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicIdentitiesConfigApi - axios parameter creator
 * @export
 */
export const PublicIdentitiesConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public-identities-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig: async (publicIdentityConfig: PublicIdentityConfig, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicIdentityConfig' is not null or undefined
            assertParamExists('updatePublicIdentityConfig', 'publicIdentityConfig', publicIdentityConfig)
            const localVarPath = `/public-identities-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicIdentityConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicIdentitiesConfigApi - functional programming interface
 * @export
 */
export const PublicIdentitiesConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicIdentitiesConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicIdentityConfig(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIdentityConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicIdentityConfig(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicIdentitiesConfigApi.getPublicIdentityConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicIdentityConfig(publicIdentityConfig: PublicIdentityConfig, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIdentityConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicIdentityConfig(publicIdentityConfig, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicIdentitiesConfigApi.updatePublicIdentityConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicIdentitiesConfigApi - factory interface
 * @export
 */
export const PublicIdentitiesConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicIdentitiesConfigApiFp(configuration)
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PublicIdentityConfig> {
            return localVarFp.getPublicIdentityConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig(requestParameters: PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<PublicIdentityConfig> {
            return localVarFp.updatePublicIdentityConfig(requestParameters.publicIdentityConfig, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updatePublicIdentityConfig operation in PublicIdentitiesConfigApi.
 * @export
 * @interface PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest
 */
export interface PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest {
    /**
     * 
     * @type {PublicIdentityConfig}
     * @memberof PublicIdentitiesConfigApiUpdatePublicIdentityConfig
     */
    readonly publicIdentityConfig: PublicIdentityConfig
}

/**
 * PublicIdentitiesConfigApi - object-oriented interface
 * @export
 * @class PublicIdentitiesConfigApi
 * @extends {BaseAPI}
 */
export class PublicIdentitiesConfigApi extends BaseAPI {
    /**
     * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns.
     * @summary Get the Public Identities Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigApi
     */
    public getPublicIdentityConfig(axiosOptions?: RawAxiosRequestConfig) {
        return PublicIdentitiesConfigApiFp(this.configuration).getPublicIdentityConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns.
     * @summary Update the Public Identities Configuration
     * @param {PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigApi
     */
    public updatePublicIdentityConfig(requestParameters: PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return PublicIdentitiesConfigApiFp(this.configuration).updatePublicIdentityConfig(requestParameters.publicIdentityConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportsDataExtractionApi - axios parameter creator
 * @export
 */
export const ReportsDataExtractionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels a running report.
         * @summary Cancel Report
         * @param {string} id ID of the running Report to cancel
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelReport', 'id', id)
            const localVarPath = `/reports/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a report in file format.
         * @summary Get Report File
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {GetReportFileFormatV3} fileFormat Output format of the requested report file
         * @param {string} [name] preferred Report file name, by default will be used report name from task result.
         * @param {boolean} [auditable] Enables auditing for current report download. Will create an audit event and sent it to the REPORT cloud-audit kafka topic.  Event will be created if there is any result present by requested taskResultId.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (taskResultId: string, fileFormat: GetReportFileFormatV3, name?: string, auditable?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskResultId' is not null or undefined
            assertParamExists('getReport', 'taskResultId', taskResultId)
            // verify required parameter 'fileFormat' is not null or undefined
            assertParamExists('getReport', 'fileFormat', fileFormat)
            const localVarPath = `/reports/{taskResultId}`
                .replace(`{${"taskResultId"}}`, encodeURIComponent(String(taskResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (fileFormat !== undefined) {
                localVarQueryParameter['fileFormat'] = fileFormat;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (auditable !== undefined) {
                localVarQueryParameter['auditable'] = auditable;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
         * @summary Get Report Result
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {boolean} [completed] state of task result to apply ordering when results are fetching from the DB
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReportResult: async (taskResultId: string, completed?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskResultId' is not null or undefined
            assertParamExists('getReportResult', 'taskResultId', taskResultId)
            const localVarPath = `/reports/{taskResultId}/result`
                .replace(`{${"taskResultId"}}`, encodeURIComponent(String(taskResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (completed !== undefined) {
                localVarQueryParameter['completed'] = completed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to run a report according to report input details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
         * @summary Run Report
         * @param {ReportDetails} reportDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startReport: async (reportDetails: ReportDetails, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportDetails' is not null or undefined
            assertParamExists('startReport', 'reportDetails', reportDetails)
            const localVarPath = `/reports/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsDataExtractionApi - functional programming interface
 * @export
 */
export const ReportsDataExtractionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsDataExtractionApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels a running report.
         * @summary Cancel Report
         * @param {string} id ID of the running Report to cancel
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelReport(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelReport(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsDataExtractionApi.cancelReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a report in file format.
         * @summary Get Report File
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {GetReportFileFormatV3} fileFormat Output format of the requested report file
         * @param {string} [name] preferred Report file name, by default will be used report name from task result.
         * @param {boolean} [auditable] Enables auditing for current report download. Will create an audit event and sent it to the REPORT cloud-audit kafka topic.  Event will be created if there is any result present by requested taskResultId.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(taskResultId: string, fileFormat: GetReportFileFormatV3, name?: string, auditable?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(taskResultId, fileFormat, name, auditable, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsDataExtractionApi.getReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
         * @summary Get Report Result
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {boolean} [completed] state of task result to apply ordering when results are fetching from the DB
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getReportResult(taskResultId: string, completed?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReportResult(taskResultId, completed, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsDataExtractionApi.getReportResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to run a report according to report input details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
         * @summary Run Report
         * @param {ReportDetails} reportDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startReport(reportDetails: ReportDetails, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResultDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startReport(reportDetails, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsDataExtractionApi.startReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportsDataExtractionApi - factory interface
 * @export
 */
export const ReportsDataExtractionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsDataExtractionApiFp(configuration)
    return {
        /**
         * Cancels a running report.
         * @summary Cancel Report
         * @param {ReportsDataExtractionApiCancelReportRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport(requestParameters: ReportsDataExtractionApiCancelReportRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelReport(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a report in file format.
         * @summary Get Report File
         * @param {ReportsDataExtractionApiGetReportRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReport(requestParameters: ReportsDataExtractionApiGetReportRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getReport(requestParameters.taskResultId, requestParameters.fileFormat, requestParameters.name, requestParameters.auditable, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
         * @summary Get Report Result
         * @param {ReportsDataExtractionApiGetReportResultRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReportResult(requestParameters: ReportsDataExtractionApiGetReportResultRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ReportResults> {
            return localVarFp.getReportResult(requestParameters.taskResultId, requestParameters.completed, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to run a report according to report input details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
         * @summary Run Report
         * @param {ReportsDataExtractionApiStartReportRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startReport(requestParameters: ReportsDataExtractionApiStartReportRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<TaskResultDetails> {
            return localVarFp.startReport(requestParameters.reportDetails, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelReport operation in ReportsDataExtractionApi.
 * @export
 * @interface ReportsDataExtractionApiCancelReportRequest
 */
export interface ReportsDataExtractionApiCancelReportRequest {
    /**
     * ID of the running Report to cancel
     * @type {string}
     * @memberof ReportsDataExtractionApiCancelReport
     */
    readonly id: string
}

/**
 * Request parameters for getReport operation in ReportsDataExtractionApi.
 * @export
 * @interface ReportsDataExtractionApiGetReportRequest
 */
export interface ReportsDataExtractionApiGetReportRequest {
    /**
     * Unique identifier of the task result which handled report
     * @type {string}
     * @memberof ReportsDataExtractionApiGetReport
     */
    readonly taskResultId: string

    /**
     * Output format of the requested report file
     * @type {'csv' | 'pdf'}
     * @memberof ReportsDataExtractionApiGetReport
     */
    readonly fileFormat: GetReportFileFormatV3

    /**
     * preferred Report file name, by default will be used report name from task result.
     * @type {string}
     * @memberof ReportsDataExtractionApiGetReport
     */
    readonly name?: string

    /**
     * Enables auditing for current report download. Will create an audit event and sent it to the REPORT cloud-audit kafka topic.  Event will be created if there is any result present by requested taskResultId.
     * @type {boolean}
     * @memberof ReportsDataExtractionApiGetReport
     */
    readonly auditable?: boolean
}

/**
 * Request parameters for getReportResult operation in ReportsDataExtractionApi.
 * @export
 * @interface ReportsDataExtractionApiGetReportResultRequest
 */
export interface ReportsDataExtractionApiGetReportResultRequest {
    /**
     * Unique identifier of the task result which handled report
     * @type {string}
     * @memberof ReportsDataExtractionApiGetReportResult
     */
    readonly taskResultId: string

    /**
     * state of task result to apply ordering when results are fetching from the DB
     * @type {boolean}
     * @memberof ReportsDataExtractionApiGetReportResult
     */
    readonly completed?: boolean
}

/**
 * Request parameters for startReport operation in ReportsDataExtractionApi.
 * @export
 * @interface ReportsDataExtractionApiStartReportRequest
 */
export interface ReportsDataExtractionApiStartReportRequest {
    /**
     * 
     * @type {ReportDetails}
     * @memberof ReportsDataExtractionApiStartReport
     */
    readonly reportDetails: ReportDetails
}

/**
 * ReportsDataExtractionApi - object-oriented interface
 * @export
 * @class ReportsDataExtractionApi
 * @extends {BaseAPI}
 */
export class ReportsDataExtractionApi extends BaseAPI {
    /**
     * Cancels a running report.
     * @summary Cancel Report
     * @param {ReportsDataExtractionApiCancelReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    public cancelReport(requestParameters: ReportsDataExtractionApiCancelReportRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ReportsDataExtractionApiFp(this.configuration).cancelReport(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a report in file format.
     * @summary Get Report File
     * @param {ReportsDataExtractionApiGetReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    public getReport(requestParameters: ReportsDataExtractionApiGetReportRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ReportsDataExtractionApiFp(this.configuration).getReport(requestParameters.taskResultId, requestParameters.fileFormat, requestParameters.name, requestParameters.auditable, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
     * @summary Get Report Result
     * @param {ReportsDataExtractionApiGetReportResultRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    public getReportResult(requestParameters: ReportsDataExtractionApiGetReportResultRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ReportsDataExtractionApiFp(this.configuration).getReportResult(requestParameters.taskResultId, requestParameters.completed, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to run a report according to report input details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
     * @summary Run Report
     * @param {ReportsDataExtractionApiStartReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    public startReport(requestParameters: ReportsDataExtractionApiStartReportRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ReportsDataExtractionApiFp(this.configuration).startReport(requestParameters.reportDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetReportFileFormatV3 = {
    Csv: 'csv',
    Pdf: 'pdf'
} as const;
export type GetReportFileFormatV3 = typeof GetReportFileFormatV3[keyof typeof GetReportFileFormatV3];


/**
 * RequestableObjectsApi - axios parameter creator
 * @export
 */
export const RequestableObjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects: async (identityId?: string, types?: Array<RequestableObjectType>, term?: string, statuses?: Array<RequestableObjectRequestStatus>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/requestable-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (identityId !== undefined) {
                localVarQueryParameter['identity-id'] = identityId;
            }

            if (types) {
                localVarQueryParameter['types'] = types.join(COLLECTION_FORMATS.csv);
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequestableObjectsApi - functional programming interface
 * @export
 */
export const RequestableObjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RequestableObjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listRequestableObjects(identityId?: string, types?: Array<RequestableObjectType>, term?: string, statuses?: Array<RequestableObjectRequestStatus>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RequestableObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRequestableObjects(identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RequestableObjectsApi.listRequestableObjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RequestableObjectsApi - factory interface
 * @export
 */
export const RequestableObjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RequestableObjectsApiFp(configuration)
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items.
         * @summary Requestable Objects List
         * @param {RequestableObjectsApiListRequestableObjectsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects(requestParameters: RequestableObjectsApiListRequestableObjectsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<RequestableObject>> {
            return localVarFp.listRequestableObjects(requestParameters.identityId, requestParameters.types, requestParameters.term, requestParameters.statuses, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listRequestableObjects operation in RequestableObjectsApi.
 * @export
 * @interface RequestableObjectsApiListRequestableObjectsRequest
 */
export interface RequestableObjectsApiListRequestableObjectsRequest {
    /**
     * If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly identityId?: string

    /**
     * Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
     * @type {Array<RequestableObjectType>}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly types?: Array<RequestableObjectType>

    /**
     * It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly term?: string

    /**
     * Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
     * @type {Array<RequestableObjectRequestStatus>}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly statuses?: Array<RequestableObjectRequestStatus>

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly sorters?: string
}

/**
 * RequestableObjectsApi - object-oriented interface
 * @export
 * @class RequestableObjectsApi
 * @extends {BaseAPI}
 */
export class RequestableObjectsApi extends BaseAPI {
    /**
     * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items.
     * @summary Requestable Objects List
     * @param {RequestableObjectsApiListRequestableObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestableObjectsApi
     */
    public listRequestableObjects(requestParameters: RequestableObjectsApiListRequestableObjectsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return RequestableObjectsApiFp(this.configuration).listRequestableObjects(requestParameters.identityId, requestParameters.types, requestParameters.term, requestParameters.statuses, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a role. In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.   The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {Role} role 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (role: Role, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('createRole', 'role', role)
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint initiates a bulk deletion of one or more roles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 roles per request.  A user with ROLE_SUBADMIN authority can only call this endpoint if all roles included in the request are associated with sources with management workgroups the ROLE_SUBADMIN is a member of.
         * @summary Delete Role(s)
         * @param {RoleBulkDeleteRequest} roleBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBulkRoles: async (roleBulkDeleteRequest: RoleBulkDeleteRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleBulkDeleteRequest' is not null or undefined
            assertParamExists('deleteBulkRoles', 'roleBulkDeleteRequest', roleBulkDeleteRequest)
            const localVarPath = `/roles/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleBulkDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes a Role by its ID.  A user with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a Role by its ID. A user with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, aliasName, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignedIdentities: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoleAssignedIdentities', 'id', id)
            const localVarPath = `/roles/{id}/assigned-identities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of Roles.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSegmentIds !== undefined) {
                localVarQueryParameter['for-segment-ids'] = forSegmentIds;
            }

            if (includeUnsegmented !== undefined) {
                localVarQueryParameter['include-unsegmented'] = includeUnsegmented;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax. The following fields are patchable: * name * description * enabled * owner * accessProfiles * entitlements * membership * requestable * accessRequestConfig * revokeRequestConfig * segments * accessModelMetadata  A user with ROLE_SUBADMIN authority may only call this API if all access profiles included in the role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.  When you use this API to modify a role\'s membership identities, you can only modify up to a limit of 500 membership identities at a time. 
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRole: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchRole', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchRole', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a role. In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.   The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {Role} role 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(role: Role, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(role, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.createRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint initiates a bulk deletion of one or more roles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 roles per request.  A user with ROLE_SUBADMIN authority can only call this endpoint if all roles included in the request are associated with sources with management workgroups the ROLE_SUBADMIN is a member of.
         * @summary Delete Role(s)
         * @param {RoleBulkDeleteRequest} roleBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBulkRoles(roleBulkDeleteRequest: RoleBulkDeleteRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBulkRoles(roleBulkDeleteRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.deleteBulkRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API deletes a Role by its ID.  A user with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.deleteRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns a Role by its ID. A user with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, aliasName, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleAssignedIdentities(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleIdentity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleAssignedIdentities(id, limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getRoleAssignedIdentities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns a list of Roles.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.listRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API updates an existing role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax. The following fields are patchable: * name * description * enabled * owner * accessProfiles * entitlements * membership * requestable * accessRequestConfig * revokeRequestConfig * segments * accessModelMetadata  A user with ROLE_SUBADMIN authority may only call this API if all access profiles included in the role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.  When you use this API to modify a role\'s membership identities, you can only modify up to a limit of 500 membership identities at a time. 
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchRole(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRole(id, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.patchRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * This API creates a role. In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.   The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {RolesApiCreateRoleRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRole(requestParameters: RolesApiCreateRoleRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Role> {
            return localVarFp.createRole(requestParameters.role, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint initiates a bulk deletion of one or more roles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 roles per request.  A user with ROLE_SUBADMIN authority can only call this endpoint if all roles included in the request are associated with sources with management workgroups the ROLE_SUBADMIN is a member of.
         * @summary Delete Role(s)
         * @param {RolesApiDeleteBulkRolesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBulkRoles(requestParameters: RolesApiDeleteBulkRolesRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<TaskResultDto> {
            return localVarFp.deleteBulkRoles(requestParameters.roleBulkDeleteRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes a Role by its ID.  A user with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(requestParameters: RolesApiDeleteRoleRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRole(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a Role by its ID. A user with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {RolesApiGetRoleRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRole(requestParameters: RolesApiGetRoleRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Role> {
            return localVarFp.getRole(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Identities assigned a Role
         * @param {RolesApiGetRoleAssignedIdentitiesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignedIdentities(requestParameters: RolesApiGetRoleAssignedIdentitiesRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<RoleIdentity>> {
            return localVarFp.getRoleAssignedIdentities(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of Roles.
         * @summary List Roles
         * @param {RolesApiListRolesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(requestParameters: RolesApiListRolesRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<Role>> {
            return localVarFp.listRoles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax. The following fields are patchable: * name * description * enabled * owner * accessProfiles * entitlements * membership * requestable * accessRequestConfig * revokeRequestConfig * segments * accessModelMetadata  A user with ROLE_SUBADMIN authority may only call this API if all access profiles included in the role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.  When you use this API to modify a role\'s membership identities, you can only modify up to a limit of 500 membership identities at a time. 
         * @summary Patch a specified Role
         * @param {RolesApiPatchRoleRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRole(requestParameters: RolesApiPatchRoleRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Role> {
            return localVarFp.patchRole(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createRole operation in RolesApi.
 * @export
 * @interface RolesApiCreateRoleRequest
 */
export interface RolesApiCreateRoleRequest {
    /**
     * 
     * @type {Role}
     * @memberof RolesApiCreateRole
     */
    readonly role: Role
}

/**
 * Request parameters for deleteBulkRoles operation in RolesApi.
 * @export
 * @interface RolesApiDeleteBulkRolesRequest
 */
export interface RolesApiDeleteBulkRolesRequest {
    /**
     * 
     * @type {RoleBulkDeleteRequest}
     * @memberof RolesApiDeleteBulkRoles
     */
    readonly roleBulkDeleteRequest: RoleBulkDeleteRequest
}

/**
 * Request parameters for deleteRole operation in RolesApi.
 * @export
 * @interface RolesApiDeleteRoleRequest
 */
export interface RolesApiDeleteRoleRequest {
    /**
     * ID of the Role
     * @type {string}
     * @memberof RolesApiDeleteRole
     */
    readonly id: string
}

/**
 * Request parameters for getRole operation in RolesApi.
 * @export
 * @interface RolesApiGetRoleRequest
 */
export interface RolesApiGetRoleRequest {
    /**
     * ID of the Role
     * @type {string}
     * @memberof RolesApiGetRole
     */
    readonly id: string
}

/**
 * Request parameters for getRoleAssignedIdentities operation in RolesApi.
 * @export
 * @interface RolesApiGetRoleAssignedIdentitiesRequest
 */
export interface RolesApiGetRoleAssignedIdentitiesRequest {
    /**
     * ID of the Role for which the assigned Identities are to be listed
     * @type {string}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
     * @type {string}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, aliasName, email**
     * @type {string}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly sorters?: string
}

/**
 * Request parameters for listRoles operation in RolesApi.
 * @export
 * @interface RolesApiListRolesRequest
 */
export interface RolesApiListRolesRequest {
    /**
     * If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly forSubadmin?: string

    /**
     * Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiListRoles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiListRoles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RolesApiListRoles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly sorters?: string

    /**
     * If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly forSegmentIds?: string

    /**
     * Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
     * @type {boolean}
     * @memberof RolesApiListRoles
     */
    readonly includeUnsegmented?: boolean
}

/**
 * Request parameters for patchRole operation in RolesApi.
 * @export
 * @interface RolesApiPatchRoleRequest
 */
export interface RolesApiPatchRoleRequest {
    /**
     * ID of the Role to patch
     * @type {string}
     * @memberof RolesApiPatchRole
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperation>}
     * @memberof RolesApiPatchRole
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * This API creates a role. In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.   The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
     * @summary Create a Role
     * @param {RolesApiCreateRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public createRole(requestParameters: RolesApiCreateRoleRequest, axiosOptions?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).createRole(requestParameters.role, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint initiates a bulk deletion of one or more roles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 roles per request.  A user with ROLE_SUBADMIN authority can only call this endpoint if all roles included in the request are associated with sources with management workgroups the ROLE_SUBADMIN is a member of.
     * @summary Delete Role(s)
     * @param {RolesApiDeleteBulkRolesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteBulkRoles(requestParameters: RolesApiDeleteBulkRolesRequest, axiosOptions?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteBulkRoles(requestParameters.roleBulkDeleteRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes a Role by its ID.  A user with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
     * @summary Delete a Role
     * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRole(requestParameters: RolesApiDeleteRoleRequest, axiosOptions?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteRole(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a Role by its ID. A user with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
     * @summary Get a Role
     * @param {RolesApiGetRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRole(requestParameters: RolesApiGetRoleRequest, axiosOptions?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRole(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Identities assigned a Role
     * @param {RolesApiGetRoleAssignedIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleAssignedIdentities(requestParameters: RolesApiGetRoleAssignedIdentitiesRequest, axiosOptions?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRoleAssignedIdentities(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of Roles.
     * @summary List Roles
     * @param {RolesApiListRolesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public listRoles(requestParameters: RolesApiListRolesRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).listRoles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax. The following fields are patchable: * name * description * enabled * owner * accessProfiles * entitlements * membership * requestable * accessRequestConfig * revokeRequestConfig * segments * accessModelMetadata  A user with ROLE_SUBADMIN authority may only call this API if all access profiles included in the role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.  When you use this API to modify a role\'s membership identities, you can only modify up to a limit of 500 membership identities at a time. 
     * @summary Patch a specified Role
     * @param {RolesApiPatchRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public patchRole(requestParameters: RolesApiPatchRoleRequest, axiosOptions?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).patchRole(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SODPoliciesApi - axios parameter creator
 * @export
 */
export const SODPoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSodPolicy: async (sodPolicy: SodPolicy, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sodPolicy' is not null or undefined
            assertParamExists('createSodPolicy', 'sodPolicy', sodPolicy)
            const localVarPath = `/sod-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicy: async (id: string, logical?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (logical !== undefined) {
                localVarQueryParameter['logical'] = logical;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicySchedule: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSodPolicySchedule', 'id', id)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCustomViolationReport: async (reportResultId: string, fileName: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('getCustomViolationReport', 'reportResultId', reportResultId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getCustomViolationReport', 'fileName', fileName)
            const localVarPath = `/sod-violation-report/{reportResultId}/download/{fileName}`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultViolationReport: async (reportResultId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('getDefaultViolationReport', 'reportResultId', reportResultId)
            const localVarPath = `/sod-violation-report/{reportResultId}/download`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodAllReportRunStatus: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-violation-report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the SOD Policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicy: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the SOD policy schedule to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicySchedule: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodPolicySchedule', 'id', id)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportRunStatus: async (reportResultId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('getSodViolationReportRunStatus', 'reportResultId', reportResultId)
            const localVarPath = `/sod-policies/sod-violation-report-status/{reportResultId}`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the violation report to retrieve status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportStatus: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodViolationReportStatus', 'id', id)
            const localVarPath = `/sod-policies/{id}/violation-report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in*  **state**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, description**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSodPolicies: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch SOD policy by ID
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSodPolicy: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchSodPolicy', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchSodPolicy', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicySchedule} sodPolicySchedule 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPolicySchedule: async (id: string, sodPolicySchedule: SodPolicySchedule, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putPolicySchedule', 'id', id)
            // verify required parameter 'sodPolicySchedule' is not null or undefined
            assertParamExists('putPolicySchedule', 'sodPolicySchedule', sodPolicySchedule)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicySchedule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSodPolicy: async (id: string, sodPolicy: SodPolicy, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putSodPolicy', 'id', id)
            // verify required parameter 'sodPolicy' is not null or undefined
            assertParamExists('putSodPolicy', 'sodPolicy', sodPolicy)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startEvaluateSodPolicy: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startEvaluateSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}/evaluate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequest} [multiPolicyRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodAllPoliciesForOrg: async (multiPolicyRequest?: MultiPolicyRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-violation-report/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(multiPolicyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodPolicy: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}/violation-report/run`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SODPoliciesApi - functional programming interface
 * @export
 */
export const SODPoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SODPoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSodPolicy(sodPolicy: SodPolicy, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSodPolicy(sodPolicy, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.createSodPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSodPolicy(id: string, logical?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSodPolicy(id, logical, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.deleteSodPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSodPolicySchedule(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSodPolicySchedule(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.deleteSodPolicySchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomViolationReport(reportResultId: string, fileName: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomViolationReport(reportResultId, fileName, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.getCustomViolationReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultViolationReport(reportResultId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultViolationReport(reportResultId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.getDefaultViolationReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodAllReportRunStatus(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodAllReportRunStatus(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.getSodAllReportRunStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the SOD Policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodPolicy(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodPolicy(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.getSodPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the SOD policy schedule to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodPolicySchedule(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicySchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodPolicySchedule(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.getSodPolicySchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodViolationReportRunStatus(reportResultId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodViolationReportRunStatus(reportResultId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.getSodViolationReportRunStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the violation report to retrieve status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodViolationReportStatus(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodViolationReportStatus(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.getSodViolationReportStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in*  **state**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, description**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSodPolicies(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SodPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSodPolicies(limit, offset, count, filters, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.listSodPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch SOD policy by ID
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSodPolicy(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSodPolicy(id, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.patchSodPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicySchedule} sodPolicySchedule 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putPolicySchedule(id: string, sodPolicySchedule: SodPolicySchedule, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicySchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPolicySchedule(id, sodPolicySchedule, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.putPolicySchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSodPolicy(id: string, sodPolicy: SodPolicy, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSodPolicy(id, sodPolicy, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.putSodPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startEvaluateSodPolicy(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startEvaluateSodPolicy(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.startEvaluateSodPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequest} [multiPolicyRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startSodAllPoliciesForOrg(multiPolicyRequest?: MultiPolicyRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startSodAllPoliciesForOrg(multiPolicyRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.startSodAllPoliciesForOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startSodPolicy(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startSodPolicy(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODPoliciesApi.startSodPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SODPoliciesApi - factory interface
 * @export
 */
export const SODPoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SODPoliciesApiFp(configuration)
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SODPoliciesApiCreateSodPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSodPolicy(requestParameters: SODPoliciesApiCreateSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SodPolicy> {
            return localVarFp.createSodPolicy(requestParameters.sodPolicy, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {SODPoliciesApiDeleteSodPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicy(requestParameters: SODPoliciesApiDeleteSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSodPolicy(requestParameters.id, requestParameters.logical, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {SODPoliciesApiDeleteSodPolicyScheduleRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicySchedule(requestParameters: SODPoliciesApiDeleteSodPolicyScheduleRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSodPolicySchedule(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {SODPoliciesApiGetCustomViolationReportRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCustomViolationReport(requestParameters: SODPoliciesApiGetCustomViolationReportRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getCustomViolationReport(requestParameters.reportResultId, requestParameters.fileName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {SODPoliciesApiGetDefaultViolationReportRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultViolationReport(requestParameters: SODPoliciesApiGetDefaultViolationReportRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getDefaultViolationReport(requestParameters.reportResultId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodAllReportRunStatus(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ReportResultReference> {
            return localVarFp.getSodAllReportRunStatus(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {SODPoliciesApiGetSodPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicy(requestParameters: SODPoliciesApiGetSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SodPolicy> {
            return localVarFp.getSodPolicy(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {SODPoliciesApiGetSodPolicyScheduleRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicySchedule(requestParameters: SODPoliciesApiGetSodPolicyScheduleRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SodPolicySchedule> {
            return localVarFp.getSodPolicySchedule(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {SODPoliciesApiGetSodViolationReportRunStatusRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportRunStatus(requestParameters: SODPoliciesApiGetSodViolationReportRunStatusRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ReportResultReference> {
            return localVarFp.getSodViolationReportRunStatus(requestParameters.reportResultId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {SODPoliciesApiGetSodViolationReportStatusRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportStatus(requestParameters: SODPoliciesApiGetSodViolationReportStatusRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ReportResultReference> {
            return localVarFp.getSodViolationReportStatus(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {SODPoliciesApiListSodPoliciesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSodPolicies(requestParameters: SODPoliciesApiListSodPoliciesRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<SodPolicy>> {
            return localVarFp.listSodPolicies(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch SOD policy by ID
         * @param {SODPoliciesApiPatchSodPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSodPolicy(requestParameters: SODPoliciesApiPatchSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SodPolicy> {
            return localVarFp.patchSodPolicy(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {SODPoliciesApiPutPolicyScheduleRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPolicySchedule(requestParameters: SODPoliciesApiPutPolicyScheduleRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SodPolicySchedule> {
            return localVarFp.putPolicySchedule(requestParameters.id, requestParameters.sodPolicySchedule, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {SODPoliciesApiPutSodPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSodPolicy(requestParameters: SODPoliciesApiPutSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SodPolicy> {
            return localVarFp.putSodPolicy(requestParameters.id, requestParameters.sodPolicy, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {SODPoliciesApiStartEvaluateSodPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startEvaluateSodPolicy(requestParameters: SODPoliciesApiStartEvaluateSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ReportResultReference> {
            return localVarFp.startEvaluateSodPolicy(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {SODPoliciesApiStartSodAllPoliciesForOrgRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodAllPoliciesForOrg(requestParameters: SODPoliciesApiStartSodAllPoliciesForOrgRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ReportResultReference> {
            return localVarFp.startSodAllPoliciesForOrg(requestParameters.multiPolicyRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {SODPoliciesApiStartSodPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodPolicy(requestParameters: SODPoliciesApiStartSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ReportResultReference> {
            return localVarFp.startSodPolicy(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiCreateSodPolicyRequest
 */
export interface SODPoliciesApiCreateSodPolicyRequest {
    /**
     * 
     * @type {SodPolicy}
     * @memberof SODPoliciesApiCreateSodPolicy
     */
    readonly sodPolicy: SodPolicy
}

/**
 * Request parameters for deleteSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiDeleteSodPolicyRequest
 */
export interface SODPoliciesApiDeleteSodPolicyRequest {
    /**
     * The ID of the SOD Policy to delete.
     * @type {string}
     * @memberof SODPoliciesApiDeleteSodPolicy
     */
    readonly id: string

    /**
     * Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
     * @type {boolean}
     * @memberof SODPoliciesApiDeleteSodPolicy
     */
    readonly logical?: boolean
}

/**
 * Request parameters for deleteSodPolicySchedule operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiDeleteSodPolicyScheduleRequest
 */
export interface SODPoliciesApiDeleteSodPolicyScheduleRequest {
    /**
     * The ID of the SOD policy the schedule must be deleted for.
     * @type {string}
     * @memberof SODPoliciesApiDeleteSodPolicySchedule
     */
    readonly id: string
}

/**
 * Request parameters for getCustomViolationReport operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiGetCustomViolationReportRequest
 */
export interface SODPoliciesApiGetCustomViolationReportRequest {
    /**
     * The ID of the report reference to download.
     * @type {string}
     * @memberof SODPoliciesApiGetCustomViolationReport
     */
    readonly reportResultId: string

    /**
     * Custom Name for the  file.
     * @type {string}
     * @memberof SODPoliciesApiGetCustomViolationReport
     */
    readonly fileName: string
}

/**
 * Request parameters for getDefaultViolationReport operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiGetDefaultViolationReportRequest
 */
export interface SODPoliciesApiGetDefaultViolationReportRequest {
    /**
     * The ID of the report reference to download.
     * @type {string}
     * @memberof SODPoliciesApiGetDefaultViolationReport
     */
    readonly reportResultId: string
}

/**
 * Request parameters for getSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiGetSodPolicyRequest
 */
export interface SODPoliciesApiGetSodPolicyRequest {
    /**
     * The ID of the SOD Policy to retrieve.
     * @type {string}
     * @memberof SODPoliciesApiGetSodPolicy
     */
    readonly id: string
}

/**
 * Request parameters for getSodPolicySchedule operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiGetSodPolicyScheduleRequest
 */
export interface SODPoliciesApiGetSodPolicyScheduleRequest {
    /**
     * The ID of the SOD policy schedule to retrieve.
     * @type {string}
     * @memberof SODPoliciesApiGetSodPolicySchedule
     */
    readonly id: string
}

/**
 * Request parameters for getSodViolationReportRunStatus operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiGetSodViolationReportRunStatusRequest
 */
export interface SODPoliciesApiGetSodViolationReportRunStatusRequest {
    /**
     * The ID of the report reference to retrieve.
     * @type {string}
     * @memberof SODPoliciesApiGetSodViolationReportRunStatus
     */
    readonly reportResultId: string
}

/**
 * Request parameters for getSodViolationReportStatus operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiGetSodViolationReportStatusRequest
 */
export interface SODPoliciesApiGetSodViolationReportStatusRequest {
    /**
     * The ID of the violation report to retrieve status for.
     * @type {string}
     * @memberof SODPoliciesApiGetSodViolationReportStatus
     */
    readonly id: string
}

/**
 * Request parameters for listSodPolicies operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiListSodPoliciesRequest
 */
export interface SODPoliciesApiListSodPoliciesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SODPoliciesApiListSodPolicies
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SODPoliciesApiListSodPolicies
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SODPoliciesApiListSodPolicies
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in*  **state**: *eq, in*
     * @type {string}
     * @memberof SODPoliciesApiListSodPolicies
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, description**
     * @type {string}
     * @memberof SODPoliciesApiListSodPolicies
     */
    readonly sorters?: string
}

/**
 * Request parameters for patchSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiPatchSodPolicyRequest
 */
export interface SODPoliciesApiPatchSodPolicyRequest {
    /**
     * The ID of the SOD policy being modified.
     * @type {string}
     * @memberof SODPoliciesApiPatchSodPolicy
     */
    readonly id: string

    /**
     * A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
     * @type {Array<JsonPatchOperation>}
     * @memberof SODPoliciesApiPatchSodPolicy
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for putPolicySchedule operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiPutPolicyScheduleRequest
 */
export interface SODPoliciesApiPutPolicyScheduleRequest {
    /**
     * The ID of the SOD policy to update its schedule.
     * @type {string}
     * @memberof SODPoliciesApiPutPolicySchedule
     */
    readonly id: string

    /**
     * 
     * @type {SodPolicySchedule}
     * @memberof SODPoliciesApiPutPolicySchedule
     */
    readonly sodPolicySchedule: SodPolicySchedule
}

/**
 * Request parameters for putSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiPutSodPolicyRequest
 */
export interface SODPoliciesApiPutSodPolicyRequest {
    /**
     * The ID of the SOD policy to update.
     * @type {string}
     * @memberof SODPoliciesApiPutSodPolicy
     */
    readonly id: string

    /**
     * 
     * @type {SodPolicy}
     * @memberof SODPoliciesApiPutSodPolicy
     */
    readonly sodPolicy: SodPolicy
}

/**
 * Request parameters for startEvaluateSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiStartEvaluateSodPolicyRequest
 */
export interface SODPoliciesApiStartEvaluateSodPolicyRequest {
    /**
     * The SOD policy ID to run.
     * @type {string}
     * @memberof SODPoliciesApiStartEvaluateSodPolicy
     */
    readonly id: string
}

/**
 * Request parameters for startSodAllPoliciesForOrg operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiStartSodAllPoliciesForOrgRequest
 */
export interface SODPoliciesApiStartSodAllPoliciesForOrgRequest {
    /**
     * 
     * @type {MultiPolicyRequest}
     * @memberof SODPoliciesApiStartSodAllPoliciesForOrg
     */
    readonly multiPolicyRequest?: MultiPolicyRequest
}

/**
 * Request parameters for startSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiStartSodPolicyRequest
 */
export interface SODPoliciesApiStartSodPolicyRequest {
    /**
     * The SOD policy ID to run.
     * @type {string}
     * @memberof SODPoliciesApiStartSodPolicy
     */
    readonly id: string
}

/**
 * SODPoliciesApi - object-oriented interface
 * @export
 * @class SODPoliciesApi
 * @extends {BaseAPI}
 */
export class SODPoliciesApi extends BaseAPI {
    /**
     * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
     * @summary Create SOD policy
     * @param {SODPoliciesApiCreateSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public createSodPolicy(requestParameters: SODPoliciesApiCreateSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).createSodPolicy(requestParameters.sodPolicy, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Delete SOD policy by ID
     * @param {SODPoliciesApiDeleteSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public deleteSodPolicy(requestParameters: SODPoliciesApiDeleteSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).deleteSodPolicy(requestParameters.id, requestParameters.logical, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes schedule for a specified SOD policy by ID.
     * @summary Delete SOD policy schedule
     * @param {SODPoliciesApiDeleteSodPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public deleteSodPolicySchedule(requestParameters: SODPoliciesApiDeleteSodPolicyScheduleRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).deleteSodPolicySchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This allows to download a specified named violation report for a given report reference.
     * @summary Download custom violation report
     * @param {SODPoliciesApiGetCustomViolationReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getCustomViolationReport(requestParameters: SODPoliciesApiGetCustomViolationReportRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getCustomViolationReport(requestParameters.reportResultId, requestParameters.fileName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This allows to download a violation report for a given report reference.
     * @summary Download violation report
     * @param {SODPoliciesApiGetDefaultViolationReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getDefaultViolationReport(requestParameters: SODPoliciesApiGetDefaultViolationReportRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getDefaultViolationReport(requestParameters.reportResultId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets the status for a violation report for all policy run.
     * @summary Get multi-report run task status
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getSodAllReportRunStatus(axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getSodAllReportRunStatus(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Get SOD policy by ID
     * @param {SODPoliciesApiGetSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getSodPolicy(requestParameters: SODPoliciesApiGetSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets a specified SOD policy\'s schedule.
     * @summary Get SOD policy schedule
     * @param {SODPoliciesApiGetSodPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getSodPolicySchedule(requestParameters: SODPoliciesApiGetSodPolicyScheduleRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getSodPolicySchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the status for a violation report run task that has already been invoked.
     * @summary Get violation report run status
     * @param {SODPoliciesApiGetSodViolationReportRunStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getSodViolationReportRunStatus(requestParameters: SODPoliciesApiGetSodViolationReportRunStatusRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getSodViolationReportRunStatus(requestParameters.reportResultId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the status for a violation report run task that has already been invoked.
     * @summary Get SOD violation report status
     * @param {SODPoliciesApiGetSodViolationReportStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getSodViolationReportStatus(requestParameters: SODPoliciesApiGetSodViolationReportStatusRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getSodViolationReportStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets list of all SOD policies. Requires role of ORG_ADMIN
     * @summary List SOD policies
     * @param {SODPoliciesApiListSodPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public listSodPolicies(requestParameters: SODPoliciesApiListSodPoliciesRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).listSodPolicies(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
     * @summary Patch SOD policy by ID
     * @param {SODPoliciesApiPatchSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public patchSodPolicy(requestParameters: SODPoliciesApiPatchSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).patchSodPolicy(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates schedule for a specified SOD policy.
     * @summary Update SOD Policy schedule
     * @param {SODPoliciesApiPutPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public putPolicySchedule(requestParameters: SODPoliciesApiPutPolicyScheduleRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).putPolicySchedule(requestParameters.id, requestParameters.sodPolicySchedule, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Update SOD policy by ID
     * @param {SODPoliciesApiPutSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public putSodPolicy(requestParameters: SODPoliciesApiPutSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).putSodPolicy(requestParameters.id, requestParameters.sodPolicy, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
     * @summary Evaluate one policy by ID
     * @param {SODPoliciesApiStartEvaluateSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public startEvaluateSodPolicy(requestParameters: SODPoliciesApiStartEvaluateSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).startEvaluateSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
     * @summary Runs all policies for org
     * @param {SODPoliciesApiStartSodAllPoliciesForOrgRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public startSodAllPoliciesForOrg(requestParameters: SODPoliciesApiStartSodAllPoliciesForOrgRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).startSodAllPoliciesForOrg(requestParameters.multiPolicyRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
     * @summary Runs SOD policy violation report
     * @param {SODPoliciesApiStartSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public startSodPolicy(requestParameters: SODPoliciesApiStartSodPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).startSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SODViolationsApi - axios parameter creator
 * @export
 */
export const SODViolationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.
         * @summary Predict SOD violations for identity.
         * @param {IdentityWithNewAccess} identityWithNewAccess 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startPredictSodViolations: async (identityWithNewAccess: IdentityWithNewAccess, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityWithNewAccess' is not null or undefined
            assertParamExists('startPredictSodViolations', 'identityWithNewAccess', identityWithNewAccess)
            const localVarPath = `/sod-violations/predict`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityWithNewAccess, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API initiates a SOD policy verification asynchronously.
         * @summary Check SOD violations
         * @param {IdentityWithNewAccess1} identityWithNewAccess1 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startViolationCheck: async (identityWithNewAccess1: IdentityWithNewAccess1, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityWithNewAccess1' is not null or undefined
            assertParamExists('startViolationCheck', 'identityWithNewAccess1', identityWithNewAccess1)
            const localVarPath = `/sod-violations/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityWithNewAccess1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SODViolationsApi - functional programming interface
 * @export
 */
export const SODViolationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SODViolationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.
         * @summary Predict SOD violations for identity.
         * @param {IdentityWithNewAccess} identityWithNewAccess 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startPredictSodViolations(identityWithNewAccess: IdentityWithNewAccess, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViolationPrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startPredictSodViolations(identityWithNewAccess, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODViolationsApi.startPredictSodViolations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API initiates a SOD policy verification asynchronously.
         * @summary Check SOD violations
         * @param {IdentityWithNewAccess1} identityWithNewAccess1 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startViolationCheck(identityWithNewAccess1: IdentityWithNewAccess1, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodViolationCheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startViolationCheck(identityWithNewAccess1, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SODViolationsApi.startViolationCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SODViolationsApi - factory interface
 * @export
 */
export const SODViolationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SODViolationsApiFp(configuration)
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.
         * @summary Predict SOD violations for identity.
         * @param {SODViolationsApiStartPredictSodViolationsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startPredictSodViolations(requestParameters: SODViolationsApiStartPredictSodViolationsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ViolationPrediction> {
            return localVarFp.startPredictSodViolations(requestParameters.identityWithNewAccess, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API initiates a SOD policy verification asynchronously.
         * @summary Check SOD violations
         * @param {SODViolationsApiStartViolationCheckRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startViolationCheck(requestParameters: SODViolationsApiStartViolationCheckRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SodViolationCheck> {
            return localVarFp.startViolationCheck(requestParameters.identityWithNewAccess1, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for startPredictSodViolations operation in SODViolationsApi.
 * @export
 * @interface SODViolationsApiStartPredictSodViolationsRequest
 */
export interface SODViolationsApiStartPredictSodViolationsRequest {
    /**
     * 
     * @type {IdentityWithNewAccess}
     * @memberof SODViolationsApiStartPredictSodViolations
     */
    readonly identityWithNewAccess: IdentityWithNewAccess
}

/**
 * Request parameters for startViolationCheck operation in SODViolationsApi.
 * @export
 * @interface SODViolationsApiStartViolationCheckRequest
 */
export interface SODViolationsApiStartViolationCheckRequest {
    /**
     * 
     * @type {IdentityWithNewAccess1}
     * @memberof SODViolationsApiStartViolationCheck
     */
    readonly identityWithNewAccess1: IdentityWithNewAccess1
}

/**
 * SODViolationsApi - object-oriented interface
 * @export
 * @class SODViolationsApi
 * @extends {BaseAPI}
 */
export class SODViolationsApi extends BaseAPI {
    /**
     * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.
     * @summary Predict SOD violations for identity.
     * @param {SODViolationsApiStartPredictSodViolationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODViolationsApi
     */
    public startPredictSodViolations(requestParameters: SODViolationsApiStartPredictSodViolationsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODViolationsApiFp(this.configuration).startPredictSodViolations(requestParameters.identityWithNewAccess, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API initiates a SOD policy verification asynchronously.
     * @summary Check SOD violations
     * @param {SODViolationsApiStartViolationCheckRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODViolationsApi
     */
    public startViolationCheck(requestParameters: SODViolationsApiStartViolationCheckRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SODViolationsApiFp(this.configuration).startViolationCheck(requestParameters.identityWithNewAccess1, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SavedSearchApi - axios parameter creator
 * @export
 */
export const SavedSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {CreateSavedSearchRequest} createSavedSearchRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch: async (createSavedSearchRequest: CreateSavedSearchRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSavedSearchRequest' is not null or undefined
            assertParamExists('createSavedSearch', 'createSavedSearchRequest', createSavedSearchRequest)
            const localVarPath = `/saved-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSavedSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearch: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSavedSearch', 'id', id)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        executeSavedSearch: async (id: string, searchArguments: SearchArguments, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('executeSavedSearch', 'id', id)
            // verify required parameter 'searchArguments' is not null or undefined
            assertParamExists('executeSavedSearch', 'searchArguments', searchArguments)
            const localVarPath = `/saved-searches/{id}/execute`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchArguments, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified saved search. 
         * @summary Return saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearch: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSavedSearch', 'id', id)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of saved searches. 
         * @summary A list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSavedSearches: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saved-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
         * @summary Updates an existing saved search 
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSavedSearch: async (id: string, savedSearch: SavedSearch, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putSavedSearch', 'id', id)
            // verify required parameter 'savedSearch' is not null or undefined
            assertParamExists('putSavedSearch', 'savedSearch', savedSearch)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(savedSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SavedSearchApi - functional programming interface
 * @export
 */
export const SavedSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SavedSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {CreateSavedSearchRequest} createSavedSearchRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSavedSearch(createSavedSearchRequest: CreateSavedSearchRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSavedSearch(createSavedSearchRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedSearchApi.createSavedSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSavedSearch(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSavedSearch(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedSearchApi.deleteSavedSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async executeSavedSearch(id: string, searchArguments: SearchArguments, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSavedSearch(id, searchArguments, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedSearchApi.executeSavedSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified saved search. 
         * @summary Return saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedSearch(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedSearch(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedSearchApi.getSavedSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of saved searches. 
         * @summary A list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSavedSearches(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SavedSearch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSavedSearches(offset, limit, count, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedSearchApi.listSavedSearches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
         * @summary Updates an existing saved search 
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSavedSearch(id: string, savedSearch: SavedSearch, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSavedSearch(id, savedSearch, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SavedSearchApi.putSavedSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SavedSearchApi - factory interface
 * @export
 */
export const SavedSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SavedSearchApiFp(configuration)
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {SavedSearchApiCreateSavedSearchRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch(requestParameters: SavedSearchApiCreateSavedSearchRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SavedSearch> {
            return localVarFp.createSavedSearch(requestParameters.createSavedSearchRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete document by ID
         * @param {SavedSearchApiDeleteSavedSearchRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearch(requestParameters: SavedSearchApiDeleteSavedSearchRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSavedSearch(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {SavedSearchApiExecuteSavedSearchRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        executeSavedSearch(requestParameters: SavedSearchApiExecuteSavedSearchRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.executeSavedSearch(requestParameters.id, requestParameters.searchArguments, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified saved search. 
         * @summary Return saved search by ID
         * @param {SavedSearchApiGetSavedSearchRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearch(requestParameters: SavedSearchApiGetSavedSearchRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SavedSearch> {
            return localVarFp.getSavedSearch(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of saved searches. 
         * @summary A list of Saved Searches
         * @param {SavedSearchApiListSavedSearchesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSavedSearches(requestParameters: SavedSearchApiListSavedSearchesRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<SavedSearch>> {
            return localVarFp.listSavedSearches(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
         * @summary Updates an existing saved search 
         * @param {SavedSearchApiPutSavedSearchRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSavedSearch(requestParameters: SavedSearchApiPutSavedSearchRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SavedSearch> {
            return localVarFp.putSavedSearch(requestParameters.id, requestParameters.savedSearch, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiCreateSavedSearchRequest
 */
export interface SavedSearchApiCreateSavedSearchRequest {
    /**
     * The saved search to persist.
     * @type {CreateSavedSearchRequest}
     * @memberof SavedSearchApiCreateSavedSearch
     */
    readonly createSavedSearchRequest: CreateSavedSearchRequest
}

/**
 * Request parameters for deleteSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiDeleteSavedSearchRequest
 */
export interface SavedSearchApiDeleteSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiDeleteSavedSearch
     */
    readonly id: string
}

/**
 * Request parameters for executeSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiExecuteSavedSearchRequest
 */
export interface SavedSearchApiExecuteSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiExecuteSavedSearch
     */
    readonly id: string

    /**
     * When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
     * @type {SearchArguments}
     * @memberof SavedSearchApiExecuteSavedSearch
     */
    readonly searchArguments: SearchArguments
}

/**
 * Request parameters for getSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiGetSavedSearchRequest
 */
export interface SavedSearchApiGetSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiGetSavedSearch
     */
    readonly id: string
}

/**
 * Request parameters for listSavedSearches operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiListSavedSearchesRequest
 */
export interface SavedSearchApiListSavedSearchesRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*
     * @type {string}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly filters?: string
}

/**
 * Request parameters for putSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiPutSavedSearchRequest
 */
export interface SavedSearchApiPutSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiPutSavedSearch
     */
    readonly id: string

    /**
     * The saved search to persist.
     * @type {SavedSearch}
     * @memberof SavedSearchApiPutSavedSearch
     */
    readonly savedSearch: SavedSearch
}

/**
 * SavedSearchApi - object-oriented interface
 * @export
 * @class SavedSearchApi
 * @extends {BaseAPI}
 */
export class SavedSearchApi extends BaseAPI {
    /**
     * Creates a new saved search. 
     * @summary Create a saved search
     * @param {SavedSearchApiCreateSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public createSavedSearch(requestParameters: SavedSearchApiCreateSavedSearchRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).createSavedSearch(requestParameters.createSavedSearchRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified saved search. 
     * @summary Delete document by ID
     * @param {SavedSearchApiDeleteSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public deleteSavedSearch(requestParameters: SavedSearchApiDeleteSavedSearchRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).deleteSavedSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Executes the specified saved search. 
     * @summary Execute a saved search by ID
     * @param {SavedSearchApiExecuteSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public executeSavedSearch(requestParameters: SavedSearchApiExecuteSavedSearchRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).executeSavedSearch(requestParameters.id, requestParameters.searchArguments, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified saved search. 
     * @summary Return saved search by ID
     * @param {SavedSearchApiGetSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public getSavedSearch(requestParameters: SavedSearchApiGetSavedSearchRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).getSavedSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of saved searches. 
     * @summary A list of Saved Searches
     * @param {SavedSearchApiListSavedSearchesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public listSavedSearches(requestParameters: SavedSearchApiListSavedSearchesRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).listSavedSearches(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
     * @summary Updates an existing saved search 
     * @param {SavedSearchApiPutSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public putSavedSearch(requestParameters: SavedSearchApiPutSavedSearchRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).putSavedSearch(requestParameters.id, requestParameters.savedSearch, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScheduledSearchApi - axios parameter creator
 * @export
 */
export const ScheduledSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {CreateScheduledSearchRequest} createScheduledSearchRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledSearch: async (createScheduledSearchRequest: CreateScheduledSearchRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createScheduledSearchRequest' is not null or undefined
            assertParamExists('createScheduledSearch', 'createScheduledSearchRequest', createScheduledSearchRequest)
            const localVarPath = `/scheduled-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScheduledSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledSearch: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteScheduledSearch', 'id', id)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledSearch: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getScheduledSearch', 'id', id)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **savedSearchId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledSearch: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scheduled-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeScheduledSearch: async (id: string, typedReference: TypedReference, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unsubscribeScheduledSearch', 'id', id)
            // verify required parameter 'typedReference' is not null or undefined
            assertParamExists('unsubscribeScheduledSearch', 'typedReference', typedReference)
            const localVarPath = `/scheduled-searches/{id}/unsubscribe`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typedReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledSearch: async (id: string, scheduledSearch: ScheduledSearch, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateScheduledSearch', 'id', id)
            // verify required parameter 'scheduledSearch' is not null or undefined
            assertParamExists('updateScheduledSearch', 'scheduledSearch', scheduledSearch)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduledSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledSearchApi - functional programming interface
 * @export
 */
export const ScheduledSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduledSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {CreateScheduledSearchRequest} createScheduledSearchRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createScheduledSearch(createScheduledSearchRequest: CreateScheduledSearchRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScheduledSearch(createScheduledSearchRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduledSearchApi.createScheduledSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScheduledSearch(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScheduledSearch(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduledSearchApi.deleteScheduledSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduledSearch(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduledSearch(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduledSearchApi.getScheduledSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **savedSearchId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listScheduledSearch(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduledSearch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScheduledSearch(offset, limit, count, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduledSearchApi.listScheduledSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribeScheduledSearch(id: string, typedReference: TypedReference, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribeScheduledSearch(id, typedReference, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduledSearchApi.unsubscribeScheduledSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateScheduledSearch(id: string, scheduledSearch: ScheduledSearch, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScheduledSearch(id, scheduledSearch, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduledSearchApi.updateScheduledSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScheduledSearchApi - factory interface
 * @export
 */
export const ScheduledSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduledSearchApiFp(configuration)
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {ScheduledSearchApiCreateScheduledSearchRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledSearch(requestParameters: ScheduledSearchApiCreateScheduledSearchRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ScheduledSearch> {
            return localVarFp.createScheduledSearch(requestParameters.createScheduledSearchRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {ScheduledSearchApiDeleteScheduledSearchRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledSearch(requestParameters: ScheduledSearchApiDeleteScheduledSearchRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteScheduledSearch(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {ScheduledSearchApiGetScheduledSearchRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledSearch(requestParameters: ScheduledSearchApiGetScheduledSearchRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ScheduledSearch> {
            return localVarFp.getScheduledSearch(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {ScheduledSearchApiListScheduledSearchRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledSearch(requestParameters: ScheduledSearchApiListScheduledSearchRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduledSearch>> {
            return localVarFp.listScheduledSearch(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {ScheduledSearchApiUnsubscribeScheduledSearchRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeScheduledSearch(requestParameters: ScheduledSearchApiUnsubscribeScheduledSearchRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unsubscribeScheduledSearch(requestParameters.id, requestParameters.typedReference, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {ScheduledSearchApiUpdateScheduledSearchRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledSearch(requestParameters: ScheduledSearchApiUpdateScheduledSearchRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ScheduledSearch> {
            return localVarFp.updateScheduledSearch(requestParameters.id, requestParameters.scheduledSearch, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiCreateScheduledSearchRequest
 */
export interface ScheduledSearchApiCreateScheduledSearchRequest {
    /**
     * The scheduled search to persist.
     * @type {CreateScheduledSearchRequest}
     * @memberof ScheduledSearchApiCreateScheduledSearch
     */
    readonly createScheduledSearchRequest: CreateScheduledSearchRequest
}

/**
 * Request parameters for deleteScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiDeleteScheduledSearchRequest
 */
export interface ScheduledSearchApiDeleteScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiDeleteScheduledSearch
     */
    readonly id: string
}

/**
 * Request parameters for getScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiGetScheduledSearchRequest
 */
export interface ScheduledSearchApiGetScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiGetScheduledSearch
     */
    readonly id: string
}

/**
 * Request parameters for listScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiListScheduledSearchRequest
 */
export interface ScheduledSearchApiListScheduledSearchRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **savedSearchId**: *eq*
     * @type {string}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly filters?: string
}

/**
 * Request parameters for unsubscribeScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiUnsubscribeScheduledSearchRequest
 */
export interface ScheduledSearchApiUnsubscribeScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiUnsubscribeScheduledSearch
     */
    readonly id: string

    /**
     * The recipient to be removed from the scheduled search. 
     * @type {TypedReference}
     * @memberof ScheduledSearchApiUnsubscribeScheduledSearch
     */
    readonly typedReference: TypedReference
}

/**
 * Request parameters for updateScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiUpdateScheduledSearchRequest
 */
export interface ScheduledSearchApiUpdateScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiUpdateScheduledSearch
     */
    readonly id: string

    /**
     * The scheduled search to persist.
     * @type {ScheduledSearch}
     * @memberof ScheduledSearchApiUpdateScheduledSearch
     */
    readonly scheduledSearch: ScheduledSearch
}

/**
 * ScheduledSearchApi - object-oriented interface
 * @export
 * @class ScheduledSearchApi
 * @extends {BaseAPI}
 */
export class ScheduledSearchApi extends BaseAPI {
    /**
     * Creates a new scheduled search. 
     * @summary Create a new scheduled search
     * @param {ScheduledSearchApiCreateScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public createScheduledSearch(requestParameters: ScheduledSearchApiCreateScheduledSearchRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).createScheduledSearch(requestParameters.createScheduledSearchRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified scheduled search. 
     * @summary Delete a Scheduled Search
     * @param {ScheduledSearchApiDeleteScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public deleteScheduledSearch(requestParameters: ScheduledSearchApiDeleteScheduledSearchRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).deleteScheduledSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified scheduled search.
     * @summary Get a Scheduled Search
     * @param {ScheduledSearchApiGetScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public getScheduledSearch(requestParameters: ScheduledSearchApiGetScheduledSearchRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).getScheduledSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of scheduled searches. 
     * @summary List scheduled searches
     * @param {ScheduledSearchApiListScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public listScheduledSearch(requestParameters: ScheduledSearchApiListScheduledSearchRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).listScheduledSearch(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unsubscribes a recipient from the specified scheduled search. 
     * @summary Unsubscribe a recipient from Scheduled Search
     * @param {ScheduledSearchApiUnsubscribeScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public unsubscribeScheduledSearch(requestParameters: ScheduledSearchApiUnsubscribeScheduledSearchRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).unsubscribeScheduledSearch(requestParameters.id, requestParameters.typedReference, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing scheduled search. 
     * @summary Update an existing Scheduled Search
     * @param {ScheduledSearchApiUpdateScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public updateScheduledSearch(requestParameters: ScheduledSearchApiUpdateScheduledSearchRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).updateScheduledSearch(requestParameters.id, requestParameters.scheduledSearch, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchAggregate: async (search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchAggregate', 'search', search)
            const localVarPath = `/search/aggregate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchCount: async (search: Search, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchCount', 'search', search)
            const localVarPath = `/search/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {SearchGetIndexV3} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *entitlements*, *events*, *identities*, and *roles*. 
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchGet: async (index: SearchGetIndexV3, id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('searchGet', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('searchGet', 'id', id)
            const localVarPath = `/search/{index}/{id}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Perform a search with the provided query and return a matching result collection. To page past 10,000 records, you can use `searchAfter` paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement `searchAfter` paging. 
         * @summary Perform Search
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPost: async (search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchPost', 'search', search)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchAggregate(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AggregationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAggregate(search, offset, limit, count, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchAggregate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchCount(search: Search, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCount(search, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {SearchGetIndexV3} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *entitlements*, *events*, *identities*, and *roles*. 
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchGet(index: SearchGetIndexV3, id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGet(index, id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Perform a search with the provided query and return a matching result collection. To page past 10,000 records, you can use `searchAfter` paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement `searchAfter` paging. 
         * @summary Perform Search
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchPost(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchDocuments>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPost(search, offset, limit, count, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {SearchApiSearchAggregateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchAggregate(requestParameters: SearchApiSearchAggregateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<AggregationResult> {
            return localVarFp.searchAggregate(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {SearchApiSearchCountRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchCount(requestParameters: SearchApiSearchCountRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.searchCount(requestParameters.search, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {SearchApiSearchGetRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchGet(requestParameters: SearchApiSearchGetRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SearchDocument> {
            return localVarFp.searchGet(requestParameters.index, requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Perform a search with the provided query and return a matching result collection. To page past 10,000 records, you can use `searchAfter` paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement `searchAfter` paging. 
         * @summary Perform Search
         * @param {SearchApiSearchPostRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPost(requestParameters: SearchApiSearchPostRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<SearchDocuments>> {
            return localVarFp.searchPost(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for searchAggregate operation in SearchApi.
 * @export
 * @interface SearchApiSearchAggregateRequest
 */
export interface SearchApiSearchAggregateRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchAggregate
     */
    readonly search: Search

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchAggregate
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchAggregate
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SearchApiSearchAggregate
     */
    readonly count?: boolean
}

/**
 * Request parameters for searchCount operation in SearchApi.
 * @export
 * @interface SearchApiSearchCountRequest
 */
export interface SearchApiSearchCountRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchCount
     */
    readonly search: Search
}

/**
 * Request parameters for searchGet operation in SearchApi.
 * @export
 * @interface SearchApiSearchGetRequest
 */
export interface SearchApiSearchGetRequest {
    /**
     * The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *entitlements*, *events*, *identities*, and *roles*. 
     * @type {'accessprofiles' | 'accountactivities' | 'entitlements' | 'events' | 'identities' | 'roles'}
     * @memberof SearchApiSearchGet
     */
    readonly index: SearchGetIndexV3

    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SearchApiSearchGet
     */
    readonly id: string
}

/**
 * Request parameters for searchPost operation in SearchApi.
 * @export
 * @interface SearchApiSearchPostRequest
 */
export interface SearchApiSearchPostRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchPost
     */
    readonly search: Search

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchPost
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchPost
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SearchApiSearchPost
     */
    readonly count?: boolean
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
     * @summary Perform a Search Query Aggregation
     * @param {SearchApiSearchAggregateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchAggregate(requestParameters: SearchApiSearchAggregateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchAggregate(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
     * @summary Count Documents Satisfying a Query
     * @param {SearchApiSearchCountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchCount(requestParameters: SearchApiSearchCountRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchCount(requestParameters.search, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a single document from the specified index, using the specified document ID.
     * @summary Get a Document by ID
     * @param {SearchApiSearchGetRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchGet(requestParameters: SearchApiSearchGetRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchGet(requestParameters.index, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a search with the provided query and return a matching result collection. To page past 10,000 records, you can use `searchAfter` paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement `searchAfter` paging. 
     * @summary Perform Search
     * @param {SearchApiSearchPostRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchPost(requestParameters: SearchApiSearchPostRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchPost(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SearchGetIndexV3 = {
    Accessprofiles: 'accessprofiles',
    Accountactivities: 'accountactivities',
    Entitlements: 'entitlements',
    Events: 'events',
    Identities: 'identities',
    Roles: 'roles'
} as const;
export type SearchGetIndexV3 = typeof SearchGetIndexV3[keyof typeof SearchGetIndexV3];


/**
 * SearchAttributeConfigurationApi - axios parameter creator
 * @export
 */
export const SearchAttributeConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create and configure extended search attributes. This API accepts an attribute name, an attribute display name and a list of name/value pair associates of application IDs to attribute names. It will then validate the inputs and configure/create and attribute promotion configuration in the Link ObjectConfig.
         * @summary Create Extended Search Attributes
         * @param {SearchAttributeConfig} searchAttributeConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSearchAttributeConfig: async (searchAttributeConfig: SearchAttributeConfig, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchAttributeConfig' is not null or undefined
            assertParamExists('createSearchAttributeConfig', 'searchAttributeConfig', searchAttributeConfig)
            const localVarPath = `/accounts/search-attribute-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchAttributeConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete an extended attribute configuration by name.
         * @summary Delete Extended Search Attribute
         * @param {string} name Name of the extended search attribute configuration to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearchAttributeConfig: async (name: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteSearchAttributeConfig', 'name', name)
            const localVarPath = `/accounts/search-attribute-config/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a list of attribute/application associates currently configured in Identity Security Cloud (ISC).
         * @summary List Extended Search Attributes
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSearchAttributeConfig: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/search-attribute-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get an extended attribute configuration by name.
         * @summary Get Extended Search Attribute
         * @param {string} name Name of the extended search attribute configuration to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSearchAttributeConfig: async (name: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getSingleSearchAttributeConfig', 'name', name)
            const localVarPath = `/accounts/search-attribute-config/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing search attribute configuration.  You can patch these fields: * name  * displayName * applicationAttributes
         * @summary Update Extended Search Attribute
         * @param {string} name Name of the search attribute configuration to patch.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSearchAttributeConfig: async (name: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('patchSearchAttributeConfig', 'name', name)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchSearchAttributeConfig', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/accounts/search-attribute-config/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchAttributeConfigurationApi - functional programming interface
 * @export
 */
export const SearchAttributeConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchAttributeConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create and configure extended search attributes. This API accepts an attribute name, an attribute display name and a list of name/value pair associates of application IDs to attribute names. It will then validate the inputs and configure/create and attribute promotion configuration in the Link ObjectConfig.
         * @summary Create Extended Search Attributes
         * @param {SearchAttributeConfig} searchAttributeConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSearchAttributeConfig(searchAttributeConfig: SearchAttributeConfig, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSearchAttributeConfig(searchAttributeConfig, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchAttributeConfigurationApi.createSearchAttributeConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an extended attribute configuration by name.
         * @summary Delete Extended Search Attribute
         * @param {string} name Name of the extended search attribute configuration to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSearchAttributeConfig(name: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSearchAttributeConfig(name, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchAttributeConfigurationApi.deleteSearchAttributeConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of attribute/application associates currently configured in Identity Security Cloud (ISC).
         * @summary List Extended Search Attributes
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchAttributeConfig(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchAttributeConfig>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchAttributeConfig(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchAttributeConfigurationApi.getSearchAttributeConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an extended attribute configuration by name.
         * @summary Get Extended Search Attribute
         * @param {string} name Name of the extended search attribute configuration to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleSearchAttributeConfig(name: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchAttributeConfig>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleSearchAttributeConfig(name, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchAttributeConfigurationApi.getSingleSearchAttributeConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing search attribute configuration.  You can patch these fields: * name  * displayName * applicationAttributes
         * @summary Update Extended Search Attribute
         * @param {string} name Name of the search attribute configuration to patch.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSearchAttributeConfig(name: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchAttributeConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSearchAttributeConfig(name, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchAttributeConfigurationApi.patchSearchAttributeConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchAttributeConfigurationApi - factory interface
 * @export
 */
export const SearchAttributeConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchAttributeConfigurationApiFp(configuration)
    return {
        /**
         * Create and configure extended search attributes. This API accepts an attribute name, an attribute display name and a list of name/value pair associates of application IDs to attribute names. It will then validate the inputs and configure/create and attribute promotion configuration in the Link ObjectConfig.
         * @summary Create Extended Search Attributes
         * @param {SearchAttributeConfigurationApiCreateSearchAttributeConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSearchAttributeConfig(requestParameters: SearchAttributeConfigurationApiCreateSearchAttributeConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createSearchAttributeConfig(requestParameters.searchAttributeConfig, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete an extended attribute configuration by name.
         * @summary Delete Extended Search Attribute
         * @param {SearchAttributeConfigurationApiDeleteSearchAttributeConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearchAttributeConfig(requestParameters: SearchAttributeConfigurationApiDeleteSearchAttributeConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSearchAttributeConfig(requestParameters.name, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of attribute/application associates currently configured in Identity Security Cloud (ISC).
         * @summary List Extended Search Attributes
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSearchAttributeConfig(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<SearchAttributeConfig>> {
            return localVarFp.getSearchAttributeConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get an extended attribute configuration by name.
         * @summary Get Extended Search Attribute
         * @param {SearchAttributeConfigurationApiGetSingleSearchAttributeConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSearchAttributeConfig(requestParameters: SearchAttributeConfigurationApiGetSingleSearchAttributeConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<SearchAttributeConfig>> {
            return localVarFp.getSingleSearchAttributeConfig(requestParameters.name, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing search attribute configuration.  You can patch these fields: * name  * displayName * applicationAttributes
         * @summary Update Extended Search Attribute
         * @param {SearchAttributeConfigurationApiPatchSearchAttributeConfigRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSearchAttributeConfig(requestParameters: SearchAttributeConfigurationApiPatchSearchAttributeConfigRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SearchAttributeConfig> {
            return localVarFp.patchSearchAttributeConfig(requestParameters.name, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSearchAttributeConfig operation in SearchAttributeConfigurationApi.
 * @export
 * @interface SearchAttributeConfigurationApiCreateSearchAttributeConfigRequest
 */
export interface SearchAttributeConfigurationApiCreateSearchAttributeConfigRequest {
    /**
     * 
     * @type {SearchAttributeConfig}
     * @memberof SearchAttributeConfigurationApiCreateSearchAttributeConfig
     */
    readonly searchAttributeConfig: SearchAttributeConfig
}

/**
 * Request parameters for deleteSearchAttributeConfig operation in SearchAttributeConfigurationApi.
 * @export
 * @interface SearchAttributeConfigurationApiDeleteSearchAttributeConfigRequest
 */
export interface SearchAttributeConfigurationApiDeleteSearchAttributeConfigRequest {
    /**
     * Name of the extended search attribute configuration to delete.
     * @type {string}
     * @memberof SearchAttributeConfigurationApiDeleteSearchAttributeConfig
     */
    readonly name: string
}

/**
 * Request parameters for getSingleSearchAttributeConfig operation in SearchAttributeConfigurationApi.
 * @export
 * @interface SearchAttributeConfigurationApiGetSingleSearchAttributeConfigRequest
 */
export interface SearchAttributeConfigurationApiGetSingleSearchAttributeConfigRequest {
    /**
     * Name of the extended search attribute configuration to retrieve.
     * @type {string}
     * @memberof SearchAttributeConfigurationApiGetSingleSearchAttributeConfig
     */
    readonly name: string
}

/**
 * Request parameters for patchSearchAttributeConfig operation in SearchAttributeConfigurationApi.
 * @export
 * @interface SearchAttributeConfigurationApiPatchSearchAttributeConfigRequest
 */
export interface SearchAttributeConfigurationApiPatchSearchAttributeConfigRequest {
    /**
     * Name of the search attribute configuration to patch.
     * @type {string}
     * @memberof SearchAttributeConfigurationApiPatchSearchAttributeConfig
     */
    readonly name: string

    /**
     * 
     * @type {Array<JsonPatchOperation>}
     * @memberof SearchAttributeConfigurationApiPatchSearchAttributeConfig
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * SearchAttributeConfigurationApi - object-oriented interface
 * @export
 * @class SearchAttributeConfigurationApi
 * @extends {BaseAPI}
 */
export class SearchAttributeConfigurationApi extends BaseAPI {
    /**
     * Create and configure extended search attributes. This API accepts an attribute name, an attribute display name and a list of name/value pair associates of application IDs to attribute names. It will then validate the inputs and configure/create and attribute promotion configuration in the Link ObjectConfig.
     * @summary Create Extended Search Attributes
     * @param {SearchAttributeConfigurationApiCreateSearchAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationApi
     */
    public createSearchAttributeConfig(requestParameters: SearchAttributeConfigurationApiCreateSearchAttributeConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SearchAttributeConfigurationApiFp(this.configuration).createSearchAttributeConfig(requestParameters.searchAttributeConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an extended attribute configuration by name.
     * @summary Delete Extended Search Attribute
     * @param {SearchAttributeConfigurationApiDeleteSearchAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationApi
     */
    public deleteSearchAttributeConfig(requestParameters: SearchAttributeConfigurationApiDeleteSearchAttributeConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SearchAttributeConfigurationApiFp(this.configuration).deleteSearchAttributeConfig(requestParameters.name, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of attribute/application associates currently configured in Identity Security Cloud (ISC).
     * @summary List Extended Search Attributes
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationApi
     */
    public getSearchAttributeConfig(axiosOptions?: RawAxiosRequestConfig) {
        return SearchAttributeConfigurationApiFp(this.configuration).getSearchAttributeConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an extended attribute configuration by name.
     * @summary Get Extended Search Attribute
     * @param {SearchAttributeConfigurationApiGetSingleSearchAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationApi
     */
    public getSingleSearchAttributeConfig(requestParameters: SearchAttributeConfigurationApiGetSingleSearchAttributeConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SearchAttributeConfigurationApiFp(this.configuration).getSingleSearchAttributeConfig(requestParameters.name, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing search attribute configuration.  You can patch these fields: * name  * displayName * applicationAttributes
     * @summary Update Extended Search Attribute
     * @param {SearchAttributeConfigurationApiPatchSearchAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationApi
     */
    public patchSearchAttributeConfig(requestParameters: SearchAttributeConfigurationApiPatchSearchAttributeConfigRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SearchAttributeConfigurationApiFp(this.configuration).patchSearchAttributeConfig(requestParameters.name, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SegmentsApi - axios parameter creator
 * @export
 */
export const SegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities.
         * @summary Create Segment
         * @param {Segment} segment 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSegment: async (segment: Segment, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segment' is not null or undefined
            assertParamExists('createSegment', 'segment', segment)
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective.    
         * @summary Delete Segment by ID
         * @param {string} id The segment ID to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSegment', 'id', id)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the segment specified by the given ID.
         * @summary Get Segment by ID
         * @param {string} id The segment ID to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSegment', 'id', id)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all segments. 
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSegments: async (limit?: number, offset?: number, count?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities.
         * @summary Update Segment
         * @param {string} id The segment ID to modify.
         * @param {Array<object>} requestBody A list of segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * owner * visibilityCriteria * active 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment: async (id: string, requestBody: Array<object>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchSegment', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('patchSegment', 'requestBody', requestBody)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities.
         * @summary Create Segment
         * @param {Segment} segment 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSegment(segment: Segment, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSegment(segment, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SegmentsApi.createSegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective.    
         * @summary Delete Segment by ID
         * @param {string} id The segment ID to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSegment(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSegment(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SegmentsApi.deleteSegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the segment specified by the given ID.
         * @summary Get Segment by ID
         * @param {string} id The segment ID to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSegment(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegment(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SegmentsApi.getSegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns a list of all segments. 
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSegments(limit?: number, offset?: number, count?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Segment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSegments(limit, offset, count, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SegmentsApi.listSegments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities.
         * @summary Update Segment
         * @param {string} id The segment ID to modify.
         * @param {Array<object>} requestBody A list of segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * owner * visibilityCriteria * active 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSegment(id: string, requestBody: Array<object>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSegment(id, requestBody, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SegmentsApi.patchSegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsApiFp(configuration)
    return {
        /**
         * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities.
         * @summary Create Segment
         * @param {SegmentsApiCreateSegmentRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSegment(requestParameters: SegmentsApiCreateSegmentRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Segment> {
            return localVarFp.createSegment(requestParameters.segment, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective.    
         * @summary Delete Segment by ID
         * @param {SegmentsApiDeleteSegmentRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment(requestParameters: SegmentsApiDeleteSegmentRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSegment(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the segment specified by the given ID.
         * @summary Get Segment by ID
         * @param {SegmentsApiGetSegmentRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSegment(requestParameters: SegmentsApiGetSegmentRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Segment> {
            return localVarFp.getSegment(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all segments. 
         * @summary List Segments
         * @param {SegmentsApiListSegmentsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSegments(requestParameters: SegmentsApiListSegmentsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<Segment>> {
            return localVarFp.listSegments(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities.
         * @summary Update Segment
         * @param {SegmentsApiPatchSegmentRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment(requestParameters: SegmentsApiPatchSegmentRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Segment> {
            return localVarFp.patchSegment(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiCreateSegmentRequest
 */
export interface SegmentsApiCreateSegmentRequest {
    /**
     * 
     * @type {Segment}
     * @memberof SegmentsApiCreateSegment
     */
    readonly segment: Segment
}

/**
 * Request parameters for deleteSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiDeleteSegmentRequest
 */
export interface SegmentsApiDeleteSegmentRequest {
    /**
     * The segment ID to delete.
     * @type {string}
     * @memberof SegmentsApiDeleteSegment
     */
    readonly id: string
}

/**
 * Request parameters for getSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiGetSegmentRequest
 */
export interface SegmentsApiGetSegmentRequest {
    /**
     * The segment ID to retrieve.
     * @type {string}
     * @memberof SegmentsApiGetSegment
     */
    readonly id: string
}

/**
 * Request parameters for listSegments operation in SegmentsApi.
 * @export
 * @interface SegmentsApiListSegmentsRequest
 */
export interface SegmentsApiListSegmentsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SegmentsApiListSegments
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SegmentsApiListSegments
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SegmentsApiListSegments
     */
    readonly count?: boolean
}

/**
 * Request parameters for patchSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiPatchSegmentRequest
 */
export interface SegmentsApiPatchSegmentRequest {
    /**
     * The segment ID to modify.
     * @type {string}
     * @memberof SegmentsApiPatchSegment
     */
    readonly id: string

    /**
     * A list of segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * owner * visibilityCriteria * active 
     * @type {Array<object>}
     * @memberof SegmentsApiPatchSegment
     */
    readonly requestBody: Array<object>
}

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
    /**
     * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities.
     * @summary Create Segment
     * @param {SegmentsApiCreateSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public createSegment(requestParameters: SegmentsApiCreateSegmentRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).createSegment(requestParameters.segment, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective.    
     * @summary Delete Segment by ID
     * @param {SegmentsApiDeleteSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public deleteSegment(requestParameters: SegmentsApiDeleteSegmentRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).deleteSegment(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the segment specified by the given ID.
     * @summary Get Segment by ID
     * @param {SegmentsApiGetSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegment(requestParameters: SegmentsApiGetSegmentRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegment(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all segments. 
     * @summary List Segments
     * @param {SegmentsApiListSegmentsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public listSegments(requestParameters: SegmentsApiListSegmentsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).listSegments(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities.
     * @summary Update Segment
     * @param {SegmentsApiPatchSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public patchSegment(requestParameters: SegmentsApiPatchSegmentRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).patchSegment(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceDeskIntegrationApi - axios parameter creator
 * @export
 */
export const ServiceDeskIntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Service Desk integration.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration: async (serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceDeskIntegrationDto' is not null or undefined
            assertParamExists('createServiceDeskIntegration', 'serviceDeskIntegrationDto', serviceDeskIntegrationDto)
            const localVarPath = `/service-desk-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceDeskIntegrationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Service Desk integration by ID.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteServiceDeskIntegration', 'id', id)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get an existing Service Desk integration by ID.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getServiceDeskIntegration', 'id', id)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.
         * @summary Service Desk integration template by scriptName
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate: async (scriptName: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getServiceDeskIntegrationTemplate', 'scriptName', scriptName)
            const localVarPath = `/service-desk-integrations/templates/{scriptName}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.
         * @summary List Service Desk integration types
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Service Desk integration objects.
         * @summary List existing Service Desk integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrations: async (offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the time check configuration of queued SDIM tickets.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations/status-check-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Service Desk integration by ID with a PATCH request.
         * @summary Patch a Service Desk Integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {PatchServiceDeskIntegrationRequest} patchServiceDeskIntegrationRequest A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Only &#x60;replace&#x60; operations are accepted by this endpoint.  A 403 Forbidden Error indicates that a PATCH operation was attempted that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration: async (id: string, patchServiceDeskIntegrationRequest: PatchServiceDeskIntegrationRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchServiceDeskIntegration', 'id', id)
            // verify required parameter 'patchServiceDeskIntegrationRequest' is not null or undefined
            assertParamExists('patchServiceDeskIntegration', 'patchServiceDeskIntegrationRequest', patchServiceDeskIntegrationRequest)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchServiceDeskIntegrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Service Desk integration by ID.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putServiceDeskIntegration: async (id: string, serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putServiceDeskIntegration', 'id', id)
            // verify required parameter 'serviceDeskIntegrationDto' is not null or undefined
            assertParamExists('putServiceDeskIntegration', 'serviceDeskIntegrationDto', serviceDeskIntegrationDto)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceDeskIntegrationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update the time check configuration of queued SDIM tickets.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails The modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails: async (queuedCheckConfigDetails: QueuedCheckConfigDetails, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queuedCheckConfigDetails' is not null or undefined
            assertParamExists('updateStatusCheckDetails', 'queuedCheckConfigDetails', queuedCheckConfigDetails)
            const localVarPath = `/service-desk-integrations/status-check-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queuedCheckConfigDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceDeskIntegrationApi - functional programming interface
 * @export
 */
export const ServiceDeskIntegrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceDeskIntegrationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Service Desk integration.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceDeskIntegration(serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceDeskIntegration(serviceDeskIntegrationDto, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceDeskIntegrationApi.createServiceDeskIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing Service Desk integration by ID.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceDeskIntegration(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceDeskIntegration(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceDeskIntegrationApi.deleteServiceDeskIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an existing Service Desk integration by ID.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegration(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegration(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceDeskIntegrationApi.getServiceDeskIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.
         * @summary Service Desk integration template by scriptName
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationTemplate(scriptName: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationTemplate(scriptName, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceDeskIntegrationApi.getServiceDeskIntegrationTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.
         * @summary List Service Desk integration types
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationTypes(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDeskIntegrationTemplateType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationTypes(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceDeskIntegrationApi.getServiceDeskIntegrationTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of Service Desk integration objects.
         * @summary List existing Service Desk integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrations(offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDeskIntegrationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrations(offset, limit, sorters, filters, count, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceDeskIntegrationApi.getServiceDeskIntegrations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the time check configuration of queued SDIM tickets.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusCheckDetails(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedCheckConfigDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusCheckDetails(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceDeskIntegrationApi.getStatusCheckDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing Service Desk integration by ID with a PATCH request.
         * @summary Patch a Service Desk Integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {PatchServiceDeskIntegrationRequest} patchServiceDeskIntegrationRequest A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Only &#x60;replace&#x60; operations are accepted by this endpoint.  A 403 Forbidden Error indicates that a PATCH operation was attempted that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchServiceDeskIntegration(id: string, patchServiceDeskIntegrationRequest: PatchServiceDeskIntegrationRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchServiceDeskIntegration(id, patchServiceDeskIntegrationRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceDeskIntegrationApi.patchServiceDeskIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing Service Desk integration by ID.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putServiceDeskIntegration(id: string, serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putServiceDeskIntegration(id, serviceDeskIntegrationDto, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceDeskIntegrationApi.putServiceDeskIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the time check configuration of queued SDIM tickets.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails The modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatusCheckDetails(queuedCheckConfigDetails: QueuedCheckConfigDetails, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedCheckConfigDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatusCheckDetails(queuedCheckConfigDetails, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceDeskIntegrationApi.updateStatusCheckDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceDeskIntegrationApi - factory interface
 * @export
 */
export const ServiceDeskIntegrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceDeskIntegrationApiFp(configuration)
    return {
        /**
         * Create a new Service Desk integration.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.createServiceDeskIntegration(requestParameters.serviceDeskIntegrationDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Service Desk integration by ID.
         * @summary Delete a Service Desk integration
         * @param {ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing Service Desk integration by ID.
         * @summary Get a Service Desk integration
         * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.getServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.
         * @summary Service Desk integration template by scriptName
         * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ServiceDeskIntegrationTemplateDto> {
            return localVarFp.getServiceDeskIntegrationTemplate(requestParameters.scriptName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.
         * @summary List Service Desk integration types
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<ServiceDeskIntegrationTemplateType>> {
            return localVarFp.getServiceDeskIntegrationTypes(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of Service Desk integration objects.
         * @summary List existing Service Desk integrations
         * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrations(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<ServiceDeskIntegrationDto>> {
            return localVarFp.getServiceDeskIntegrations(requestParameters.offset, requestParameters.limit, requestParameters.sorters, requestParameters.filters, requestParameters.count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get the time check configuration of queued SDIM tickets.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<QueuedCheckConfigDetails> {
            return localVarFp.getStatusCheckDetails(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Service Desk integration by ID with a PATCH request.
         * @summary Patch a Service Desk Integration
         * @param {ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.patchServiceDeskIntegration(requestParameters.id, requestParameters.patchServiceDeskIntegrationRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Service Desk integration by ID.
         * @summary Update a Service Desk integration
         * @param {ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.putServiceDeskIntegration(requestParameters.id, requestParameters.serviceDeskIntegrationDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update the time check configuration of queued SDIM tickets.
         * @summary Update the time check configuration
         * @param {ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails(requestParameters: ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<QueuedCheckConfigDetails> {
            return localVarFp.updateStatusCheckDetails(requestParameters.queuedCheckConfigDetails, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest {
    /**
     * The specifics of a new integration to create
     * @type {ServiceDeskIntegrationDto}
     * @memberof ServiceDeskIntegrationApiCreateServiceDeskIntegration
     */
    readonly serviceDeskIntegrationDto: ServiceDeskIntegrationDto
}

/**
 * Request parameters for deleteServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest {
    /**
     * ID of Service Desk integration to delete
     * @type {string}
     * @memberof ServiceDeskIntegrationApiDeleteServiceDeskIntegration
     */
    readonly id: string
}

/**
 * Request parameters for getServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to get
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegration
     */
    readonly id: string
}

/**
 * Request parameters for getServiceDeskIntegrationTemplate operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest {
    /**
     * The scriptName value of the Service Desk integration template to get
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplate
     */
    readonly scriptName: string
}

/**
 * Request parameters for getServiceDeskIntegrations operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly limit?: number

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly filters?: string

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly count?: boolean
}

/**
 * Request parameters for patchServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to update
     * @type {string}
     * @memberof ServiceDeskIntegrationApiPatchServiceDeskIntegration
     */
    readonly id: string

    /**
     * A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Only &#x60;replace&#x60; operations are accepted by this endpoint.  A 403 Forbidden Error indicates that a PATCH operation was attempted that is not allowed. 
     * @type {PatchServiceDeskIntegrationRequest}
     * @memberof ServiceDeskIntegrationApiPatchServiceDeskIntegration
     */
    readonly patchServiceDeskIntegrationRequest: PatchServiceDeskIntegrationRequest
}

/**
 * Request parameters for putServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to update
     * @type {string}
     * @memberof ServiceDeskIntegrationApiPutServiceDeskIntegration
     */
    readonly id: string

    /**
     * The specifics of the integration to update
     * @type {ServiceDeskIntegrationDto}
     * @memberof ServiceDeskIntegrationApiPutServiceDeskIntegration
     */
    readonly serviceDeskIntegrationDto: ServiceDeskIntegrationDto
}

/**
 * Request parameters for updateStatusCheckDetails operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest
 */
export interface ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest {
    /**
     * The modified time check configuration
     * @type {QueuedCheckConfigDetails}
     * @memberof ServiceDeskIntegrationApiUpdateStatusCheckDetails
     */
    readonly queuedCheckConfigDetails: QueuedCheckConfigDetails
}

/**
 * ServiceDeskIntegrationApi - object-oriented interface
 * @export
 * @class ServiceDeskIntegrationApi
 * @extends {BaseAPI}
 */
export class ServiceDeskIntegrationApi extends BaseAPI {
    /**
     * Create a new Service Desk integration.
     * @summary Create new Service Desk integration
     * @param {ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public createServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).createServiceDeskIntegration(requestParameters.serviceDeskIntegrationDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Service Desk integration by ID.
     * @summary Delete a Service Desk integration
     * @param {ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public deleteServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).deleteServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing Service Desk integration by ID.
     * @summary Get a Service Desk integration
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns an existing Service Desk integration template by scriptName.
     * @summary Service Desk integration template by scriptName
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrationTemplate(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrationTemplate(requestParameters.scriptName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns the current list of supported Service Desk integration types.
     * @summary List Service Desk integration types
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrationTypes(axiosOptions?: RawAxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrationTypes(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of Service Desk integration objects.
     * @summary List existing Service Desk integrations
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrations(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrations(requestParameters.offset, requestParameters.limit, requestParameters.sorters, requestParameters.filters, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the time check configuration of queued SDIM tickets.
     * @summary Get the time check configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getStatusCheckDetails(axiosOptions?: RawAxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getStatusCheckDetails(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Service Desk integration by ID with a PATCH request.
     * @summary Patch a Service Desk Integration
     * @param {ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public patchServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).patchServiceDeskIntegration(requestParameters.id, requestParameters.patchServiceDeskIntegrationRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Service Desk integration by ID.
     * @summary Update a Service Desk integration
     * @param {ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public putServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).putServiceDeskIntegration(requestParameters.id, requestParameters.serviceDeskIntegrationDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the time check configuration of queued SDIM tickets.
     * @summary Update the time check configuration
     * @param {ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public updateStatusCheckDetails(requestParameters: ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).updateStatusCheckDetails(requestParameters.queuedCheckConfigDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SourceUsagesApi - axios parameter creator
 * @export
 */
export const SourceUsagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the status of the source usage insights setup by IDN source ID.
         * @summary Finds status of source usage
         * @param {string} sourceId ID of IDN source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusBySourceId: async (sourceId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getStatusBySourceId', 'sourceId', sourceId)
            const localVarPath = `/source-usages/{sourceId}/status`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a summary of source usage insights for past 12 months.
         * @summary Returns source usage insights
         * @param {string} sourceId ID of IDN source
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesBySourceId: async (sourceId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getUsagesBySourceId', 'sourceId', sourceId)
            const localVarPath = `/source-usages/{sourceId}/summaries`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourceUsagesApi - functional programming interface
 * @export
 */
export const SourceUsagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourceUsagesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the status of the source usage insights setup by IDN source ID.
         * @summary Finds status of source usage
         * @param {string} sourceId ID of IDN source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusBySourceId(sourceId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceUsageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusBySourceId(sourceId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceUsagesApi.getStatusBySourceId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns a summary of source usage insights for past 12 months.
         * @summary Returns source usage insights
         * @param {string} sourceId ID of IDN source
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getUsagesBySourceId(sourceId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SourceUsage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsagesBySourceId(sourceId, limit, offset, count, sorters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceUsagesApi.getUsagesBySourceId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SourceUsagesApi - factory interface
 * @export
 */
export const SourceUsagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourceUsagesApiFp(configuration)
    return {
        /**
         * This API returns the status of the source usage insights setup by IDN source ID.
         * @summary Finds status of source usage
         * @param {SourceUsagesApiGetStatusBySourceIdRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusBySourceId(requestParameters: SourceUsagesApiGetStatusBySourceIdRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SourceUsageStatus> {
            return localVarFp.getStatusBySourceId(requestParameters.sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a summary of source usage insights for past 12 months.
         * @summary Returns source usage insights
         * @param {SourceUsagesApiGetUsagesBySourceIdRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesBySourceId(requestParameters: SourceUsagesApiGetUsagesBySourceIdRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<SourceUsage>> {
            return localVarFp.getUsagesBySourceId(requestParameters.sourceId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getStatusBySourceId operation in SourceUsagesApi.
 * @export
 * @interface SourceUsagesApiGetStatusBySourceIdRequest
 */
export interface SourceUsagesApiGetStatusBySourceIdRequest {
    /**
     * ID of IDN source
     * @type {string}
     * @memberof SourceUsagesApiGetStatusBySourceId
     */
    readonly sourceId: string
}

/**
 * Request parameters for getUsagesBySourceId operation in SourceUsagesApi.
 * @export
 * @interface SourceUsagesApiGetUsagesBySourceIdRequest
 */
export interface SourceUsagesApiGetUsagesBySourceIdRequest {
    /**
     * ID of IDN source
     * @type {string}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly sourceId: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
     * @type {string}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly sorters?: string
}

/**
 * SourceUsagesApi - object-oriented interface
 * @export
 * @class SourceUsagesApi
 * @extends {BaseAPI}
 */
export class SourceUsagesApi extends BaseAPI {
    /**
     * This API returns the status of the source usage insights setup by IDN source ID.
     * @summary Finds status of source usage
     * @param {SourceUsagesApiGetStatusBySourceIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceUsagesApi
     */
    public getStatusBySourceId(requestParameters: SourceUsagesApiGetStatusBySourceIdRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourceUsagesApiFp(this.configuration).getStatusBySourceId(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a summary of source usage insights for past 12 months.
     * @summary Returns source usage insights
     * @param {SourceUsagesApiGetUsagesBySourceIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceUsagesApi
     */
    public getUsagesBySourceId(requestParameters: SourceUsagesApiGetUsagesBySourceIdRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourceUsagesApiFp(this.configuration).getUsagesBySourceId(requestParameters.sourceId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SourcesApi - axios parameter creator
 * @export
 */
export const SourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy: async (sourceId: string, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('createProvisioningPolicy', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source 
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource: async (source: Source, provisionAsCsv?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('createSource', 'source', source)
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (provisionAsCsv !== undefined) {
                localVarQueryParameter['provisionAsCsv'] = provisionAsCsv;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(source, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to create a new schema on the specified source in Identity Security Cloud (ISC). 
         * @summary Create Schema on Source
         * @param {string} sourceId Source ID.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSourceSchema: async (sourceId: string, schema: Schema, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schema' is not null or undefined
            assertParamExists('createSourceSchema', 'schema', schema)
            const localVarPath = `/sources/{sourceId}/schemas`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy: async (sourceId: string, usageType: UsageType, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('deleteProvisioningPolicy', 'usageType', usageType)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to delete a specific source in Identity Security Cloud (ISC). The API removes all the accounts on the source first, and then it deletes the source. You can retrieve the actual task execution status with this method: GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSource', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceSchema: async (sourceId: string, schemaId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('deleteSourceSchema', 'schemaId', schemaId)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsSchema: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementsSchema: async (id: string, schemaName?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEntitlementsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (schemaName !== undefined) {
                localVarQueryParameter['schemaName'] = schemaName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy: async (sourceId: string, usageType: UsageType, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('getProvisioningPolicy', 'usageType', usageType)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get a source by a specified ID in Identity Security Cloud (ISC).
         * @summary Get Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSource', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get all dependent Profiles, Attributes, Applications and Custom Transforms for a source by a specified ID in Identity Security Cloud (ISC).
         * @summary Get Source Connections by ID
         * @param {string} sourceId Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceConnections: async (sourceId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceConnections', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/connections`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceHealth: async (sourceId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceHealth', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/source-health`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchema: async (sourceId: string, schemaId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('getSourceSchema', 'schemaId', schemaId)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to list the schemas that exist on the specified source in Identity Security Cloud (ISC).
         * @summary List Schemas on Source
         * @param {string} sourceId Source ID.
         * @param {GetSourceSchemasIncludeTypesV3} [includeTypes] If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized presently.  Note: The API will check whether include-types is group or not, if not, it will list schemas based on include-names, if include-names is not provided, it will list all schemas.
         * @param {string} [includeNames] A comma-separated list of schema names to filter result.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchemas: async (sourceId: string, includeTypes?: GetSourceSchemasIncludeTypesV3, includeNames?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceSchemas', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/schemas`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (includeTypes !== undefined) {
                localVarQueryParameter['include-types'] = includeTypes;
            }

            if (includeNames !== undefined) {
                localVarQueryParameter['include-names'] = includeNames;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importAccountsSchema: async (id: string, file?: File, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importAccountsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importConnectorFile: async (sourceId: string, file?: File, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('importConnectorFile', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/upload-connector-file`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importEntitlementsSchema: async (id: string, schemaName?: string, file?: File, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importEntitlementsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (schemaName !== undefined) {
                localVarQueryParameter['schemaName'] = schemaName;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies: async (sourceId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('listProvisioningPolicies', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/provisioning-policies`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the sources in IdentityNow.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **name**: *co, eq, in, sw, ge, gt, ne, isnull*  **type**: *eq, in, ge, gt, ne, isnull, sw*  **owner.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **features**: *ca, co*  **created**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **modified**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **managementWorkgroup.id**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **description**: *eq, sw*  **authoritative**: *eq, ne, isnull*  **healthy**: *isnull*  **status**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **connectionType**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **connectorName**: *eq, ge, gt, in, ne, isnull, sw*  **category**: *co, eq, ge, gt, in, le, lt, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status, id, description, owner.id, accountCorrelationConfig.id, accountCorrelationConfig.name, managerCorrelationRule.type, managerCorrelationRule.id, managerCorrelationRule.name, authoritative, managementWorkgroup.id, connectorName, connectionType**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {boolean} [includeIDNSource] Include the IdentityNow source in the response.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, includeIDNSource?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }

            if (includeIDNSource !== undefined) {
                localVarQueryParameter['includeIDNSource'] = includeIDNSource;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putProvisioningPolicy: async (sourceId: string, usageType: UsageType, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'usageType', usageType)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update a source in Identity Security Cloud (ISC), using a full object representation. This means that when you use this API, it completely replaces the existing source configuration.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error. 
         * @summary Update Source (Full)
         * @param {string} id Source ID.
         * @param {Source} source 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSource: async (id: string, source: Source, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putSource', 'id', id)
            // verify required parameter 'source' is not null or undefined
            assertParamExists('putSource', 'source', source)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(source, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceSchema: async (sourceId: string, schemaId: string, schema: Schema, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('putSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('putSourceSchema', 'schemaId', schemaId)
            // verify required parameter 'schema' is not null or undefined
            assertParamExists('putSourceSchema', 'schema', schema)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPoliciesInBulk: async (sourceId: string, provisioningPolicyDto: Array<ProvisioningPolicyDto>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateProvisioningPoliciesInBulk', 'sourceId', sourceId)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('updateProvisioningPoliciesInBulk', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/bulk-update`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy: async (sourceId: string, usageType: UsageType, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'usageType', usageType)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to partially update a source in Identity Security Cloud (ISC), using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error. 
         * @summary Update Source (Partial)
         * @param {string} id Source ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in Identity Security Cloud (ISC).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSource', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateSource', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceSchema: async (sourceId: string, schemaId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('updateSourceSchema', 'schemaId', schemaId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateSourceSchema', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesApi - functional programming interface
 * @export
 */
export const SourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createProvisioningPolicy(sourceId: string, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProvisioningPolicy(sourceId, provisioningPolicyDto, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.createProvisioningPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source 
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSource(source: Source, provisionAsCsv?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSource(source, provisionAsCsv, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.createSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to create a new schema on the specified source in Identity Security Cloud (ISC). 
         * @summary Create Schema on Source
         * @param {string} sourceId Source ID.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSourceSchema(sourceId: string, schema: Schema, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSourceSchema(sourceId, schema, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.createSourceSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProvisioningPolicy(sourceId, usageType, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.deleteProvisioningPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to delete a specific source in Identity Security Cloud (ISC). The API removes all the accounts on the source first, and then it deletes the source. You can retrieve the actual task execution status with this method: GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteSource202Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.deleteSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSourceSchema(sourceId: string, schemaId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSourceSchema(sourceId, schemaId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.deleteSourceSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsSchema(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsSchema(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.getAccountsSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitlementsSchema(id: string, schemaName?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitlementsSchema(id, schemaName, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.getEntitlementsSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProvisioningPolicy(sourceId, usageType, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.getProvisioningPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to get a source by a specified ID in Identity Security Cloud (ISC).
         * @summary Get Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSource(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSource(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.getSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to get all dependent Profiles, Attributes, Applications and Custom Transforms for a source by a specified ID in Identity Security Cloud (ISC).
         * @summary Get Source Connections by ID
         * @param {string} sourceId Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceConnections(sourceId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceConnectionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceConnections(sourceId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.getSourceConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceHealth(sourceId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceHealthDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceHealth(sourceId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.getSourceHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceSchema(sourceId: string, schemaId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceSchema(sourceId, schemaId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.getSourceSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to list the schemas that exist on the specified source in Identity Security Cloud (ISC).
         * @summary List Schemas on Source
         * @param {string} sourceId Source ID.
         * @param {GetSourceSchemasIncludeTypesV3} [includeTypes] If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized presently.  Note: The API will check whether include-types is group or not, if not, it will list schemas based on include-names, if include-names is not provided, it will list all schemas.
         * @param {string} [includeNames] A comma-separated list of schema names to filter result.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceSchemas(sourceId: string, includeTypes?: GetSourceSchemasIncludeTypesV3, includeNames?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceSchemas(sourceId, includeTypes, includeNames, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.getSourceSchemas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importAccountsSchema(id: string, file?: File, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importAccountsSchema(id, file, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.importAccountsSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importConnectorFile(sourceId: string, file?: File, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importConnectorFile(sourceId, file, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.importConnectorFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {File} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importEntitlementsSchema(id: string, schemaName?: string, file?: File, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importEntitlementsSchema(id, schemaName, file, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.importEntitlementsSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listProvisioningPolicies(sourceId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProvisioningPolicyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProvisioningPolicies(sourceId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.listProvisioningPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This end-point lists all the sources in IdentityNow.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **name**: *co, eq, in, sw, ge, gt, ne, isnull*  **type**: *eq, in, ge, gt, ne, isnull, sw*  **owner.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **features**: *ca, co*  **created**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **modified**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **managementWorkgroup.id**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **description**: *eq, sw*  **authoritative**: *eq, ne, isnull*  **healthy**: *isnull*  **status**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **connectionType**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **connectorName**: *eq, ge, gt, in, ne, isnull, sw*  **category**: *co, eq, ge, gt, in, le, lt, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status, id, description, owner.id, accountCorrelationConfig.id, accountCorrelationConfig.name, managerCorrelationRule.type, managerCorrelationRule.id, managerCorrelationRule.name, authoritative, managementWorkgroup.id, connectorName, connectionType**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {boolean} [includeIDNSource] Include the IdentityNow source in the response.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSources(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, includeIDNSource?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Source>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSources(limit, offset, count, filters, sorters, forSubadmin, includeIDNSource, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.listSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putProvisioningPolicy(sourceId: string, usageType: UsageType, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProvisioningPolicy(sourceId, usageType, provisioningPolicyDto, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.putProvisioningPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to update a source in Identity Security Cloud (ISC), using a full object representation. This means that when you use this API, it completely replaces the existing source configuration.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error. 
         * @summary Update Source (Full)
         * @param {string} id Source ID.
         * @param {Source} source 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSource(id: string, source: Source, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSource(id, source, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.putSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSourceSchema(sourceId: string, schemaId: string, schema: Schema, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSourceSchema(sourceId, schemaId, schema, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.putSourceSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateProvisioningPoliciesInBulk(sourceId: string, provisioningPolicyDto: Array<ProvisioningPolicyDto>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProvisioningPolicyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProvisioningPoliciesInBulk(sourceId, provisioningPolicyDto, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.updateProvisioningPoliciesInBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateProvisioningPolicy(sourceId: string, usageType: UsageType, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProvisioningPolicy(sourceId, usageType, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.updateProvisioningPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to partially update a source in Identity Security Cloud (ISC), using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error. 
         * @summary Update Source (Partial)
         * @param {string} id Source ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in Identity Security Cloud (ISC).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSource(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSource(id, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.updateSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSourceSchema(sourceId: string, schemaId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSourceSchema(sourceId, schemaId, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.updateSourceSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SourcesApi - factory interface
 * @export
 */
export const SourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourcesApiFp(configuration)
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information.
         * @summary Create Provisioning Policy
         * @param {SourcesApiCreateProvisioningPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy(requestParameters: SourcesApiCreateProvisioningPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.createProvisioningPolicy(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @summary Creates a source in IdentityNow.
         * @param {SourcesApiCreateSourceRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource(requestParameters: SourcesApiCreateSourceRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Source> {
            return localVarFp.createSource(requestParameters.source, requestParameters.provisionAsCsv, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to create a new schema on the specified source in Identity Security Cloud (ISC). 
         * @summary Create Schema on Source
         * @param {SourcesApiCreateSourceSchemaRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSourceSchema(requestParameters: SourcesApiCreateSourceSchemaRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Schema> {
            return localVarFp.createSourceSchema(requestParameters.sourceId, requestParameters.schema, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application.
         * @summary Delete Provisioning Policy by UsageType
         * @param {SourcesApiDeleteProvisioningPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy(requestParameters: SourcesApiDeleteProvisioningPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to delete a specific source in Identity Security Cloud (ISC). The API removes all the accounts on the source first, and then it deletes the source. You can retrieve the actual task execution status with this method: GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {SourcesApiDeleteSourceRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(requestParameters: SourcesApiDeleteSourceRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<DeleteSource202Response> {
            return localVarFp.deleteSource(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {SourcesApiDeleteSourceSchemaRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceSchema(requestParameters: SourcesApiDeleteSourceSchemaRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {SourcesApiGetAccountsSchemaRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsSchema(requestParameters: SourcesApiGetAccountsSchemaRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getAccountsSchema(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {SourcesApiGetEntitlementsSchemaRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementsSchema(requestParameters: SourcesApiGetEntitlementsSchemaRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getEntitlementsSchema(requestParameters.id, requestParameters.schemaName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow.
         * @summary Get Provisioning Policy by UsageType
         * @param {SourcesApiGetProvisioningPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy(requestParameters: SourcesApiGetProvisioningPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.getProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get a source by a specified ID in Identity Security Cloud (ISC).
         * @summary Get Source by ID
         * @param {SourcesApiGetSourceRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource(requestParameters: SourcesApiGetSourceRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Source> {
            return localVarFp.getSource(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get all dependent Profiles, Attributes, Applications and Custom Transforms for a source by a specified ID in Identity Security Cloud (ISC).
         * @summary Get Source Connections by ID
         * @param {SourcesApiGetSourceConnectionsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceConnections(requestParameters: SourcesApiGetSourceConnectionsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SourceConnectionsDto> {
            return localVarFp.getSourceConnections(requestParameters.sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {SourcesApiGetSourceHealthRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceHealth(requestParameters: SourcesApiGetSourceHealthRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<SourceHealthDto> {
            return localVarFp.getSourceHealth(requestParameters.sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {SourcesApiGetSourceSchemaRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchema(requestParameters: SourcesApiGetSourceSchemaRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Schema> {
            return localVarFp.getSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to list the schemas that exist on the specified source in Identity Security Cloud (ISC).
         * @summary List Schemas on Source
         * @param {SourcesApiGetSourceSchemasRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchemas(requestParameters: SourcesApiGetSourceSchemasRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<Schema>> {
            return localVarFp.getSourceSchemas(requestParameters.sourceId, requestParameters.includeTypes, requestParameters.includeNames, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {SourcesApiImportAccountsSchemaRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importAccountsSchema(requestParameters: SourcesApiImportAccountsSchemaRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Schema> {
            return localVarFp.importAccountsSchema(requestParameters.id, requestParameters.file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events.
         * @summary Upload connector file to source
         * @param {SourcesApiImportConnectorFileRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importConnectorFile(requestParameters: SourcesApiImportConnectorFileRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Source> {
            return localVarFp.importConnectorFile(requestParameters.sourceId, requestParameters.file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {SourcesApiImportEntitlementsSchemaRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importEntitlementsSchema(requestParameters: SourcesApiImportEntitlementsSchemaRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Schema> {
            return localVarFp.importEntitlementsSchema(requestParameters.id, requestParameters.schemaName, requestParameters.file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow.
         * @summary Lists ProvisioningPolicies
         * @param {SourcesApiListProvisioningPoliciesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies(requestParameters: SourcesApiListProvisioningPoliciesRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<ProvisioningPolicyDto>> {
            return localVarFp.listProvisioningPolicies(requestParameters.sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the sources in IdentityNow.
         * @summary Lists all sources in IdentityNow.
         * @param {SourcesApiListSourcesRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources(requestParameters: SourcesApiListSourcesRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<Source>> {
            return localVarFp.listSources(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSubadmin, requestParameters.includeIDNSource, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information.
         * @summary Update Provisioning Policy by UsageType
         * @param {SourcesApiPutProvisioningPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putProvisioningPolicy(requestParameters: SourcesApiPutProvisioningPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.putProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to update a source in Identity Security Cloud (ISC), using a full object representation. This means that when you use this API, it completely replaces the existing source configuration.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error. 
         * @summary Update Source (Full)
         * @param {SourcesApiPutSourceRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSource(requestParameters: SourcesApiPutSourceRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Source> {
            return localVarFp.putSource(requestParameters.id, requestParameters.source, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {SourcesApiPutSourceSchemaRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceSchema(requestParameters: SourcesApiPutSourceSchemaRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Schema> {
            return localVarFp.putSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.schema, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow.
         * @summary Bulk Update Provisioning Policies
         * @param {SourcesApiUpdateProvisioningPoliciesInBulkRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPoliciesInBulk(requestParameters: SourcesApiUpdateProvisioningPoliciesInBulkRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<ProvisioningPolicyDto>> {
            return localVarFp.updateProvisioningPoliciesInBulk(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information.
         * @summary Partial update of Provisioning Policy
         * @param {SourcesApiUpdateProvisioningPolicyRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy(requestParameters: SourcesApiUpdateProvisioningPolicyRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.updateProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to partially update a source in Identity Security Cloud (ISC), using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error. 
         * @summary Update Source (Partial)
         * @param {SourcesApiUpdateSourceRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(requestParameters: SourcesApiUpdateSourceRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Source> {
            return localVarFp.updateSource(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {SourcesApiUpdateSourceSchemaRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceSchema(requestParameters: SourcesApiUpdateSourceSchemaRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Schema> {
            return localVarFp.updateSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateProvisioningPolicyRequest
 */
export interface SourcesApiCreateProvisioningPolicyRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiCreateProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * 
     * @type {ProvisioningPolicyDto}
     * @memberof SourcesApiCreateProvisioningPolicy
     */
    readonly provisioningPolicyDto: ProvisioningPolicyDto
}

/**
 * Request parameters for createSource operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateSourceRequest
 */
export interface SourcesApiCreateSourceRequest {
    /**
     * 
     * @type {Source}
     * @memberof SourcesApiCreateSource
     */
    readonly source: Source

    /**
     * If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
     * @type {boolean}
     * @memberof SourcesApiCreateSource
     */
    readonly provisionAsCsv?: boolean
}

/**
 * Request parameters for createSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateSourceSchemaRequest
 */
export interface SourcesApiCreateSourceSchemaRequest {
    /**
     * Source ID.
     * @type {string}
     * @memberof SourcesApiCreateSourceSchema
     */
    readonly sourceId: string

    /**
     * 
     * @type {Schema}
     * @memberof SourcesApiCreateSourceSchema
     */
    readonly schema: Schema
}

/**
 * Request parameters for deleteProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteProvisioningPolicyRequest
 */
export interface SourcesApiDeleteProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiDeleteProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
     * @type {UsageType}
     * @memberof SourcesApiDeleteProvisioningPolicy
     */
    readonly usageType: UsageType
}

/**
 * Request parameters for deleteSource operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteSourceRequest
 */
export interface SourcesApiDeleteSourceRequest {
    /**
     * Source ID.
     * @type {string}
     * @memberof SourcesApiDeleteSource
     */
    readonly id: string
}

/**
 * Request parameters for deleteSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteSourceSchemaRequest
 */
export interface SourcesApiDeleteSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiDeleteSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiDeleteSourceSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for getAccountsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiGetAccountsSchemaRequest
 */
export interface SourcesApiGetAccountsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiGetAccountsSchema
     */
    readonly id: string
}

/**
 * Request parameters for getEntitlementsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiGetEntitlementsSchemaRequest
 */
export interface SourcesApiGetEntitlementsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiGetEntitlementsSchema
     */
    readonly id: string

    /**
     * Name of entitlement schema
     * @type {string}
     * @memberof SourcesApiGetEntitlementsSchema
     */
    readonly schemaName?: string
}

/**
 * Request parameters for getProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiGetProvisioningPolicyRequest
 */
export interface SourcesApiGetProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiGetProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
     * @type {UsageType}
     * @memberof SourcesApiGetProvisioningPolicy
     */
    readonly usageType: UsageType
}

/**
 * Request parameters for getSource operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceRequest
 */
export interface SourcesApiGetSourceRequest {
    /**
     * Source ID.
     * @type {string}
     * @memberof SourcesApiGetSource
     */
    readonly id: string
}

/**
 * Request parameters for getSourceConnections operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceConnectionsRequest
 */
export interface SourcesApiGetSourceConnectionsRequest {
    /**
     * Source ID.
     * @type {string}
     * @memberof SourcesApiGetSourceConnections
     */
    readonly sourceId: string
}

/**
 * Request parameters for getSourceHealth operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceHealthRequest
 */
export interface SourcesApiGetSourceHealthRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiGetSourceHealth
     */
    readonly sourceId: string
}

/**
 * Request parameters for getSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceSchemaRequest
 */
export interface SourcesApiGetSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiGetSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiGetSourceSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for getSourceSchemas operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceSchemasRequest
 */
export interface SourcesApiGetSourceSchemasRequest {
    /**
     * Source ID.
     * @type {string}
     * @memberof SourcesApiGetSourceSchemas
     */
    readonly sourceId: string

    /**
     * If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized presently.  Note: The API will check whether include-types is group or not, if not, it will list schemas based on include-names, if include-names is not provided, it will list all schemas.
     * @type {'group' | 'user'}
     * @memberof SourcesApiGetSourceSchemas
     */
    readonly includeTypes?: GetSourceSchemasIncludeTypesV3

    /**
     * A comma-separated list of schema names to filter result.
     * @type {string}
     * @memberof SourcesApiGetSourceSchemas
     */
    readonly includeNames?: string
}

/**
 * Request parameters for importAccountsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiImportAccountsSchemaRequest
 */
export interface SourcesApiImportAccountsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiImportAccountsSchema
     */
    readonly id: string

    /**
     * 
     * @type {File}
     * @memberof SourcesApiImportAccountsSchema
     */
    readonly file?: File
}

/**
 * Request parameters for importConnectorFile operation in SourcesApi.
 * @export
 * @interface SourcesApiImportConnectorFileRequest
 */
export interface SourcesApiImportConnectorFileRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiImportConnectorFile
     */
    readonly sourceId: string

    /**
     * 
     * @type {File}
     * @memberof SourcesApiImportConnectorFile
     */
    readonly file?: File
}

/**
 * Request parameters for importEntitlementsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiImportEntitlementsSchemaRequest
 */
export interface SourcesApiImportEntitlementsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiImportEntitlementsSchema
     */
    readonly id: string

    /**
     * Name of entitlement schema
     * @type {string}
     * @memberof SourcesApiImportEntitlementsSchema
     */
    readonly schemaName?: string

    /**
     * 
     * @type {File}
     * @memberof SourcesApiImportEntitlementsSchema
     */
    readonly file?: File
}

/**
 * Request parameters for listProvisioningPolicies operation in SourcesApi.
 * @export
 * @interface SourcesApiListProvisioningPoliciesRequest
 */
export interface SourcesApiListProvisioningPoliciesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiListProvisioningPolicies
     */
    readonly sourceId: string
}

/**
 * Request parameters for listSources operation in SourcesApi.
 * @export
 * @interface SourcesApiListSourcesRequest
 */
export interface SourcesApiListSourcesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourcesApiListSources
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourcesApiListSources
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SourcesApiListSources
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **name**: *co, eq, in, sw, ge, gt, ne, isnull*  **type**: *eq, in, ge, gt, ne, isnull, sw*  **owner.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **features**: *ca, co*  **created**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **modified**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **managementWorkgroup.id**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **description**: *eq, sw*  **authoritative**: *eq, ne, isnull*  **healthy**: *isnull*  **status**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **connectionType**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **connectorName**: *eq, ge, gt, in, ne, isnull, sw*  **category**: *co, eq, ge, gt, in, le, lt, ne, sw*
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status, id, description, owner.id, accountCorrelationConfig.id, accountCorrelationConfig.name, managerCorrelationRule.type, managerCorrelationRule.id, managerCorrelationRule.name, authoritative, managementWorkgroup.id, connectorName, connectionType**
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly sorters?: string

    /**
     * Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly forSubadmin?: string

    /**
     * Include the IdentityNow source in the response.
     * @type {boolean}
     * @memberof SourcesApiListSources
     */
    readonly includeIDNSource?: boolean
}

/**
 * Request parameters for putProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiPutProvisioningPolicyRequest
 */
export interface SourcesApiPutProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiPutProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
     * @type {UsageType}
     * @memberof SourcesApiPutProvisioningPolicy
     */
    readonly usageType: UsageType

    /**
     * 
     * @type {ProvisioningPolicyDto}
     * @memberof SourcesApiPutProvisioningPolicy
     */
    readonly provisioningPolicyDto: ProvisioningPolicyDto
}

/**
 * Request parameters for putSource operation in SourcesApi.
 * @export
 * @interface SourcesApiPutSourceRequest
 */
export interface SourcesApiPutSourceRequest {
    /**
     * Source ID.
     * @type {string}
     * @memberof SourcesApiPutSource
     */
    readonly id: string

    /**
     * 
     * @type {Source}
     * @memberof SourcesApiPutSource
     */
    readonly source: Source
}

/**
 * Request parameters for putSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiPutSourceSchemaRequest
 */
export interface SourcesApiPutSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiPutSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiPutSourceSchema
     */
    readonly schemaId: string

    /**
     * 
     * @type {Schema}
     * @memberof SourcesApiPutSourceSchema
     */
    readonly schema: Schema
}

/**
 * Request parameters for updateProvisioningPoliciesInBulk operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateProvisioningPoliciesInBulkRequest
 */
export interface SourcesApiUpdateProvisioningPoliciesInBulkRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateProvisioningPoliciesInBulk
     */
    readonly sourceId: string

    /**
     * 
     * @type {Array<ProvisioningPolicyDto>}
     * @memberof SourcesApiUpdateProvisioningPoliciesInBulk
     */
    readonly provisioningPolicyDto: Array<ProvisioningPolicyDto>
}

/**
 * Request parameters for updateProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateProvisioningPolicyRequest
 */
export interface SourcesApiUpdateProvisioningPolicyRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
     * @type {UsageType}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly usageType: UsageType

    /**
     * The JSONPatch payload used to update the schema.
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for updateSource operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateSourceRequest
 */
export interface SourcesApiUpdateSourceRequest {
    /**
     * Source ID.
     * @type {string}
     * @memberof SourcesApiUpdateSource
     */
    readonly id: string

    /**
     * A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in Identity Security Cloud (ISC).
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateSource
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for updateSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateSourceSchemaRequest
 */
export interface SourcesApiUpdateSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiUpdateSourceSchema
     */
    readonly schemaId: string

    /**
     * The JSONPatch payload used to update the schema.
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateSourceSchema
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * SourcesApi - object-oriented interface
 * @export
 * @class SourcesApi
 * @extends {BaseAPI}
 */
export class SourcesApi extends BaseAPI {
    /**
     * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information.
     * @summary Create Provisioning Policy
     * @param {SourcesApiCreateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createProvisioningPolicy(requestParameters: SourcesApiCreateProvisioningPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createProvisioningPolicy(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow.
     * @summary Creates a source in IdentityNow.
     * @param {SourcesApiCreateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createSource(requestParameters: SourcesApiCreateSourceRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createSource(requestParameters.source, requestParameters.provisionAsCsv, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to create a new schema on the specified source in Identity Security Cloud (ISC). 
     * @summary Create Schema on Source
     * @param {SourcesApiCreateSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createSourceSchema(requestParameters: SourcesApiCreateSourceSchemaRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createSourceSchema(requestParameters.sourceId, requestParameters.schema, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the provisioning policy with the specified usage on an application.
     * @summary Delete Provisioning Policy by UsageType
     * @param {SourcesApiDeleteProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteProvisioningPolicy(requestParameters: SourcesApiDeleteProvisioningPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to delete a specific source in Identity Security Cloud (ISC). The API removes all the accounts on the source first, and then it deletes the source. You can retrieve the actual task execution status with this method: GET `/task-status/{id}`
     * @summary Delete Source by ID
     * @param {SourcesApiDeleteSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteSource(requestParameters: SourcesApiDeleteSourceRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteSource(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Source Schema by ID
     * @param {SourcesApiDeleteSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteSourceSchema(requestParameters: SourcesApiDeleteSourceSchemaRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Downloads source accounts schema template
     * @param {SourcesApiGetAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getAccountsSchema(requestParameters: SourcesApiGetAccountsSchemaRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getAccountsSchema(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Downloads source entitlements schema template
     * @param {SourcesApiGetEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getEntitlementsSchema(requestParameters: SourcesApiGetEntitlementsSchemaRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getEntitlementsSchema(requestParameters.id, requestParameters.schemaName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow.
     * @summary Get Provisioning Policy by UsageType
     * @param {SourcesApiGetProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getProvisioningPolicy(requestParameters: SourcesApiGetProvisioningPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get a source by a specified ID in Identity Security Cloud (ISC).
     * @summary Get Source by ID
     * @param {SourcesApiGetSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSource(requestParameters: SourcesApiGetSourceRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSource(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get all dependent Profiles, Attributes, Applications and Custom Transforms for a source by a specified ID in Identity Security Cloud (ISC).
     * @summary Get Source Connections by ID
     * @param {SourcesApiGetSourceConnectionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourceConnections(requestParameters: SourcesApiGetSourceConnectionsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSourceConnections(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint fetches source health by source\'s id
     * @summary Fetches source health by id
     * @param {SourcesApiGetSourceHealthRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourceHealth(requestParameters: SourcesApiGetSourceHealthRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSourceHealth(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Source Schema by ID in IdentityNow. 
     * @summary Get Source Schema by ID
     * @param {SourcesApiGetSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourceSchema(requestParameters: SourcesApiGetSourceSchemaRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to list the schemas that exist on the specified source in Identity Security Cloud (ISC).
     * @summary List Schemas on Source
     * @param {SourcesApiGetSourceSchemasRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourceSchemas(requestParameters: SourcesApiGetSourceSchemasRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSourceSchemas(requestParameters.sourceId, requestParameters.includeTypes, requestParameters.includeNames, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Uploads source accounts schema template
     * @param {SourcesApiImportAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public importAccountsSchema(requestParameters: SourcesApiImportAccountsSchemaRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).importAccountsSchema(requestParameters.id, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events.
     * @summary Upload connector file to source
     * @param {SourcesApiImportConnectorFileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public importConnectorFile(requestParameters: SourcesApiImportConnectorFileRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).importConnectorFile(requestParameters.sourceId, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Uploads source entitlements schema template
     * @param {SourcesApiImportEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public importEntitlementsSchema(requestParameters: SourcesApiImportEntitlementsSchemaRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).importEntitlementsSchema(requestParameters.id, requestParameters.schemaName, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the ProvisioningPolicies in IdentityNow.
     * @summary Lists ProvisioningPolicies
     * @param {SourcesApiListProvisioningPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listProvisioningPolicies(requestParameters: SourcesApiListProvisioningPoliciesRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).listProvisioningPolicies(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the sources in IdentityNow.
     * @summary Lists all sources in IdentityNow.
     * @param {SourcesApiListSourcesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listSources(requestParameters: SourcesApiListSourcesRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).listSources(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSubadmin, requestParameters.includeIDNSource, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information.
     * @summary Update Provisioning Policy by UsageType
     * @param {SourcesApiPutProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public putProvisioningPolicy(requestParameters: SourcesApiPutProvisioningPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).putProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to update a source in Identity Security Cloud (ISC), using a full object representation. This means that when you use this API, it completely replaces the existing source configuration.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error. 
     * @summary Update Source (Full)
     * @param {SourcesApiPutSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public putSource(requestParameters: SourcesApiPutSourceRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).putSource(requestParameters.id, requestParameters.source, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
     * @summary Update Source Schema (Full)
     * @param {SourcesApiPutSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public putSourceSchema(requestParameters: SourcesApiPutSourceSchemaRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).putSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.schema, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point updates a list of provisioning policies on the specified source in IdentityNow.
     * @summary Bulk Update Provisioning Policies
     * @param {SourcesApiUpdateProvisioningPoliciesInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateProvisioningPoliciesInBulk(requestParameters: SourcesApiUpdateProvisioningPoliciesInBulkRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateProvisioningPoliciesInBulk(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information.
     * @summary Partial update of Provisioning Policy
     * @param {SourcesApiUpdateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateProvisioningPolicy(requestParameters: SourcesApiUpdateProvisioningPolicyRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to partially update a source in Identity Security Cloud (ISC), using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error. 
     * @summary Update Source (Partial)
     * @param {SourcesApiUpdateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateSource(requestParameters: SourcesApiUpdateSourceRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateSource(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
     * @summary Update Source Schema (Partial)
     * @param {SourcesApiUpdateSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateSourceSchema(requestParameters: SourcesApiUpdateSourceSchemaRequest, axiosOptions?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetSourceSchemasIncludeTypesV3 = {
    Group: 'group',
    User: 'user'
} as const;
export type GetSourceSchemasIncludeTypesV3 = typeof GetSourceSchemasIncludeTypesV3[keyof typeof GetSourceSchemasIncludeTypesV3];


/**
 * TaggedObjectsApi - axios parameter creator
 * @export
 */
export const TaggedObjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete all tags from a tagged object.
         * @summary Delete Object Tags
         * @param {DeleteTaggedObjectTypeV3} type The type of object to delete tags from.
         * @param {string} id The ID of the object to delete tags from.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaggedObject: async (type: DeleteTaggedObjectTypeV3, id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTaggedObject', 'id', id)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API removes tags from multiple objects.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkRemoveTaggedObject} bulkRemoveTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsToManyObject: async (bulkRemoveTaggedObject: BulkRemoveTaggedObject, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkRemoveTaggedObject' is not null or undefined
            assertParamExists('deleteTagsToManyObject', 'bulkRemoveTaggedObject', bulkRemoveTaggedObject)
            const localVarPath = `/tagged-objects/bulk-remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkRemoveTaggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {GetTaggedObjectTypeV3} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTaggedObject: async (type: GetTaggedObjectTypeV3, id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaggedObject', 'id', id)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjects: async (limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tagged-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects by Type
         * @param {ListTaggedObjectsByTypeTypeV3} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjectsByType: async (type: ListTaggedObjectsByTypeTypeV3, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('listTaggedObjectsByType', 'type', type)
            const localVarPath = `/tagged-objects/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {PutTaggedObjectTypeV3} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTaggedObject: async (type: PutTaggedObjectTypeV3, id: string, taggedObject: TaggedObject, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('putTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putTaggedObject', 'id', id)
            // verify required parameter 'taggedObject' is not null or undefined
            assertParamExists('putTaggedObject', 'taggedObject', taggedObject)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagToObject: async (taggedObject: TaggedObject, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taggedObject' is not null or undefined
            assertParamExists('setTagToObject', 'taggedObject', taggedObject)
            const localVarPath = `/tagged-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API adds tags to multiple objects.
         * @summary Tag Multiple Objects
         * @param {BulkAddTaggedObject} bulkAddTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagsToManyObjects: async (bulkAddTaggedObject: BulkAddTaggedObject, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkAddTaggedObject' is not null or undefined
            assertParamExists('setTagsToManyObjects', 'bulkAddTaggedObject', bulkAddTaggedObject)
            const localVarPath = `/tagged-objects/bulk-add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication applicationAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "applicationAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkAddTaggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaggedObjectsApi - functional programming interface
 * @export
 */
export const TaggedObjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaggedObjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete all tags from a tagged object.
         * @summary Delete Object Tags
         * @param {DeleteTaggedObjectTypeV3} type The type of object to delete tags from.
         * @param {string} id The ID of the object to delete tags from.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaggedObject(type: DeleteTaggedObjectTypeV3, id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaggedObject(type, id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaggedObjectsApi.deleteTaggedObject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API removes tags from multiple objects.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkRemoveTaggedObject} bulkRemoveTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTagsToManyObject(bulkRemoveTaggedObject: BulkRemoveTaggedObject, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTagsToManyObject(bulkRemoveTaggedObject, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaggedObjectsApi.deleteTagsToManyObject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {GetTaggedObjectTypeV3} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTaggedObject(type: GetTaggedObjectTypeV3, id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggedObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaggedObject(type, id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaggedObjectsApi.getTaggedObject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTaggedObjects(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaggedObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTaggedObjects(limit, offset, count, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaggedObjectsApi.listTaggedObjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects by Type
         * @param {ListTaggedObjectsByTypeTypeV3} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTaggedObjectsByType(type: ListTaggedObjectsByTypeTypeV3, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaggedObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTaggedObjectsByType(type, limit, offset, count, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaggedObjectsApi.listTaggedObjectsByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {PutTaggedObjectTypeV3} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putTaggedObject(type: PutTaggedObjectTypeV3, id: string, taggedObject: TaggedObject, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggedObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTaggedObject(type, id, taggedObject, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaggedObjectsApi.putTaggedObject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setTagToObject(taggedObject: TaggedObject, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTagToObject(taggedObject, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaggedObjectsApi.setTagToObject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API adds tags to multiple objects.
         * @summary Tag Multiple Objects
         * @param {BulkAddTaggedObject} bulkAddTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setTagsToManyObjects(bulkAddTaggedObject: BulkAddTaggedObject, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BulkTaggedObjectResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTagsToManyObjects(bulkAddTaggedObject, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaggedObjectsApi.setTagsToManyObjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TaggedObjectsApi - factory interface
 * @export
 */
export const TaggedObjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaggedObjectsApiFp(configuration)
    return {
        /**
         * Delete all tags from a tagged object.
         * @summary Delete Object Tags
         * @param {TaggedObjectsApiDeleteTaggedObjectRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaggedObject(requestParameters: TaggedObjectsApiDeleteTaggedObjectRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API removes tags from multiple objects.
         * @summary Remove Tags from Multiple Objects
         * @param {TaggedObjectsApiDeleteTagsToManyObjectRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsToManyObject(requestParameters: TaggedObjectsApiDeleteTagsToManyObjectRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTagsToManyObject(requestParameters.bulkRemoveTaggedObject, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {TaggedObjectsApiGetTaggedObjectRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTaggedObject(requestParameters: TaggedObjectsApiGetTaggedObjectRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<TaggedObject> {
            return localVarFp.getTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {TaggedObjectsApiListTaggedObjectsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjects(requestParameters: TaggedObjectsApiListTaggedObjectsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<TaggedObject>> {
            return localVarFp.listTaggedObjects(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects by Type
         * @param {TaggedObjectsApiListTaggedObjectsByTypeRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjectsByType(requestParameters: TaggedObjectsApiListTaggedObjectsByTypeRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<TaggedObject>> {
            return localVarFp.listTaggedObjectsByType(requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {TaggedObjectsApiPutTaggedObjectRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTaggedObject(requestParameters: TaggedObjectsApiPutTaggedObjectRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<TaggedObject> {
            return localVarFp.putTaggedObject(requestParameters.type, requestParameters.id, requestParameters.taggedObject, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObjectsApiSetTagToObjectRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagToObject(requestParameters: TaggedObjectsApiSetTagToObjectRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setTagToObject(requestParameters.taggedObject, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API adds tags to multiple objects.
         * @summary Tag Multiple Objects
         * @param {TaggedObjectsApiSetTagsToManyObjectsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagsToManyObjects(requestParameters: TaggedObjectsApiSetTagsToManyObjectsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<BulkTaggedObjectResponse>> {
            return localVarFp.setTagsToManyObjects(requestParameters.bulkAddTaggedObject, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteTaggedObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiDeleteTaggedObjectRequest
 */
export interface TaggedObjectsApiDeleteTaggedObjectRequest {
    /**
     * The type of object to delete tags from.
     * @type {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'}
     * @memberof TaggedObjectsApiDeleteTaggedObject
     */
    readonly type: DeleteTaggedObjectTypeV3

    /**
     * The ID of the object to delete tags from.
     * @type {string}
     * @memberof TaggedObjectsApiDeleteTaggedObject
     */
    readonly id: string
}

/**
 * Request parameters for deleteTagsToManyObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiDeleteTagsToManyObjectRequest
 */
export interface TaggedObjectsApiDeleteTagsToManyObjectRequest {
    /**
     * Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
     * @type {BulkRemoveTaggedObject}
     * @memberof TaggedObjectsApiDeleteTagsToManyObject
     */
    readonly bulkRemoveTaggedObject: BulkRemoveTaggedObject
}

/**
 * Request parameters for getTaggedObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiGetTaggedObjectRequest
 */
export interface TaggedObjectsApiGetTaggedObjectRequest {
    /**
     * The type of tagged object to retrieve.
     * @type {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'}
     * @memberof TaggedObjectsApiGetTaggedObject
     */
    readonly type: GetTaggedObjectTypeV3

    /**
     * The ID of the object reference to retrieve.
     * @type {string}
     * @memberof TaggedObjectsApiGetTaggedObject
     */
    readonly id: string
}

/**
 * Request parameters for listTaggedObjects operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiListTaggedObjectsRequest
 */
export interface TaggedObjectsApiListTaggedObjectsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
     * @type {string}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly filters?: string
}

/**
 * Request parameters for listTaggedObjectsByType operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiListTaggedObjectsByTypeRequest
 */
export interface TaggedObjectsApiListTaggedObjectsByTypeRequest {
    /**
     * The type of tagged object to retrieve.
     * @type {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly type: ListTaggedObjectsByTypeTypeV3

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
     * @type {string}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly filters?: string
}

/**
 * Request parameters for putTaggedObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiPutTaggedObjectRequest
 */
export interface TaggedObjectsApiPutTaggedObjectRequest {
    /**
     * The type of tagged object to update.
     * @type {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'}
     * @memberof TaggedObjectsApiPutTaggedObject
     */
    readonly type: PutTaggedObjectTypeV3

    /**
     * The ID of the object reference to update.
     * @type {string}
     * @memberof TaggedObjectsApiPutTaggedObject
     */
    readonly id: string

    /**
     * 
     * @type {TaggedObject}
     * @memberof TaggedObjectsApiPutTaggedObject
     */
    readonly taggedObject: TaggedObject
}

/**
 * Request parameters for setTagToObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiSetTagToObjectRequest
 */
export interface TaggedObjectsApiSetTagToObjectRequest {
    /**
     * 
     * @type {TaggedObject}
     * @memberof TaggedObjectsApiSetTagToObject
     */
    readonly taggedObject: TaggedObject
}

/**
 * Request parameters for setTagsToManyObjects operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiSetTagsToManyObjectsRequest
 */
export interface TaggedObjectsApiSetTagsToManyObjectsRequest {
    /**
     * Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
     * @type {BulkAddTaggedObject}
     * @memberof TaggedObjectsApiSetTagsToManyObjects
     */
    readonly bulkAddTaggedObject: BulkAddTaggedObject
}

/**
 * TaggedObjectsApi - object-oriented interface
 * @export
 * @class TaggedObjectsApi
 * @extends {BaseAPI}
 */
export class TaggedObjectsApi extends BaseAPI {
    /**
     * Delete all tags from a tagged object.
     * @summary Delete Object Tags
     * @param {TaggedObjectsApiDeleteTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public deleteTaggedObject(requestParameters: TaggedObjectsApiDeleteTaggedObjectRequest, axiosOptions?: RawAxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).deleteTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API removes tags from multiple objects.
     * @summary Remove Tags from Multiple Objects
     * @param {TaggedObjectsApiDeleteTagsToManyObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public deleteTagsToManyObject(requestParameters: TaggedObjectsApiDeleteTagsToManyObjectRequest, axiosOptions?: RawAxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).deleteTagsToManyObject(requestParameters.bulkRemoveTaggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a tagged object for the specified type.
     * @summary Get Tagged Object
     * @param {TaggedObjectsApiGetTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public getTaggedObject(requestParameters: TaggedObjectsApiGetTaggedObjectRequest, axiosOptions?: RawAxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).getTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
     * @summary List Tagged Objects
     * @param {TaggedObjectsApiListTaggedObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public listTaggedObjects(requestParameters: TaggedObjectsApiListTaggedObjectsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).listTaggedObjects(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
     * @summary List Tagged Objects by Type
     * @param {TaggedObjectsApiListTaggedObjectsByTypeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public listTaggedObjectsByType(requestParameters: TaggedObjectsApiListTaggedObjectsByTypeRequest, axiosOptions?: RawAxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).listTaggedObjectsByType(requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates a tagged object for the specified type.
     * @summary Update Tagged Object
     * @param {TaggedObjectsApiPutTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public putTaggedObject(requestParameters: TaggedObjectsApiPutTaggedObjectRequest, axiosOptions?: RawAxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).putTaggedObject(requestParameters.type, requestParameters.id, requestParameters.taggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This adds a tag to an object.  Any authenticated token may be used to call this API.
     * @summary Add Tag to Object
     * @param {TaggedObjectsApiSetTagToObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public setTagToObject(requestParameters: TaggedObjectsApiSetTagToObjectRequest, axiosOptions?: RawAxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).setTagToObject(requestParameters.taggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API adds tags to multiple objects.
     * @summary Tag Multiple Objects
     * @param {TaggedObjectsApiSetTagsToManyObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public setTagsToManyObjects(requestParameters: TaggedObjectsApiSetTagsToManyObjectsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).setTagsToManyObjects(requestParameters.bulkAddTaggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteTaggedObjectTypeV3 = {
    AccessProfile: 'ACCESS_PROFILE',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    Entitlement: 'ENTITLEMENT',
    Identity: 'IDENTITY',
    Role: 'ROLE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE'
} as const;
export type DeleteTaggedObjectTypeV3 = typeof DeleteTaggedObjectTypeV3[keyof typeof DeleteTaggedObjectTypeV3];
/**
 * @export
 */
export const GetTaggedObjectTypeV3 = {
    AccessProfile: 'ACCESS_PROFILE',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    Entitlement: 'ENTITLEMENT',
    Identity: 'IDENTITY',
    Role: 'ROLE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE'
} as const;
export type GetTaggedObjectTypeV3 = typeof GetTaggedObjectTypeV3[keyof typeof GetTaggedObjectTypeV3];
/**
 * @export
 */
export const ListTaggedObjectsByTypeTypeV3 = {
    AccessProfile: 'ACCESS_PROFILE',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    Entitlement: 'ENTITLEMENT',
    Identity: 'IDENTITY',
    Role: 'ROLE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE'
} as const;
export type ListTaggedObjectsByTypeTypeV3 = typeof ListTaggedObjectsByTypeTypeV3[keyof typeof ListTaggedObjectsByTypeTypeV3];
/**
 * @export
 */
export const PutTaggedObjectTypeV3 = {
    AccessProfile: 'ACCESS_PROFILE',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    Entitlement: 'ENTITLEMENT',
    Identity: 'IDENTITY',
    Role: 'ROLE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE'
} as const;
export type PutTaggedObjectTypeV3 = typeof PutTaggedObjectTypeV3[keyof typeof PutTaggedObjectTypeV3];


/**
 * TransformsApi - axios parameter creator
 * @export
 */
export const TransformsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform: async (transform: Transform, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transform' is not null or undefined
            assertParamExists('createTransform', 'transform', transform)
            const localVarPath = `/transforms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transform, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the transform specified by the given ID.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all saved transform objects.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **internal**: *eq*  **name**: *eq, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTransforms: async (offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transforms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object. Must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields, but \&quot;name\&quot; and \&quot;type\&quot; must not be modified.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform: async (id: string, transform?: Transform, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transform, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransformsApi - functional programming interface
 * @export
 */
export const TransformsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransformsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createTransform(transform: Transform, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransformRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransform(transform, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransformsApi.createTransform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransform(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransform(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransformsApi.deleteTransform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API returns the transform specified by the given ID.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTransform(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransformRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransform(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransformsApi.getTransform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a list of all saved transform objects.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **internal**: *eq*  **name**: *eq, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTransforms(offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransformRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransforms(offset, limit, count, name, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransformsApi.listTransforms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object. Must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields, but \&quot;name\&quot; and \&quot;type\&quot; must not be modified.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransform(id: string, transform?: Transform, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransformRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransform(id, transform, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransformsApi.updateTransform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransformsApi - factory interface
 * @export
 */
export const TransformsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransformsApiFp(configuration)
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI.
         * @summary Create transform
         * @param {TransformsApiCreateTransformRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform(requestParameters: TransformsApiCreateTransformRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<TransformRead> {
            return localVarFp.createTransform(requestParameters.transform, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform.
         * @summary Delete a transform
         * @param {TransformsApiDeleteTransformRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform(requestParameters: TransformsApiDeleteTransformRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTransform(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the transform specified by the given ID.
         * @summary Transform by ID
         * @param {TransformsApiGetTransformRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform(requestParameters: TransformsApiGetTransformRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<TransformRead> {
            return localVarFp.getTransform(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all saved transform objects.
         * @summary List transforms
         * @param {TransformsApiListTransformsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTransforms(requestParameters: TransformsApiListTransformsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<TransformRead>> {
            return localVarFp.listTransforms(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.name, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error.
         * @summary Update a transform
         * @param {TransformsApiUpdateTransformRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform(requestParameters: TransformsApiUpdateTransformRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<TransformRead> {
            return localVarFp.updateTransform(requestParameters.id, requestParameters.transform, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiCreateTransformRequest
 */
export interface TransformsApiCreateTransformRequest {
    /**
     * The transform to be created.
     * @type {Transform}
     * @memberof TransformsApiCreateTransform
     */
    readonly transform: Transform
}

/**
 * Request parameters for deleteTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiDeleteTransformRequest
 */
export interface TransformsApiDeleteTransformRequest {
    /**
     * ID of the transform to delete
     * @type {string}
     * @memberof TransformsApiDeleteTransform
     */
    readonly id: string
}

/**
 * Request parameters for getTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiGetTransformRequest
 */
export interface TransformsApiGetTransformRequest {
    /**
     * ID of the transform to retrieve
     * @type {string}
     * @memberof TransformsApiGetTransform
     */
    readonly id: string
}

/**
 * Request parameters for listTransforms operation in TransformsApi.
 * @export
 * @interface TransformsApiListTransformsRequest
 */
export interface TransformsApiListTransformsRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TransformsApiListTransforms
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TransformsApiListTransforms
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TransformsApiListTransforms
     */
    readonly count?: boolean

    /**
     * Name of the transform to retrieve from the list.
     * @type {string}
     * @memberof TransformsApiListTransforms
     */
    readonly name?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **internal**: *eq*  **name**: *eq, sw*
     * @type {string}
     * @memberof TransformsApiListTransforms
     */
    readonly filters?: string
}

/**
 * Request parameters for updateTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiUpdateTransformRequest
 */
export interface TransformsApiUpdateTransformRequest {
    /**
     * ID of the transform to update
     * @type {string}
     * @memberof TransformsApiUpdateTransform
     */
    readonly id: string

    /**
     * The updated transform object. Must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields, but \&quot;name\&quot; and \&quot;type\&quot; must not be modified.
     * @type {Transform}
     * @memberof TransformsApiUpdateTransform
     */
    readonly transform?: Transform
}

/**
 * TransformsApi - object-oriented interface
 * @export
 * @class TransformsApi
 * @extends {BaseAPI}
 */
export class TransformsApi extends BaseAPI {
    /**
     * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI.
     * @summary Create transform
     * @param {TransformsApiCreateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public createTransform(requestParameters: TransformsApiCreateTransformRequest, axiosOptions?: RawAxiosRequestConfig) {
        return TransformsApiFp(this.configuration).createTransform(requestParameters.transform, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform.
     * @summary Delete a transform
     * @param {TransformsApiDeleteTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public deleteTransform(requestParameters: TransformsApiDeleteTransformRequest, axiosOptions?: RawAxiosRequestConfig) {
        return TransformsApiFp(this.configuration).deleteTransform(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the transform specified by the given ID.
     * @summary Transform by ID
     * @param {TransformsApiGetTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public getTransform(requestParameters: TransformsApiGetTransformRequest, axiosOptions?: RawAxiosRequestConfig) {
        return TransformsApiFp(this.configuration).getTransform(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all saved transform objects.
     * @summary List transforms
     * @param {TransformsApiListTransformsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public listTransforms(requestParameters: TransformsApiListTransformsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return TransformsApiFp(this.configuration).listTransforms(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.name, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error.
     * @summary Update a transform
     * @param {TransformsApiUpdateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public updateTransform(requestParameters: TransformsApiUpdateTransformRequest, axiosOptions?: RawAxiosRequestConfig) {
        return TransformsApiFp(this.configuration).updateTransform(requestParameters.id, requestParameters.transform, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VendorConnectorMappingsApi - axios parameter creator
 * @export
 */
export const VendorConnectorMappingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new mapping between a SaaS vendor and an ISC connector to establish correlation paths. 
         * @summary Create Vendor Connector Mapping
         * @param {VendorConnectorMapping} vendorConnectorMapping 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createVendorConnectorMapping: async (vendorConnectorMapping: VendorConnectorMapping, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorConnectorMapping' is not null or undefined
            assertParamExists('createVendorConnectorMapping', 'vendorConnectorMapping', vendorConnectorMapping)
            const localVarPath = `/vendor-connector-mappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vendorConnectorMapping, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Soft delete a mapping between a SaaS vendor and an ISC connector, removing the established correlation. 
         * @summary Delete Vendor Connector Mapping
         * @param {VendorConnectorMapping} vendorConnectorMapping 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteVendorConnectorMapping: async (vendorConnectorMapping: VendorConnectorMapping, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorConnectorMapping' is not null or undefined
            assertParamExists('deleteVendorConnectorMapping', 'vendorConnectorMapping', vendorConnectorMapping)
            const localVarPath = `/vendor-connector-mappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vendorConnectorMapping, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a list of mappings between SaaS vendors and ISC connectors, detailing the connections established for correlation. 
         * @summary List Vendor Connector Mappings
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getVendorConnectorMappings: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vendor-connector-mappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * VendorConnectorMappingsApi - functional programming interface
 * @export
 */
export const VendorConnectorMappingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VendorConnectorMappingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new mapping between a SaaS vendor and an ISC connector to establish correlation paths. 
         * @summary Create Vendor Connector Mapping
         * @param {VendorConnectorMapping} vendorConnectorMapping 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createVendorConnectorMapping(vendorConnectorMapping: VendorConnectorMapping, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorConnectorMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVendorConnectorMapping(vendorConnectorMapping, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorConnectorMappingsApi.createVendorConnectorMapping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Soft delete a mapping between a SaaS vendor and an ISC connector, removing the established correlation. 
         * @summary Delete Vendor Connector Mapping
         * @param {VendorConnectorMapping} vendorConnectorMapping 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVendorConnectorMapping(vendorConnectorMapping: VendorConnectorMapping, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteVendorConnectorMapping200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVendorConnectorMapping(vendorConnectorMapping, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorConnectorMappingsApi.deleteVendorConnectorMapping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of mappings between SaaS vendors and ISC connectors, detailing the connections established for correlation. 
         * @summary List Vendor Connector Mappings
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getVendorConnectorMappings(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorConnectorMapping>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVendorConnectorMappings(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorConnectorMappingsApi.getVendorConnectorMappings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VendorConnectorMappingsApi - factory interface
 * @export
 */
export const VendorConnectorMappingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VendorConnectorMappingsApiFp(configuration)
    return {
        /**
         * Create a new mapping between a SaaS vendor and an ISC connector to establish correlation paths. 
         * @summary Create Vendor Connector Mapping
         * @param {VendorConnectorMappingsApiCreateVendorConnectorMappingRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createVendorConnectorMapping(requestParameters: VendorConnectorMappingsApiCreateVendorConnectorMappingRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<VendorConnectorMapping> {
            return localVarFp.createVendorConnectorMapping(requestParameters.vendorConnectorMapping, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Soft delete a mapping between a SaaS vendor and an ISC connector, removing the established correlation. 
         * @summary Delete Vendor Connector Mapping
         * @param {VendorConnectorMappingsApiDeleteVendorConnectorMappingRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteVendorConnectorMapping(requestParameters: VendorConnectorMappingsApiDeleteVendorConnectorMappingRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<DeleteVendorConnectorMapping200Response> {
            return localVarFp.deleteVendorConnectorMapping(requestParameters.vendorConnectorMapping, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of mappings between SaaS vendors and ISC connectors, detailing the connections established for correlation. 
         * @summary List Vendor Connector Mappings
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getVendorConnectorMappings(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<VendorConnectorMapping>> {
            return localVarFp.getVendorConnectorMappings(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createVendorConnectorMapping operation in VendorConnectorMappingsApi.
 * @export
 * @interface VendorConnectorMappingsApiCreateVendorConnectorMappingRequest
 */
export interface VendorConnectorMappingsApiCreateVendorConnectorMappingRequest {
    /**
     * 
     * @type {VendorConnectorMapping}
     * @memberof VendorConnectorMappingsApiCreateVendorConnectorMapping
     */
    readonly vendorConnectorMapping: VendorConnectorMapping
}

/**
 * Request parameters for deleteVendorConnectorMapping operation in VendorConnectorMappingsApi.
 * @export
 * @interface VendorConnectorMappingsApiDeleteVendorConnectorMappingRequest
 */
export interface VendorConnectorMappingsApiDeleteVendorConnectorMappingRequest {
    /**
     * 
     * @type {VendorConnectorMapping}
     * @memberof VendorConnectorMappingsApiDeleteVendorConnectorMapping
     */
    readonly vendorConnectorMapping: VendorConnectorMapping
}

/**
 * VendorConnectorMappingsApi - object-oriented interface
 * @export
 * @class VendorConnectorMappingsApi
 * @extends {BaseAPI}
 */
export class VendorConnectorMappingsApi extends BaseAPI {
    /**
     * Create a new mapping between a SaaS vendor and an ISC connector to establish correlation paths. 
     * @summary Create Vendor Connector Mapping
     * @param {VendorConnectorMappingsApiCreateVendorConnectorMappingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorConnectorMappingsApi
     */
    public createVendorConnectorMapping(requestParameters: VendorConnectorMappingsApiCreateVendorConnectorMappingRequest, axiosOptions?: RawAxiosRequestConfig) {
        return VendorConnectorMappingsApiFp(this.configuration).createVendorConnectorMapping(requestParameters.vendorConnectorMapping, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft delete a mapping between a SaaS vendor and an ISC connector, removing the established correlation. 
     * @summary Delete Vendor Connector Mapping
     * @param {VendorConnectorMappingsApiDeleteVendorConnectorMappingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorConnectorMappingsApi
     */
    public deleteVendorConnectorMapping(requestParameters: VendorConnectorMappingsApiDeleteVendorConnectorMappingRequest, axiosOptions?: RawAxiosRequestConfig) {
        return VendorConnectorMappingsApiFp(this.configuration).deleteVendorConnectorMapping(requestParameters.vendorConnectorMapping, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of mappings between SaaS vendors and ISC connectors, detailing the connections established for correlation. 
     * @summary List Vendor Connector Mappings
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorConnectorMappingsApi
     */
    public getVendorConnectorMappings(axiosOptions?: RawAxiosRequestConfig) {
        return VendorConnectorMappingsApiFp(this.configuration).getVendorConnectorMappings(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkItemsApi - axios parameter creator
 * @export
 */
export const WorkItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem: async (id: string, approvalItemId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveApprovalItem', 'id', id)
            // verify required parameter 'approvalItemId' is not null or undefined
            assertParamExists('approveApprovalItem', 'approvalItemId', approvalItemId)
            const localVarPath = `/work-items/{id}/approve/{approvalItemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"approvalItemId"}}`, encodeURIComponent(String(approvalItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItemsInBulk: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveApprovalItemsInBulk', 'id', id)
            const localVarPath = `/work-items/bulk-approve/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {string | null} [body] Body is the request payload to create form definition request
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem: async (id: string, body?: string | null, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeWorkItem', 'id', id)
            const localVarPath = `/work-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCompletedWorkItems: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountCompletedWorkItems: async (ownerId?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/completed/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountWorkItems: async (ownerId?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItem: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkItem', 'id', id)
            const localVarPath = `/work-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsSummary: async (ownerId?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems: async (limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem: async (id: string, approvalItemId: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectApprovalItem', 'id', id)
            // verify required parameter 'approvalItemId' is not null or undefined
            assertParamExists('rejectApprovalItem', 'approvalItemId', approvalItemId)
            const localVarPath = `/work-items/{id}/reject/{approvalItemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"approvalItemId"}}`, encodeURIComponent(String(approvalItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItemsInBulk: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectApprovalItemsInBulk', 'id', id)
            const localVarPath = `/work-items/bulk-reject/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API forwards a work item to a new owner. Either an admin, or the owning/current user must make this request. Accessible to work-item Owner, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN.
         * @summary Forward a Work Item
         * @param {string} id The ID of the work item
         * @param {WorkItemForward} workItemForward 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendWorkItemForward: async (id: string, workItemForward: WorkItemForward, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sendWorkItemForward', 'id', id)
            // verify required parameter 'workItemForward' is not null or undefined
            assertParamExists('sendWorkItemForward', 'workItemForward', workItemForward)
            const localVarPath = `/work-items/{id}/forward`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workItemForward, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection: async (id: string, requestBody: { [key: string]: any; }, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitAccountSelection', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('submitAccountSelection', 'requestBody', requestBody)
            const localVarPath = `/work-items/{id}/submit-account-selection`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", ["sp:scopes:all"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkItemsApi - functional programming interface
 * @export
 */
export const WorkItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveApprovalItem(id: string, approvalItemId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveApprovalItem(id, approvalItemId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkItemsApi.approveApprovalItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveApprovalItemsInBulk(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveApprovalItemsInBulk(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkItemsApi.approveApprovalItemsInBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {string | null} [body] Body is the request payload to create form definition request
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async completeWorkItem(id: string, body?: string | null, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeWorkItem(id, body, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkItemsApi.completeWorkItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCompletedWorkItems(ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItems>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompletedWorkItems(ownerId, limit, offset, count, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkItemsApi.getCompletedWorkItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCountCompletedWorkItems(ownerId?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountCompletedWorkItems(ownerId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkItemsApi.getCountCompletedWorkItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCountWorkItems(ownerId?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountWorkItems(ownerId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkItemsApi.getCountWorkItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItem(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItem(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkItemsApi.getWorkItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItemsSummary(ownerId?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItemsSummary(ownerId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkItemsApi.getWorkItemsSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkItems(limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItems>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkItems(limit, offset, count, ownerId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkItemsApi.listWorkItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectApprovalItem(id: string, approvalItemId: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectApprovalItem(id, approvalItemId, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkItemsApi.rejectApprovalItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectApprovalItemsInBulk(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectApprovalItemsInBulk(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkItemsApi.rejectApprovalItemsInBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API forwards a work item to a new owner. Either an admin, or the owning/current user must make this request. Accessible to work-item Owner, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN.
         * @summary Forward a Work Item
         * @param {string} id The ID of the work item
         * @param {WorkItemForward} workItemForward 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async sendWorkItemForward(id: string, workItemForward: WorkItemForward, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendWorkItemForward(id, workItemForward, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkItemsApi.sendWorkItemForward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async submitAccountSelection(id: string, requestBody: { [key: string]: any; }, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitAccountSelection(id, requestBody, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkItemsApi.submitAccountSelection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkItemsApi - factory interface
 * @export
 */
export const WorkItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkItemsApiFp(configuration)
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {WorkItemsApiApproveApprovalItemRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem(requestParameters: WorkItemsApiApproveApprovalItemRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.approveApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {WorkItemsApiApproveApprovalItemsInBulkRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItemsInBulk(requestParameters: WorkItemsApiApproveApprovalItemsInBulkRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.approveApprovalItemsInBulk(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {WorkItemsApiCompleteWorkItemRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem(requestParameters: WorkItemsApiCompleteWorkItemRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.completeWorkItem(requestParameters.id, requestParameters.body, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {WorkItemsApiGetCompletedWorkItemsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCompletedWorkItems(requestParameters: WorkItemsApiGetCompletedWorkItemsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<WorkItems>> {
            return localVarFp.getCompletedWorkItems(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {WorkItemsApiGetCountCompletedWorkItemsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountCompletedWorkItems(requestParameters: WorkItemsApiGetCountCompletedWorkItemsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<WorkItemsCount> {
            return localVarFp.getCountCompletedWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {WorkItemsApiGetCountWorkItemsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountWorkItems(requestParameters: WorkItemsApiGetCountWorkItemsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<WorkItemsCount> {
            return localVarFp.getCountWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {WorkItemsApiGetWorkItemRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItem(requestParameters: WorkItemsApiGetWorkItemRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.getWorkItem(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {WorkItemsApiGetWorkItemsSummaryRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsSummary(requestParameters: WorkItemsApiGetWorkItemsSummaryRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<WorkItemsSummary> {
            return localVarFp.getWorkItemsSummary(requestParameters.ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {WorkItemsApiListWorkItemsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems(requestParameters: WorkItemsApiListWorkItemsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<WorkItems>> {
            return localVarFp.listWorkItems(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {WorkItemsApiRejectApprovalItemRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem(requestParameters: WorkItemsApiRejectApprovalItemRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.rejectApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {WorkItemsApiRejectApprovalItemsInBulkRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItemsInBulk(requestParameters: WorkItemsApiRejectApprovalItemsInBulkRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.rejectApprovalItemsInBulk(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API forwards a work item to a new owner. Either an admin, or the owning/current user must make this request. Accessible to work-item Owner, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN.
         * @summary Forward a Work Item
         * @param {WorkItemsApiSendWorkItemForwardRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendWorkItemForward(requestParameters: WorkItemsApiSendWorkItemForwardRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendWorkItemForward(requestParameters.id, requestParameters.workItemForward, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {WorkItemsApiSubmitAccountSelectionRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection(requestParameters: WorkItemsApiSubmitAccountSelectionRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<WorkItems> {
            return localVarFp.submitAccountSelection(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveApprovalItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiApproveApprovalItemRequest
 */
export interface WorkItemsApiApproveApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItem
     */
    readonly id: string

    /**
     * The ID of the approval item.
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItem
     */
    readonly approvalItemId: string
}

/**
 * Request parameters for approveApprovalItemsInBulk operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiApproveApprovalItemsInBulkRequest
 */
export interface WorkItemsApiApproveApprovalItemsInBulkRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItemsInBulk
     */
    readonly id: string
}

/**
 * Request parameters for completeWorkItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiCompleteWorkItemRequest
 */
export interface WorkItemsApiCompleteWorkItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiCompleteWorkItem
     */
    readonly id: string

    /**
     * Body is the request payload to create form definition request
     * @type {string}
     * @memberof WorkItemsApiCompleteWorkItem
     */
    readonly body?: string | null
}

/**
 * Request parameters for getCompletedWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetCompletedWorkItemsRequest
 */
export interface WorkItemsApiGetCompletedWorkItemsRequest {
    /**
     * The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
     * @type {string}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly count?: boolean
}

/**
 * Request parameters for getCountCompletedWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetCountCompletedWorkItemsRequest
 */
export interface WorkItemsApiGetCountCompletedWorkItemsRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiGetCountCompletedWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for getCountWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetCountWorkItemsRequest
 */
export interface WorkItemsApiGetCountWorkItemsRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiGetCountWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for getWorkItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetWorkItemRequest
 */
export interface WorkItemsApiGetWorkItemRequest {
    /**
     * ID of the work item.
     * @type {string}
     * @memberof WorkItemsApiGetWorkItem
     */
    readonly id: string
}

/**
 * Request parameters for getWorkItemsSummary operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetWorkItemsSummaryRequest
 */
export interface WorkItemsApiGetWorkItemsSummaryRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiGetWorkItemsSummary
     */
    readonly ownerId?: string
}

/**
 * Request parameters for listWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiListWorkItemsRequest
 */
export interface WorkItemsApiListWorkItemsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly count?: boolean

    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for rejectApprovalItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiRejectApprovalItemRequest
 */
export interface WorkItemsApiRejectApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItem
     */
    readonly id: string

    /**
     * The ID of the approval item.
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItem
     */
    readonly approvalItemId: string
}

/**
 * Request parameters for rejectApprovalItemsInBulk operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiRejectApprovalItemsInBulkRequest
 */
export interface WorkItemsApiRejectApprovalItemsInBulkRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItemsInBulk
     */
    readonly id: string
}

/**
 * Request parameters for sendWorkItemForward operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiSendWorkItemForwardRequest
 */
export interface WorkItemsApiSendWorkItemForwardRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiSendWorkItemForward
     */
    readonly id: string

    /**
     * 
     * @type {WorkItemForward}
     * @memberof WorkItemsApiSendWorkItemForward
     */
    readonly workItemForward: WorkItemForward
}

/**
 * Request parameters for submitAccountSelection operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiSubmitAccountSelectionRequest
 */
export interface WorkItemsApiSubmitAccountSelectionRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiSubmitAccountSelection
     */
    readonly id: string

    /**
     * Account Selection Data map, keyed on fieldName
     * @type {{ [key: string]: any; }}
     * @memberof WorkItemsApiSubmitAccountSelection
     */
    readonly requestBody: { [key: string]: any; }
}

/**
 * WorkItemsApi - object-oriented interface
 * @export
 * @class WorkItemsApi
 * @extends {BaseAPI}
 */
export class WorkItemsApi extends BaseAPI {
    /**
     * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Approve an Approval Item
     * @param {WorkItemsApiApproveApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public approveApprovalItem(requestParameters: WorkItemsApiApproveApprovalItemRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).approveApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk approve Approval Items
     * @param {WorkItemsApiApproveApprovalItemsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public approveApprovalItemsInBulk(requestParameters: WorkItemsApiApproveApprovalItemsInBulkRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).approveApprovalItemsInBulk(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API completes a work item. Either an admin, or the owning/current user must make this request.
     * @summary Complete a Work Item
     * @param {WorkItemsApiCompleteWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public completeWorkItem(requestParameters: WorkItemsApiCompleteWorkItemRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).completeWorkItem(requestParameters.id, requestParameters.body, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Completed Work Items
     * @param {WorkItemsApiGetCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getCompletedWorkItems(requestParameters: WorkItemsApiGetCompletedWorkItemsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getCompletedWorkItems(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Completed Work Items
     * @param {WorkItemsApiGetCountCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getCountCompletedWorkItems(requestParameters: WorkItemsApiGetCountCompletedWorkItemsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getCountCompletedWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a count of work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Work Items
     * @param {WorkItemsApiGetCountWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getCountWorkItems(requestParameters: WorkItemsApiGetCountWorkItemsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getCountWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
     * @summary Get a Work Item
     * @param {WorkItemsApiGetWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getWorkItem(requestParameters: WorkItemsApiGetWorkItemRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getWorkItem(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
     * @summary Work Items Summary
     * @param {WorkItemsApiGetWorkItemsSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getWorkItemsSummary(requestParameters: WorkItemsApiGetWorkItemsSummaryRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getWorkItemsSummary(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
     * @summary List Work Items
     * @param {WorkItemsApiListWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public listWorkItems(requestParameters: WorkItemsApiListWorkItemsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).listWorkItems(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Reject an Approval Item
     * @param {WorkItemsApiRejectApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public rejectApprovalItem(requestParameters: WorkItemsApiRejectApprovalItemRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).rejectApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk reject Approval Items
     * @param {WorkItemsApiRejectApprovalItemsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public rejectApprovalItemsInBulk(requestParameters: WorkItemsApiRejectApprovalItemsInBulkRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).rejectApprovalItemsInBulk(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API forwards a work item to a new owner. Either an admin, or the owning/current user must make this request. Accessible to work-item Owner, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN.
     * @summary Forward a Work Item
     * @param {WorkItemsApiSendWorkItemForwardRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public sendWorkItemForward(requestParameters: WorkItemsApiSendWorkItemForwardRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).sendWorkItemForward(requestParameters.id, requestParameters.workItemForward, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits account selections. Either an admin, or the owning/current user must make this request.
     * @summary Submit Account Selections
     * @param {WorkItemsApiSubmitAccountSelectionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public submitAccountSelection(requestParameters: WorkItemsApiSubmitAccountSelectionRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).submitAccountSelection(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to cancel a running workflow execution.
         * @summary Cancel Workflow Execution by ID
         * @param {string} id The workflow execution ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelWorkflowExecution: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelWorkflowExecution', 'id', id)
            const localVarPath = `/workflow-executions/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
         * @summary Execute Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {CreateExternalExecuteWorkflowRequest} [createExternalExecuteWorkflowRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createExternalExecuteWorkflow: async (id: string, createExternalExecuteWorkflowRequest?: CreateExternalExecuteWorkflowRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createExternalExecuteWorkflow', 'id', id)
            const localVarPath = `/workflows/execute/external/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createExternalExecuteWorkflowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Create a new workflow with the desired trigger and steps specified in the request body.
         * @summary Create Workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow: async (createWorkflowRequest: CreateWorkflowRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkflowRequest' is not null or undefined
            assertParamExists('createWorkflow', 'createWorkflowRequest', createWorkflowRequest)
            const localVarPath = `/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkflowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
         * @summary Generate External Trigger OAuth Client
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowExternalTrigger: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createWorkflowExternalTrigger', 'id', id)
            const localVarPath = `/workflows/{id}/external/oauth-clients`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
         * @summary Delete Workflow By Id
         * @param {string} id Id of the Workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWorkflow', 'id', id)
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a single workflow by id.
         * @summary Get Workflow By Id
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkflow', 'id', id)
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get a single workflow execution. Workflow executions are available for up to 90 days before being archived. If you attempt to access a workflow execution that has been archived, you will receive a \"404 Not Found\" response.
         * @summary Get Workflow Execution
         * @param {string} id Workflow execution ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecution: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkflowExecution', 'id', id)
            const localVarPath = `/workflow-executions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get Workflow Execution History
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutionHistory: async (id: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkflowExecutionHistory', 'id', id)
            const localVarPath = `/workflow-executions/{id}/history`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to list a specified workflow\'s executions. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions. To get executions past the first 250 records, you can do the following: 1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows. 2. Get your workflow ID from the response. 3. You can then do either of the following:    - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - Paginate through results with the `offset` parameter.   For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.   Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination.
         * @summary List Workflow Executions
         * @param {string} id Workflow ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **start_time**: *eq, lt, le, gt, ge*  **status**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutions: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkflowExecutions', 'id', id)
            const localVarPath = `/workflows/{id}/executions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists all triggers, actions, and operators in the library
         * @summary List Complete Workflow Library
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompleteWorkflowLibrary: async (limit?: number, offset?: number, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow-library`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists the workflow actions available to you.
         * @summary List Workflow Library Actions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryActions: async (limit?: number, offset?: number, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow-library/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists the workflow operators available to you
         * @summary List Workflow Library Operators
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryOperators: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow-library/operators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists the workflow triggers available to you
         * @summary List Workflow Library Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryTriggers: async (limit?: number, offset?: number, filters?: string, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow-library/triggers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * List all workflows in the tenant.
         * @summary List Workflows
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows: async (axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
         * @summary Patch Workflow
         * @param {string} id Id of the Workflow
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkflow: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchWorkflow', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchWorkflow', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Perform a full update of a workflow.  The updated workflow object is returned in the response.
         * @summary Update Workflow
         * @param {string} id Id of the Workflow
         * @param {WorkflowBody} workflowBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putWorkflow: async (id: string, workflowBody: WorkflowBody, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putWorkflow', 'id', id)
            // verify required parameter 'workflowBody' is not null or undefined
            assertParamExists('putWorkflow', 'workflowBody', workflowBody)
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
         * @summary Test Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {TestExternalExecuteWorkflowRequest} [testExternalExecuteWorkflowRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testExternalExecuteWorkflow: async (id: string, testExternalExecuteWorkflowRequest?: TestExternalExecuteWorkflowRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('testExternalExecuteWorkflow', 'id', id)
            const localVarPath = `/workflows/execute/external/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testExternalExecuteWorkflowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
         * @summary Test Workflow By Id
         * @param {string} id Id of the workflow
         * @param {TestWorkflowRequest} testWorkflowRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testWorkflow: async (id: string, testWorkflowRequest: TestWorkflowRequest, axiosOptions: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('testWorkflow', 'id', id)
            // verify required parameter 'testWorkflowRequest' is not null or undefined
            assertParamExists('testWorkflow', 'testWorkflowRequest', testWorkflowRequest)
            const localVarPath = `/workflows/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)

            // authentication userAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "userAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testWorkflowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to cancel a running workflow execution.
         * @summary Cancel Workflow Execution by ID
         * @param {string} id The workflow execution ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelWorkflowExecution(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelWorkflowExecution(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.cancelWorkflowExecution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
         * @summary Execute Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {CreateExternalExecuteWorkflowRequest} [createExternalExecuteWorkflowRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createExternalExecuteWorkflow(id: string, createExternalExecuteWorkflowRequest?: CreateExternalExecuteWorkflowRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateExternalExecuteWorkflow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExternalExecuteWorkflow(id, createExternalExecuteWorkflowRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.createExternalExecuteWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new workflow with the desired trigger and steps specified in the request body.
         * @summary Create Workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflow(createWorkflowRequest: CreateWorkflowRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflow(createWorkflowRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.createWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
         * @summary Generate External Trigger OAuth Client
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowExternalTrigger(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOAuthClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowExternalTrigger(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.createWorkflowExternalTrigger']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
         * @summary Delete Workflow By Id
         * @param {string} id Id of the Workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflow(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflow(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.deleteWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a single workflow by id.
         * @summary Get Workflow By Id
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflow(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflow(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.getWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to get a single workflow execution. Workflow executions are available for up to 90 days before being archived. If you attempt to access a workflow execution that has been archived, you will receive a \"404 Not Found\" response.
         * @summary Get Workflow Execution
         * @param {string} id Workflow execution ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowExecution(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowExecution(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.getWorkflowExecution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get Workflow Execution History
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowExecutionHistory(id: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowExecutionEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowExecutionHistory(id, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.getWorkflowExecutionHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API to list a specified workflow\'s executions. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions. To get executions past the first 250 records, you can do the following: 1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows. 2. Get your workflow ID from the response. 3. You can then do either of the following:    - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - Paginate through results with the `offset` parameter.   For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.   Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination.
         * @summary List Workflow Executions
         * @param {string} id Workflow ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **start_time**: *eq, lt, le, gt, ge*  **status**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowExecutions(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowExecution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowExecutions(id, limit, offset, count, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.getWorkflowExecutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This lists all triggers, actions, and operators in the library
         * @summary List Complete Workflow Library
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCompleteWorkflowLibrary(limit?: number, offset?: number, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListCompleteWorkflowLibrary200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCompleteWorkflowLibrary(limit, offset, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.listCompleteWorkflowLibrary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This lists the workflow actions available to you.
         * @summary List Workflow Library Actions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowLibraryActions(limit?: number, offset?: number, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowLibraryAction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowLibraryActions(limit, offset, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.listWorkflowLibraryActions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This lists the workflow operators available to you
         * @summary List Workflow Library Operators
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowLibraryOperators(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowLibraryOperator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowLibraryOperators(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.listWorkflowLibraryOperators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This lists the workflow triggers available to you
         * @summary List Workflow Library Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowLibraryTriggers(limit?: number, offset?: number, filters?: string, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowLibraryTrigger>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowLibraryTriggers(limit, offset, filters, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.listWorkflowLibraryTriggers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all workflows in the tenant.
         * @summary List Workflows
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflows(axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workflow>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflows(axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.listWorkflows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
         * @summary Patch Workflow
         * @param {string} id Id of the Workflow
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchWorkflow(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchWorkflow(id, jsonPatchOperation, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.patchWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Perform a full update of a workflow.  The updated workflow object is returned in the response.
         * @summary Update Workflow
         * @param {string} id Id of the Workflow
         * @param {WorkflowBody} workflowBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putWorkflow(id: string, workflowBody: WorkflowBody, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putWorkflow(id, workflowBody, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.putWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
         * @summary Test Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {TestExternalExecuteWorkflowRequest} [testExternalExecuteWorkflowRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async testExternalExecuteWorkflow(id: string, testExternalExecuteWorkflowRequest?: TestExternalExecuteWorkflowRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestExternalExecuteWorkflow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testExternalExecuteWorkflow(id, testExternalExecuteWorkflowRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.testExternalExecuteWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
         * @summary Test Workflow By Id
         * @param {string} id Id of the workflow
         * @param {TestWorkflowRequest} testWorkflowRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async testWorkflow(id: string, testWorkflowRequest: TestWorkflowRequest, axiosOptions?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestWorkflow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testWorkflow(id, testWorkflowRequest, axiosOptions);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.testWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsApiFp(configuration)
    return {
        /**
         * Use this API to cancel a running workflow execution.
         * @summary Cancel Workflow Execution by ID
         * @param {WorkflowsApiCancelWorkflowExecutionRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelWorkflowExecution(requestParameters: WorkflowsApiCancelWorkflowExecutionRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelWorkflowExecution(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
         * @summary Execute Workflow via External Trigger
         * @param {WorkflowsApiCreateExternalExecuteWorkflowRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createExternalExecuteWorkflow(requestParameters: WorkflowsApiCreateExternalExecuteWorkflowRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<CreateExternalExecuteWorkflow200Response> {
            return localVarFp.createExternalExecuteWorkflow(requestParameters.id, requestParameters.createExternalExecuteWorkflowRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Create a new workflow with the desired trigger and steps specified in the request body.
         * @summary Create Workflow
         * @param {WorkflowsApiCreateWorkflowRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(requestParameters: WorkflowsApiCreateWorkflowRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Workflow> {
            return localVarFp.createWorkflow(requestParameters.createWorkflowRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
         * @summary Generate External Trigger OAuth Client
         * @param {WorkflowsApiCreateWorkflowExternalTriggerRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowExternalTrigger(requestParameters: WorkflowsApiCreateWorkflowExternalTriggerRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<WorkflowOAuthClient> {
            return localVarFp.createWorkflowExternalTrigger(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
         * @summary Delete Workflow By Id
         * @param {WorkflowsApiDeleteWorkflowRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(requestParameters: WorkflowsApiDeleteWorkflowRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkflow(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a single workflow by id.
         * @summary Get Workflow By Id
         * @param {WorkflowsApiGetWorkflowRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(requestParameters: WorkflowsApiGetWorkflowRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Workflow> {
            return localVarFp.getWorkflow(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get a single workflow execution. Workflow executions are available for up to 90 days before being archived. If you attempt to access a workflow execution that has been archived, you will receive a \"404 Not Found\" response.
         * @summary Get Workflow Execution
         * @param {WorkflowsApiGetWorkflowExecutionRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecution(requestParameters: WorkflowsApiGetWorkflowExecutionRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getWorkflowExecution(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get Workflow Execution History
         * @param {WorkflowsApiGetWorkflowExecutionHistoryRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutionHistory(requestParameters: WorkflowsApiGetWorkflowExecutionHistoryRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<WorkflowExecutionEvent>> {
            return localVarFp.getWorkflowExecutionHistory(requestParameters.id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to list a specified workflow\'s executions. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions. To get executions past the first 250 records, you can do the following: 1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows. 2. Get your workflow ID from the response. 3. You can then do either of the following:    - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - Paginate through results with the `offset` parameter.   For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.   Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination.
         * @summary List Workflow Executions
         * @param {WorkflowsApiGetWorkflowExecutionsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutions(requestParameters: WorkflowsApiGetWorkflowExecutionsRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<WorkflowExecution>> {
            return localVarFp.getWorkflowExecutions(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists all triggers, actions, and operators in the library
         * @summary List Complete Workflow Library
         * @param {WorkflowsApiListCompleteWorkflowLibraryRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompleteWorkflowLibrary(requestParameters: WorkflowsApiListCompleteWorkflowLibraryRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<ListCompleteWorkflowLibrary200ResponseInner>> {
            return localVarFp.listCompleteWorkflowLibrary(requestParameters.limit, requestParameters.offset, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists the workflow actions available to you.
         * @summary List Workflow Library Actions
         * @param {WorkflowsApiListWorkflowLibraryActionsRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryActions(requestParameters: WorkflowsApiListWorkflowLibraryActionsRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<WorkflowLibraryAction>> {
            return localVarFp.listWorkflowLibraryActions(requestParameters.limit, requestParameters.offset, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists the workflow operators available to you
         * @summary List Workflow Library Operators
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryOperators(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<WorkflowLibraryOperator>> {
            return localVarFp.listWorkflowLibraryOperators(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists the workflow triggers available to you
         * @summary List Workflow Library Triggers
         * @param {WorkflowsApiListWorkflowLibraryTriggersRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryTriggers(requestParameters: WorkflowsApiListWorkflowLibraryTriggersRequest = {}, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<WorkflowLibraryTrigger>> {
            return localVarFp.listWorkflowLibraryTriggers(requestParameters.limit, requestParameters.offset, requestParameters.filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * List all workflows in the tenant.
         * @summary List Workflows
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Array<Workflow>> {
            return localVarFp.listWorkflows(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
         * @summary Patch Workflow
         * @param {WorkflowsApiPatchWorkflowRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkflow(requestParameters: WorkflowsApiPatchWorkflowRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Workflow> {
            return localVarFp.patchWorkflow(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Perform a full update of a workflow.  The updated workflow object is returned in the response.
         * @summary Update Workflow
         * @param {WorkflowsApiPutWorkflowRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putWorkflow(requestParameters: WorkflowsApiPutWorkflowRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<Workflow> {
            return localVarFp.putWorkflow(requestParameters.id, requestParameters.workflowBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
         * @summary Test Workflow via External Trigger
         * @param {WorkflowsApiTestExternalExecuteWorkflowRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testExternalExecuteWorkflow(requestParameters: WorkflowsApiTestExternalExecuteWorkflowRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<TestExternalExecuteWorkflow200Response> {
            return localVarFp.testExternalExecuteWorkflow(requestParameters.id, requestParameters.testExternalExecuteWorkflowRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
         * @summary Test Workflow By Id
         * @param {WorkflowsApiTestWorkflowRequest} requestParameters Request parameters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testWorkflow(requestParameters: WorkflowsApiTestWorkflowRequest, axiosOptions?: RawAxiosRequestConfig): AxiosPromise<TestWorkflow200Response> {
            return localVarFp.testWorkflow(requestParameters.id, requestParameters.testWorkflowRequest, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelWorkflowExecution operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiCancelWorkflowExecutionRequest
 */
export interface WorkflowsApiCancelWorkflowExecutionRequest {
    /**
     * The workflow execution ID
     * @type {string}
     * @memberof WorkflowsApiCancelWorkflowExecution
     */
    readonly id: string
}

/**
 * Request parameters for createExternalExecuteWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiCreateExternalExecuteWorkflowRequest
 */
export interface WorkflowsApiCreateExternalExecuteWorkflowRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsApiCreateExternalExecuteWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {CreateExternalExecuteWorkflowRequest}
     * @memberof WorkflowsApiCreateExternalExecuteWorkflow
     */
    readonly createExternalExecuteWorkflowRequest?: CreateExternalExecuteWorkflowRequest
}

/**
 * Request parameters for createWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiCreateWorkflowRequest
 */
export interface WorkflowsApiCreateWorkflowRequest {
    /**
     * 
     * @type {CreateWorkflowRequest}
     * @memberof WorkflowsApiCreateWorkflow
     */
    readonly createWorkflowRequest: CreateWorkflowRequest
}

/**
 * Request parameters for createWorkflowExternalTrigger operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiCreateWorkflowExternalTriggerRequest
 */
export interface WorkflowsApiCreateWorkflowExternalTriggerRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsApiCreateWorkflowExternalTrigger
     */
    readonly id: string
}

/**
 * Request parameters for deleteWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiDeleteWorkflowRequest
 */
export interface WorkflowsApiDeleteWorkflowRequest {
    /**
     * Id of the Workflow
     * @type {string}
     * @memberof WorkflowsApiDeleteWorkflow
     */
    readonly id: string
}

/**
 * Request parameters for getWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiGetWorkflowRequest
 */
export interface WorkflowsApiGetWorkflowRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsApiGetWorkflow
     */
    readonly id: string
}

/**
 * Request parameters for getWorkflowExecution operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiGetWorkflowExecutionRequest
 */
export interface WorkflowsApiGetWorkflowExecutionRequest {
    /**
     * Workflow execution ID.
     * @type {string}
     * @memberof WorkflowsApiGetWorkflowExecution
     */
    readonly id: string
}

/**
 * Request parameters for getWorkflowExecutionHistory operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiGetWorkflowExecutionHistoryRequest
 */
export interface WorkflowsApiGetWorkflowExecutionHistoryRequest {
    /**
     * Id of the workflow execution
     * @type {string}
     * @memberof WorkflowsApiGetWorkflowExecutionHistory
     */
    readonly id: string
}

/**
 * Request parameters for getWorkflowExecutions operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiGetWorkflowExecutionsRequest
 */
export interface WorkflowsApiGetWorkflowExecutionsRequest {
    /**
     * Workflow ID.
     * @type {string}
     * @memberof WorkflowsApiGetWorkflowExecutions
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiGetWorkflowExecutions
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiGetWorkflowExecutions
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkflowsApiGetWorkflowExecutions
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **start_time**: *eq, lt, le, gt, ge*  **status**: *eq*
     * @type {string}
     * @memberof WorkflowsApiGetWorkflowExecutions
     */
    readonly filters?: string
}

/**
 * Request parameters for listCompleteWorkflowLibrary operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiListCompleteWorkflowLibraryRequest
 */
export interface WorkflowsApiListCompleteWorkflowLibraryRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiListCompleteWorkflowLibrary
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiListCompleteWorkflowLibrary
     */
    readonly offset?: number
}

/**
 * Request parameters for listWorkflowLibraryActions operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiListWorkflowLibraryActionsRequest
 */
export interface WorkflowsApiListWorkflowLibraryActionsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiListWorkflowLibraryActions
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiListWorkflowLibraryActions
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
     * @type {string}
     * @memberof WorkflowsApiListWorkflowLibraryActions
     */
    readonly filters?: string
}

/**
 * Request parameters for listWorkflowLibraryTriggers operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiListWorkflowLibraryTriggersRequest
 */
export interface WorkflowsApiListWorkflowLibraryTriggersRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiListWorkflowLibraryTriggers
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiListWorkflowLibraryTriggers
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
     * @type {string}
     * @memberof WorkflowsApiListWorkflowLibraryTriggers
     */
    readonly filters?: string
}

/**
 * Request parameters for patchWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiPatchWorkflowRequest
 */
export interface WorkflowsApiPatchWorkflowRequest {
    /**
     * Id of the Workflow
     * @type {string}
     * @memberof WorkflowsApiPatchWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperation>}
     * @memberof WorkflowsApiPatchWorkflow
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for putWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiPutWorkflowRequest
 */
export interface WorkflowsApiPutWorkflowRequest {
    /**
     * Id of the Workflow
     * @type {string}
     * @memberof WorkflowsApiPutWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {WorkflowBody}
     * @memberof WorkflowsApiPutWorkflow
     */
    readonly workflowBody: WorkflowBody
}

/**
 * Request parameters for testExternalExecuteWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiTestExternalExecuteWorkflowRequest
 */
export interface WorkflowsApiTestExternalExecuteWorkflowRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsApiTestExternalExecuteWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {TestExternalExecuteWorkflowRequest}
     * @memberof WorkflowsApiTestExternalExecuteWorkflow
     */
    readonly testExternalExecuteWorkflowRequest?: TestExternalExecuteWorkflowRequest
}

/**
 * Request parameters for testWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiTestWorkflowRequest
 */
export interface WorkflowsApiTestWorkflowRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsApiTestWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {TestWorkflowRequest}
     * @memberof WorkflowsApiTestWorkflow
     */
    readonly testWorkflowRequest: TestWorkflowRequest
}

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * Use this API to cancel a running workflow execution.
     * @summary Cancel Workflow Execution by ID
     * @param {WorkflowsApiCancelWorkflowExecutionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public cancelWorkflowExecution(requestParameters: WorkflowsApiCancelWorkflowExecutionRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).cancelWorkflowExecution(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
     * @summary Execute Workflow via External Trigger
     * @param {WorkflowsApiCreateExternalExecuteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createExternalExecuteWorkflow(requestParameters: WorkflowsApiCreateExternalExecuteWorkflowRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createExternalExecuteWorkflow(requestParameters.id, requestParameters.createExternalExecuteWorkflowRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new workflow with the desired trigger and steps specified in the request body.
     * @summary Create Workflow
     * @param {WorkflowsApiCreateWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflow(requestParameters: WorkflowsApiCreateWorkflowRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createWorkflow(requestParameters.createWorkflowRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
     * @summary Generate External Trigger OAuth Client
     * @param {WorkflowsApiCreateWorkflowExternalTriggerRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflowExternalTrigger(requestParameters: WorkflowsApiCreateWorkflowExternalTriggerRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createWorkflowExternalTrigger(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
     * @summary Delete Workflow By Id
     * @param {WorkflowsApiDeleteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public deleteWorkflow(requestParameters: WorkflowsApiDeleteWorkflowRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).deleteWorkflow(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single workflow by id.
     * @summary Get Workflow By Id
     * @param {WorkflowsApiGetWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflow(requestParameters: WorkflowsApiGetWorkflowRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflow(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get a single workflow execution. Workflow executions are available for up to 90 days before being archived. If you attempt to access a workflow execution that has been archived, you will receive a \"404 Not Found\" response.
     * @summary Get Workflow Execution
     * @param {WorkflowsApiGetWorkflowExecutionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflowExecution(requestParameters: WorkflowsApiGetWorkflowExecutionRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflowExecution(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
     * @summary Get Workflow Execution History
     * @param {WorkflowsApiGetWorkflowExecutionHistoryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflowExecutionHistory(requestParameters: WorkflowsApiGetWorkflowExecutionHistoryRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflowExecutionHistory(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to list a specified workflow\'s executions. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions. To get executions past the first 250 records, you can do the following: 1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows. 2. Get your workflow ID from the response. 3. You can then do either of the following:    - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - Paginate through results with the `offset` parameter.   For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.   Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination.
     * @summary List Workflow Executions
     * @param {WorkflowsApiGetWorkflowExecutionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflowExecutions(requestParameters: WorkflowsApiGetWorkflowExecutionsRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflowExecutions(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists all triggers, actions, and operators in the library
     * @summary List Complete Workflow Library
     * @param {WorkflowsApiListCompleteWorkflowLibraryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public listCompleteWorkflowLibrary(requestParameters: WorkflowsApiListCompleteWorkflowLibraryRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).listCompleteWorkflowLibrary(requestParameters.limit, requestParameters.offset, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists the workflow actions available to you.
     * @summary List Workflow Library Actions
     * @param {WorkflowsApiListWorkflowLibraryActionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public listWorkflowLibraryActions(requestParameters: WorkflowsApiListWorkflowLibraryActionsRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).listWorkflowLibraryActions(requestParameters.limit, requestParameters.offset, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists the workflow operators available to you
     * @summary List Workflow Library Operators
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public listWorkflowLibraryOperators(axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).listWorkflowLibraryOperators(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists the workflow triggers available to you
     * @summary List Workflow Library Triggers
     * @param {WorkflowsApiListWorkflowLibraryTriggersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public listWorkflowLibraryTriggers(requestParameters: WorkflowsApiListWorkflowLibraryTriggersRequest = {}, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).listWorkflowLibraryTriggers(requestParameters.limit, requestParameters.offset, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all workflows in the tenant.
     * @summary List Workflows
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public listWorkflows(axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).listWorkflows(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
     * @summary Patch Workflow
     * @param {WorkflowsApiPatchWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public patchWorkflow(requestParameters: WorkflowsApiPatchWorkflowRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).patchWorkflow(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a full update of a workflow.  The updated workflow object is returned in the response.
     * @summary Update Workflow
     * @param {WorkflowsApiPutWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public putWorkflow(requestParameters: WorkflowsApiPutWorkflowRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).putWorkflow(requestParameters.id, requestParameters.workflowBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
     * @summary Test Workflow via External Trigger
     * @param {WorkflowsApiTestExternalExecuteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public testExternalExecuteWorkflow(requestParameters: WorkflowsApiTestExternalExecuteWorkflowRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).testExternalExecuteWorkflow(requestParameters.id, requestParameters.testExternalExecuteWorkflowRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
     * @summary Test Workflow By Id
     * @param {WorkflowsApiTestWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public testWorkflow(requestParameters: WorkflowsApiTestWorkflowRequest, axiosOptions?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).testWorkflow(requestParameters.id, requestParameters.testWorkflowRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}



