/* tslint:disable */
/* eslint-disable */
/**
 * Identity Security Cloud V3 API
 * Use these APIs to interact with the Identity Security Cloud platform to achieve repeatable, automated processes with greater scalability. We encourage you to join the SailPoint Developer Community forum at https://developer.sailpoint.com/discuss to connect with other developers using our APIs.
 *
 * The version of the OpenAPI document: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof Access
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof Access
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof Access
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AccessAllOf
 */
export interface AccessAllOf {
    /**
     * 
     * @type {DtoType}
     * @memberof AccessAllOf
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessAllOf
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AccessConstraint
 */
export interface AccessConstraint {
    /**
     * Type of Access
     * @type {string}
     * @memberof AccessConstraint
     */
    'type': AccessConstraintTypeEnum;
    /**
     * Must be set only if operator is SELECTED.
     * @type {Array<string>}
     * @memberof AccessConstraint
     */
    'ids'?: Array<string>;
    /**
     * Used to determine whether the scope of the campaign should be reduced for selected ids or all.
     * @type {string}
     * @memberof AccessConstraint
     */
    'operator': AccessConstraintOperatorEnum;
}

export const AccessConstraintTypeEnum = {
    Entitlement: 'ENTITLEMENT',
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE'
} as const;

export type AccessConstraintTypeEnum = typeof AccessConstraintTypeEnum[keyof typeof AccessConstraintTypeEnum];
export const AccessConstraintOperatorEnum = {
    All: 'ALL',
    Selected: 'SELECTED'
} as const;

export type AccessConstraintOperatorEnum = typeof AccessConstraintOperatorEnum[keyof typeof AccessConstraintOperatorEnum];

/**
 * 
 * @export
 * @interface AccessCriteria
 */
export interface AccessCriteria {
    /**
     * Business name for the access construct list
     * @type {string}
     * @memberof AccessCriteria
     */
    'name'?: string;
    /**
     * List of criteria. There is a min of 1 and max of 50 items in the list.
     * @type {Array<AccessCriteriaCriteriaListInner>}
     * @memberof AccessCriteria
     */
    'criteriaList'?: Array<AccessCriteriaCriteriaListInner>;
}
/**
 * 
 * @export
 * @interface AccessCriteriaCriteriaListInner
 */
export interface AccessCriteriaCriteriaListInner {
    /**
     * Type of the propery to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInner
     */
    'type'?: AccessCriteriaCriteriaListInnerTypeEnum;
    /**
     * ID of the object to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInner
     */
    'name'?: string;
}

export const AccessCriteriaCriteriaListInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessCriteriaCriteriaListInnerTypeEnum = typeof AccessCriteriaCriteriaListInnerTypeEnum[keyof typeof AccessCriteriaCriteriaListInnerTypeEnum];

/**
 * Identity the access item is requested for.
 * @export
 * @interface AccessItemRequestedFor
 */
export interface AccessItemRequestedFor {
    /**
     * DTO type of identity the access item is requested for.
     * @type {string}
     * @memberof AccessItemRequestedFor
     */
    'type'?: AccessItemRequestedForTypeEnum;
    /**
     * ID of identity the access item is requested for.
     * @type {string}
     * @memberof AccessItemRequestedFor
     */
    'id'?: string;
    /**
     * Human-readable display name of identity the access item is requested for.
     * @type {string}
     * @memberof AccessItemRequestedFor
     */
    'name'?: string;
}

export const AccessItemRequestedForTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccessItemRequestedForTypeEnum = typeof AccessItemRequestedForTypeEnum[keyof typeof AccessItemRequestedForTypeEnum];

/**
 * Access item requester\'s identity.
 * @export
 * @interface AccessItemRequester
 */
export interface AccessItemRequester {
    /**
     * Access item requester\'s DTO type.
     * @type {string}
     * @memberof AccessItemRequester
     */
    'type'?: AccessItemRequesterTypeEnum;
    /**
     * Access item requester\'s identity ID.
     * @type {string}
     * @memberof AccessItemRequester
     */
    'id'?: string;
    /**
     * Access item owner\'s human-readable display name.
     * @type {string}
     * @memberof AccessItemRequester
     */
    'name'?: string;
}

export const AccessItemRequesterTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccessItemRequesterTypeEnum = typeof AccessItemRequesterTypeEnum[keyof typeof AccessItemRequesterTypeEnum];

/**
 * Identity who reviewed the access item request.
 * @export
 * @interface AccessItemReviewedBy
 */
export interface AccessItemReviewedBy {
    /**
     * DTO type of identity who reviewed the access item request.
     * @type {string}
     * @memberof AccessItemReviewedBy
     */
    'type'?: AccessItemReviewedByTypeEnum;
    /**
     * ID of identity who reviewed the access item request.
     * @type {string}
     * @memberof AccessItemReviewedBy
     */
    'id'?: string;
    /**
     * Human-readable display name of identity who reviewed the access item request.
     * @type {string}
     * @memberof AccessItemReviewedBy
     */
    'name'?: string;
}

export const AccessItemReviewedByTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AccessItemReviewedByTypeEnum = typeof AccessItemReviewedByTypeEnum[keyof typeof AccessItemReviewedByTypeEnum];

/**
 * Access Profile
 * @export
 * @interface AccessProfile
 */
export interface AccessProfile {
    /**
     * The ID of the Access Profile
     * @type {string}
     * @memberof AccessProfile
     */
    'id'?: string;
    /**
     * Name of the Access Profile
     * @type {string}
     * @memberof AccessProfile
     */
    'name': string;
    /**
     * Information about the Access Profile
     * @type {string}
     * @memberof AccessProfile
     */
    'description'?: string | null;
    /**
     * Date the Access Profile was created
     * @type {string}
     * @memberof AccessProfile
     */
    'created'?: string;
    /**
     * Date the Access Profile was last modified.
     * @type {string}
     * @memberof AccessProfile
     */
    'modified'?: string;
    /**
     * Whether the Access Profile is enabled. If the Access Profile is enabled then you must include at least one Entitlement.
     * @type {boolean}
     * @memberof AccessProfile
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {OwnerReference}
     * @memberof AccessProfile
     */
    'owner': OwnerReference;
    /**
     * 
     * @type {AccessProfileSourceRef}
     * @memberof AccessProfile
     */
    'source': AccessProfileSourceRef;
    /**
     * A list of entitlements associated with the Access Profile. If enabled is false this is allowed to be empty otherwise it needs to contain at least one Entitlement.
     * @type {Array<EntitlementRef>}
     * @memberof AccessProfile
     */
    'entitlements'?: Array<EntitlementRef> | null;
    /**
     * Whether the Access Profile is requestable via access request. Currently, making an Access Profile non-requestable is only supported  for customers enabled with the new Request Center. Otherwise, attempting to create an Access Profile with a value  **false** in this field results in a 400 error.
     * @type {boolean}
     * @memberof AccessProfile
     */
    'requestable'?: boolean;
    /**
     * 
     * @type {Requestability}
     * @memberof AccessProfile
     */
    'accessRequestConfig'?: Requestability | null;
    /**
     * 
     * @type {Revocability}
     * @memberof AccessProfile
     */
    'revocationRequestConfig'?: Revocability | null;
    /**
     * List of IDs of segments, if any, to which this Access Profile is assigned.
     * @type {Array<string>}
     * @memberof AccessProfile
     */
    'segments'?: Array<string> | null;
    /**
     * 
     * @type {ProvisioningCriteriaLevel1}
     * @memberof AccessProfile
     */
    'provisioningCriteria'?: ProvisioningCriteriaLevel1 | null;
}
/**
 * 
 * @export
 * @interface AccessProfileApprovalScheme
 */
export interface AccessProfileApprovalScheme {
    /**
     * Describes the individual or group that is responsible for an approval step. Values are as follows. **APP_OWNER**: The owner of the Application  **OWNER**: Owner of the associated Access Profile or Role  **SOURCE_OWNER**: Owner of the Source associated with an Access Profile  **MANAGER**: Manager of the Identity making the request  **GOVERNANCE_GROUP**: A Governance Group, the ID of which is specified by the **approverId** field
     * @type {string}
     * @memberof AccessProfileApprovalScheme
     */
    'approverType'?: AccessProfileApprovalSchemeApproverTypeEnum;
    /**
     * Id of the specific approver, used only when approverType is GOVERNANCE_GROUP
     * @type {string}
     * @memberof AccessProfileApprovalScheme
     */
    'approverId'?: string | null;
}

export const AccessProfileApprovalSchemeApproverTypeEnum = {
    AppOwner: 'APP_OWNER',
    Owner: 'OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type AccessProfileApprovalSchemeApproverTypeEnum = typeof AccessProfileApprovalSchemeApproverTypeEnum[keyof typeof AccessProfileApprovalSchemeApproverTypeEnum];

/**
 * 
 * @export
 * @interface AccessProfileBulkDeleteRequest
 */
export interface AccessProfileBulkDeleteRequest {
    /**
     * List of IDs of Access Profiles to be deleted.
     * @type {Array<string>}
     * @memberof AccessProfileBulkDeleteRequest
     */
    'accessProfileIds'?: Array<string>;
    /**
     * If **true**, silently skip over any of the specified Access Profiles if they cannot be deleted because they are in use. If **false**, no deletions will be attempted if any of the Access Profiles are in use.
     * @type {boolean}
     * @memberof AccessProfileBulkDeleteRequest
     */
    'bestEffortOnly'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileBulkDeleteResponse
 */
export interface AccessProfileBulkDeleteResponse {
    /**
     * ID of the task which is executing the bulk deletion. This can be passed to the **_/task-status** API to track status.
     * @type {string}
     * @memberof AccessProfileBulkDeleteResponse
     */
    'taskId'?: string;
    /**
     * List of IDs of Access Profiles which are pending deletion.
     * @type {Array<string>}
     * @memberof AccessProfileBulkDeleteResponse
     */
    'pending'?: Array<string>;
    /**
     * List of usages of Access Profiles targeted for deletion.
     * @type {Array<AccessProfileUsage>}
     * @memberof AccessProfileBulkDeleteResponse
     */
    'inUse'?: Array<AccessProfileUsage>;
}
/**
 * More complete representation of an access profile.  
 * @export
 * @interface AccessProfileDocument
 */
export interface AccessProfileDocument {
    /**
     * Access profile\'s ID.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'id': string;
    /**
     * Access profile\'s name.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'name': string;
    /**
     * Access item\'s description.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'description'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'synced'?: string | null;
    /**
     * Indicates whether the access item is currently enabled.
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'enabled'?: boolean;
    /**
     * Indicates whether the access item can be requested.
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'requestable'?: boolean;
    /**
     * Indicates whether comments are required for requests to access the item.
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {BaseAccessAllOfOwner}
     * @memberof AccessProfileDocument
     */
    'owner'?: BaseAccessAllOfOwner;
    /**
     * Access profile\'s document type.  This enum represents the currently supported document types. Additional values may be added in the future without notice.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    '_type': AccessProfileDocumentTypeEnum;
    /**
     * 
     * @type {AccessProfileDocumentAllOfSource}
     * @memberof AccessProfileDocument
     */
    'source'?: AccessProfileDocumentAllOfSource;
    /**
     * Entitlements the access profile has access to.
     * @type {Array<BaseEntitlement>}
     * @memberof AccessProfileDocument
     */
    'entitlements'?: Array<BaseEntitlement>;
    /**
     * Number of entitlements.
     * @type {number}
     * @memberof AccessProfileDocument
     */
    'entitlementCount'?: number;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof AccessProfileDocument
     */
    'tags'?: Array<string>;
}

export const AccessProfileDocumentTypeEnum = {
    Accessprofile: 'accessprofile',
    Accountactivity: 'accountactivity',
    Account: 'account',
    Aggregation: 'aggregation',
    Entitlement: 'entitlement',
    Event: 'event',
    Identity: 'identity',
    Role: 'role'
} as const;

export type AccessProfileDocumentTypeEnum = typeof AccessProfileDocumentTypeEnum[keyof typeof AccessProfileDocumentTypeEnum];

/**
 * 
 * @export
 * @interface AccessProfileDocumentAllOf
 */
export interface AccessProfileDocumentAllOf {
    /**
     * Access profile\'s ID.
     * @type {string}
     * @memberof AccessProfileDocumentAllOf
     */
    'id': string;
    /**
     * Access profile\'s name.
     * @type {string}
     * @memberof AccessProfileDocumentAllOf
     */
    'name': string;
    /**
     * Access profile\'s document type.  This enum represents the currently supported document types. Additional values may be added in the future without notice.
     * @type {string}
     * @memberof AccessProfileDocumentAllOf
     */
    '_type': AccessProfileDocumentAllOfTypeEnum;
    /**
     * 
     * @type {AccessProfileDocumentAllOfSource}
     * @memberof AccessProfileDocumentAllOf
     */
    'source'?: AccessProfileDocumentAllOfSource;
    /**
     * Entitlements the access profile has access to.
     * @type {Array<BaseEntitlement>}
     * @memberof AccessProfileDocumentAllOf
     */
    'entitlements'?: Array<BaseEntitlement>;
    /**
     * Number of entitlements.
     * @type {number}
     * @memberof AccessProfileDocumentAllOf
     */
    'entitlementCount'?: number;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof AccessProfileDocumentAllOf
     */
    'tags'?: Array<string>;
}

export const AccessProfileDocumentAllOfTypeEnum = {
    Accessprofile: 'accessprofile',
    Accountactivity: 'accountactivity',
    Account: 'account',
    Aggregation: 'aggregation',
    Entitlement: 'entitlement',
    Event: 'event',
    Identity: 'identity',
    Role: 'role'
} as const;

export type AccessProfileDocumentAllOfTypeEnum = typeof AccessProfileDocumentAllOfTypeEnum[keyof typeof AccessProfileDocumentAllOfTypeEnum];

/**
 * Access profile\'s source.
 * @export
 * @interface AccessProfileDocumentAllOfSource
 */
export interface AccessProfileDocumentAllOfSource {
    /**
     * Source\'s ID.
     * @type {string}
     * @memberof AccessProfileDocumentAllOfSource
     */
    'id'?: string;
    /**
     * Source\'s name.
     * @type {string}
     * @memberof AccessProfileDocumentAllOfSource
     */
    'name'?: string;
}
/**
 * EntitlementReference
 * @export
 * @interface AccessProfileEntitlement
 */
export interface AccessProfileEntitlement {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof AccessProfileEntitlement
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileEntitlement
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileEntitlement
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'attribute'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileEntitlement
     */
    'standalone'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileRef
 */
export interface AccessProfileRef {
    /**
     * ID of the Access Profile
     * @type {string}
     * @memberof AccessProfileRef
     */
    'id'?: string;
    /**
     * Type of requested object. This field must be either left null or set to \'ACCESS_PROFILE\' when creating an Access Profile, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof AccessProfileRef
     */
    'type'?: AccessProfileRefTypeEnum;
    /**
     * Human-readable display name of the Access Profile. This field is ignored on input.
     * @type {string}
     * @memberof AccessProfileRef
     */
    'name'?: string;
}

export const AccessProfileRefTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE'
} as const;

export type AccessProfileRefTypeEnum = typeof AccessProfileRefTypeEnum[keyof typeof AccessProfileRefTypeEnum];

/**
 * Role
 * @export
 * @interface AccessProfileRole
 */
export interface AccessProfileRole {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileRole
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileRole
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileRole
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof AccessProfileRole
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileRole
     */
    'description'?: string | null;
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccessProfileRole
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileRole
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileRole
     */
    'revocable'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileSourceRef
 */
export interface AccessProfileSourceRef {
    /**
     * The ID of the Source with with which the Access Profile is associated
     * @type {string}
     * @memberof AccessProfileSourceRef
     */
    'id'?: string;
    /**
     * The type of the Source, will always be SOURCE
     * @type {string}
     * @memberof AccessProfileSourceRef
     */
    'type'?: AccessProfileSourceRefTypeEnum;
    /**
     * The display name of the associated Source
     * @type {string}
     * @memberof AccessProfileSourceRef
     */
    'name'?: string;
}

export const AccessProfileSourceRefTypeEnum = {
    Source: 'SOURCE'
} as const;

export type AccessProfileSourceRefTypeEnum = typeof AccessProfileSourceRefTypeEnum[keyof typeof AccessProfileSourceRefTypeEnum];

/**
 * This is a summary representation of an access profile.
 * @export
 * @interface AccessProfileSummary
 */
export interface AccessProfileSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof AccessProfileSummary
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileSummary
     */
    'source'?: Reference1;
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccessProfileSummary
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileSummary
     */
    'revocable'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileSummaryAllOf
 */
export interface AccessProfileSummaryAllOf {
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileSummaryAllOf
     */
    'source'?: Reference1;
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccessProfileSummaryAllOf
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileSummaryAllOf
     */
    'revocable'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileUsage
 */
export interface AccessProfileUsage {
    /**
     * ID of the Access Profile that is in use
     * @type {string}
     * @memberof AccessProfileUsage
     */
    'accessProfileId'?: string;
    /**
     * List of references to objects which are using the indicated Access Profile
     * @type {Array<AccessProfileUsageUsedByInner>}
     * @memberof AccessProfileUsage
     */
    'usedBy'?: Array<AccessProfileUsageUsedByInner>;
}
/**
 * Role using the access profile.
 * @export
 * @interface AccessProfileUsageUsedByInner
 */
export interface AccessProfileUsageUsedByInner {
    /**
     * DTO type of role using the access profile.
     * @type {string}
     * @memberof AccessProfileUsageUsedByInner
     */
    'type'?: AccessProfileUsageUsedByInnerTypeEnum;
    /**
     * ID of role using the access profile.
     * @type {string}
     * @memberof AccessProfileUsageUsedByInner
     */
    'id'?: string;
    /**
     * Display name of role using the access profile.
     * @type {string}
     * @memberof AccessProfileUsageUsedByInner
     */
    'name'?: string;
}

export const AccessProfileUsageUsedByInnerTypeEnum = {
    Role: 'ROLE'
} as const;

export type AccessProfileUsageUsedByInnerTypeEnum = typeof AccessProfileUsageUsedByInnerTypeEnum[keyof typeof AccessProfileUsageUsedByInnerTypeEnum];

/**
 * 
 * @export
 * @interface AccessRequest
 */
export interface AccessRequest {
    /**
     * A list of Identity IDs for whom the Access is requested. If it\'s a Revoke request, there can only be one Identity ID.
     * @type {Array<string>}
     * @memberof AccessRequest
     */
    'requestedFor': Array<string>;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof AccessRequest
     */
    'requestType'?: AccessRequestType | null;
    /**
     * 
     * @type {Array<AccessRequestItem>}
     * @memberof AccessRequest
     */
    'requestedItems': Array<AccessRequestItem>;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on associated APIs such as /account-activities.
     * @type {{ [key: string]: string; }}
     * @memberof AccessRequest
     */
    'clientMetadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface AccessRequestConfig
 */
export interface AccessRequestConfig {
    /**
     * If this is true, approvals must be processed by an external system. Also, if this is true, it blocks Request Center access requests and returns an error for any user who isn\'t an org admin.
     * @type {boolean}
     * @memberof AccessRequestConfig
     */
    'approvalsMustBeExternal'?: boolean;
    /**
     * If this is true and the requester and reviewer are the same, the request is automatically approved.
     * @type {boolean}
     * @memberof AccessRequestConfig
     */
    'autoApprovalEnabled'?: boolean;
    /**
     * 
     * @type {RequestOnBehalfOfConfig}
     * @memberof AccessRequestConfig
     */
    'requestOnBehalfOfConfig'?: RequestOnBehalfOfConfig;
    /**
     * 
     * @type {ApprovalReminderAndEscalationConfig}
     * @memberof AccessRequestConfig
     */
    'approvalReminderAndEscalationConfig'?: ApprovalReminderAndEscalationConfig;
    /**
     * 
     * @type {EntitlementRequestConfig}
     * @memberof AccessRequestConfig
     */
    'entitlementRequestConfig'?: EntitlementRequestConfig;
}
/**
 * 
 * @export
 * @interface AccessRequestItem
 */
export interface AccessRequestItem {
    /**
     * The type of the item being requested.
     * @type {string}
     * @memberof AccessRequestItem
     */
    'type': AccessRequestItemTypeEnum;
    /**
     * ID of Role, Access Profile or Entitlement being requested.
     * @type {string}
     * @memberof AccessRequestItem
     */
    'id': string;
    /**
     * Comment provided by requester. * Comment is required when the request is of type Revoke Access. 
     * @type {string}
     * @memberof AccessRequestItem
     */
    'comment'?: string;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on associated APIs such as /account-activities and /access-request-status.
     * @type {{ [key: string]: string; }}
     * @memberof AccessRequestItem
     */
    'clientMetadata'?: { [key: string]: string; };
    /**
     * The date the role or access profile or entitlement is no longer assigned to the specified identity. Also known as the expiration date. * Specify a date in the future. * The current SLA for the deprovisioning is 24 hours. * This date can be modified to either extend or decrease the duration of access item assignments for the specified identity. You can change the expiration date for requests for yourself or direct reports, but you cannot remove an expiration date on an already approved item. If the access request has not been approved, you can cancel it and submit a new one without the expiration. If it has already been approved, then you have to revoke the access and then re-request without the expiration. 
     * @type {string}
     * @memberof AccessRequestItem
     */
    'removeDate'?: string;
}

export const AccessRequestItemTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessRequestItemTypeEnum = typeof AccessRequestItemTypeEnum[keyof typeof AccessRequestItemTypeEnum];

/**
 * Provides additional details about this access request phase.
 * @export
 * @interface AccessRequestPhases
 */
export interface AccessRequestPhases {
    /**
     * The time that this phase started.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'started'?: string;
    /**
     * The time that this phase finished.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'finished'?: string | null;
    /**
     * The name of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'name'?: string;
    /**
     * The state of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'state'?: AccessRequestPhasesStateEnum;
    /**
     * The state of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'result'?: AccessRequestPhasesResultEnum;
    /**
     * A reference to another object on the RequestedItemStatus that contains more details about the phase. Note that for the Provisioning phase, this will be empty if there are no manual work items.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'phaseReference'?: string | null;
}

export const AccessRequestPhasesStateEnum = {
    Pending: 'PENDING',
    Executing: 'EXECUTING',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    NotExecuted: 'NOT_EXECUTED'
} as const;

export type AccessRequestPhasesStateEnum = typeof AccessRequestPhasesStateEnum[keyof typeof AccessRequestPhasesStateEnum];
export const AccessRequestPhasesResultEnum = {
    Successful: 'SUCCESSFUL',
    Failed: 'FAILED',
    Null: 'null'
} as const;

export type AccessRequestPhasesResultEnum = typeof AccessRequestPhasesResultEnum[keyof typeof AccessRequestPhasesResultEnum];

/**
 * Access request type. Defaults to GRANT_ACCESS. REVOKE_ACCESS type can only have a single Identity ID in the requestedFor field.
 * @export
 * @enum {string}
 */

export const AccessRequestType = {
    GrantAccess: 'GRANT_ACCESS',
    RevokeAccess: 'REVOKE_ACCESS',
    Null: 'null'
} as const;

export type AccessRequestType = typeof AccessRequestType[keyof typeof AccessRequestType];


/**
 * 
 * @export
 * @interface AccessReviewItem
 */
export interface AccessReviewItem {
    /**
     * 
     * @type {AccessSummary}
     * @memberof AccessReviewItem
     */
    'accessSummary'?: AccessSummary;
    /**
     * 
     * @type {CertificationIdentitySummary}
     * @memberof AccessReviewItem
     */
    'identitySummary'?: CertificationIdentitySummary;
    /**
     * The review item\'s id
     * @type {string}
     * @memberof AccessReviewItem
     */
    'id'?: string;
    /**
     * Whether the review item is complete
     * @type {boolean}
     * @memberof AccessReviewItem
     */
    'completed'?: boolean;
    /**
     * Indicates whether the review item is for new access to a source
     * @type {boolean}
     * @memberof AccessReviewItem
     */
    'newAccess'?: boolean;
    /**
     * 
     * @type {CertificationDecision}
     * @memberof AccessReviewItem
     */
    'decision'?: CertificationDecision;
    /**
     * Comments for this review item
     * @type {string}
     * @memberof AccessReviewItem
     */
    'comments'?: string | null;
}
/**
 * 
 * @export
 * @interface AccessReviewReassignment
 */
export interface AccessReviewReassignment {
    /**
     * 
     * @type {Array<ReassignReference>}
     * @memberof AccessReviewReassignment
     */
    'reassign': Array<ReassignReference>;
    /**
     * The ID of the identity to which the certification is reassigned
     * @type {string}
     * @memberof AccessReviewReassignment
     */
    'reassignTo': string;
    /**
     * The reason comment for why the reassign was made
     * @type {string}
     * @memberof AccessReviewReassignment
     */
    'reason': string;
}
/**
 * An object holding the access that is being reviewed
 * @export
 * @interface AccessSummary
 */
export interface AccessSummary {
    /**
     * 
     * @type {AccessSummaryAccess}
     * @memberof AccessSummary
     */
    'access'?: AccessSummaryAccess;
    /**
     * 
     * @type {ReviewableEntitlement}
     * @memberof AccessSummary
     */
    'entitlement'?: ReviewableEntitlement | null;
    /**
     * 
     * @type {ReviewableAccessProfile}
     * @memberof AccessSummary
     */
    'accessProfile'?: ReviewableAccessProfile;
    /**
     * 
     * @type {ReviewableRole}
     * @memberof AccessSummary
     */
    'role'?: ReviewableRole | null;
}
/**
 * 
 * @export
 * @interface AccessSummaryAccess
 */
export interface AccessSummaryAccess {
    /**
     * 
     * @type {DtoType}
     * @memberof AccessSummaryAccess
     */
    'type'?: DtoType;
    /**
     * The ID of the item being certified
     * @type {string}
     * @memberof AccessSummaryAccess
     */
    'id'?: string;
    /**
     * The name of the item being certified
     * @type {string}
     * @memberof AccessSummaryAccess
     */
    'name'?: string;
}
/**
 * Access type of API Client indicating online or offline use
 * @export
 * @enum {string}
 */

export const AccessType = {
    Online: 'ONLINE',
    Offline: 'OFFLINE'
} as const;

export type AccessType = typeof AccessType[keyof typeof AccessType];


/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof Account
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof Account
     */
    'modified'?: string;
    /**
     * The unique ID of the source this account belongs to
     * @type {string}
     * @memberof Account
     */
    'sourceId': string;
    /**
     * The display name of the source this account belongs to
     * @type {string}
     * @memberof Account
     */
    'sourceName': string;
    /**
     * The unique ID of the identity this account is correlated to
     * @type {string}
     * @memberof Account
     */
    'identityId'?: string;
    /**
     * The account attributes that are aggregated
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    'attributes': { [key: string]: any; } | null;
    /**
     * Indicates if this account is from an authoritative source
     * @type {boolean}
     * @memberof Account
     */
    'authoritative': boolean;
    /**
     * A description of the account
     * @type {string}
     * @memberof Account
     */
    'description'?: string | null;
    /**
     * Indicates if the account is currently disabled
     * @type {boolean}
     * @memberof Account
     */
    'disabled': boolean;
    /**
     * Indicates if the account is currently locked
     * @type {boolean}
     * @memberof Account
     */
    'locked': boolean;
    /**
     * The unique ID of the account generated by the source system
     * @type {string}
     * @memberof Account
     */
    'nativeIdentity': string;
    /**
     * If true, this is a user account within IdentityNow.  If false, this is an account from a source system.
     * @type {boolean}
     * @memberof Account
     */
    'systemAccount': boolean;
    /**
     * Indicates if this account is not correlated to an identity
     * @type {boolean}
     * @memberof Account
     */
    'uncorrelated': boolean;
    /**
     * The unique ID of the account as determined by the account schema
     * @type {string}
     * @memberof Account
     */
    'uuid'?: string | null;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof Account
     */
    'manuallyCorrelated': boolean;
    /**
     * Indicates if the account has entitlements
     * @type {boolean}
     * @memberof Account
     */
    'hasEntitlements': boolean;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof Account
     */
    'identity'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof Account
     */
    'sourceOwner'?: BaseReferenceDto;
    /**
     * A string list containing the owning source\'s features
     * @type {string}
     * @memberof Account
     */
    'features'?: string | null;
}
/**
 * Object for specifying Actions to be performed on a specified list of sources\' account.
 * @export
 * @interface AccountAction
 */
export interface AccountAction {
    /**
     * Describes if action will be enabled or disabled
     * @type {string}
     * @memberof AccountAction
     */
    'action'?: AccountActionActionEnum;
    /**
     * List of unique source IDs. The sources must have the ENABLE feature or flat file source. See \"/sources\" endpoint for source features.
     * @type {Set<string>}
     * @memberof AccountAction
     */
    'sourceIds'?: Set<string>;
}

export const AccountActionActionEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type AccountActionActionEnum = typeof AccountActionActionEnum[keyof typeof AccountActionActionEnum];

/**
 * 
 * @export
 * @interface AccountActivity
 */
export interface AccountActivity {
    /**
     * Id of the account activity
     * @type {string}
     * @memberof AccountActivity
     */
    'id'?: string;
    /**
     * The name of the activity
     * @type {string}
     * @memberof AccountActivity
     */
    'name'?: string;
    /**
     * When the activity was first created
     * @type {string}
     * @memberof AccountActivity
     */
    'created'?: string;
    /**
     * When the activity was last modified
     * @type {string}
     * @memberof AccountActivity
     */
    'modified'?: string | null;
    /**
     * When the activity was completed
     * @type {string}
     * @memberof AccountActivity
     */
    'completed'?: string | null;
    /**
     * 
     * @type {CompletionStatus & object}
     * @memberof AccountActivity
     */
    'completionStatus'?: CompletionStatus & object;
    /**
     * The type of action the activity performed.  Please see the following list of types.  This list may grow over time.  - CloudAutomated - IdentityAttributeUpdate - appRequest - LifecycleStateChange - AccountStateUpdate - AccountAttributeUpdate - CloudPasswordRequest - Attribute Synchronization Refresh - Certification - Identity Refresh - Lifecycle Change Refresh   [Learn more here](https://documentation.sailpoint.com/saas/help/search/searchable-fields.html#searching-account-activity-data). 
     * @type {string}
     * @memberof AccountActivity
     */
    'type'?: string | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivity
     */
    'requesterIdentitySummary'?: IdentitySummary | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivity
     */
    'targetIdentitySummary'?: IdentitySummary | null;
    /**
     * A list of error messages, if any, that were encountered.
     * @type {Array<string>}
     * @memberof AccountActivity
     */
    'errors'?: Array<string> | null;
    /**
     * A list of warning messages, if any, that were encountered.
     * @type {Array<string>}
     * @memberof AccountActivity
     */
    'warnings'?: Array<string> | null;
    /**
     * Individual actions performed as part of this account activity
     * @type {Array<AccountActivityItem>}
     * @memberof AccountActivity
     */
    'items'?: Array<AccountActivityItem> | null;
    /**
     * 
     * @type {ExecutionStatus}
     * @memberof AccountActivity
     */
    'executionStatus'?: ExecutionStatus;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request
     * @type {{ [key: string]: string; }}
     * @memberof AccountActivity
     */
    'clientMetadata'?: { [key: string]: string; } | null;
}
/**
 * The state of an approval status
 * @export
 * @enum {string}
 */

export const AccountActivityApprovalStatus = {
    Finished: 'FINISHED',
    Rejected: 'REJECTED',
    Returned: 'RETURNED',
    Expired: 'EXPIRED',
    Pending: 'PENDING',
    Canceled: 'CANCELED',
    Null: 'null'
} as const;

export type AccountActivityApprovalStatus = typeof AccountActivityApprovalStatus[keyof typeof AccountActivityApprovalStatus];


/**
 * AccountActivity
 * @export
 * @interface AccountActivityDocument
 */
export interface AccountActivityDocument {
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccountActivityDocument
     */
    '_type': DocumentType;
    /**
     * Type of action performed in the activity.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'action'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'modified'?: string | null;
    /**
     * Activity\'s current stage.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'stage'?: string;
    /**
     * Activity\'s origin.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'origin'?: string | null;
    /**
     * Activity\'s current status.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'status'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivityDocument
     */
    'requester'?: AccountSource;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivityDocument
     */
    'recipient'?: AccountSource;
    /**
     * Account activity\'s tracking number.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'trackingNumber'?: string;
    /**
     * Errors provided by the source while completing account actions.
     * @type {Array<string>}
     * @memberof AccountActivityDocument
     */
    'errors'?: Array<string> | null;
    /**
     * Warnings provided by the source while completing account actions.
     * @type {Array<string>}
     * @memberof AccountActivityDocument
     */
    'warnings'?: Array<string> | null;
    /**
     * Approvals performed on an item during activity.
     * @type {Array<Approval>}
     * @memberof AccountActivityDocument
     */
    'approvals'?: Array<Approval>;
    /**
     * Original actions that triggered all individual source actions related to the account action.
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivityDocument
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * Controls that translated the attribute requests into actual provisioning actions on the source.
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivityDocument
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * Account data for each individual source action triggered by the original requests.
     * @type {Array<AccountRequest>}
     * @memberof AccountActivityDocument
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * Sources involved in the account activity.
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'sources'?: string;
}
/**
 * 
 * @export
 * @interface AccountActivityItem
 */
export interface AccountActivityItem {
    /**
     * Item id
     * @type {string}
     * @memberof AccountActivityItem
     */
    'id'?: string;
    /**
     * Human-readable display name of item
     * @type {string}
     * @memberof AccountActivityItem
     */
    'name'?: string;
    /**
     * Date and time item was requested
     * @type {string}
     * @memberof AccountActivityItem
     */
    'requested'?: string;
    /**
     * 
     * @type {AccountActivityApprovalStatus & object}
     * @memberof AccountActivityItem
     */
    'approvalStatus'?: AccountActivityApprovalStatus & object;
    /**
     * 
     * @type {ProvisioningState}
     * @memberof AccountActivityItem
     */
    'provisioningStatus'?: ProvisioningState;
    /**
     * 
     * @type {Comment}
     * @memberof AccountActivityItem
     */
    'requesterComment'?: Comment | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivityItem
     */
    'reviewerIdentitySummary'?: IdentitySummary | null;
    /**
     * 
     * @type {Comment}
     * @memberof AccountActivityItem
     */
    'reviewerComment'?: Comment | null;
    /**
     * 
     * @type {AccountActivityItemOperation & object}
     * @memberof AccountActivityItem
     */
    'operation'?: AccountActivityItemOperation & object;
    /**
     * Attribute to which account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'attribute'?: string | null;
    /**
     * Value of attribute
     * @type {string}
     * @memberof AccountActivityItem
     */
    'value'?: string | null;
    /**
     * Native identity in the target system to which the account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'nativeIdentity'?: string | null;
    /**
     * Id of Source to which account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'sourceId'?: string;
    /**
     * 
     * @type {AccountRequestInfo}
     * @memberof AccountActivityItem
     */
    'accountRequestInfo'?: AccountRequestInfo | null;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request item
     * @type {{ [key: string]: string; }}
     * @memberof AccountActivityItem
     */
    'clientMetadata'?: { [key: string]: string; } | null;
    /**
     * The date the role or access profile or entitlement is no longer assigned to the specified identity.
     * @type {string}
     * @memberof AccountActivityItem
     */
    'removeDate'?: string | null;
}
/**
 * Represents an operation in an account activity item
 * @export
 * @enum {string}
 */

export const AccountActivityItemOperation = {
    Add: 'ADD',
    Create: 'CREATE',
    Modify: 'MODIFY',
    Delete: 'DELETE',
    Disable: 'DISABLE',
    Enable: 'ENABLE',
    Unlock: 'UNLOCK',
    Lock: 'LOCK',
    Remove: 'REMOVE',
    Set: 'SET',
    Null: 'null'
} as const;

export type AccountActivityItemOperation = typeof AccountActivityItemOperation[keyof typeof AccountActivityItemOperation];


/**
 * AccountActivity
 * @export
 * @interface AccountActivitySearchedItem
 */
export interface AccountActivitySearchedItem {
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccountActivitySearchedItem
     */
    '_type': DocumentType;
    /**
     * Type of action performed in the activity.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'action'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'modified'?: string | null;
    /**
     * Activity\'s current stage.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'stage'?: string;
    /**
     * Activity\'s origin.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'origin'?: string | null;
    /**
     * Activity\'s current status.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'status'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItem
     */
    'requester'?: AccountSource;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItem
     */
    'recipient'?: AccountSource;
    /**
     * Account activity\'s tracking number.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'trackingNumber'?: string;
    /**
     * Errors provided by the source while completing account actions.
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItem
     */
    'errors'?: Array<string> | null;
    /**
     * Warnings provided by the source while completing account actions.
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItem
     */
    'warnings'?: Array<string> | null;
    /**
     * Approvals performed on an item during activity.
     * @type {Array<Approval>}
     * @memberof AccountActivitySearchedItem
     */
    'approvals'?: Array<Approval>;
    /**
     * Original actions that triggered all individual source actions related to the account action.
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivitySearchedItem
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * Controls that translated the attribute requests into actual provisioning actions on the source.
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivitySearchedItem
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * Account data for each individual source action triggered by the original requests.
     * @type {Array<AccountRequest>}
     * @memberof AccountActivitySearchedItem
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * Sources involved in the account activity.
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'sources'?: string;
}
/**
 * 
 * @export
 * @interface AccountActivitySearchedItemAllOf
 */
export interface AccountActivitySearchedItemAllOf {
    /**
     * Type of action performed in the activity.
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'action'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'modified'?: string | null;
    /**
     * Activity\'s current stage.
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'stage'?: string;
    /**
     * Activity\'s origin.
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'origin'?: string | null;
    /**
     * Activity\'s current status.
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'status'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'requester'?: AccountSource;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'recipient'?: AccountSource;
    /**
     * Account activity\'s tracking number.
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'trackingNumber'?: string;
    /**
     * Errors provided by the source while completing account actions.
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'errors'?: Array<string> | null;
    /**
     * Warnings provided by the source while completing account actions.
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'warnings'?: Array<string> | null;
    /**
     * Approvals performed on an item during activity.
     * @type {Array<Approval>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'approvals'?: Array<Approval>;
    /**
     * Original actions that triggered all individual source actions related to the account action.
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * Controls that translated the attribute requests into actual provisioning actions on the source.
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * Account data for each individual source action triggered by the original requests.
     * @type {Array<AccountRequest>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * Sources involved in the account activity.
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'sources'?: string;
}
/**
 * 
 * @export
 * @interface AccountAllOf
 */
export interface AccountAllOf {
    /**
     * The unique ID of the source this account belongs to
     * @type {string}
     * @memberof AccountAllOf
     */
    'sourceId': string;
    /**
     * The display name of the source this account belongs to
     * @type {string}
     * @memberof AccountAllOf
     */
    'sourceName': string;
    /**
     * The unique ID of the identity this account is correlated to
     * @type {string}
     * @memberof AccountAllOf
     */
    'identityId'?: string;
    /**
     * The account attributes that are aggregated
     * @type {{ [key: string]: any; }}
     * @memberof AccountAllOf
     */
    'attributes': { [key: string]: any; } | null;
    /**
     * Indicates if this account is from an authoritative source
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'authoritative': boolean;
    /**
     * A description of the account
     * @type {string}
     * @memberof AccountAllOf
     */
    'description'?: string | null;
    /**
     * Indicates if the account is currently disabled
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'disabled': boolean;
    /**
     * Indicates if the account is currently locked
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'locked': boolean;
    /**
     * The unique ID of the account generated by the source system
     * @type {string}
     * @memberof AccountAllOf
     */
    'nativeIdentity': string;
    /**
     * If true, this is a user account within IdentityNow.  If false, this is an account from a source system.
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'systemAccount': boolean;
    /**
     * Indicates if this account is not correlated to an identity
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'uncorrelated': boolean;
    /**
     * The unique ID of the account as determined by the account schema
     * @type {string}
     * @memberof AccountAllOf
     */
    'uuid'?: string | null;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'manuallyCorrelated': boolean;
    /**
     * Indicates if the account has entitlements
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'hasEntitlements': boolean;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof AccountAllOf
     */
    'identity'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof AccountAllOf
     */
    'sourceOwner'?: BaseReferenceDto;
    /**
     * A string list containing the owning source\'s features
     * @type {string}
     * @memberof AccountAllOf
     */
    'features'?: string | null;
}
/**
 * 
 * @export
 * @interface AccountAttribute
 */
export interface AccountAttribute {
    /**
     * A reference to the source to search for the account
     * @type {string}
     * @memberof AccountAttribute
     */
    'sourceName': string;
    /**
     * The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema.
     * @type {string}
     * @memberof AccountAttribute
     */
    'attributeName': string;
    /**
     * The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountSortAttribute'?: string;
    /**
     * The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'accountSortDescending'?: boolean;
    /**
     * The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'accountReturnFirstLink'?: boolean;
    /**
     * This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria. Only certain searchable attributes are available:  - `nativeIdentity` - the Account ID  - `displayName` - the Account Name  - `entitlements` - a boolean value to determine if the account has entitlements
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountFilter'?: string;
    /**
     * This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.  All account attributes are available for filtering as this operation is performed in memory.
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountPropertyFilter'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof AccountAttribute
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface AccountAttributes
 */
export interface AccountAttributes {
    /**
     * The schema attribute values for the account
     * @type {{ [key: string]: any; }}
     * @memberof AccountAttributes
     */
    'attributes': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface AccountAttributesCreate
 */
export interface AccountAttributesCreate {
    /**
     * 
     * @type {AccountAttributesCreateAttributes}
     * @memberof AccountAttributesCreate
     */
    'attributes': AccountAttributesCreateAttributes;
}
/**
 * The schema attribute values for the account
 * @export
 * @interface AccountAttributesCreateAttributes
 */
export interface AccountAttributesCreateAttributes {
    [key: string]: string | any;

    /**
     * Target source to create an account
     * @type {string}
     * @memberof AccountAttributesCreateAttributes
     */
    'sourceId': string;
}
/**
 * 
 * @export
 * @interface AccountRequest
 */
export interface AccountRequest {
    /**
     * Unique ID of the account
     * @type {string}
     * @memberof AccountRequest
     */
    'accountId'?: string;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof AccountRequest
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * The operation that was performed
     * @type {string}
     * @memberof AccountRequest
     */
    'op'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountRequest
     */
    'provisioningTarget'?: AccountSource;
    /**
     * 
     * @type {AccountRequestResult}
     * @memberof AccountRequest
     */
    'result'?: AccountRequestResult;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountRequest
     */
    'source'?: AccountSource;
}
/**
 * If an account activity item is associated with an access request, captures details of that request.
 * @export
 * @interface AccountRequestInfo
 */
export interface AccountRequestInfo {
    /**
     * Id of requested object
     * @type {string}
     * @memberof AccountRequestInfo
     */
    'requestedObjectId'?: string;
    /**
     * Human-readable name of requested object
     * @type {string}
     * @memberof AccountRequestInfo
     */
    'requestedObjectName'?: string;
    /**
     * 
     * @type {RequestableObjectType}
     * @memberof AccountRequestInfo
     */
    'requestedObjectType'?: RequestableObjectType;
}
/**
 * 
 * @export
 * @interface AccountRequestResult
 */
export interface AccountRequestResult {
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountRequestResult
     */
    'errors'?: Array<string>;
    /**
     * The status of the account request
     * @type {string}
     * @memberof AccountRequestResult
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountRequestResult
     */
    'ticketId'?: string | null;
}
/**
 * 
 * @export
 * @interface AccountSource
 */
export interface AccountSource {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccountSource
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccountSource
     */
    'name'?: string;
    /**
     * Type of source returned.
     * @type {string}
     * @memberof AccountSource
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface AccountSourceAllOf
 */
export interface AccountSourceAllOf {
    /**
     * Type of source returned.
     * @type {string}
     * @memberof AccountSourceAllOf
     */
    'type'?: string;
}
/**
 * Request used for account enable/disable
 * @export
 * @interface AccountToggleRequest
 */
export interface AccountToggleRequest {
    /**
     * If set, an external process validates that the user wants to proceed with this request.
     * @type {string}
     * @memberof AccountToggleRequest
     */
    'externalVerificationId'?: string;
    /**
     * If set, provisioning updates the account attribute at the source.   This option is used when the account is not synced to ensure the attribute is updated. Providing \'true\' for an unlocked account will add and process \'Unlock\' operation by the workflow.
     * @type {boolean}
     * @memberof AccountToggleRequest
     */
    'forceProvisioning'?: boolean;
}
/**
 * Request used for account unlock
 * @export
 * @interface AccountUnlockRequest
 */
export interface AccountUnlockRequest {
    /**
     * If set, an external process validates that the user wants to proceed with this request.
     * @type {string}
     * @memberof AccountUnlockRequest
     */
    'externalVerificationId'?: string;
    /**
     * If set, the IDN account is unlocked after the workflow completes.
     * @type {boolean}
     * @memberof AccountUnlockRequest
     */
    'unlockIDNAccount'?: boolean;
    /**
     * If set, provisioning updates the account attribute at the source.   This option is used when the account is not synced to ensure the attribute is updated.
     * @type {boolean}
     * @memberof AccountUnlockRequest
     */
    'forceProvisioning'?: boolean;
}
/**
 * 
 * @export
 * @interface AccountUsage
 */
export interface AccountUsage {
    /**
     * The first day of the month for which activity is aggregated.
     * @type {string}
     * @memberof AccountUsage
     */
    'date'?: string;
    /**
     * The number of days within the month that the account was active in a source.
     * @type {number}
     * @memberof AccountUsage
     */
    'count'?: number;
}
/**
 * Accounts async response containing details on started async process
 * @export
 * @interface AccountsAsyncResult
 */
export interface AccountsAsyncResult {
    /**
     * id of the task
     * @type {string}
     * @memberof AccountsAsyncResult
     */
    'id': string;
}
/**
 * Arguments for Account Export (ACCOUNTS)
 * @export
 * @interface AccountsExportReportArguments
 */
export interface AccountsExportReportArguments {
    /**
     * Id of the authoritative source to export related accounts e.g. identities
     * @type {string}
     * @memberof AccountsExportReportArguments
     */
    'application': string;
    /**
     * Name of the authoritative source for accounts export
     * @type {string}
     * @memberof AccountsExportReportArguments
     */
    'sourceName': string;
}
/**
 * 
 * @export
 * @interface ActivateCampaignOptions
 */
export interface ActivateCampaignOptions {
    /**
     * The timezone must be in a valid ISO 8601 format. Timezones in ISO 8601 are represented as UTC (represented as \'Z\') or as an offset from UTC. The offset format can be +/-hh:mm, +/-hhmm, or +/-hh.
     * @type {string}
     * @memberof ActivateCampaignOptions
     */
    'timeZone'?: string;
}
/**
 * Insights into account activity
 * @export
 * @interface ActivityInsights
 */
export interface ActivityInsights {
    /**
     * UUID of the account
     * @type {string}
     * @memberof ActivityInsights
     */
    'accountID'?: string;
    /**
     * The number of days of activity
     * @type {number}
     * @memberof ActivityInsights
     */
    'usageDays'?: number;
    /**
     * Status indicating if the activity is complete or unknown
     * @type {string}
     * @memberof ActivityInsights
     */
    'usageDaysState'?: ActivityInsightsUsageDaysStateEnum;
}

export const ActivityInsightsUsageDaysStateEnum = {
    Complete: 'COMPLETE',
    Unknown: 'UNKNOWN'
} as const;

export type ActivityInsightsUsageDaysStateEnum = typeof ActivityInsightsUsageDaysStateEnum[keyof typeof ActivityInsightsUsageDaysStateEnum];

/**
 * 
 * @export
 * @interface AdminReviewReassign
 */
export interface AdminReviewReassign {
    /**
     * List of certification IDs to reassign
     * @type {Array<string>}
     * @memberof AdminReviewReassign
     */
    'certificationIds'?: Array<string>;
    /**
     * 
     * @type {AdminReviewReassignReassignTo}
     * @memberof AdminReviewReassign
     */
    'reassignTo'?: AdminReviewReassignReassignTo;
    /**
     * Comment to explain why the certification was reassigned
     * @type {string}
     * @memberof AdminReviewReassign
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface AdminReviewReassignReassignTo
 */
export interface AdminReviewReassignReassignTo {
    /**
     * The identity ID to which the review is being assigned.
     * @type {string}
     * @memberof AdminReviewReassignReassignTo
     */
    'id'?: string;
    /**
     * The type of the ID provided.
     * @type {string}
     * @memberof AdminReviewReassignReassignTo
     */
    'type'?: AdminReviewReassignReassignToTypeEnum;
}

export const AdminReviewReassignReassignToTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AdminReviewReassignReassignToTypeEnum = typeof AdminReviewReassignReassignToTypeEnum[keyof typeof AdminReviewReassignReassignToTypeEnum];

/**
 * 
 * @export
 * @interface AggregationResult
 */
export interface AggregationResult {
    /**
     * The document containing the results of the aggregation. This document is controlled by Elasticsearch and depends on the type of aggregation query that is run.  See Elasticsearch [Aggregations](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations.html) documentation for information. 
     * @type {object}
     * @memberof AggregationResult
     */
    'aggregations'?: object;
    /**
     * The results of the aggregation search query. 
     * @type {Array<SearchDocument>}
     * @memberof AggregationResult
     */
    'hits'?: Array<SearchDocument>;
}
/**
 * Enum representing the currently available query languages for aggregations, which are used to perform calculations or groupings on search results.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const AggregationType = {
    Dsl: 'DSL',
    Sailpoint: 'SAILPOINT'
} as const;

export type AggregationType = typeof AggregationType[keyof typeof AggregationType];


/**
 * 
 * @export
 * @interface Aggregations
 */
export interface Aggregations {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof Aggregations
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof Aggregations
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof Aggregations
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof Aggregations
     */
    'bucket'?: BucketAggregation;
}
/**
 * 
 * @export
 * @interface App
 */
export interface App {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof App
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof App
     */
    'name'?: string;
    /**
     * 
     * @type {Reference1}
     * @memberof App
     */
    'source'?: Reference1;
    /**
     * 
     * @type {AppAllOfAccount}
     * @memberof App
     */
    'account'?: AppAllOfAccount;
}
/**
 * 
 * @export
 * @interface AppAllOf
 */
export interface AppAllOf {
    /**
     * 
     * @type {Reference1}
     * @memberof AppAllOf
     */
    'source'?: Reference1;
    /**
     * 
     * @type {AppAllOfAccount}
     * @memberof AppAllOf
     */
    'account'?: AppAllOfAccount;
}
/**
 * 
 * @export
 * @interface AppAllOfAccount
 */
export interface AppAllOfAccount {
    /**
     * The SailPoint generated unique ID
     * @type {string}
     * @memberof AppAllOfAccount
     */
    'id'?: string;
    /**
     * The account ID generated by the source
     * @type {string}
     * @memberof AppAllOfAccount
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface Approval
 */
export interface Approval {
    /**
     * 
     * @type {Array<ApprovalComment>}
     * @memberof Approval
     */
    'comments'?: Array<ApprovalComment>;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Approval
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Approval
     */
    'modified'?: string | null;
    /**
     * 
     * @type {AccountSource}
     * @memberof Approval
     */
    'owner'?: AccountSource;
    /**
     * The result of the approval
     * @type {string}
     * @memberof Approval
     */
    'result'?: string;
    /**
     * 
     * @type {string}
     * @memberof Approval
     */
    'type'?: string | null;
}
/**
 * 
 * @export
 * @interface ApprovalComment
 */
export interface ApprovalComment {
    /**
     * The comment text
     * @type {string}
     * @memberof ApprovalComment
     */
    'comment'?: string;
    /**
     * The name of the commenter
     * @type {string}
     * @memberof ApprovalComment
     */
    'commenter'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof ApprovalComment
     */
    'date'?: string | null;
}
/**
 * 
 * @export
 * @interface ApprovalForwardHistory
 */
export interface ApprovalForwardHistory {
    /**
     * Display name of approver from whom the approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'oldApproverName'?: string;
    /**
     * Display name of approver to whom the approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'newApproverName'?: string;
    /**
     * Comment made while forwarding.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'comment'?: string | null;
    /**
     * Time at which approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'modified'?: string;
    /**
     * Display name of forwarder who forwarded the approval.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'forwarderName'?: string | null;
    /**
     * 
     * @type {ReassignmentType}
     * @memberof ApprovalForwardHistory
     */
    'reassignmentType'?: ReassignmentType;
}
/**
 * 
 * @export
 * @interface ApprovalItemDetails
 */
export interface ApprovalItemDetails {
    /**
     * The approval item\'s ID
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'id'?: string;
    /**
     * The account referenced by the approval item
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'account'?: string | null;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'application'?: string;
    /**
     * The attribute\'s name
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'name'?: string | null;
    /**
     * The attribute\'s operation
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'operation'?: string;
    /**
     * The attribute\'s value
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'value'?: string | null;
    /**
     * 
     * @type {WorkItemState & object}
     * @memberof ApprovalItemDetails
     */
    'state'?: WorkItemState & object;
}
/**
 * 
 * @export
 * @interface ApprovalItems
 */
export interface ApprovalItems {
    /**
     * The approval item\'s ID
     * @type {string}
     * @memberof ApprovalItems
     */
    'id'?: string;
    /**
     * The account referenced by the approval item
     * @type {string}
     * @memberof ApprovalItems
     */
    'account'?: string | null;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof ApprovalItems
     */
    'application'?: string;
    /**
     * The attribute\'s name
     * @type {string}
     * @memberof ApprovalItems
     */
    'name'?: string | null;
    /**
     * The attribute\'s operation
     * @type {string}
     * @memberof ApprovalItems
     */
    'operation'?: string;
    /**
     * The attribute\'s value
     * @type {string}
     * @memberof ApprovalItems
     */
    'value'?: string | null;
    /**
     * 
     * @type {WorkItemState & object}
     * @memberof ApprovalItems
     */
    'state'?: WorkItemState & object;
}
/**
 * 
 * @export
 * @interface ApprovalReminderAndEscalationConfig
 */
export interface ApprovalReminderAndEscalationConfig {
    /**
     * Number of days to wait before the first reminder. If no reminders are configured, then this is the number of days to wait before escalation.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'daysUntilEscalation'?: number | null;
    /**
     * Number of days to wait between reminder notifications.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'daysBetweenReminders'?: number | null;
    /**
     * Maximum number of reminder notification to send to the reviewer before approval escalation.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'maxReminders'?: number | null;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'fallbackApproverRef'?: IdentityReferenceWithNameAndEmail | null;
}
/**
 * Describes the individual or group that is responsible for an approval step.
 * @export
 * @enum {string}
 */

export const ApprovalScheme = {
    AppOwner: 'APP_OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    RoleOwner: 'ROLE_OWNER',
    AccessProfileOwner: 'ACCESS_PROFILE_OWNER',
    EntitlementOwner: 'ENTITLEMENT_OWNER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type ApprovalScheme = typeof ApprovalScheme[keyof typeof ApprovalScheme];


/**
 * 
 * @export
 * @interface ApprovalSchemeForRole
 */
export interface ApprovalSchemeForRole {
    /**
     * Describes the individual or group that is responsible for an approval step. Values are as follows.  **OWNER**: Owner of the associated Role  **MANAGER**: Manager of the Identity making the request  **GOVERNANCE_GROUP**: A Governance Group, the ID of which is specified by the **approverId** field
     * @type {string}
     * @memberof ApprovalSchemeForRole
     */
    'approverType'?: ApprovalSchemeForRoleApproverTypeEnum;
    /**
     * Id of the specific approver, used only when approverType is GOVERNANCE_GROUP
     * @type {string}
     * @memberof ApprovalSchemeForRole
     */
    'approverId'?: string | null;
}

export const ApprovalSchemeForRoleApproverTypeEnum = {
    Owner: 'OWNER',
    Manager: 'MANAGER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type ApprovalSchemeForRoleApproverTypeEnum = typeof ApprovalSchemeForRoleApproverTypeEnum[keyof typeof ApprovalSchemeForRoleApproverTypeEnum];

/**
 * Enum representing the non-employee request approval status
 * @export
 * @enum {string}
 */

export const ApprovalStatus = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Pending: 'PENDING',
    NotReady: 'NOT_READY',
    Cancelled: 'CANCELLED'
} as const;

export type ApprovalStatus = typeof ApprovalStatus[keyof typeof ApprovalStatus];


/**
 * 
 * @export
 * @interface ApprovalStatusDto
 */
export interface ApprovalStatusDto {
    /**
     * True if the request for this item was forwarded from one owner to another.
     * @type {boolean}
     * @memberof ApprovalStatusDto
     */
    'forwarded'?: boolean;
    /**
     * 
     * @type {ApprovalStatusDtoOriginalOwner}
     * @memberof ApprovalStatusDto
     */
    'originalOwner'?: ApprovalStatusDtoOriginalOwner;
    /**
     * 
     * @type {ApprovalStatusDtoCurrentOwner}
     * @memberof ApprovalStatusDto
     */
    'currentOwner'?: ApprovalStatusDtoCurrentOwner;
    /**
     * Time at which item was modified.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'modified'?: string | null;
    /**
     * 
     * @type {ManualWorkItemState}
     * @memberof ApprovalStatusDto
     */
    'status'?: ManualWorkItemState;
    /**
     * 
     * @type {ApprovalScheme}
     * @memberof ApprovalStatusDto
     */
    'scheme'?: ApprovalScheme;
    /**
     * If the request failed, includes any error messages that were generated.
     * @type {Array<ErrorMessageDto>}
     * @memberof ApprovalStatusDto
     */
    'errorMessages'?: Array<ErrorMessageDto> | null;
    /**
     * Comment, if any, provided by the approver.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'comment'?: string | null;
    /**
     * The date the role or access profile or entitlement is no longer assigned to the specified identity.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'removeDate'?: string | null;
}
/**
 * 
 * @export
 * @interface ApprovalStatusDtoCurrentOwner
 */
export interface ApprovalStatusDtoCurrentOwner {
    /**
     * DTO type of identity who reviewed the access item request.
     * @type {string}
     * @memberof ApprovalStatusDtoCurrentOwner
     */
    'type'?: ApprovalStatusDtoCurrentOwnerTypeEnum;
    /**
     * ID of identity who reviewed the access item request.
     * @type {string}
     * @memberof ApprovalStatusDtoCurrentOwner
     */
    'id'?: string;
    /**
     * Human-readable display name of identity who reviewed the access item request.
     * @type {string}
     * @memberof ApprovalStatusDtoCurrentOwner
     */
    'name'?: string;
}

export const ApprovalStatusDtoCurrentOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type ApprovalStatusDtoCurrentOwnerTypeEnum = typeof ApprovalStatusDtoCurrentOwnerTypeEnum[keyof typeof ApprovalStatusDtoCurrentOwnerTypeEnum];

/**
 * Identity of orginal approval owner.
 * @export
 * @interface ApprovalStatusDtoOriginalOwner
 */
export interface ApprovalStatusDtoOriginalOwner {
    /**
     * DTO type of original approval owner\'s identity.
     * @type {string}
     * @memberof ApprovalStatusDtoOriginalOwner
     */
    'type'?: ApprovalStatusDtoOriginalOwnerTypeEnum;
    /**
     * ID of original approval owner\'s identity.
     * @type {string}
     * @memberof ApprovalStatusDtoOriginalOwner
     */
    'id'?: string;
    /**
     * Display name of original approval owner.
     * @type {string}
     * @memberof ApprovalStatusDtoOriginalOwner
     */
    'name'?: string;
}

export const ApprovalStatusDtoOriginalOwnerTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type ApprovalStatusDtoOriginalOwnerTypeEnum = typeof ApprovalStatusDtoOriginalOwnerTypeEnum[keyof typeof ApprovalStatusDtoOriginalOwnerTypeEnum];

/**
 * 
 * @export
 * @interface ApprovalSummary
 */
export interface ApprovalSummary {
    /**
     * The number of pending access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'pending'?: number;
    /**
     * The number of approved access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'approved'?: number;
    /**
     * The number of rejected access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'rejected'?: number;
}
/**
 * 
 * @export
 * @interface ArrayInner
 */
export interface ArrayInner {
}
/**
 * 
 * @export
 * @interface AttributeDefinition
 */
export interface AttributeDefinition {
    /**
     * The name of the attribute.
     * @type {string}
     * @memberof AttributeDefinition
     */
    'name'?: string;
    /**
     * 
     * @type {AttributeDefinitionType}
     * @memberof AttributeDefinition
     */
    'type'?: AttributeDefinitionType;
    /**
     * 
     * @type {AttributeDefinitionSchema}
     * @memberof AttributeDefinition
     */
    'schema'?: AttributeDefinitionSchema;
    /**
     * A human-readable description of the attribute.
     * @type {string}
     * @memberof AttributeDefinition
     */
    'description'?: string;
    /**
     * Flag indicating whether or not the attribute is multi-valued.
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isMulti'?: boolean;
    /**
     * Flag indicating whether or not the attribute is an entitlement.
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isEntitlement'?: boolean;
    /**
     * Flag indicating whether or not the attribute represents a group. This can only be `true` if `isEntitlement` is also `true` **and** there is a schema defined for the attribute.. 
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isGroup'?: boolean;
}
/**
 * A reference to the schema on the source to the attribute values map to.
 * @export
 * @interface AttributeDefinitionSchema
 */
export interface AttributeDefinitionSchema {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'type'?: AttributeDefinitionSchemaTypeEnum;
    /**
     * The object ID this reference applies to.
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'id'?: string;
    /**
     * The human-readable display name of the object.
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'name'?: string;
}

export const AttributeDefinitionSchemaTypeEnum = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
} as const;

export type AttributeDefinitionSchemaTypeEnum = typeof AttributeDefinitionSchemaTypeEnum[keyof typeof AttributeDefinitionSchemaTypeEnum];

/**
 * The underlying type of the value which an AttributeDefinition represents.
 * @export
 * @enum {string}
 */

export const AttributeDefinitionType = {
    String: 'STRING',
    Long: 'LONG',
    Int: 'INT',
    Boolean: 'BOOLEAN'
} as const;

export type AttributeDefinitionType = typeof AttributeDefinitionType[keyof typeof AttributeDefinitionType];


/**
 * 
 * @export
 * @interface AttributeRequest
 */
export interface AttributeRequest {
    /**
     * Attribute name.
     * @type {string}
     * @memberof AttributeRequest
     */
    'name'?: string;
    /**
     * Operation to perform on attribute.
     * @type {string}
     * @memberof AttributeRequest
     */
    'op'?: string;
    /**
     * Value of attribute.
     * @type {string}
     * @memberof AttributeRequest
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface AuthUser
 */
export interface AuthUser {
    /**
     * Tenant name.
     * @type {string}
     * @memberof AuthUser
     */
    'tenant'?: string;
    /**
     * Identity ID.
     * @type {string}
     * @memberof AuthUser
     */
    'id'?: string;
    /**
     * Identity\'s unique identitifier.
     * @type {string}
     * @memberof AuthUser
     */
    'uid'?: string;
    /**
     * ID of the auth profile associated with the auth user.
     * @type {string}
     * @memberof AuthUser
     */
    'profile'?: string;
    /**
     * Auth user\'s employee number.
     * @type {string}
     * @memberof AuthUser
     */
    'identificationNumber'?: string;
    /**
     * Auth user\'s email.
     * @type {string}
     * @memberof AuthUser
     */
    'email'?: string;
    /**
     * Auth user\'s phone number.
     * @type {string}
     * @memberof AuthUser
     */
    'phone'?: string;
    /**
     * Auth user\'s work phone number.
     * @type {string}
     * @memberof AuthUser
     */
    'workPhone'?: string;
    /**
     * Auth user\'s personal email.
     * @type {string}
     * @memberof AuthUser
     */
    'personalEmail'?: string;
    /**
     * Auth user\'s first name.
     * @type {string}
     * @memberof AuthUser
     */
    'firstname'?: string;
    /**
     * Auth user\'s last name.
     * @type {string}
     * @memberof AuthUser
     */
    'lastname'?: string;
    /**
     * Auth user\'s name in displayed format.
     * @type {string}
     * @memberof AuthUser
     */
    'displayName'?: string;
    /**
     * Auth user\'s alias.
     * @type {string}
     * @memberof AuthUser
     */
    'alias'?: string;
    /**
     * Date of last password change.
     * @type {string}
     * @memberof AuthUser
     */
    'lastPasswordChangeDate'?: string;
    /**
     * Timestamp of the last login (long type value).
     * @type {number}
     * @memberof AuthUser
     */
    'lastLoginTimestamp'?: number;
    /**
     * Timestamp of the current login (long type value).
     * @type {number}
     * @memberof AuthUser
     */
    'currentLoginTimestamp'?: number;
    /**
     * Array of the auth user\'s capabilities.
     * @type {Array<string>}
     * @memberof AuthUser
     */
    'capabilities'?: Array<AuthUserCapabilitiesEnum>;
}

export const AuthUserCapabilitiesEnum = {
    CertAdmin: 'CERT_ADMIN',
    CloudGovAdmin: 'CLOUD_GOV_ADMIN',
    CloudGovUser: 'CLOUD_GOV_USER',
    Helpdesk: 'HELPDESK',
    OrgAdmin: 'ORG_ADMIN',
    ReportAdmin: 'REPORT_ADMIN',
    RoleAdmin: 'ROLE_ADMIN',
    RoleSubadmin: 'ROLE_SUBADMIN',
    SaasManagementAdmin: 'SAAS_MANAGEMENT_ADMIN',
    SaasManagementReader: 'SAAS_MANAGEMENT_READER',
    SourceAdmin: 'SOURCE_ADMIN',
    SourceSubadmin: 'SOURCE_SUBADMIN',
    DasuiAdministrator: 'das:ui-administrator',
    DasuiComplianceManager: 'das:ui-compliance_manager',
    DasuiAuditor: 'das:ui-auditor',
    DasuiDataScope: 'das:ui-data-scope',
    SpaicDashboardRead: 'sp:aic-dashboard-read',
    SpaicDashboardWrite: 'sp:aic-dashboard-write',
    SpuiConfigHubAdmin: 'sp:ui-config-hub-admin',
    SpuiConfigHubBackupAdmin: 'sp:ui-config-hub-backup-admin',
    SpuiConfigHubRead: 'sp:ui-config-hub-read'
} as const;

export type AuthUserCapabilitiesEnum = typeof AuthUserCapabilitiesEnum[keyof typeof AuthUserCapabilitiesEnum];

/**
 * 
 * @export
 * @interface Base64Decode
 */
export interface Base64Decode {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Base64Decode
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Base64Decode
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Base64Encode
 */
export interface Base64Encode {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Base64Encode
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Base64Encode
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BaseAccess
 */
export interface BaseAccess {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof BaseAccess
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof BaseAccess
     */
    'name'?: string;
    /**
     * Access item\'s description.
     * @type {string}
     * @memberof BaseAccess
     */
    'description'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof BaseAccess
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof BaseAccess
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof BaseAccess
     */
    'synced'?: string | null;
    /**
     * Indicates whether the access item is currently enabled.
     * @type {boolean}
     * @memberof BaseAccess
     */
    'enabled'?: boolean;
    /**
     * Indicates whether the access item can be requested.
     * @type {boolean}
     * @memberof BaseAccess
     */
    'requestable'?: boolean;
    /**
     * Indicates whether comments are required for requests to access the item.
     * @type {boolean}
     * @memberof BaseAccess
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {BaseAccessAllOfOwner}
     * @memberof BaseAccess
     */
    'owner'?: BaseAccessAllOfOwner;
}
/**
 * 
 * @export
 * @interface BaseAccessAllOf
 */
export interface BaseAccessAllOf {
    /**
     * Access item\'s description.
     * @type {string}
     * @memberof BaseAccessAllOf
     */
    'description'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof BaseAccessAllOf
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof BaseAccessAllOf
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof BaseAccessAllOf
     */
    'synced'?: string | null;
    /**
     * Indicates whether the access item is currently enabled.
     * @type {boolean}
     * @memberof BaseAccessAllOf
     */
    'enabled'?: boolean;
    /**
     * Indicates whether the access item can be requested.
     * @type {boolean}
     * @memberof BaseAccessAllOf
     */
    'requestable'?: boolean;
    /**
     * Indicates whether comments are required for requests to access the item.
     * @type {boolean}
     * @memberof BaseAccessAllOf
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {BaseAccessAllOfOwner}
     * @memberof BaseAccessAllOf
     */
    'owner'?: BaseAccessAllOfOwner;
}
/**
 * Owner\'s identity.
 * @export
 * @interface BaseAccessAllOfOwner
 */
export interface BaseAccessAllOfOwner {
    /**
     * Owner\'s DTO type.
     * @type {string}
     * @memberof BaseAccessAllOfOwner
     */
    'type'?: BaseAccessAllOfOwnerTypeEnum;
    /**
     * Owner\'s identity ID.
     * @type {string}
     * @memberof BaseAccessAllOfOwner
     */
    'id'?: string;
    /**
     * Owner\'s display name.
     * @type {string}
     * @memberof BaseAccessAllOfOwner
     */
    'name'?: string;
    /**
     * Owner\'s email.
     * @type {string}
     * @memberof BaseAccessAllOfOwner
     */
    'email'?: string;
}

export const BaseAccessAllOfOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type BaseAccessAllOfOwnerTypeEnum = typeof BaseAccessAllOfOwnerTypeEnum[keyof typeof BaseAccessAllOfOwnerTypeEnum];

/**
 * 
 * @export
 * @interface BaseAccessProfile
 */
export interface BaseAccessProfile {
    /**
     * Access profile\'s unique ID.
     * @type {string}
     * @memberof BaseAccessProfile
     */
    'id'?: string;
    /**
     * Access profile\'s display name.
     * @type {string}
     * @memberof BaseAccessProfile
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface BaseAccount
 */
export interface BaseAccount {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof BaseAccount
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof BaseAccount
     */
    'name'?: string;
    /**
     * Account ID.
     * @type {string}
     * @memberof BaseAccount
     */
    'accountId'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof BaseAccount
     */
    'source'?: AccountSource;
    /**
     * Indicates whether the account is disabled.
     * @type {boolean}
     * @memberof BaseAccount
     */
    'disabled'?: boolean;
    /**
     * Indicates whether the account is locked.
     * @type {boolean}
     * @memberof BaseAccount
     */
    'locked'?: boolean;
    /**
     * Indicates whether the account is privileged.
     * @type {boolean}
     * @memberof BaseAccount
     */
    'privileged'?: boolean;
    /**
     * Indicates whether the account has been manually correlated to an identity.
     * @type {boolean}
     * @memberof BaseAccount
     */
    'manuallyCorrelated'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccount
     */
    'passwordLastSet'?: string | null;
    /**
     * Map or dictionary of key/value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof BaseAccount
     */
    'entitlementAttributes'?: { [key: string]: any; } | null;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof BaseAccount
     */
    'created'?: string | null;
}
/**
 * 
 * @export
 * @interface BaseAccountAllOf
 */
export interface BaseAccountAllOf {
    /**
     * Account ID.
     * @type {string}
     * @memberof BaseAccountAllOf
     */
    'accountId'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof BaseAccountAllOf
     */
    'source'?: AccountSource;
    /**
     * Indicates whether the account is disabled.
     * @type {boolean}
     * @memberof BaseAccountAllOf
     */
    'disabled'?: boolean;
    /**
     * Indicates whether the account is locked.
     * @type {boolean}
     * @memberof BaseAccountAllOf
     */
    'locked'?: boolean;
    /**
     * Indicates whether the account is privileged.
     * @type {boolean}
     * @memberof BaseAccountAllOf
     */
    'privileged'?: boolean;
    /**
     * Indicates whether the account has been manually correlated to an identity.
     * @type {boolean}
     * @memberof BaseAccountAllOf
     */
    'manuallyCorrelated'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccountAllOf
     */
    'passwordLastSet'?: string | null;
    /**
     * Map or dictionary of key/value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof BaseAccountAllOf
     */
    'entitlementAttributes'?: { [key: string]: any; } | null;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof BaseAccountAllOf
     */
    'created'?: string | null;
}
/**
 * 
 * @export
 * @interface BaseCommonDto
 */
export interface BaseCommonDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface BaseDocument
 */
export interface BaseDocument {
    /**
     * 
     * @type {string}
     * @memberof BaseDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BaseDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof BaseDocument
     */
    '_type': DocumentType;
}
/**
 * 
 * @export
 * @interface BaseEntitlement
 */
export interface BaseEntitlement {
    /**
     * Indicates whether the entitlement has permissions.
     * @type {boolean}
     * @memberof BaseEntitlement
     */
    'hasPermissions'?: boolean;
    /**
     * Entitlement\'s description.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'description'?: string;
    /**
     * Entitlement attribute\'s name.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'attribute'?: string;
    /**
     * Entitlement\'s value.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'value'?: string;
    /**
     * Entitlement\'s schema.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'schema'?: string;
    /**
     * Indicates whether the entitlement is privileged.
     * @type {boolean}
     * @memberof BaseEntitlement
     */
    'privileged'?: boolean;
    /**
     * Entitlement\'s ID.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'id'?: string;
    /**
     * Entitlement\'s name.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface BaseReferenceDto
 */
export interface BaseReferenceDto {
    /**
     * 
     * @type {DtoType}
     * @memberof BaseReferenceDto
     */
    'type'?: DtoType;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof BaseReferenceDto
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof BaseReferenceDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface BaseSegment
 */
export interface BaseSegment {
    /**
     * Segment\'s unique ID.
     * @type {string}
     * @memberof BaseSegment
     */
    'id'?: string;
    /**
     * Segment\'s display name.
     * @type {string}
     * @memberof BaseSegment
     */
    'name'?: string;
}
/**
 * Before Provisioning Rule.
 * @export
 * @interface BeforeProvisioningRuleDto
 */
export interface BeforeProvisioningRuleDto {
    /**
     * Before Provisioning Rule DTO type.
     * @type {string}
     * @memberof BeforeProvisioningRuleDto
     */
    'type'?: BeforeProvisioningRuleDtoTypeEnum;
    /**
     * Before Provisioning Rule ID.
     * @type {string}
     * @memberof BeforeProvisioningRuleDto
     */
    'id'?: string;
    /**
     * Rule display name.
     * @type {string}
     * @memberof BeforeProvisioningRuleDto
     */
    'name'?: string;
}

export const BeforeProvisioningRuleDtoTypeEnum = {
    Rule: 'RULE'
} as const;

export type BeforeProvisioningRuleDtoTypeEnum = typeof BeforeProvisioningRuleDtoTypeEnum[keyof typeof BeforeProvisioningRuleDtoTypeEnum];

/**
 * 
 * @export
 * @interface Bound
 */
export interface Bound {
    /**
     * The value of the range\'s endpoint.
     * @type {string}
     * @memberof Bound
     */
    'value': string;
    /**
     * Indicates if the endpoint is included in the range.
     * @type {boolean}
     * @memberof Bound
     */
    'inclusive'?: boolean;
}
/**
 * 
 * @export
 * @interface BrandingItem
 */
export interface BrandingItem {
    /**
     * name of branding item
     * @type {string}
     * @memberof BrandingItem
     */
    'name'?: string;
    /**
     * product name
     * @type {string}
     * @memberof BrandingItem
     */
    'productName'?: string | null;
    /**
     * hex value of color for action button
     * @type {string}
     * @memberof BrandingItem
     */
    'actionButtonColor'?: string | null;
    /**
     * hex value of color for link
     * @type {string}
     * @memberof BrandingItem
     */
    'activeLinkColor'?: string | null;
    /**
     * hex value of color for navigation bar
     * @type {string}
     * @memberof BrandingItem
     */
    'navigationColor'?: string | null;
    /**
     * email from address
     * @type {string}
     * @memberof BrandingItem
     */
    'emailFromAddress'?: string | null;
    /**
     * url to standard logo
     * @type {string}
     * @memberof BrandingItem
     */
    'standardLogoURL'?: string | null;
    /**
     * login information message
     * @type {string}
     * @memberof BrandingItem
     */
    'loginInformationalMessage'?: string | null;
}
/**
 * 
 * @export
 * @interface BrandingItemCreate
 */
export interface BrandingItemCreate {
    /**
     * name of branding item
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'name': string;
    /**
     * product name
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'productName': string | null;
    /**
     * hex value of color for action button
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'actionButtonColor'?: string;
    /**
     * hex value of color for link
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'activeLinkColor'?: string;
    /**
     * hex value of color for navigation bar
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'navigationColor'?: string;
    /**
     * email from address
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'emailFromAddress'?: string;
    /**
     * login information message
     * @type {string}
     * @memberof BrandingItemCreate
     */
    'loginInformationalMessage'?: string;
    /**
     * png file with logo
     * @type {any}
     * @memberof BrandingItemCreate
     */
    'fileStandard'?: any;
}
/**
 * The bucket to group the results of the aggregation query by.
 * @export
 * @interface BucketAggregation
 */
export interface BucketAggregation {
    /**
     * The name of the bucket aggregate to be included in the result.
     * @type {string}
     * @memberof BucketAggregation
     */
    'name': string;
    /**
     * 
     * @type {BucketType}
     * @memberof BucketAggregation
     */
    'type'?: BucketType;
    /**
     * The field to bucket on. Prefix the field name with \'@\' to reference a nested object.
     * @type {string}
     * @memberof BucketAggregation
     */
    'field': string;
    /**
     * Maximum number of buckets to include.
     * @type {number}
     * @memberof BucketAggregation
     */
    'size'?: number;
    /**
     * Minimum number of documents a bucket should have.
     * @type {number}
     * @memberof BucketAggregation
     */
    'minDocCount'?: number;
}
/**
 * Enum representing the currently supported bucket aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const BucketType = {
    Terms: 'TERMS'
} as const;

export type BucketType = typeof BucketType[keyof typeof BucketType];


/**
 * 
 * @export
 * @interface BulkTaggedObject
 */
export interface BulkTaggedObject {
    /**
     * 
     * @type {Array<TaggedObjectDto>}
     * @memberof BulkTaggedObject
     */
    'objectRefs'?: Array<TaggedObjectDto>;
    /**
     * Label to be applied to an Object
     * @type {Array<string>}
     * @memberof BulkTaggedObject
     */
    'tags'?: Array<string>;
    /**
     * If APPEND, tags are appended to the list of tags for the object. A 400 error is returned if this would add duplicate tags to the object.  If MERGE, tags are merged with the existing tags. Duplicate tags are silently ignored.
     * @type {string}
     * @memberof BulkTaggedObject
     */
    'operation'?: BulkTaggedObjectOperationEnum;
}

export const BulkTaggedObjectOperationEnum = {
    Append: 'APPEND',
    Merge: 'MERGE'
} as const;

export type BulkTaggedObjectOperationEnum = typeof BulkTaggedObjectOperationEnum[keyof typeof BulkTaggedObjectOperationEnum];

/**
 * 
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     * Id of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'id'?: string;
    /**
     * The campaign name. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof Campaign
     */
    'name': string;
    /**
     * The campaign description. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof Campaign
     */
    'description': string;
    /**
     * The campaign\'s completion deadline.  This date must be in the future in order to activate the campaign.  If you try to activate a campaign with a deadline of today or in the past, you will receive a 400 error response.
     * @type {string}
     * @memberof Campaign
     */
    'deadline'?: string;
    /**
     * The type of campaign. Could be extended in the future.
     * @type {string}
     * @memberof Campaign
     */
    'type': CampaignTypeEnum;
    /**
     * Enables email notification for this campaign
     * @type {boolean}
     * @memberof Campaign
     */
    'emailNotificationEnabled'?: boolean;
    /**
     * Allows auto revoke for this campaign
     * @type {boolean}
     * @memberof Campaign
     */
    'autoRevokeAllowed'?: boolean;
    /**
     * Enables IAI for this campaign. Accepts true even if the IAI product feature is off. If IAI is turned off then campaigns generated from this template will indicate false. The real value will then be returned if IAI is ever enabled for the org in the future.
     * @type {boolean}
     * @memberof Campaign
     */
    'recommendationsEnabled'?: boolean;
    /**
     * The campaign\'s current status.
     * @type {string}
     * @memberof Campaign
     */
    'status'?: CampaignStatusEnum;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {object}
     * @memberof Campaign
     */
    'correlatedStatus'?: CampaignCorrelatedStatusEnum;
    /**
     * Created time of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'created'?: string;
    /**
     * The total number of certifications in this campaign.
     * @type {number}
     * @memberof Campaign
     */
    'totalCertifications'?: number;
    /**
     * The number of completed certifications in this campaign.
     * @type {number}
     * @memberof Campaign
     */
    'completedCertifications'?: number;
    /**
     * A list of errors and warnings that have accumulated.
     * @type {Array<CampaignAlert>}
     * @memberof Campaign
     */
    'alerts'?: Array<CampaignAlert>;
    /**
     * Modified time of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'modified'?: string;
    /**
     * 
     * @type {CampaignAllOfFilter}
     * @memberof Campaign
     */
    'filter'?: CampaignAllOfFilter;
    /**
     * Determines if comments on sunset date changes are required.
     * @type {boolean}
     * @memberof Campaign
     */
    'sunsetCommentsRequired'?: boolean;
    /**
     * 
     * @type {CampaignAllOfSourceOwnerCampaignInfo}
     * @memberof Campaign
     */
    'sourceOwnerCampaignInfo'?: CampaignAllOfSourceOwnerCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfSearchCampaignInfo}
     * @memberof Campaign
     */
    'searchCampaignInfo'?: CampaignAllOfSearchCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfRoleCompositionCampaignInfo}
     * @memberof Campaign
     */
    'roleCompositionCampaignInfo'?: CampaignAllOfRoleCompositionCampaignInfo;
    /**
     * A list of sources in the campaign that contain \\\"orphan entitlements\\\" (entitlements without a corresponding Managed Attribute). An empty list indicates the campaign has no orphan entitlements. Null indicates there may be unknown orphan entitlements in the campaign (the campaign was created before this feature was implemented).
     * @type {Array<CampaignAllOfSourcesWithOrphanEntitlements>}
     * @memberof Campaign
     */
    'sourcesWithOrphanEntitlements'?: Array<CampaignAllOfSourcesWithOrphanEntitlements>;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof Campaign
     */
    'mandatoryCommentRequirement'?: CampaignMandatoryCommentRequirementEnum;
}

export const CampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
} as const;

export type CampaignTypeEnum = typeof CampaignTypeEnum[keyof typeof CampaignTypeEnum];
export const CampaignStatusEnum = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
} as const;

export type CampaignStatusEnum = typeof CampaignStatusEnum[keyof typeof CampaignStatusEnum];
export const CampaignCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type CampaignCorrelatedStatusEnum = typeof CampaignCorrelatedStatusEnum[keyof typeof CampaignCorrelatedStatusEnum];
export const CampaignMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type CampaignMandatoryCommentRequirementEnum = typeof CampaignMandatoryCommentRequirementEnum[keyof typeof CampaignMandatoryCommentRequirementEnum];

/**
 * 
 * @export
 * @interface CampaignAlert
 */
export interface CampaignAlert {
    /**
     * Denotes the level of the message
     * @type {string}
     * @memberof CampaignAlert
     */
    'level'?: CampaignAlertLevelEnum;
    /**
     * 
     * @type {Array<ErrorMessageDto>}
     * @memberof CampaignAlert
     */
    'localizations'?: Array<ErrorMessageDto>;
}

export const CampaignAlertLevelEnum = {
    Error: 'ERROR',
    Warn: 'WARN',
    Info: 'INFO'
} as const;

export type CampaignAlertLevelEnum = typeof CampaignAlertLevelEnum[keyof typeof CampaignAlertLevelEnum];

/**
 * 
 * @export
 * @interface CampaignAllOf
 */
export interface CampaignAllOf {
    /**
     * Modified time of the campaign
     * @type {string}
     * @memberof CampaignAllOf
     */
    'modified'?: string;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {object}
     * @memberof CampaignAllOf
     */
    'correlatedStatus'?: CampaignAllOfCorrelatedStatusEnum;
    /**
     * 
     * @type {CampaignAllOfFilter}
     * @memberof CampaignAllOf
     */
    'filter'?: CampaignAllOfFilter;
    /**
     * Determines if comments on sunset date changes are required.
     * @type {boolean}
     * @memberof CampaignAllOf
     */
    'sunsetCommentsRequired'?: boolean;
    /**
     * 
     * @type {CampaignAllOfSourceOwnerCampaignInfo}
     * @memberof CampaignAllOf
     */
    'sourceOwnerCampaignInfo'?: CampaignAllOfSourceOwnerCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfSearchCampaignInfo}
     * @memberof CampaignAllOf
     */
    'searchCampaignInfo'?: CampaignAllOfSearchCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfRoleCompositionCampaignInfo}
     * @memberof CampaignAllOf
     */
    'roleCompositionCampaignInfo'?: CampaignAllOfRoleCompositionCampaignInfo;
    /**
     * A list of sources in the campaign that contain \\\"orphan entitlements\\\" (entitlements without a corresponding Managed Attribute). An empty list indicates the campaign has no orphan entitlements. Null indicates there may be unknown orphan entitlements in the campaign (the campaign was created before this feature was implemented).
     * @type {Array<CampaignAllOfSourcesWithOrphanEntitlements>}
     * @memberof CampaignAllOf
     */
    'sourcesWithOrphanEntitlements'?: Array<CampaignAllOfSourcesWithOrphanEntitlements>;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof CampaignAllOf
     */
    'mandatoryCommentRequirement'?: CampaignAllOfMandatoryCommentRequirementEnum;
}

export const CampaignAllOfCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type CampaignAllOfCorrelatedStatusEnum = typeof CampaignAllOfCorrelatedStatusEnum[keyof typeof CampaignAllOfCorrelatedStatusEnum];
export const CampaignAllOfMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type CampaignAllOfMandatoryCommentRequirementEnum = typeof CampaignAllOfMandatoryCommentRequirementEnum[keyof typeof CampaignAllOfMandatoryCommentRequirementEnum];

/**
 * Determines which items will be included in this campaign. The default campaign filter is used if this field is left blank.
 * @export
 * @interface CampaignAllOfFilter
 */
export interface CampaignAllOfFilter {
    /**
     * The ID of whatever type of filter is being used.
     * @type {string}
     * @memberof CampaignAllOfFilter
     */
    'id'?: string;
    /**
     * Type of the filter
     * @type {string}
     * @memberof CampaignAllOfFilter
     */
    'type'?: CampaignAllOfFilterTypeEnum;
    /**
     * Name of the filter
     * @type {string}
     * @memberof CampaignAllOfFilter
     */
    'name'?: string;
}

export const CampaignAllOfFilterTypeEnum = {
    CampaignFilter: 'CAMPAIGN_FILTER',
    Rule: 'RULE'
} as const;

export type CampaignAllOfFilterTypeEnum = typeof CampaignAllOfFilterTypeEnum[keyof typeof CampaignAllOfFilterTypeEnum];

/**
 * Optional configuration options for role composition campaigns.
 * @export
 * @interface CampaignAllOfRoleCompositionCampaignInfo
 */
export interface CampaignAllOfRoleCompositionCampaignInfo {
    /**
     * 
     * @type {CampaignAllOfSearchCampaignInfoReviewer}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'reviewer'?: CampaignAllOfSearchCampaignInfoReviewer;
    /**
     * Optional list of roles to include in this campaign. Only one of `roleIds` and `query` may be set; if neither are set, all roles are included.
     * @type {Array<string>}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'roleIds'?: Array<string>;
    /**
     * 
     * @type {CampaignAllOfRoleCompositionCampaignInfoRemediatorRef}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'remediatorRef': CampaignAllOfRoleCompositionCampaignInfoRemediatorRef;
    /**
     * Optional search query to scope this campaign to a set of roles. Only one of `roleIds` and `query` may be set; if neither are set, all roles are included.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'query'?: string;
    /**
     * Describes this role composition campaign. Intended for storing the query used, and possibly the number of roles selected/available.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'description'?: string;
}
/**
 * This determines who remediation tasks will be assigned to. Remediation tasks are created for each revoke decision on items in the campaign. The only legal remediator type is \'IDENTITY\', and the chosen identity must be a Role Admin or Org Admin.
 * @export
 * @interface CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
 */
export interface CampaignAllOfRoleCompositionCampaignInfoRemediatorRef {
    /**
     * Legal Remediator Type
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
     */
    'type': CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum;
    /**
     * The ID of the remediator.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
     */
    'id': string;
    /**
     * The name of the remediator.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
     */
    'name'?: string;
}

export const CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum = typeof CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum[keyof typeof CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum];

/**
 * Must be set only if the campaign type is SEARCH.
 * @export
 * @interface CampaignAllOfSearchCampaignInfo
 */
export interface CampaignAllOfSearchCampaignInfo {
    /**
     * The type of search campaign represented.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'type': CampaignAllOfSearchCampaignInfoTypeEnum;
    /**
     * Describes this search campaign. Intended for storing the query used, and possibly the number of identities selected/available.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'description'?: string;
    /**
     * 
     * @type {CampaignAllOfSearchCampaignInfoReviewer}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'reviewer'?: CampaignAllOfSearchCampaignInfoReviewer;
    /**
     * The scope for the campaign. The campaign will cover identities returned by the query and identities that have access items returned by the query. One of `query` or `identityIds` must be set.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'query'?: string;
    /**
     * A direct list of identities to include in this campaign. One of `identityIds` or `query` must be set.
     * @type {Array<string>}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'identityIds'?: Array<string>;
    /**
     * Further reduces the scope of the campaign by excluding identities (from `query` or `identityIds`) that do not have this access.
     * @type {Array<AccessConstraint>}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'accessConstraints'?: Array<AccessConstraint>;
}

export const CampaignAllOfSearchCampaignInfoTypeEnum = {
    Identity: 'IDENTITY',
    Access: 'ACCESS'
} as const;

export type CampaignAllOfSearchCampaignInfoTypeEnum = typeof CampaignAllOfSearchCampaignInfoTypeEnum[keyof typeof CampaignAllOfSearchCampaignInfoTypeEnum];

/**
 * If specified, this identity or governance group will be the reviewer for all certifications in this campaign. The allowed DTO types are IDENTITY and GOVERNANCE_GROUP.
 * @export
 * @interface CampaignAllOfSearchCampaignInfoReviewer
 */
export interface CampaignAllOfSearchCampaignInfoReviewer {
    /**
     * The reviewer\'s DTO type.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfoReviewer
     */
    'type'?: CampaignAllOfSearchCampaignInfoReviewerTypeEnum;
    /**
     * The reviewer\'s ID.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfoReviewer
     */
    'id'?: string;
    /**
     * The reviewer\'s name.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfoReviewer
     */
    'name'?: string;
}

export const CampaignAllOfSearchCampaignInfoReviewerTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type CampaignAllOfSearchCampaignInfoReviewerTypeEnum = typeof CampaignAllOfSearchCampaignInfoReviewerTypeEnum[keyof typeof CampaignAllOfSearchCampaignInfoReviewerTypeEnum];

/**
 * Must be set only if the campaign type is SOURCE_OWNER.
 * @export
 * @interface CampaignAllOfSourceOwnerCampaignInfo
 */
export interface CampaignAllOfSourceOwnerCampaignInfo {
    /**
     * The list of sources to be included in the campaign.
     * @type {Array<string>}
     * @memberof CampaignAllOfSourceOwnerCampaignInfo
     */
    'sourceIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CampaignAllOfSourcesWithOrphanEntitlements
 */
export interface CampaignAllOfSourcesWithOrphanEntitlements {
    /**
     * Id of the source
     * @type {string}
     * @memberof CampaignAllOfSourcesWithOrphanEntitlements
     */
    'id'?: string;
    /**
     * Type
     * @type {string}
     * @memberof CampaignAllOfSourcesWithOrphanEntitlements
     */
    'type'?: CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum;
    /**
     * Name of the source
     * @type {string}
     * @memberof CampaignAllOfSourcesWithOrphanEntitlements
     */
    'name'?: string;
}

export const CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum = {
    Source: 'SOURCE'
} as const;

export type CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum = typeof CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum[keyof typeof CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum];

/**
 * 
 * @export
 * @interface CampaignCompleteOptions
 */
export interface CampaignCompleteOptions {
    /**
     * Determines whether to auto-approve(APPROVE) or auto-revoke(REVOKE) upon campaign completion.
     * @type {string}
     * @memberof CampaignCompleteOptions
     */
    'autoCompleteAction'?: CampaignCompleteOptionsAutoCompleteActionEnum;
}

export const CampaignCompleteOptionsAutoCompleteActionEnum = {
    Approve: 'APPROVE',
    Revoke: 'REVOKE'
} as const;

export type CampaignCompleteOptionsAutoCompleteActionEnum = typeof CampaignCompleteOptionsAutoCompleteActionEnum[keyof typeof CampaignCompleteOptionsAutoCompleteActionEnum];

/**
 * Campaign Filter Details
 * @export
 * @interface CampaignFilterDetails
 */
export interface CampaignFilterDetails {
    /**
     * Id of the campaign filter
     * @type {string}
     * @memberof CampaignFilterDetails
     */
    'id'?: string;
    /**
     * This is campaign filter\'s name.
     * @type {string}
     * @memberof CampaignFilterDetails
     */
    'name': string;
    /**
     * This is campaign filter\'s description.
     * @type {string}
     * @memberof CampaignFilterDetails
     */
    'description': string;
    /**
     * The owner of this filter. This field is automatically populated at creation time with the current user.
     * @type {string}
     * @memberof CampaignFilterDetails
     */
    'owner': string | null;
    /**
     * The mode/type of Filter, where it is of INCLUSION or EXCLUSION type. INCLUSION type will include the data in generated campaign  as per specified in criteria, whereas EXCLUSION type will exclude the the data in generated campaign as per specified in criteria.
     * @type {object}
     * @memberof CampaignFilterDetails
     */
    'mode': CampaignFilterDetailsModeEnum;
    /**
     * List of criteria.
     * @type {Array<CampaignFilterDetailsCriteriaListInner>}
     * @memberof CampaignFilterDetails
     */
    'criteriaList'?: Array<CampaignFilterDetailsCriteriaListInner>;
}

export const CampaignFilterDetailsModeEnum = {
    Inclusion: 'INCLUSION',
    Exclusion: 'EXCLUSION'
} as const;

export type CampaignFilterDetailsModeEnum = typeof CampaignFilterDetailsModeEnum[keyof typeof CampaignFilterDetailsModeEnum];

/**
 * 
 * @export
 * @interface CampaignFilterDetailsCriteriaListInner
 */
export interface CampaignFilterDetailsCriteriaListInner {
    /**
     * 
     * @type {CriteriaType}
     * @memberof CampaignFilterDetailsCriteriaListInner
     */
    'type': CriteriaType;
    /**
     * 
     * @type {Operation & object}
     * @memberof CampaignFilterDetailsCriteriaListInner
     */
    'operation': Operation & object;
    /**
     * The specified key from the Type of criteria.
     * @type {string}
     * @memberof CampaignFilterDetailsCriteriaListInner
     */
    'property': string | null;
    /**
     * The value for the specified key from the Type of Criteria
     * @type {string}
     * @memberof CampaignFilterDetailsCriteriaListInner
     */
    'value': string | null;
}
/**
 * 
 * @export
 * @interface CampaignReference
 */
export interface CampaignReference {
    /**
     * The unique ID of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'id': string;
    /**
     * The name of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'name': string;
    /**
     * The type of object that is being referenced.
     * @type {string}
     * @memberof CampaignReference
     */
    'type': CampaignReferenceTypeEnum;
    /**
     * The type of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'campaignType': CampaignReferenceCampaignTypeEnum;
    /**
     * The description of the campaign set by the admin who created it.
     * @type {string}
     * @memberof CampaignReference
     */
    'description': string | null;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {object}
     * @memberof CampaignReference
     */
    'correlatedStatus': CampaignReferenceCorrelatedStatusEnum;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof CampaignReference
     */
    'mandatoryCommentRequirement': CampaignReferenceMandatoryCommentRequirementEnum;
}

export const CampaignReferenceTypeEnum = {
    Campaign: 'CAMPAIGN'
} as const;

export type CampaignReferenceTypeEnum = typeof CampaignReferenceTypeEnum[keyof typeof CampaignReferenceTypeEnum];
export const CampaignReferenceCampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH'
} as const;

export type CampaignReferenceCampaignTypeEnum = typeof CampaignReferenceCampaignTypeEnum[keyof typeof CampaignReferenceCampaignTypeEnum];
export const CampaignReferenceCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type CampaignReferenceCorrelatedStatusEnum = typeof CampaignReferenceCorrelatedStatusEnum[keyof typeof CampaignReferenceCorrelatedStatusEnum];
export const CampaignReferenceMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type CampaignReferenceMandatoryCommentRequirementEnum = typeof CampaignReferenceMandatoryCommentRequirementEnum[keyof typeof CampaignReferenceMandatoryCommentRequirementEnum];

/**
 * 
 * @export
 * @interface CampaignReport
 */
export interface CampaignReport {
    /**
     * SOD policy violation report result DTO type.
     * @type {string}
     * @memberof CampaignReport
     */
    'type'?: CampaignReportTypeEnum;
    /**
     * SOD policy violation report result ID.
     * @type {string}
     * @memberof CampaignReport
     */
    'id'?: string;
    /**
     * Human-readable name of the SOD policy violation report result.
     * @type {string}
     * @memberof CampaignReport
     */
    'name'?: string;
    /**
     * Status of a SOD policy violation report.
     * @type {string}
     * @memberof CampaignReport
     */
    'status'?: CampaignReportStatusEnum;
    /**
     * 
     * @type {ReportType}
     * @memberof CampaignReport
     */
    'reportType': ReportType;
    /**
     * The most recent date and time this report was run
     * @type {string}
     * @memberof CampaignReport
     */
    'lastRunAt'?: string;
}

export const CampaignReportTypeEnum = {
    ReportResult: 'REPORT_RESULT'
} as const;

export type CampaignReportTypeEnum = typeof CampaignReportTypeEnum[keyof typeof CampaignReportTypeEnum];
export const CampaignReportStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
} as const;

export type CampaignReportStatusEnum = typeof CampaignReportStatusEnum[keyof typeof CampaignReportStatusEnum];

/**
 * 
 * @export
 * @interface CampaignReportAllOf
 */
export interface CampaignReportAllOf {
    /**
     * 
     * @type {ReportType}
     * @memberof CampaignReportAllOf
     */
    'reportType'?: ReportType;
    /**
     * The most recent date and time this report was run
     * @type {string}
     * @memberof CampaignReportAllOf
     */
    'lastRunAt'?: string;
}
/**
 * 
 * @export
 * @interface CampaignReportsConfig
 */
export interface CampaignReportsConfig {
    /**
     * list of identity attribute columns
     * @type {Array<string>}
     * @memberof CampaignReportsConfig
     */
    'identityAttributeColumns'?: Array<string> | null;
}
/**
 * Campaign Template
 * @export
 * @interface CampaignTemplate
 */
export interface CampaignTemplate {
    /**
     * Id of the campaign template
     * @type {string}
     * @memberof CampaignTemplate
     */
    'id'?: string;
    /**
     * This template\'s name. Has no bearing on generated campaigns\' names.
     * @type {string}
     * @memberof CampaignTemplate
     */
    'name': string;
    /**
     * This template\'s description. Has no bearing on generated campaigns\' descriptions.
     * @type {string}
     * @memberof CampaignTemplate
     */
    'description': string;
    /**
     * Creation date of Campaign Template
     * @type {string}
     * @memberof CampaignTemplate
     */
    'created': string;
    /**
     * Modification date of Campaign Template
     * @type {string}
     * @memberof CampaignTemplate
     */
    'modified': string;
    /**
     * Indicates if this campaign template has been scheduled.
     * @type {boolean}
     * @memberof CampaignTemplate
     */
    'scheduled'?: boolean;
    /**
     * 
     * @type {CampaignTemplateOwnerRef}
     * @memberof CampaignTemplate
     */
    'ownerRef'?: CampaignTemplateOwnerRef;
    /**
     * The time period during which the campaign should be completed, formatted as an ISO-8601 Duration. When this template generates a campaign, the campaign\'s deadline will be the current date plus this duration. For example, if generation occurred on 2020-01-01 and this field was \"P2W\" (two weeks), the resulting campaign\'s deadline would be 2020-01-15 (the current date plus 14 days).
     * @type {string}
     * @memberof CampaignTemplate
     */
    'deadlineDuration'?: string;
    /**
     * This will hold campaign related information like name, description etc.
     * @type {Campaign}
     * @memberof CampaignTemplate
     */
    'campaign': Campaign;
}
/**
 * The owner of this template, and the owner of campaigns generated from this template via a schedule. This field is automatically populated at creation time with the current user.
 * @export
 * @interface CampaignTemplateOwnerRef
 */
export interface CampaignTemplateOwnerRef {
    /**
     * Id of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRef
     */
    'id'?: string;
    /**
     * Type of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRef
     */
    'type'?: CampaignTemplateOwnerRefTypeEnum;
    /**
     * Name of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRef
     */
    'name'?: string;
    /**
     * Email of the owner
     * @type {string}
     * @memberof CampaignTemplateOwnerRef
     */
    'email'?: string;
}

export const CampaignTemplateOwnerRefTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type CampaignTemplateOwnerRefTypeEnum = typeof CampaignTemplateOwnerRefTypeEnum[keyof typeof CampaignTemplateOwnerRefTypeEnum];

/**
 * 
 * @export
 * @interface CampaignsDeleteRequest
 */
export interface CampaignsDeleteRequest {
    /**
     * The ids of the campaigns to delete
     * @type {Array<string>}
     * @memberof CampaignsDeleteRequest
     */
    'ids'?: Array<string>;
}
/**
 * Request body payload for cancel access request endpoint.
 * @export
 * @interface CancelAccessRequest
 */
export interface CancelAccessRequest {
    /**
     * This refers to the identityRequestId. To successfully cancel an access request, you must provide the identityRequestId.
     * @type {string}
     * @memberof CancelAccessRequest
     */
    'accountActivityId': string;
    /**
     * Reason for cancelling the pending access request.
     * @type {string}
     * @memberof CancelAccessRequest
     */
    'comment': string;
}
/**
 * Provides additional details for a request that has been cancelled.
 * @export
 * @interface CancelledRequestDetails
 */
export interface CancelledRequestDetails {
    /**
     * Comment made by the owner when cancelling the associated request.
     * @type {string}
     * @memberof CancelledRequestDetails
     */
    'comment'?: string;
    /**
     * 
     * @type {OwnerDto}
     * @memberof CancelledRequestDetails
     */
    'owner'?: OwnerDto;
    /**
     * Date comment was added by the owner when cancelling the associated request.
     * @type {string}
     * @memberof CancelledRequestDetails
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface Certification
 */
export interface Certification {
    /**
     * id of the certification
     * @type {string}
     * @memberof Certification
     */
    'id'?: string;
    /**
     * name of the certification
     * @type {string}
     * @memberof Certification
     */
    'name'?: string;
    /**
     * 
     * @type {CampaignReference}
     * @memberof Certification
     */
    'campaign'?: CampaignReference;
    /**
     * Have all decisions been made?
     * @type {boolean}
     * @memberof Certification
     */
    'completed'?: boolean;
    /**
     * The number of identities for whom all decisions have been made and are complete.
     * @type {number}
     * @memberof Certification
     */
    'identitiesCompleted'?: number;
    /**
     * The total number of identities in the Certification, both complete and incomplete.
     * @type {number}
     * @memberof Certification
     */
    'identitiesTotal'?: number;
    /**
     * created date
     * @type {string}
     * @memberof Certification
     */
    'created'?: string;
    /**
     * modified date
     * @type {string}
     * @memberof Certification
     */
    'modified'?: string;
    /**
     * The number of approve/revoke/acknowledge decisions that have been made.
     * @type {number}
     * @memberof Certification
     */
    'decisionsMade'?: number;
    /**
     * The total number of approve/revoke/acknowledge decisions.
     * @type {number}
     * @memberof Certification
     */
    'decisionsTotal'?: number;
    /**
     * The due date of the certification.
     * @type {string}
     * @memberof Certification
     */
    'due'?: string;
    /**
     * The date the reviewer signed off on the Certification.
     * @type {string}
     * @memberof Certification
     */
    'signed'?: string | null;
    /**
     * 
     * @type {Reviewer}
     * @memberof Certification
     */
    'reviewer'?: Reviewer;
    /**
     * 
     * @type {Reassignment}
     * @memberof Certification
     */
    'reassignment'?: Reassignment | null;
    /**
     * Identifies if the certification has an error
     * @type {boolean}
     * @memberof Certification
     */
    'hasErrors'?: boolean;
    /**
     * Description of the certification error
     * @type {string}
     * @memberof Certification
     */
    'errorMessage'?: string | null;
    /**
     * 
     * @type {CertificationPhase}
     * @memberof Certification
     */
    'phase'?: CertificationPhase;
}
/**
 * The decision to approve or revoke the review item
 * @export
 * @enum {string}
 */

export const CertificationDecision = {
    Approve: 'APPROVE',
    Revoke: 'REVOKE'
} as const;

export type CertificationDecision = typeof CertificationDecision[keyof typeof CertificationDecision];


/**
 * 
 * @export
 * @interface CertificationIdentitySummary
 */
export interface CertificationIdentitySummary {
    /**
     * The ID of the identity summary
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'id'?: string;
    /**
     * Name of the linked identity
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'name'?: string;
    /**
     * The ID of the identity being certified
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'identityId'?: string;
    /**
     * Indicates whether the review items for the linked identity\'s certification have been completed
     * @type {boolean}
     * @memberof CertificationIdentitySummary
     */
    'completed'?: boolean;
}
/**
 * The current phase of the campaign. * `STAGED`: The campaign is waiting to be activated. * `ACTIVE`: The campaign is active. * `SIGNED`: The reviewer has signed off on the campaign, and it is considered complete. 
 * @export
 * @enum {string}
 */

export const CertificationPhase = {
    Staged: 'STAGED',
    Active: 'ACTIVE',
    Signed: 'SIGNED'
} as const;

export type CertificationPhase = typeof CertificationPhase[keyof typeof CertificationPhase];


/**
 * 
 * @export
 * @interface CertificationReference
 */
export interface CertificationReference {
    /**
     * The id of the certification.
     * @type {string}
     * @memberof CertificationReference
     */
    'id'?: string;
    /**
     * The name of the certification.
     * @type {string}
     * @memberof CertificationReference
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CertificationReference
     */
    'type'?: CertificationReferenceTypeEnum;
    /**
     * 
     * @type {Reviewer}
     * @memberof CertificationReference
     */
    'reviewer'?: Reviewer;
}

export const CertificationReferenceTypeEnum = {
    Certification: 'CERTIFICATION'
} as const;

export type CertificationReferenceTypeEnum = typeof CertificationReferenceTypeEnum[keyof typeof CertificationReferenceTypeEnum];

/**
 * 
 * @export
 * @interface CertificationTask
 */
export interface CertificationTask {
    /**
     * The ID of the certification task.
     * @type {string}
     * @memberof CertificationTask
     */
    'id'?: string;
    /**
     * The type of the certification task. More values may be added in the future.
     * @type {string}
     * @memberof CertificationTask
     */
    'type'?: CertificationTaskTypeEnum;
    /**
     * The type of item that is being operated on by this task whose ID is stored in the targetId field.
     * @type {string}
     * @memberof CertificationTask
     */
    'targetType'?: CertificationTaskTargetTypeEnum;
    /**
     * The ID of the item being operated on by this task.
     * @type {string}
     * @memberof CertificationTask
     */
    'targetId'?: string;
    /**
     * The status of the task.
     * @type {string}
     * @memberof CertificationTask
     */
    'status'?: CertificationTaskStatusEnum;
    /**
     * 
     * @type {Array<ErrorMessageDto>}
     * @memberof CertificationTask
     */
    'errors'?: Array<ErrorMessageDto>;
    /**
     * Reassignment trails that lead to self certification identity
     * @type {Array<ReassignmentTrailDTO>}
     * @memberof CertificationTask
     */
    'reassignmentTrailDTOs'?: Array<ReassignmentTrailDTO>;
    /**
     * The date and time on which this task was created.
     * @type {string}
     * @memberof CertificationTask
     */
    'created'?: string;
}

export const CertificationTaskTypeEnum = {
    Reassign: 'REASSIGN',
    AdminReassign: 'ADMIN_REASSIGN',
    CompleteCertification: 'COMPLETE_CERTIFICATION',
    FinishCertification: 'FINISH_CERTIFICATION',
    CompleteCampaign: 'COMPLETE_CAMPAIGN',
    ActivateCampaign: 'ACTIVATE_CAMPAIGN',
    CampaignCreate: 'CAMPAIGN_CREATE',
    CampaignDelete: 'CAMPAIGN_DELETE'
} as const;

export type CertificationTaskTypeEnum = typeof CertificationTaskTypeEnum[keyof typeof CertificationTaskTypeEnum];
export const CertificationTaskTargetTypeEnum = {
    Certification: 'CERTIFICATION',
    Campaign: 'CAMPAIGN'
} as const;

export type CertificationTaskTargetTypeEnum = typeof CertificationTaskTargetTypeEnum[keyof typeof CertificationTaskTargetTypeEnum];
export const CertificationTaskStatusEnum = {
    Queued: 'QUEUED',
    InProgress: 'IN_PROGRESS',
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type CertificationTaskStatusEnum = typeof CertificationTaskStatusEnum[keyof typeof CertificationTaskStatusEnum];

/**
 * Client Runtime Logging Configuration
 * @export
 * @interface ClientLogConfiguration
 */
export interface ClientLogConfiguration {
    /**
     * Log configuration\'s client ID
     * @type {string}
     * @memberof ClientLogConfiguration
     */
    'clientId'?: string;
    /**
     * Duration in minutes for log configuration to remain in effect before resetting to defaults
     * @type {number}
     * @memberof ClientLogConfiguration
     */
    'durationMinutes': number;
    /**
     * Expiration date-time of the log configuration request
     * @type {string}
     * @memberof ClientLogConfiguration
     */
    'expiration'?: string;
    /**
     * 
     * @type {StandardLevel}
     * @memberof ClientLogConfiguration
     */
    'rootLevel': StandardLevel;
    /**
     * Mapping of identifiers to Standard Log Level values
     * @type {{ [key: string]: StandardLevel; }}
     * @memberof ClientLogConfiguration
     */
    'logLevels'?: { [key: string]: StandardLevel; };
}
/**
 * Type of an API Client indicating public or confidentials use
 * @export
 * @enum {string}
 */

export const ClientType = {
    Confidential: 'CONFIDENTIAL',
    Public: 'PUBLIC'
} as const;

export type ClientType = typeof ClientType[keyof typeof ClientType];


/**
 * 
 * @export
 * @interface Column
 */
export interface Column {
    /**
     * The name of the field. 
     * @type {string}
     * @memberof Column
     */
    'field': string;
    /**
     * The value of the header. 
     * @type {string}
     * @memberof Column
     */
    'header'?: string;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * Id of the identity making the comment
     * @type {string}
     * @memberof Comment
     */
    'commenterId'?: string;
    /**
     * Human-readable display name of the identity making the comment
     * @type {string}
     * @memberof Comment
     */
    'commenterName'?: string;
    /**
     * Content of the comment
     * @type {string}
     * @memberof Comment
     */
    'body'?: string;
    /**
     * Date and time comment was made
     * @type {string}
     * @memberof Comment
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface CommentDto
 */
export interface CommentDto {
    /**
     * Comment content.
     * @type {string}
     * @memberof CommentDto
     */
    'comment'?: string | null;
    /**
     * Date and time comment was created.
     * @type {string}
     * @memberof CommentDto
     */
    'created'?: string;
    /**
     * 
     * @type {CommentDtoAuthor}
     * @memberof CommentDto
     */
    'author'?: CommentDtoAuthor;
}
/**
 * Author of the comment
 * @export
 * @interface CommentDtoAuthor
 */
export interface CommentDtoAuthor {
    /**
     * The type of object
     * @type {string}
     * @memberof CommentDtoAuthor
     */
    'type'?: CommentDtoAuthorTypeEnum;
    /**
     * The unique ID of the object
     * @type {string}
     * @memberof CommentDtoAuthor
     */
    'id'?: string;
    /**
     * The display name of the object
     * @type {string}
     * @memberof CommentDtoAuthor
     */
    'name'?: string;
}

export const CommentDtoAuthorTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type CommentDtoAuthorTypeEnum = typeof CommentDtoAuthorTypeEnum[keyof typeof CommentDtoAuthorTypeEnum];

/**
 * 
 * @export
 * @interface CompletedApproval
 */
export interface CompletedApproval {
    /**
     * The approval id.
     * @type {string}
     * @memberof CompletedApproval
     */
    'id'?: string;
    /**
     * The name of the approval.
     * @type {string}
     * @memberof CompletedApproval
     */
    'name'?: string;
    /**
     * When the approval was created.
     * @type {string}
     * @memberof CompletedApproval
     */
    'created'?: string;
    /**
     * When the approval was modified last time.
     * @type {string}
     * @memberof CompletedApproval
     */
    'modified'?: string;
    /**
     * When the access-request was created.
     * @type {string}
     * @memberof CompletedApproval
     */
    'requestCreated'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof CompletedApproval
     */
    'requestType'?: AccessRequestType | null;
    /**
     * 
     * @type {AccessItemRequester}
     * @memberof CompletedApproval
     */
    'requester'?: AccessItemRequester;
    /**
     * Identities access was requested for.
     * @type {Array<AccessItemRequestedFor>}
     * @memberof CompletedApproval
     */
    'requestedFor'?: Array<AccessItemRequestedFor>;
    /**
     * 
     * @type {AccessItemReviewedBy}
     * @memberof CompletedApproval
     */
    'reviewedBy'?: AccessItemReviewedBy;
    /**
     * 
     * @type {OwnerDto}
     * @memberof CompletedApproval
     */
    'owner'?: OwnerDto;
    /**
     * 
     * @type {RequestableObjectReference}
     * @memberof CompletedApproval
     */
    'requestedObject'?: RequestableObjectReference;
    /**
     * 
     * @type {CompletedApprovalRequesterComment}
     * @memberof CompletedApproval
     */
    'requesterComment'?: CompletedApprovalRequesterComment;
    /**
     * 
     * @type {CompletedApprovalReviewerComment}
     * @memberof CompletedApproval
     */
    'reviewerComment'?: CompletedApprovalReviewerComment;
    /**
     * The history of the previous reviewers comments.
     * @type {Array<CommentDto>}
     * @memberof CompletedApproval
     */
    'previousReviewersComments'?: Array<CommentDto>;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof CompletedApproval
     */
    'forwardHistory'?: Array<ApprovalForwardHistory>;
    /**
     * When true the rejector has to provide comments when rejecting
     * @type {boolean}
     * @memberof CompletedApproval
     */
    'commentRequiredWhenRejected'?: boolean;
    /**
     * 
     * @type {CompletedApprovalState}
     * @memberof CompletedApproval
     */
    'state'?: CompletedApprovalState;
    /**
     * The date the role or access profile or entitlement is no longer assigned to the specified identity.
     * @type {string}
     * @memberof CompletedApproval
     */
    'removeDate'?: string | null;
    /**
     * If true, then the request was to change the remove date or sunset date.
     * @type {boolean}
     * @memberof CompletedApproval
     */
    'removeDateUpdateRequested'?: boolean;
    /**
     * The remove date or sunset date that was assigned at the time of the request.
     * @type {string}
     * @memberof CompletedApproval
     */
    'currentRemoveDate'?: string | null;
    /**
     * 
     * @type {SodViolationContextCheckCompleted}
     * @memberof CompletedApproval
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted;
    /**
     * 
     * @type {CompletedApprovalPreApprovalTriggerResult}
     * @memberof CompletedApproval
     */
    'preApprovalTriggerResult'?: CompletedApprovalPreApprovalTriggerResult | null;
    /**
     * Arbitrary key-value pairs provided during the request.
     * @type {{ [key: string]: string; }}
     * @memberof CompletedApproval
     */
    'clientMetadata'?: { [key: string]: string; };
    /**
     * Information about the requested accounts
     * @type {string}
     * @memberof CompletedApproval
     */
    'requestedAccounts'?: string | null;
}
/**
 * If the access request submitted event trigger is configured and this access request was intercepted by it, then this is the result of the trigger\'s decision to either approve or deny the request.
 * @export
 * @interface CompletedApprovalPreApprovalTriggerResult
 */
export interface CompletedApprovalPreApprovalTriggerResult {
    /**
     * The comment from the trigger
     * @type {string}
     * @memberof CompletedApprovalPreApprovalTriggerResult
     */
    'comment'?: string;
    /**
     * 
     * @type {CompletedApprovalState}
     * @memberof CompletedApprovalPreApprovalTriggerResult
     */
    'decision'?: CompletedApprovalState;
    /**
     * The name of the approver
     * @type {string}
     * @memberof CompletedApprovalPreApprovalTriggerResult
     */
    'reviewer'?: string;
    /**
     * The date and time the trigger decided on the request
     * @type {string}
     * @memberof CompletedApprovalPreApprovalTriggerResult
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface CompletedApprovalRequesterComment
 */
export interface CompletedApprovalRequesterComment {
    /**
     * Comment content.
     * @type {string}
     * @memberof CompletedApprovalRequesterComment
     */
    'comment'?: string | null;
    /**
     * Date and time comment was created.
     * @type {string}
     * @memberof CompletedApprovalRequesterComment
     */
    'created'?: string;
    /**
     * 
     * @type {CommentDtoAuthor}
     * @memberof CompletedApprovalRequesterComment
     */
    'author'?: CommentDtoAuthor;
}
/**
 * 
 * @export
 * @interface CompletedApprovalReviewerComment
 */
export interface CompletedApprovalReviewerComment {
    /**
     * Comment content.
     * @type {string}
     * @memberof CompletedApprovalReviewerComment
     */
    'comment'?: string | null;
    /**
     * Date and time comment was created.
     * @type {string}
     * @memberof CompletedApprovalReviewerComment
     */
    'created'?: string;
    /**
     * 
     * @type {CommentDtoAuthor}
     * @memberof CompletedApprovalReviewerComment
     */
    'author'?: CommentDtoAuthor;
}
/**
 * Enum represents completed approval object\'s state.
 * @export
 * @enum {string}
 */

export const CompletedApprovalState = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type CompletedApprovalState = typeof CompletedApprovalState[keyof typeof CompletedApprovalState];


/**
 * The status after completion.
 * @export
 * @enum {string}
 */

export const CompletionStatus = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Incomplete: 'INCOMPLETE',
    Pending: 'PENDING',
    Null: 'null'
} as const;

export type CompletionStatus = typeof CompletionStatus[keyof typeof CompletionStatus];


/**
 * 
 * @export
 * @interface Concatenation
 */
export interface Concatenation {
    /**
     * An array of items to join together
     * @type {Array<object>}
     * @memberof Concatenation
     */
    'values': Array<object>;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Concatenation
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Concatenation
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Conditional
 */
export interface Conditional {
    /**
     * A comparison statement that follows the structure of `ValueA eq ValueB` where `ValueA` and `ValueB` are static strings or outputs of other transforms.   The `eq` operator is the only valid comparison
     * @type {string}
     * @memberof Conditional
     */
    'expression': string;
    /**
     * The output of the transform if the expression evalutes to true
     * @type {string}
     * @memberof Conditional
     */
    'positiveCondition': string;
    /**
     * The output of the transform if the expression evalutes to false
     * @type {string}
     * @memberof Conditional
     */
    'negativeCondition': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Conditional
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Conditional
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ConflictingAccessCriteria
 */
export interface ConflictingAccessCriteria {
    /**
     * 
     * @type {AccessCriteria}
     * @memberof ConflictingAccessCriteria
     */
    'leftCriteria'?: AccessCriteria;
    /**
     * 
     * @type {AccessCriteria}
     * @memberof ConflictingAccessCriteria
     */
    'rightCriteria'?: AccessCriteria;
}
/**
 * 
 * @export
 * @interface ConnectorDetail
 */
export interface ConnectorDetail {
    /**
     * The connector name
     * @type {string}
     * @memberof ConnectorDetail
     */
    'name'?: string;
    /**
     * The connector type
     * @type {string}
     * @memberof ConnectorDetail
     */
    'type'?: string;
    /**
     * The connector class name
     * @type {string}
     * @memberof ConnectorDetail
     */
    'className'?: string;
    /**
     * The connector script name
     * @type {string}
     * @memberof ConnectorDetail
     */
    'scriptName'?: string;
    /**
     * The connector application xml
     * @type {string}
     * @memberof ConnectorDetail
     */
    'applicationXml'?: string;
    /**
     * The connector correlation config xml
     * @type {string}
     * @memberof ConnectorDetail
     */
    'correlationConfigXml'?: string;
    /**
     * The connector source config xml
     * @type {string}
     * @memberof ConnectorDetail
     */
    'sourceConfigXml'?: string;
    /**
     * The connector source config
     * @type {string}
     * @memberof ConnectorDetail
     */
    'sourceConfig'?: string;
    /**
     * The connector source config origin
     * @type {string}
     * @memberof ConnectorDetail
     */
    'sourceConfigFrom'?: string;
    /**
     * storage path key for this connector
     * @type {string}
     * @memberof ConnectorDetail
     */
    's3Location'?: string;
    /**
     * The list of uploaded files supported by the connector. If there was any executable files uploaded to thee connector. Typically this be empty as the executable be uploaded at source creation.
     * @type {Array<string>}
     * @memberof ConnectorDetail
     */
    'uploadedFiles'?: Array<string> | null;
    /**
     * true if the source is file upload
     * @type {boolean}
     * @memberof ConnectorDetail
     */
    'fileUpload'?: boolean;
    /**
     * true if the source is a direct connect source
     * @type {boolean}
     * @memberof ConnectorDetail
     */
    'directConnect'?: boolean;
    /**
     * A map containing translation attributes by loacale key
     * @type {{ [key: string]: any; }}
     * @memberof ConnectorDetail
     */
    'translationProperties'?: { [key: string]: any; };
    /**
     * A map containing metadata pertinent to the UI to be used
     * @type {{ [key: string]: any; }}
     * @memberof ConnectorDetail
     */
    'connectorMetadata'?: { [key: string]: any; };
    /**
     * The connector status
     * @type {string}
     * @memberof ConnectorDetail
     */
    'status'?: ConnectorDetailStatusEnum;
}

export const ConnectorDetailStatusEnum = {
    Deprecated: 'DEPRECATED',
    Development: 'DEVELOPMENT',
    Demo: 'DEMO',
    Released: 'RELEASED'
} as const;

export type ConnectorDetailStatusEnum = typeof ConnectorDetailStatusEnum[keyof typeof ConnectorDetailStatusEnum];

/**
 * 
 * @export
 * @interface CreateExternalExecuteWorkflow200Response
 */
export interface CreateExternalExecuteWorkflow200Response {
    /**
     * The workflow execution id
     * @type {string}
     * @memberof CreateExternalExecuteWorkflow200Response
     */
    'workflowExecutionId'?: string;
    /**
     * An error message if any errors occurred
     * @type {string}
     * @memberof CreateExternalExecuteWorkflow200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface CreateExternalExecuteWorkflowRequest
 */
export interface CreateExternalExecuteWorkflowRequest {
    /**
     * The input for the workflow
     * @type {object}
     * @memberof CreateExternalExecuteWorkflowRequest
     */
    'input'?: object;
}
/**
 * 
 * @export
 * @interface CreateOAuthClientRequest
 */
export interface CreateOAuthClientRequest {
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'businessName'?: string | null;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'homepageUrl'?: string | null;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'name': string | null;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'description': string | null;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientRequest
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientRequest
     */
    'refreshTokenValiditySeconds'?: number;
    /**
     * A list of the approved redirect URIs. Provide one or more URIs when assigning the AUTHORIZATION_CODE grant type to a new OAuth Client.
     * @type {Array<string>}
     * @memberof CreateOAuthClientRequest
     */
    'redirectUris'?: Array<string> | null;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof CreateOAuthClientRequest
     */
    'grantTypes': Array<GrantType> | null;
    /**
     * 
     * @type {AccessType}
     * @memberof CreateOAuthClientRequest
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof CreateOAuthClientRequest
     */
    'type'?: ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal within the product.
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'internal'?: boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'strongAuthSupported'?: boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'claimsSupported'?: boolean;
    /**
     * Scopes of the API Client. If no scope is specified, the client will be created with the default scope \"sp:scopes:all\". This means the API Client will have all the rights of the owner who created it.
     * @type {Array<string>}
     * @memberof CreateOAuthClientRequest
     */
    'scope'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreateOAuthClientResponse
 */
export interface CreateOAuthClientResponse {
    /**
     * ID of the OAuth client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'id': string;
    /**
     * Secret of the OAuth client (This field is only returned on the intial create call.)
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'secret': string;
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'businessName': string;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'homepageUrl': string;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'name': string;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'description': string;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientResponse
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientResponse
     */
    'refreshTokenValiditySeconds': number;
    /**
     * A list of the approved redirect URIs used with the authorization_code flow
     * @type {Array<string>}
     * @memberof CreateOAuthClientResponse
     */
    'redirectUris': Array<string>;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof CreateOAuthClientResponse
     */
    'grantTypes': Array<GrantType>;
    /**
     * 
     * @type {AccessType}
     * @memberof CreateOAuthClientResponse
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof CreateOAuthClientResponse
     */
    'type': ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal to IDN
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'internal': boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'strongAuthSupported': boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'claimsSupported': boolean;
    /**
     * The date and time, down to the millisecond, when the API Client was created
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when the API Client was last updated
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'modified': string;
    /**
     * Scopes of the API Client.
     * @type {Array<string>}
     * @memberof CreateOAuthClientResponse
     */
    'scope': Array<string> | null;
}
/**
 * Object for specifying the name of a personal access token to create
 * @export
 * @interface CreatePersonalAccessTokenRequest
 */
export interface CreatePersonalAccessTokenRequest {
    /**
     * The name of the personal access token (PAT) to be created. Cannot be the same as another PAT owned by the user for whom this PAT is being created.
     * @type {string}
     * @memberof CreatePersonalAccessTokenRequest
     */
    'name': string;
    /**
     * Scopes of the personal  access token. If no scope is specified, the token will be created with the default scope \"sp:scopes:all\". This means the personal access token will have all the rights of the owner who created it.
     * @type {Array<string>}
     * @memberof CreatePersonalAccessTokenRequest
     */
    'scope'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreatePersonalAccessTokenResponse
 */
export interface CreatePersonalAccessTokenResponse {
    /**
     * The ID of the personal access token (to be used as the username for Basic Auth).
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'id': string;
    /**
     * The secret of the personal access token (to be used as the password for Basic Auth).
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'secret': string;
    /**
     * Scopes of the personal  access token.
     * @type {Array<string>}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'scope': Array<string> | null;
    /**
     * The name of the personal access token. Cannot be the same as other personal access tokens owned by a user.
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'name': string;
    /**
     * 
     * @type {PatOwner}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'owner': PatOwner;
    /**
     * The date and time, down to the millisecond, when this personal access token was created.
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'created': string;
}
/**
 * 
 * @export
 * @interface CreateSavedSearchRequest
 */
export interface CreateSavedSearchRequest {
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'description'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof CreateSavedSearchRequest
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof CreateSavedSearchRequest
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof CreateSavedSearchRequest
     */
    'fields'?: Array<string> | null;
    /**
     * Sort by index. This takes precedence over the `sort` property. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof CreateSavedSearchRequest
     */
    'orderBy'?: { [key: string]: Array<string>; } | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof CreateSavedSearchRequest
     */
    'sort'?: Array<string> | null;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof CreateSavedSearchRequest
     */
    'filters'?: SavedSearchDetailFilters | null;
}
/**
 * 
 * @export
 * @interface CreateScheduledSearchRequest
 */
export interface CreateScheduledSearchRequest {
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'description'?: string | null;
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'savedSearchId': string;
    /**
     * The date the scheduled search was initially created.
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'created'?: string;
    /**
     * The last date the scheduled search was modified.
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'modified'?: string;
    /**
     * 
     * @type {Schedule1}
     * @memberof CreateScheduledSearchRequest
     */
    'schedule': Schedule1;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof CreateScheduledSearchRequest
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof CreateScheduledSearchRequest
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should occur when search returns no results. 
     * @type {boolean}
     * @memberof CreateScheduledSearchRequest
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof CreateScheduledSearchRequest
     */
    'displayQueryDetails'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateWorkflowRequest
 */
export interface CreateWorkflowRequest {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof CreateWorkflowRequest
     */
    'name': string;
    /**
     * 
     * @type {WorkflowBodyOwner}
     * @memberof CreateWorkflowRequest
     */
    'owner': WorkflowBodyOwner;
    /**
     * Description of what the workflow accomplishes
     * @type {string}
     * @memberof CreateWorkflowRequest
     */
    'description'?: string;
    /**
     * 
     * @type {WorkflowDefinition}
     * @memberof CreateWorkflowRequest
     */
    'definition'?: WorkflowDefinition;
    /**
     * Enable or disable the workflow.  Workflows cannot be created in an enabled state.
     * @type {boolean}
     * @memberof CreateWorkflowRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {WorkflowTrigger}
     * @memberof CreateWorkflowRequest
     */
    'trigger'?: WorkflowTrigger;
}
/**
 * Type of the criteria in the filter. The `COMPOSITE` filter can contain multiple filters in an AND/OR relationship.
 * @export
 * @enum {string}
 */

export const CriteriaType = {
    Composite: 'COMPOSITE',
    Role: 'ROLE',
    Identity: 'IDENTITY',
    IdentityAttribute: 'IDENTITY_ATTRIBUTE',
    Entitlement: 'ENTITLEMENT',
    AccessProfile: 'ACCESS_PROFILE',
    Source: 'SOURCE',
    Account: 'ACCOUNT',
    AggregatedEntitlement: 'AGGREGATED_ENTITLEMENT',
    InvalidCertifiableEntity: 'INVALID_CERTIFIABLE_ENTITY'
} as const;

export type CriteriaType = typeof CriteriaType[keyof typeof CriteriaType];


/**
 * DAS data for the entitlement
 * @export
 * @interface DataAccess
 */
export interface DataAccess {
    /**
     * List of classification policies that apply to resources the entitlement \\ groups has access to
     * @type {Array<DataAccessPoliciesInner>}
     * @memberof DataAccess
     */
    'policies'?: Array<DataAccessPoliciesInner>;
    /**
     * List of classification categories that apply to resources the entitlement \\ groups has access to
     * @type {Array<DataAccessCategoriesInner>}
     * @memberof DataAccess
     */
    'categories'?: Array<DataAccessCategoriesInner>;
    /**
     * 
     * @type {DataAccessImpactScore}
     * @memberof DataAccess
     */
    'impactScore'?: DataAccessImpactScore;
}
/**
 * 
 * @export
 * @interface DataAccessCategoriesInner
 */
export interface DataAccessCategoriesInner {
    /**
     * Value of the category
     * @type {string}
     * @memberof DataAccessCategoriesInner
     */
    'value'?: string;
    /**
     * Number of matched for each category
     * @type {number}
     * @memberof DataAccessCategoriesInner
     */
    'matchCount'?: number;
}
/**
 * 
 * @export
 * @interface DataAccessImpactScore
 */
export interface DataAccessImpactScore {
    /**
     * Impact Score for this data
     * @type {string}
     * @memberof DataAccessImpactScore
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface DataAccessPoliciesInner
 */
export interface DataAccessPoliciesInner {
    /**
     * Value of the policy
     * @type {string}
     * @memberof DataAccessPoliciesInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface DateCompare
 */
export interface DateCompare {
    /**
     * 
     * @type {DateCompareFirstDate}
     * @memberof DateCompare
     */
    'firstDate': DateCompareFirstDate;
    /**
     * 
     * @type {DateCompareSecondDate}
     * @memberof DateCompare
     */
    'secondDate': DateCompareSecondDate;
    /**
     * This is the comparison to perform. | Operation | Description | | --------- | ------- | | LT        | Strictly less than: firstDate < secondDate | | LTE       | Less than or equal to: firstDate <= secondDate | | GT        | Strictly greater than: firstDate > secondDate | | GTE       | Greater than or equal to: firstDate >= secondDate | 
     * @type {string}
     * @memberof DateCompare
     */
    'operator': DateCompareOperatorEnum;
    /**
     * The output of the transform if the expression evalutes to true
     * @type {string}
     * @memberof DateCompare
     */
    'positiveCondition': string;
    /**
     * The output of the transform if the expression evalutes to false
     * @type {string}
     * @memberof DateCompare
     */
    'negativeCondition': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateCompare
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateCompare
     */
    'input'?: { [key: string]: any; };
}

export const DateCompareOperatorEnum = {
    Lt: 'LT',
    Lte: 'LTE',
    Gt: 'GT',
    Gte: 'GTE'
} as const;

export type DateCompareOperatorEnum = typeof DateCompareOperatorEnum[keyof typeof DateCompareOperatorEnum];

/**
 * @type DateCompareFirstDate
 * This is the first date to consider (The date that would be on the left hand side of the comparison operation).
 * @export
 */
export type DateCompareFirstDate = AccountAttribute | DateFormat;

/**
 * @type DateCompareSecondDate
 * This is the second date to consider (The date that would be on the right hand side of the comparison operation).
 * @export
 */
export type DateCompareSecondDate = AccountAttribute | DateFormat;

/**
 * 
 * @export
 * @interface DateFormat
 */
export interface DateFormat {
    /**
     * 
     * @type {DateFormatInputFormat}
     * @memberof DateFormat
     */
    'inputFormat'?: DateFormatInputFormat;
    /**
     * 
     * @type {DateFormatOutputFormat}
     * @memberof DateFormat
     */
    'outputFormat'?: DateFormatOutputFormat;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateFormat
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateFormat
     */
    'input'?: { [key: string]: any; };
}
/**
 * @type DateFormatInputFormat
 * A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.  *If no inputFormat is provided, the transform assumes that it is in ISO8601 format*
 * @export
 */
export type DateFormatInputFormat = NamedConstructs | string;

/**
 * @type DateFormatOutputFormat
 * A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.  *If no inputFormat is provided, the transform assumes that it is in ISO8601 format*
 * @export
 */
export type DateFormatOutputFormat = NamedConstructs | string;

/**
 * 
 * @export
 * @interface DateMath
 */
export interface DateMath {
    /**
     * A string value of the date and time components to operation on, along with the math operations to execute. 
     * @type {string}
     * @memberof DateMath
     */
    'expression': string;
    /**
     * A boolean value to indicate whether the transform should round up or down when a rounding `/` operation is defined in the expression.    If not provided, the transform will default to `false`   `true` indicates the transform should round up (i.e., truncate the fractional date/time component indicated and then add one unit of that component)   `false` indicates the transform should round down (i.e., truncate the fractional date/time component indicated) 
     * @type {boolean}
     * @memberof DateMath
     */
    'roundUp'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateMath
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateMath
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface DecomposeDiacriticalMarks
 */
export interface DecomposeDiacriticalMarks {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DecomposeDiacriticalMarks
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DecomposeDiacriticalMarks
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface DeleteNonEmployeeRecordsInBulkRequest
 */
export interface DeleteNonEmployeeRecordsInBulkRequest {
    /**
     * List of non-employee ids.
     * @type {Array<string>}
     * @memberof DeleteNonEmployeeRecordsInBulkRequest
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteSource202Response
 */
export interface DeleteSource202Response {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'type'?: DeleteSource202ResponseTypeEnum;
    /**
     * Task result ID.
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'id'?: string;
    /**
     * Task result\'s human-readable display name (this should be null/empty).
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'name'?: string;
}

export const DeleteSource202ResponseTypeEnum = {
    TaskResult: 'TASK_RESULT'
} as const;

export type DeleteSource202ResponseTypeEnum = typeof DeleteSource202ResponseTypeEnum[keyof typeof DeleteSource202ResponseTypeEnum];

/**
 * 
 * @export
 * @interface DisplayReference
 */
export interface DisplayReference {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof DisplayReference
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof DisplayReference
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisplayReference
     */
    'displayName'?: string;
}
/**
 * 
 * @export
 * @interface DisplayReferenceAllOf
 */
export interface DisplayReferenceAllOf {
    /**
     * 
     * @type {string}
     * @memberof DisplayReferenceAllOf
     */
    'displayName'?: string;
}
/**
 * Enum representing the currently supported document types.  Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const DocumentType = {
    Accessprofile: 'accessprofile',
    Accountactivity: 'accountactivity',
    Account: 'account',
    Aggregation: 'aggregation',
    Entitlement: 'entitlement',
    Event: 'event',
    Identity: 'identity',
    Role: 'role'
} as const;

export type DocumentType = typeof DocumentType[keyof typeof DocumentType];


/**
 * An enumeration of the types of DTOs supported within the IdentityNow infrastructure.
 * @export
 * @enum {string}
 */

export const DtoType = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG',
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestApproval: 'ACCESS_REQUEST_APPROVAL',
    Account: 'ACCOUNT',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    CampaignFilter: 'CAMPAIGN_FILTER',
    Certification: 'CERTIFICATION',
    Cluster: 'CLUSTER',
    ConnectorSchema: 'CONNECTOR_SCHEMA',
    Entitlement: 'ENTITLEMENT',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY',
    IdentityProfile: 'IDENTITY_PROFILE',
    IdentityRequest: 'IDENTITY_REQUEST',
    LifecycleState: 'LIFECYCLE_STATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    Role: 'ROLE',
    Rule: 'RULE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    TagCategory: 'TAG_CATEGORY',
    TaskResult: 'TASK_RESULT',
    ReportResult: 'REPORT_RESULT',
    SodViolation: 'SOD_VIOLATION',
    AccountActivity: 'ACCOUNT_ACTIVITY',
    Workgroup: 'WORKGROUP'
} as const;

export type DtoType = typeof DtoType[keyof typeof DtoType];


/**
 * 
 * @export
 * @interface DuoVerificationRequest
 */
export interface DuoVerificationRequest {
    /**
     * User id for Verification request.
     * @type {string}
     * @memberof DuoVerificationRequest
     */
    'userId': string;
    /**
     * User id for Verification request.
     * @type {string}
     * @memberof DuoVerificationRequest
     */
    'signedResponse': string;
}
/**
 * 
 * @export
 * @interface E164phone
 */
export interface E164phone {
    /**
     * This is an optional attribute that can be used to define the region of the phone number to format into.   If defaultRegion is not provided, it will take US as the default country.   The format of the country code should be in [ISO 3166-1 alpha-2 format](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) 
     * @type {string}
     * @memberof E164phone
     */
    'defaultRegion'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof E164phone
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof E164phone
     */
    'input'?: { [key: string]: any; };
}
/**
 * This is used for representing email configuration for a lifecycle state
 * @export
 * @interface EmailNotificationOption
 */
export interface EmailNotificationOption {
    /**
     * If true, then the manager is notified of the lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifyManagers'?: boolean;
    /**
     * If true, then all the admins are notified of the lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifyAllAdmins'?: boolean;
    /**
     * If true, then the users specified in \"emailAddressList\" below are notified of lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifySpecificUsers'?: boolean;
    /**
     * List of user email addresses. If \"notifySpecificUsers\" option is true, then these users are notified of lifecycle state change.
     * @type {Array<string>}
     * @memberof EmailNotificationOption
     */
    'emailAddressList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Entitlement
 */
export interface Entitlement {
    /**
     * The entitlement id
     * @type {string}
     * @memberof Entitlement
     */
    'id'?: string;
    /**
     * The entitlement name
     * @type {string}
     * @memberof Entitlement
     */
    'name'?: string;
    /**
     * The entitlement attribute name
     * @type {string}
     * @memberof Entitlement
     */
    'attribute'?: string;
    /**
     * The value of the entitlement
     * @type {string}
     * @memberof Entitlement
     */
    'value'?: string;
    /**
     * The object type of the entitlement from the source schema
     * @type {string}
     * @memberof Entitlement
     */
    'sourceSchemaObjectType'?: string;
    /**
     * The description of the entitlement
     * @type {string}
     * @memberof Entitlement
     */
    'description'?: string;
    /**
     * True if the entitlement is privileged
     * @type {boolean}
     * @memberof Entitlement
     */
    'privileged'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof Entitlement
     */
    'cloudGoverned'?: boolean;
    /**
     * Time when the entitlement was created
     * @type {string}
     * @memberof Entitlement
     */
    'created'?: string;
    /**
     * Time when the entitlement was last modified
     * @type {string}
     * @memberof Entitlement
     */
    'modified'?: string;
    /**
     * 
     * @type {EntitlementSource}
     * @memberof Entitlement
     */
    'source'?: EntitlementSource;
    /**
     * A map of free-form key-value pairs from the source system
     * @type {{ [key: string]: any; }}
     * @memberof Entitlement
     */
    'attributes'?: { [key: string]: any; };
    /**
     * List of IDs of segments, if any, to which this Entitlement is assigned.
     * @type {Array<string>}
     * @memberof Entitlement
     */
    'segments'?: Array<string> | null;
    /**
     * 
     * @type {Array<PermissionDto>}
     * @memberof Entitlement
     */
    'directPermissions'?: Array<PermissionDto>;
}
/**
 * Entitlement
 * @export
 * @interface EntitlementDocument
 */
export interface EntitlementDocument {
    /**
     * 
     * @type {string}
     * @memberof EntitlementDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof EntitlementDocument
     */
    '_type': DocumentType;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof EntitlementDocument
     */
    'synced'?: string;
    /**
     * Entitlement\'s display name.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'displayName'?: string;
    /**
     * 
     * @type {EntitlementDocumentAllOfSource}
     * @memberof EntitlementDocument
     */
    'source'?: EntitlementDocumentAllOfSource;
    /**
     * Segments with the role.
     * @type {Array<BaseSegment>}
     * @memberof EntitlementDocument
     */
    'segments'?: Array<BaseSegment>;
    /**
     * Number of segments with the role.
     * @type {number}
     * @memberof EntitlementDocument
     */
    'segmentCount'?: number;
    /**
     * Indicates whether the entitlement is requestable.
     * @type {boolean}
     * @memberof EntitlementDocument
     */
    'requestable'?: boolean;
    /**
     * Indicates whether the entitlement is cloud governed.
     * @type {boolean}
     * @memberof EntitlementDocument
     */
    'cloudGoverned'?: boolean;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'created'?: string | null;
    /**
     * Indicates whether the entitlement is privileged.
     * @type {boolean}
     * @memberof EntitlementDocument
     */
    'privileged'?: boolean;
    /**
     * Number of identities who have access to the entitlement.
     * @type {number}
     * @memberof EntitlementDocument
     */
    'identityCount'?: number;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof EntitlementDocument
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EntitlementDocumentAllOf
 */
export interface EntitlementDocumentAllOf {
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof EntitlementDocumentAllOf
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof EntitlementDocumentAllOf
     */
    'synced'?: string;
    /**
     * Entitlement\'s display name.
     * @type {string}
     * @memberof EntitlementDocumentAllOf
     */
    'displayName'?: string;
    /**
     * 
     * @type {EntitlementDocumentAllOfSource}
     * @memberof EntitlementDocumentAllOf
     */
    'source'?: EntitlementDocumentAllOfSource;
    /**
     * Segments with the role.
     * @type {Array<BaseSegment>}
     * @memberof EntitlementDocumentAllOf
     */
    'segments'?: Array<BaseSegment>;
    /**
     * Number of segments with the role.
     * @type {number}
     * @memberof EntitlementDocumentAllOf
     */
    'segmentCount'?: number;
    /**
     * Indicates whether the entitlement is requestable.
     * @type {boolean}
     * @memberof EntitlementDocumentAllOf
     */
    'requestable'?: boolean;
    /**
     * Indicates whether the entitlement is cloud governed.
     * @type {boolean}
     * @memberof EntitlementDocumentAllOf
     */
    'cloudGoverned'?: boolean;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof EntitlementDocumentAllOf
     */
    'created'?: string | null;
    /**
     * Indicates whether the entitlement is privileged.
     * @type {boolean}
     * @memberof EntitlementDocumentAllOf
     */
    'privileged'?: boolean;
    /**
     * Number of identities who have access to the entitlement.
     * @type {number}
     * @memberof EntitlementDocumentAllOf
     */
    'identityCount'?: number;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof EntitlementDocumentAllOf
     */
    'tags'?: Array<string>;
}
/**
 * Entitlement\'s source.
 * @export
 * @interface EntitlementDocumentAllOfSource
 */
export interface EntitlementDocumentAllOfSource {
    /**
     * ID of entitlement\'s source.
     * @type {string}
     * @memberof EntitlementDocumentAllOfSource
     */
    'id'?: string;
    /**
     * Display name of entitlement\'s source.
     * @type {string}
     * @memberof EntitlementDocumentAllOfSource
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface EntitlementDto
 */
export interface EntitlementDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'modified'?: string;
    /**
     * Name of the entitlement attribute
     * @type {string}
     * @memberof EntitlementDto
     */
    'attribute'?: string;
    /**
     * Raw value of the entitlement
     * @type {string}
     * @memberof EntitlementDto
     */
    'value'?: string;
    /**
     * Entitlment description
     * @type {string}
     * @memberof EntitlementDto
     */
    'description'?: string;
    /**
     * Entitlement attributes
     * @type {{ [key: string]: any; }}
     * @memberof EntitlementDto
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Schema objectType on the given application that maps to an Account Group
     * @type {string}
     * @memberof EntitlementDto
     */
    'sourceSchemaObjectType'?: string;
    /**
     * Determines if this Entitlement is privileged.
     * @type {boolean}
     * @memberof EntitlementDto
     */
    'privileged'?: boolean;
    /**
     * Determines if this Entitlement is goverened in the cloud.
     * @type {boolean}
     * @memberof EntitlementDto
     */
    'cloudGoverned'?: boolean;
    /**
     * 
     * @type {EntitlementSource}
     * @memberof EntitlementDto
     */
    'source'?: EntitlementSource;
}
/**
 * Entitlement object that represents entitlement
 * @export
 * @interface EntitlementDtoAllOf
 */
export interface EntitlementDtoAllOf {
    /**
     * Name of the entitlement attribute
     * @type {string}
     * @memberof EntitlementDtoAllOf
     */
    'attribute'?: string;
    /**
     * Raw value of the entitlement
     * @type {string}
     * @memberof EntitlementDtoAllOf
     */
    'value'?: string;
    /**
     * Entitlment description
     * @type {string}
     * @memberof EntitlementDtoAllOf
     */
    'description'?: string;
    /**
     * Entitlement attributes
     * @type {{ [key: string]: any; }}
     * @memberof EntitlementDtoAllOf
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Schema objectType on the given application that maps to an Account Group
     * @type {string}
     * @memberof EntitlementDtoAllOf
     */
    'sourceSchemaObjectType'?: string;
    /**
     * Determines if this Entitlement is privileged.
     * @type {boolean}
     * @memberof EntitlementDtoAllOf
     */
    'privileged'?: boolean;
    /**
     * Determines if this Entitlement is goverened in the cloud.
     * @type {boolean}
     * @memberof EntitlementDtoAllOf
     */
    'cloudGoverned'?: boolean;
    /**
     * 
     * @type {EntitlementSource}
     * @memberof EntitlementDtoAllOf
     */
    'source'?: EntitlementSource;
}
/**
 * Entitlement including a specific set of access.
 * @export
 * @interface EntitlementRef
 */
export interface EntitlementRef {
    /**
     * Entitlement\'s DTO type.
     * @type {string}
     * @memberof EntitlementRef
     */
    'type'?: EntitlementRefTypeEnum;
    /**
     * Entitlement\'s ID.
     * @type {string}
     * @memberof EntitlementRef
     */
    'id'?: string;
    /**
     * Entitlement\'s display name.
     * @type {string}
     * @memberof EntitlementRef
     */
    'name'?: string | null;
}

export const EntitlementRefTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type EntitlementRefTypeEnum = typeof EntitlementRefTypeEnum[keyof typeof EntitlementRefTypeEnum];

/**
 * Entitlement including a specific set of access.
 * @export
 * @interface EntitlementRef1
 */
export interface EntitlementRef1 {
    /**
     * Entitlement\'s DTO type.
     * @type {string}
     * @memberof EntitlementRef1
     */
    'type'?: EntitlementRef1TypeEnum;
    /**
     * Entitlement\'s ID.
     * @type {string}
     * @memberof EntitlementRef1
     */
    'id'?: string;
    /**
     * Entitlement\'s display name.
     * @type {string}
     * @memberof EntitlementRef1
     */
    'name'?: string;
}

export const EntitlementRef1TypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type EntitlementRef1TypeEnum = typeof EntitlementRef1TypeEnum[keyof typeof EntitlementRef1TypeEnum];

/**
 * 
 * @export
 * @interface EntitlementRequestConfig
 */
export interface EntitlementRequestConfig {
    /**
     * If this is true, entitlement requests are allowed.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'allowEntitlementRequest'?: boolean;
    /**
     * If this is true, comments are required to submit entitlement requests.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'requestCommentsRequired'?: boolean;
    /**
     * If this is true, comments are required to reject entitlement requests.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'deniedCommentsRequired'?: boolean;
    /**
     * Approval schemes for granting entitlement request. This can be empty if no approval is needed. Multiple schemes must be comma-separated. The valid schemes are \"entitlementOwner\", \"sourceOwner\", \"manager\" and \"workgroup:{id}\". You can use multiple governance groups (workgroups). 
     * @type {string}
     * @memberof EntitlementRequestConfig
     */
    'grantRequestApprovalSchemes'?: string | null;
}
/**
 * 
 * @export
 * @interface EntitlementSource
 */
export interface EntitlementSource {
    /**
     * The source ID
     * @type {string}
     * @memberof EntitlementSource
     */
    'id'?: string;
    /**
     * The source type, will always be \"SOURCE\"
     * @type {string}
     * @memberof EntitlementSource
     */
    'type'?: string;
    /**
     * The source name
     * @type {string}
     * @memberof EntitlementSource
     */
    'name'?: string;
}
/**
 * EntitlementReference
 * @export
 * @interface EntitlementSummary
 */
export interface EntitlementSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof EntitlementSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof EntitlementSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof EntitlementSummary
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof EntitlementSummary
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummary
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'attribute'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummary
     */
    'standalone'?: boolean;
}
/**
 * 
 * @export
 * @interface EntitlementSummaryAllOf
 */
export interface EntitlementSummaryAllOf {
    /**
     * 
     * @type {Reference1}
     * @memberof EntitlementSummaryAllOf
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummaryAllOf
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummaryAllOf
     */
    'attribute'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummaryAllOf
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummaryAllOf
     */
    'standalone'?: boolean;
}
/**
 * 
 * @export
 * @interface ErrorMessageDto
 */
export interface ErrorMessageDto {
    /**
     * The locale for the message text, a BCP 47 language tag.
     * @type {string}
     * @memberof ErrorMessageDto
     */
    'locale'?: string | null;
    /**
     * 
     * @type {LocaleOrigin}
     * @memberof ErrorMessageDto
     */
    'localeOrigin'?: LocaleOrigin | null;
    /**
     * Actual text of the error message in the indicated locale.
     * @type {string}
     * @memberof ErrorMessageDto
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponseDto
 */
export interface ErrorResponseDto {
    /**
     * Fine-grained error code providing more detail of the error.
     * @type {string}
     * @memberof ErrorResponseDto
     */
    'detailCode'?: string;
    /**
     * Unique tracking id for the error.
     * @type {string}
     * @memberof ErrorResponseDto
     */
    'trackingId'?: string;
    /**
     * Generic localized reason for error
     * @type {Array<ErrorMessageDto>}
     * @memberof ErrorResponseDto
     */
    'messages'?: Array<ErrorMessageDto>;
    /**
     * Plain-text descriptive reasons to provide additional detail to the text provided in the messages field
     * @type {Array<ErrorMessageDto>}
     * @memberof ErrorResponseDto
     */
    'causes'?: Array<ErrorMessageDto>;
}
/**
 * Event
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof Event
     */
    '_type': DocumentType;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof Event
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof Event
     */
    'synced'?: string;
    /**
     * Name of the event as it\'s displayed in audit reports.
     * @type {string}
     * @memberof Event
     */
    'action'?: string;
    /**
     * Event type. Refer to [Event Types](https://documentation.sailpoint.com/saas/help/search/index.html#event-types) for a list of event types and their meanings.
     * @type {string}
     * @memberof Event
     */
    'type'?: string;
    /**
     * Name of the actor that generated the event.
     * @type {string}
     * @memberof Event
     */
    'actor'?: string;
    /**
     * Name of the target, or recipient, of the event.
     * @type {string}
     * @memberof Event
     */
    'target'?: string;
    /**
     * The event\'s stack.
     * @type {string}
     * @memberof Event
     */
    'stack'?: string;
    /**
     * ID of the group of events.
     * @type {string}
     * @memberof Event
     */
    'trackingNumber'?: string;
    /**
     * Target system\'s IP address.
     * @type {string}
     * @memberof Event
     */
    'ipAddress'?: string;
    /**
     * ID of event\'s details.
     * @type {string}
     * @memberof Event
     */
    'details'?: string;
    /**
     * Attributes involved in the event.
     * @type {{ [key: string]: any; }}
     * @memberof Event
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Objects the event is happening to.
     * @type {Array<string>}
     * @memberof Event
     */
    'objects'?: Array<string>;
    /**
     * Operation, or action, performed during the event.
     * @type {string}
     * @memberof Event
     */
    'operation'?: string;
    /**
     * Event status. Refer to [Event Statuses](https://documentation.sailpoint.com/saas/help/search/index.html#event-statuses) for a list of event statuses and their meanings.
     * @type {string}
     * @memberof Event
     */
    'status'?: string;
    /**
     * Event\'s normalized name. This normalized name always follows the pattern of \'objects_operation_status\'.
     * @type {string}
     * @memberof Event
     */
    'technicalName'?: string;
}
/**
 * 
 * @export
 * @interface EventAllOf
 */
export interface EventAllOf {
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof EventAllOf
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof EventAllOf
     */
    'synced'?: string;
    /**
     * Name of the event as it\'s displayed in audit reports.
     * @type {string}
     * @memberof EventAllOf
     */
    'action'?: string;
    /**
     * Event type. Refer to [Event Types](https://documentation.sailpoint.com/saas/help/search/index.html#event-types) for a list of event types and their meanings.
     * @type {string}
     * @memberof EventAllOf
     */
    'type'?: string;
    /**
     * Name of the actor that generated the event.
     * @type {string}
     * @memberof EventAllOf
     */
    'actor'?: string;
    /**
     * Name of the target, or recipient, of the event.
     * @type {string}
     * @memberof EventAllOf
     */
    'target'?: string;
    /**
     * The event\'s stack.
     * @type {string}
     * @memberof EventAllOf
     */
    'stack'?: string;
    /**
     * ID of the group of events.
     * @type {string}
     * @memberof EventAllOf
     */
    'trackingNumber'?: string;
    /**
     * Target system\'s IP address.
     * @type {string}
     * @memberof EventAllOf
     */
    'ipAddress'?: string;
    /**
     * ID of event\'s details.
     * @type {string}
     * @memberof EventAllOf
     */
    'details'?: string;
    /**
     * Attributes involved in the event.
     * @type {{ [key: string]: any; }}
     * @memberof EventAllOf
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Objects the event is happening to.
     * @type {Array<string>}
     * @memberof EventAllOf
     */
    'objects'?: Array<string>;
    /**
     * Operation, or action, performed during the event.
     * @type {string}
     * @memberof EventAllOf
     */
    'operation'?: string;
    /**
     * Event status. Refer to [Event Statuses](https://documentation.sailpoint.com/saas/help/search/index.html#event-statuses) for a list of event statuses and their meanings.
     * @type {string}
     * @memberof EventAllOf
     */
    'status'?: string;
    /**
     * Event\'s normalized name. This normalized name always follows the pattern of \'objects_operation_status\'.
     * @type {string}
     * @memberof EventAllOf
     */
    'technicalName'?: string;
}
/**
 * Attributes related to an IdentityNow ETS event
 * @export
 * @interface EventAttributes
 */
export interface EventAttributes {
    /**
     * The unique ID of the trigger
     * @type {string}
     * @memberof EventAttributes
     */
    'id': string;
    /**
     * JSON path expression that will limit which events the trigger will fire on
     * @type {string}
     * @memberof EventAttributes
     */
    'filter.$'?: string;
}
/**
 * Event
 * @export
 * @interface EventDocument
 */
export interface EventDocument {
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof EventDocument
     */
    '_type': DocumentType;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof EventDocument
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof EventDocument
     */
    'synced'?: string;
    /**
     * Name of the event as it\'s displayed in audit reports.
     * @type {string}
     * @memberof EventDocument
     */
    'action'?: string;
    /**
     * Event type. Refer to [Event Types](https://documentation.sailpoint.com/saas/help/search/index.html#event-types) for a list of event types and their meanings.
     * @type {string}
     * @memberof EventDocument
     */
    'type'?: string;
    /**
     * Name of the actor that generated the event.
     * @type {string}
     * @memberof EventDocument
     */
    'actor'?: string;
    /**
     * Name of the target, or recipient, of the event.
     * @type {string}
     * @memberof EventDocument
     */
    'target'?: string;
    /**
     * The event\'s stack.
     * @type {string}
     * @memberof EventDocument
     */
    'stack'?: string;
    /**
     * ID of the group of events.
     * @type {string}
     * @memberof EventDocument
     */
    'trackingNumber'?: string;
    /**
     * Target system\'s IP address.
     * @type {string}
     * @memberof EventDocument
     */
    'ipAddress'?: string;
    /**
     * ID of event\'s details.
     * @type {string}
     * @memberof EventDocument
     */
    'details'?: string;
    /**
     * Attributes involved in the event.
     * @type {{ [key: string]: any; }}
     * @memberof EventDocument
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Objects the event is happening to.
     * @type {Array<string>}
     * @memberof EventDocument
     */
    'objects'?: Array<string>;
    /**
     * Operation, or action, performed during the event.
     * @type {string}
     * @memberof EventDocument
     */
    'operation'?: string;
    /**
     * Event status. Refer to [Event Statuses](https://documentation.sailpoint.com/saas/help/search/index.html#event-statuses) for a list of event statuses and their meanings.
     * @type {string}
     * @memberof EventDocument
     */
    'status'?: string;
    /**
     * Event\'s normalized name. This normalized name always follows the pattern of \'objects_operation_status\'.
     * @type {string}
     * @memberof EventDocument
     */
    'technicalName'?: string;
}
/**
 * 
 * @export
 * @interface ExceptionAccessCriteria
 */
export interface ExceptionAccessCriteria {
    /**
     * 
     * @type {ExceptionCriteria}
     * @memberof ExceptionAccessCriteria
     */
    'leftCriteria'?: ExceptionCriteria;
    /**
     * 
     * @type {ExceptionCriteria}
     * @memberof ExceptionAccessCriteria
     */
    'rightCriteria'?: ExceptionCriteria;
}
/**
 * 
 * @export
 * @interface ExceptionCriteria
 */
export interface ExceptionCriteria {
    /**
     * List of exception criteria. There is a min of 1 and max of 50 items in the list.
     * @type {Array<ExceptionCriteriaCriteriaListInner>}
     * @memberof ExceptionCriteria
     */
    'criteriaList'?: Array<ExceptionCriteriaCriteriaListInner>;
}
/**
 * Access reference with addition of boolean existing flag to indicate whether the access was extant
 * @export
 * @interface ExceptionCriteriaAccess
 */
export interface ExceptionCriteriaAccess {
    /**
     * 
     * @type {DtoType}
     * @memberof ExceptionCriteriaAccess
     */
    'type'?: DtoType;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaAccess
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaAccess
     */
    'name'?: string;
    /**
     * Whether the subject identity already had that access or not
     * @type {boolean}
     * @memberof ExceptionCriteriaAccess
     */
    'existing'?: boolean;
}
/**
 * The types of objects supported for SOD violations
 * @export
 * @interface ExceptionCriteriaCriteriaListInner
 */
export interface ExceptionCriteriaCriteriaListInner {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'type'?: ExceptionCriteriaCriteriaListInnerTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'name'?: string;
    /**
     * Whether the subject identity already had that access or not
     * @type {boolean}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'existing'?: boolean;
}

export const ExceptionCriteriaCriteriaListInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type ExceptionCriteriaCriteriaListInnerTypeEnum = typeof ExceptionCriteriaCriteriaListInnerTypeEnum[keyof typeof ExceptionCriteriaCriteriaListInnerTypeEnum];

/**
 * The current state of execution.
 * @export
 * @enum {string}
 */

export const ExecutionStatus = {
    Executing: 'EXECUTING',
    Verifying: 'VERIFYING',
    Terminated: 'TERMINATED',
    Completed: 'COMPLETED'
} as const;

export type ExecutionStatus = typeof ExecutionStatus[keyof typeof ExecutionStatus];


/**
 * 
 * @export
 * @interface ExpansionItem
 */
export interface ExpansionItem {
    /**
     * The ID of the account
     * @type {string}
     * @memberof ExpansionItem
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpansionItem
     */
    'cause'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ExpansionItem
     */
    'name'?: string;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof ExpansionItem
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * 
     * @type {AccountSource}
     * @memberof ExpansionItem
     */
    'source'?: AccountSource;
}
/**
 * 
 * @export
 * @interface Expression
 */
export interface Expression {
    /**
     * Operator for the expression
     * @type {string}
     * @memberof Expression
     */
    'operator'?: ExpressionOperatorEnum;
    /**
     * Name for the attribute
     * @type {string}
     * @memberof Expression
     */
    'attribute'?: string | null;
    /**
     * 
     * @type {Value}
     * @memberof Expression
     */
    'value'?: Value | null;
    /**
     * List of expressions
     * @type {Array<ExpressionChildrenInner>}
     * @memberof Expression
     */
    'children'?: Array<ExpressionChildrenInner> | null;
}

export const ExpressionOperatorEnum = {
    And: 'AND',
    Equals: 'EQUALS'
} as const;

export type ExpressionOperatorEnum = typeof ExpressionOperatorEnum[keyof typeof ExpressionOperatorEnum];

/**
 * 
 * @export
 * @interface ExpressionChildrenInner
 */
export interface ExpressionChildrenInner {
    /**
     * Operator for the expression
     * @type {string}
     * @memberof ExpressionChildrenInner
     */
    'operator'?: ExpressionChildrenInnerOperatorEnum;
    /**
     * Name for the attribute
     * @type {string}
     * @memberof ExpressionChildrenInner
     */
    'attribute'?: string | null;
    /**
     * 
     * @type {Value}
     * @memberof ExpressionChildrenInner
     */
    'value'?: Value | null;
    /**
     * There cannot be anymore nested children. This will always be null.
     * @type {string}
     * @memberof ExpressionChildrenInner
     */
    'children'?: string | null;
}

export const ExpressionChildrenInnerOperatorEnum = {
    And: 'AND',
    Equals: 'EQUALS'
} as const;

export type ExpressionChildrenInnerOperatorEnum = typeof ExpressionChildrenInnerOperatorEnum[keyof typeof ExpressionChildrenInnerOperatorEnum];

/**
 * Attributes related to an external trigger
 * @export
 * @interface ExternalAttributes
 */
export interface ExternalAttributes {
    /**
     * A unique name for the external trigger
     * @type {string}
     * @memberof ExternalAttributes
     */
    'name': string;
    /**
     * Additonal context about the external trigger
     * @type {string}
     * @memberof ExternalAttributes
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface FieldDetailsDto
 */
export interface FieldDetailsDto {
    /**
     * The name of the attribute.
     * @type {string}
     * @memberof FieldDetailsDto
     */
    'name'?: string;
    /**
     * The transform to apply to the field
     * @type {object}
     * @memberof FieldDetailsDto
     */
    'transform'?: object;
    /**
     * Attributes required for the transform
     * @type {object}
     * @memberof FieldDetailsDto
     */
    'attributes'?: object;
    /**
     * Flag indicating whether or not the attribute is required.
     * @type {boolean}
     * @memberof FieldDetailsDto
     */
    'isRequired'?: boolean;
    /**
     * The type of the attribute.
     * @type {string}
     * @memberof FieldDetailsDto
     */
    'type'?: string;
    /**
     * Flag indicating whether or not the attribute is multi-valued.
     * @type {boolean}
     * @memberof FieldDetailsDto
     */
    'isMultiValued'?: boolean;
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {FilterType}
     * @memberof Filter
     */
    'type'?: FilterType;
    /**
     * 
     * @type {Range}
     * @memberof Filter
     */
    'range'?: Range;
    /**
     * The terms to be filtered.
     * @type {Array<string>}
     * @memberof Filter
     */
    'terms'?: Array<string>;
    /**
     * Indicates if the filter excludes results.
     * @type {boolean}
     * @memberof Filter
     */
    'exclude'?: boolean;
}
/**
 * An additional filter to constrain the results of the search query.
 * @export
 * @interface FilterAggregation
 */
export interface FilterAggregation {
    /**
     * The name of the filter aggregate to be included in the result.
     * @type {string}
     * @memberof FilterAggregation
     */
    'name': string;
    /**
     * 
     * @type {SearchFilterType}
     * @memberof FilterAggregation
     */
    'type'?: SearchFilterType;
    /**
     * The search field to apply the filter to.  Prefix the field name with \'@\' to reference a nested object. 
     * @type {string}
     * @memberof FilterAggregation
     */
    'field': string;
    /**
     * The value to filter on.
     * @type {string}
     * @memberof FilterAggregation
     */
    'value': string;
}
/**
 * Enum representing the currently supported filter types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const FilterType = {
    Exists: 'EXISTS',
    Range: 'RANGE',
    Terms: 'TERMS'
} as const;

export type FilterType = typeof FilterType[keyof typeof FilterType];


/**
 * 
 * @export
 * @interface FirstValid
 */
export interface FirstValid {
    /**
     * An array of attributes to evaluate for existence.
     * @type {Array<object>}
     * @memberof FirstValid
     */
    'values': Array<object>;
    /**
     * a true or false value representing to move on to the next option if an error (like an Null Pointer Exception) were to occur.
     * @type {boolean}
     * @memberof FirstValid
     */
    'ignoreErrors'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof FirstValid
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface FormDetails
 */
export interface FormDetails {
    /**
     * ID of the form
     * @type {string}
     * @memberof FormDetails
     */
    'id'?: string | null;
    /**
     * Name of the form
     * @type {string}
     * @memberof FormDetails
     */
    'name'?: string | null;
    /**
     * The form title
     * @type {string}
     * @memberof FormDetails
     */
    'title'?: string;
    /**
     * The form subtitle.
     * @type {string}
     * @memberof FormDetails
     */
    'subtitle'?: string;
    /**
     * The name of the user that should be shown this form
     * @type {string}
     * @memberof FormDetails
     */
    'targetUser'?: string;
    /**
     * Sections of the form
     * @type {Array<SectionDetails>}
     * @memberof FormDetails
     */
    'sections'?: Array<SectionDetails>;
}
/**
 * 
 * @export
 * @interface FormItemDetails
 */
export interface FormItemDetails {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof FormItemDetails
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ForwardApprovalDto
 */
export interface ForwardApprovalDto {
    /**
     * The Id of the new owner
     * @type {string}
     * @memberof ForwardApprovalDto
     */
    'newOwnerId': string;
    /**
     * The comment provided by the forwarder
     * @type {string}
     * @memberof ForwardApprovalDto
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface GenerateRandomString
 */
export interface GenerateRandomString {
    /**
     * This must always be set to \"Cloud Services Deployment Utility\"
     * @type {string}
     * @memberof GenerateRandomString
     */
    'name': string;
    /**
     * The operation to perform `generateRandomString`
     * @type {string}
     * @memberof GenerateRandomString
     */
    'operation': string;
    /**
     * This must be either \"true\" or \"false\" to indicate whether the generator logic should include numbers
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'includeNumbers': boolean;
    /**
     * This must be either \"true\" or \"false\" to indicate whether the generator logic should include special characters
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'includeSpecialChars': boolean;
    /**
     * This specifies how long the randomly generated string needs to be   >NOTE Due to identity attribute data constraints, the maximum allowable value is 450 characters 
     * @type {string}
     * @memberof GenerateRandomString
     */
    'length': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface GenericRule
 */
export interface GenericRule {
    /**
     * This is the name of the Generic rule that needs to be invoked by the transform
     * @type {string}
     * @memberof GenericRule
     */
    'name': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GenericRule
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * @type GetActiveCampaigns200ResponseInner
 * @export
 */
export type GetActiveCampaigns200ResponseInner = Campaign | SlimCampaign;

/**
 * 
 * @export
 * @interface GetOAuthClientResponse
 */
export interface GetOAuthClientResponse {
    /**
     * ID of the OAuth client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'id': string;
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'businessName': string | null;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'homepageUrl': string | null;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'name': string;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'description': string | null;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof GetOAuthClientResponse
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof GetOAuthClientResponse
     */
    'refreshTokenValiditySeconds': number;
    /**
     * A list of the approved redirect URIs used with the authorization_code flow
     * @type {Array<string>}
     * @memberof GetOAuthClientResponse
     */
    'redirectUris': Array<string> | null;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof GetOAuthClientResponse
     */
    'grantTypes': Array<GrantType>;
    /**
     * 
     * @type {AccessType}
     * @memberof GetOAuthClientResponse
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof GetOAuthClientResponse
     */
    'type': ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal to IDN
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'internal': boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'strongAuthSupported': boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'claimsSupported': boolean;
    /**
     * The date and time, down to the millisecond, when the API Client was created
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when the API Client was last updated
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'modified': string;
    /**
     * The date and time, down to the millisecond, when this API Client was last used to generate an access token. This timestamp does not get updated on every API Client usage, but only once a day. This property can be useful for identifying which API Clients are no longer actively used and can be removed.
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'lastUsed'?: string | null;
    /**
     * Scopes of the API Client.
     * @type {Array<string>}
     * @memberof GetOAuthClientResponse
     */
    'scope': Array<string> | null;
}
/**
 * 
 * @export
 * @interface GetPersonalAccessTokenResponse
 */
export interface GetPersonalAccessTokenResponse {
    /**
     * The ID of the personal access token (to be used as the username for Basic Auth).
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'id': string;
    /**
     * The name of the personal access token. Cannot be the same as other personal access tokens owned by a user.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'name': string;
    /**
     * Scopes of the personal  access token.
     * @type {Array<string>}
     * @memberof GetPersonalAccessTokenResponse
     */
    'scope': Array<string> | null;
    /**
     * 
     * @type {PatOwner}
     * @memberof GetPersonalAccessTokenResponse
     */
    'owner': PatOwner;
    /**
     * The date and time, down to the millisecond, when this personal access token was created.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when this personal access token was last used to generate an access token. This timestamp does not get updated on every PAT usage, but only once a day. This property can be useful for identifying which PATs are no longer actively used and can be removed.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'lastUsed'?: string | null;
    /**
     * If true, this token is managed by the SailPoint platform, and is not visible in the user interface. For example, Workflows will create managed personal access tokens for users who create workflows.
     * @type {boolean}
     * @memberof GetPersonalAccessTokenResponse
     */
    'managed'?: boolean;
}
/**
 * 
 * @export
 * @interface GetReferenceIdentityAttribute
 */
export interface GetReferenceIdentityAttribute {
    /**
     * This must always be set to \"Cloud Services Deployment Utility\"
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'name': string;
    /**
     * The operation to perform `getReferenceIdentityAttribute`
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'operation': string;
    /**
     * This is the SailPoint User Name (uid) value of the identity whose attribute is desired  As a convenience feature, you can use the `manager` keyword to dynamically look up the user\'s manager and then get that manager\'s identity attribute. 
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'uid': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GetReferenceIdentityAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * OAuth2 Grant Type
 * @export
 * @enum {string}
 */

export const GrantType = {
    ClientCredentials: 'CLIENT_CREDENTIALS',
    AuthorizationCode: 'AUTHORIZATION_CODE',
    RefreshToken: 'REFRESH_TOKEN'
} as const;

export type GrantType = typeof GrantType[keyof typeof GrantType];


/**
 * 
 * @export
 * @interface ISO3166
 */
export interface ISO3166 {
    /**
     * An optional value to denote which ISO 3166 format to return. Valid values are:   `alpha2` - Two-character country code (e.g., \"US\"); this is the default value if no format is supplied   `alpha3` - Three-character country code (e.g., \"USA\")   `numeric` - The numeric country code (e.g., \"840\") 
     * @type {string}
     * @memberof ISO3166
     */
    'format'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof ISO3166
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof ISO3166
     */
    'input'?: { [key: string]: any; };
}
/**
 * Arguments for Identities details report (IDENTITIES_DETAILS)
 * @export
 * @interface IdentitiesDetailsReportArguments
 */
export interface IdentitiesDetailsReportArguments {
    /**
     * Boolean FLAG to specify if only correlated identities should be used in report processing
     * @type {boolean}
     * @memberof IdentitiesDetailsReportArguments
     */
    'correlatedOnly': boolean;
}
/**
 * Arguments for Identities report (IDENTITIES)
 * @export
 * @interface IdentitiesReportArguments
 */
export interface IdentitiesReportArguments {
    /**
     * Boolean FLAG to specify if only correlated identities should be used in report processing
     * @type {boolean}
     * @memberof IdentitiesReportArguments
     */
    'correlatedOnly'?: boolean;
}
/**
 * @type IdentityAccess
 * @export
 */
export type IdentityAccess = AccessProfileEntitlement | AccessProfileRole | AccessProfileSummary;

/**
 * 
 * @export
 * @interface IdentityAttribute
 */
export interface IdentityAttribute {
    /**
     * The system (camel-cased) name of the identity attribute to bring in
     * @type {string}
     * @memberof IdentityAttribute
     */
    'name': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof IdentityAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof IdentityAttribute
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface IdentityAttribute1
 */
export interface IdentityAttribute1 {
    /**
     * The attribute key
     * @type {string}
     * @memberof IdentityAttribute1
     */
    'key'?: string;
    /**
     * Human-readable display name of the attribute
     * @type {string}
     * @memberof IdentityAttribute1
     */
    'name'?: string;
    /**
     * The attribute value
     * @type {string}
     * @memberof IdentityAttribute1
     */
    'value'?: string;
}
/**
 * Defines all the identity attribute mapping configurations. This defines how to generate or collect data for each identity attributes in identity refresh process.
 * @export
 * @interface IdentityAttributeConfig
 */
export interface IdentityAttributeConfig {
    /**
     * The backend will only promote values if the profile/mapping is enabled.
     * @type {boolean}
     * @memberof IdentityAttributeConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<IdentityAttributeTransform>}
     * @memberof IdentityAttributeConfig
     */
    'attributeTransforms'?: Array<IdentityAttributeTransform>;
}
/**
 * Defines a transformation definition for an identity attribute.
 * @export
 * @interface IdentityAttributeTransform
 */
export interface IdentityAttributeTransform {
    /**
     * Name of the identity attribute.
     * @type {string}
     * @memberof IdentityAttributeTransform
     */
    'identityAttributeName'?: string;
    /**
     * 
     * @type {TransformDefinition}
     * @memberof IdentityAttributeTransform
     */
    'transformDefinition'?: TransformDefinition;
}
/**
 * 
 * @export
 * @interface IdentityCertDecisionSummary
 */
export interface IdentityCertDecisionSummary {
    /**
     * Number of entitlement decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementDecisionsMade'?: number;
    /**
     * Number of access profile decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfileDecisionsMade'?: number;
    /**
     * Number of role decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'roleDecisionsMade'?: number;
    /**
     * Number of account decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountDecisionsMade'?: number;
    /**
     * The total number of entitlement decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementDecisionsTotal'?: number;
    /**
     * The total number of access profile decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfileDecisionsTotal'?: number;
    /**
     * The total number of role decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'roleDecisionsTotal'?: number;
    /**
     * The total number of account decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountDecisionsTotal'?: number;
    /**
     * The number of entitlement decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementsApproved'?: number;
    /**
     * The number of entitlement decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementsRevoked'?: number;
    /**
     * The number of access profile decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfilesApproved'?: number;
    /**
     * The number of access profile decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfilesRevoked'?: number;
    /**
     * The number of role decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'rolesApproved'?: number;
    /**
     * The number of role decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'rolesRevoked'?: number;
    /**
     * The number of account decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountsApproved'?: number;
    /**
     * The number of account decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountsRevoked'?: number;
}
/**
 * 
 * @export
 * @interface IdentityCertificationDto
 */
export interface IdentityCertificationDto {
    /**
     * id of the certification
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'id'?: string;
    /**
     * name of the certification
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'name'?: string;
    /**
     * 
     * @type {CampaignReference}
     * @memberof IdentityCertificationDto
     */
    'campaign'?: CampaignReference;
    /**
     * Have all decisions been made?
     * @type {boolean}
     * @memberof IdentityCertificationDto
     */
    'completed'?: boolean;
    /**
     * The number of identities for whom all decisions have been made and are complete.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'identitiesCompleted'?: number;
    /**
     * The total number of identities in the Certification, both complete and incomplete.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'identitiesTotal'?: number;
    /**
     * created date
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'created'?: string;
    /**
     * modified date
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'modified'?: string;
    /**
     * The number of approve/revoke/acknowledge decisions that have been made.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'decisionsMade'?: number;
    /**
     * The total number of approve/revoke/acknowledge decisions.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'decisionsTotal'?: number;
    /**
     * The due date of the certification.
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'due'?: string;
    /**
     * The date the reviewer signed off on the Certification.
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'signed'?: string | null;
    /**
     * 
     * @type {Reviewer}
     * @memberof IdentityCertificationDto
     */
    'reviewer'?: Reviewer;
    /**
     * 
     * @type {Reassignment}
     * @memberof IdentityCertificationDto
     */
    'reassignment'?: Reassignment | null;
    /**
     * Identifies if the certification has an error
     * @type {boolean}
     * @memberof IdentityCertificationDto
     */
    'hasErrors'?: boolean;
    /**
     * Description of the certification error
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'errorMessage'?: string | null;
    /**
     * 
     * @type {CertificationPhase}
     * @memberof IdentityCertificationDto
     */
    'phase'?: CertificationPhase;
}
/**
 * Identity
 * @export
 * @interface IdentityDocument
 */
export interface IdentityDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof IdentityDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof IdentityDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof IdentityDocument
     */
    '_type': DocumentType;
    /**
     * Identity\'s display name.
     * @type {string}
     * @memberof IdentityDocument
     */
    'displayName'?: string;
    /**
     * Identity\'s first name.
     * @type {string}
     * @memberof IdentityDocument
     */
    'firstName'?: string;
    /**
     * Identity\'s last name.
     * @type {string}
     * @memberof IdentityDocument
     */
    'lastName'?: string;
    /**
     * Identity\'s primary email address.
     * @type {string}
     * @memberof IdentityDocument
     */
    'email'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof IdentityDocument
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof IdentityDocument
     */
    'modified'?: string | null;
    /**
     * Identity\'s phone number.
     * @type {string}
     * @memberof IdentityDocument
     */
    'phone'?: string;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof IdentityDocument
     */
    'synced'?: string;
    /**
     * Indicates whether the identity is inactive.
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'inactive'?: boolean;
    /**
     * Indicates whether the identity is protected.
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'protected'?: boolean;
    /**
     * Identity\'s status in SailPoint.
     * @type {string}
     * @memberof IdentityDocument
     */
    'status'?: string;
    /**
     * Identity\'s employee number.
     * @type {string}
     * @memberof IdentityDocument
     */
    'employeeNumber'?: string;
    /**
     * 
     * @type {IdentityDocumentAllOfManager}
     * @memberof IdentityDocument
     */
    'manager'?: IdentityDocumentAllOfManager | null;
    /**
     * Indicates whether the identity is a manager of other identities.
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'isManager'?: boolean;
    /**
     * 
     * @type {IdentityDocumentAllOfIdentityProfile}
     * @memberof IdentityDocument
     */
    'identityProfile'?: IdentityDocumentAllOfIdentityProfile;
    /**
     * 
     * @type {IdentityDocumentAllOfSource}
     * @memberof IdentityDocument
     */
    'source'?: IdentityDocumentAllOfSource;
    /**
     * Map or dictionary of key/value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof IdentityDocument
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Identity\'s processing state.
     * @type {string}
     * @memberof IdentityDocument
     */
    'processingState'?: string | null;
    /**
     * 
     * @type {ProcessingDetails}
     * @memberof IdentityDocument
     */
    'processingDetails'?: ProcessingDetails;
    /**
     * List of accounts associated with the identity.
     * @type {Array<BaseAccount>}
     * @memberof IdentityDocument
     */
    'accounts'?: Array<BaseAccount>;
    /**
     * Number of accounts associated with the identity.
     * @type {number}
     * @memberof IdentityDocument
     */
    'accountCount'?: number;
    /**
     * List of applications the identity has access to.
     * @type {Array<App>}
     * @memberof IdentityDocument
     */
    'apps'?: Array<App>;
    /**
     * Number of applications the identity has access to.
     * @type {number}
     * @memberof IdentityDocument
     */
    'appCount'?: number;
    /**
     * List of access items assigned to the identity.
     * @type {Array<IdentityAccess>}
     * @memberof IdentityDocument
     */
    'access'?: Array<IdentityAccess>;
    /**
     * Number of access items assigned to the identity.
     * @type {number}
     * @memberof IdentityDocument
     */
    'accessCount'?: number;
    /**
     * Number of entitlements assigned to the identity.
     * @type {number}
     * @memberof IdentityDocument
     */
    'entitlementCount'?: number;
    /**
     * Number of roles assigned to the identity.
     * @type {number}
     * @memberof IdentityDocument
     */
    'roleCount'?: number;
    /**
     * Number of access profiles assigned to the identity.
     * @type {number}
     * @memberof IdentityDocument
     */
    'accessProfileCount'?: number;
    /**
     * Access items the identity owns.
     * @type {Array<Owns>}
     * @memberof IdentityDocument
     */
    'owns'?: Array<Owns>;
    /**
     * Number of access items the identity owns.
     * @type {number}
     * @memberof IdentityDocument
     */
    'ownsCount'?: number;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof IdentityDocument
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IdentityDocumentAllOf
 */
export interface IdentityDocumentAllOf {
    /**
     * Identity\'s display name.
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'displayName'?: string;
    /**
     * Identity\'s first name.
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'firstName'?: string;
    /**
     * Identity\'s last name.
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'lastName'?: string;
    /**
     * Identity\'s primary email address.
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'email'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'modified'?: string | null;
    /**
     * Identity\'s phone number.
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'phone'?: string;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'synced'?: string;
    /**
     * Indicates whether the identity is inactive.
     * @type {boolean}
     * @memberof IdentityDocumentAllOf
     */
    'inactive'?: boolean;
    /**
     * Indicates whether the identity is protected.
     * @type {boolean}
     * @memberof IdentityDocumentAllOf
     */
    'protected'?: boolean;
    /**
     * Identity\'s status in SailPoint.
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'status'?: string;
    /**
     * Identity\'s employee number.
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'employeeNumber'?: string;
    /**
     * 
     * @type {IdentityDocumentAllOfManager}
     * @memberof IdentityDocumentAllOf
     */
    'manager'?: IdentityDocumentAllOfManager | null;
    /**
     * Indicates whether the identity is a manager of other identities.
     * @type {boolean}
     * @memberof IdentityDocumentAllOf
     */
    'isManager'?: boolean;
    /**
     * 
     * @type {IdentityDocumentAllOfIdentityProfile}
     * @memberof IdentityDocumentAllOf
     */
    'identityProfile'?: IdentityDocumentAllOfIdentityProfile;
    /**
     * 
     * @type {IdentityDocumentAllOfSource}
     * @memberof IdentityDocumentAllOf
     */
    'source'?: IdentityDocumentAllOfSource;
    /**
     * Map or dictionary of key/value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof IdentityDocumentAllOf
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Identity\'s processing state.
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'processingState'?: string | null;
    /**
     * 
     * @type {ProcessingDetails}
     * @memberof IdentityDocumentAllOf
     */
    'processingDetails'?: ProcessingDetails;
    /**
     * List of accounts associated with the identity.
     * @type {Array<BaseAccount>}
     * @memberof IdentityDocumentAllOf
     */
    'accounts'?: Array<BaseAccount>;
    /**
     * Number of accounts associated with the identity.
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'accountCount'?: number;
    /**
     * List of applications the identity has access to.
     * @type {Array<App>}
     * @memberof IdentityDocumentAllOf
     */
    'apps'?: Array<App>;
    /**
     * Number of applications the identity has access to.
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'appCount'?: number;
    /**
     * List of access items assigned to the identity.
     * @type {Array<IdentityAccess>}
     * @memberof IdentityDocumentAllOf
     */
    'access'?: Array<IdentityAccess>;
    /**
     * Number of access items assigned to the identity.
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'accessCount'?: number;
    /**
     * Number of entitlements assigned to the identity.
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'entitlementCount'?: number;
    /**
     * Number of roles assigned to the identity.
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'roleCount'?: number;
    /**
     * Number of access profiles assigned to the identity.
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'accessProfileCount'?: number;
    /**
     * Access items the identity owns.
     * @type {Array<Owns>}
     * @memberof IdentityDocumentAllOf
     */
    'owns'?: Array<Owns>;
    /**
     * Number of access items the identity owns.
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'ownsCount'?: number;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof IdentityDocumentAllOf
     */
    'tags'?: Array<string>;
}
/**
 * Identity\'s identity profile.
 * @export
 * @interface IdentityDocumentAllOfIdentityProfile
 */
export interface IdentityDocumentAllOfIdentityProfile {
    /**
     * Identity profile\'s ID.
     * @type {string}
     * @memberof IdentityDocumentAllOfIdentityProfile
     */
    'id'?: string;
    /**
     * Identity profile\'s name.
     * @type {string}
     * @memberof IdentityDocumentAllOfIdentityProfile
     */
    'name'?: string;
}
/**
 * Identity\'s manager.
 * @export
 * @interface IdentityDocumentAllOfManager
 */
export interface IdentityDocumentAllOfManager {
    /**
     * ID of identity\'s manager.
     * @type {string}
     * @memberof IdentityDocumentAllOfManager
     */
    'id'?: string;
    /**
     * Name of identity\'s manager.
     * @type {string}
     * @memberof IdentityDocumentAllOfManager
     */
    'name'?: string;
    /**
     * Display name of identity\'s manager.
     * @type {string}
     * @memberof IdentityDocumentAllOfManager
     */
    'displayName'?: string;
}
/**
 * Identity\'s source.
 * @export
 * @interface IdentityDocumentAllOfSource
 */
export interface IdentityDocumentAllOfSource {
    /**
     * ID of identity\'s source.
     * @type {string}
     * @memberof IdentityDocumentAllOfSource
     */
    'id'?: string;
    /**
     * Display name of identity\'s source.
     * @type {string}
     * @memberof IdentityDocumentAllOfSource
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface IdentityExceptionReportReference
 */
export interface IdentityExceptionReportReference {
    /**
     * The id of the task result.
     * @type {string}
     * @memberof IdentityExceptionReportReference
     */
    'taskResultId'?: string;
    /**
     * The name of the report.
     * @type {string}
     * @memberof IdentityExceptionReportReference
     */
    'reportName'?: string;
}
/**
 * 
 * @export
 * @interface IdentityProfile
 */
export interface IdentityProfile {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'modified'?: string;
    /**
     * The description of the Identity Profile.
     * @type {string}
     * @memberof IdentityProfile
     */
    'description'?: string | null;
    /**
     * 
     * @type {IdentityProfileAllOfOwner}
     * @memberof IdentityProfile
     */
    'owner'?: IdentityProfileAllOfOwner | null;
    /**
     * The priority for an Identity Profile.
     * @type {number}
     * @memberof IdentityProfile
     */
    'priority'?: number;
    /**
     * 
     * @type {IdentityProfileAllOfAuthoritativeSource}
     * @memberof IdentityProfile
     */
    'authoritativeSource': IdentityProfileAllOfAuthoritativeSource;
    /**
     * True if a identity refresh is needed. Typically triggered when a change on the source has been made.
     * @type {boolean}
     * @memberof IdentityProfile
     */
    'identityRefreshRequired'?: boolean;
    /**
     * The number of identities that belong to the Identity Profile.
     * @type {number}
     * @memberof IdentityProfile
     */
    'identityCount'?: number;
    /**
     * 
     * @type {IdentityAttributeConfig}
     * @memberof IdentityProfile
     */
    'identityAttributeConfig'?: IdentityAttributeConfig;
    /**
     * 
     * @type {IdentityExceptionReportReference}
     * @memberof IdentityProfile
     */
    'identityExceptionReportReference'?: IdentityExceptionReportReference | null;
    /**
     * Indicates the value of requiresPeriodicRefresh attribute for the Identity Profile.
     * @type {boolean}
     * @memberof IdentityProfile
     */
    'hasTimeBasedAttr'?: boolean;
}
/**
 * 
 * @export
 * @interface IdentityProfileAllOf
 */
export interface IdentityProfileAllOf {
    /**
     * The description of the Identity Profile.
     * @type {string}
     * @memberof IdentityProfileAllOf
     */
    'description'?: string | null;
    /**
     * 
     * @type {IdentityProfileAllOfOwner}
     * @memberof IdentityProfileAllOf
     */
    'owner'?: IdentityProfileAllOfOwner | null;
    /**
     * The priority for an Identity Profile.
     * @type {number}
     * @memberof IdentityProfileAllOf
     */
    'priority'?: number;
    /**
     * 
     * @type {IdentityProfileAllOfAuthoritativeSource}
     * @memberof IdentityProfileAllOf
     */
    'authoritativeSource': IdentityProfileAllOfAuthoritativeSource;
    /**
     * True if a identity refresh is needed. Typically triggered when a change on the source has been made.
     * @type {boolean}
     * @memberof IdentityProfileAllOf
     */
    'identityRefreshRequired'?: boolean;
    /**
     * The number of identities that belong to the Identity Profile.
     * @type {number}
     * @memberof IdentityProfileAllOf
     */
    'identityCount'?: number;
    /**
     * 
     * @type {IdentityAttributeConfig}
     * @memberof IdentityProfileAllOf
     */
    'identityAttributeConfig'?: IdentityAttributeConfig;
    /**
     * 
     * @type {IdentityExceptionReportReference}
     * @memberof IdentityProfileAllOf
     */
    'identityExceptionReportReference'?: IdentityExceptionReportReference | null;
    /**
     * Indicates the value of requiresPeriodicRefresh attribute for the Identity Profile.
     * @type {boolean}
     * @memberof IdentityProfileAllOf
     */
    'hasTimeBasedAttr'?: boolean;
}
/**
 * 
 * @export
 * @interface IdentityProfileAllOfAuthoritativeSource
 */
export interface IdentityProfileAllOfAuthoritativeSource {
    /**
     * Type of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'type'?: IdentityProfileAllOfAuthoritativeSourceTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'name'?: string;
}

export const IdentityProfileAllOfAuthoritativeSourceTypeEnum = {
    Source: 'SOURCE'
} as const;

export type IdentityProfileAllOfAuthoritativeSourceTypeEnum = typeof IdentityProfileAllOfAuthoritativeSourceTypeEnum[keyof typeof IdentityProfileAllOfAuthoritativeSourceTypeEnum];

/**
 * The owner of the Identity Profile.
 * @export
 * @interface IdentityProfileAllOfOwner
 */
export interface IdentityProfileAllOfOwner {
    /**
     * Type of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'type'?: IdentityProfileAllOfOwnerTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'name'?: string;
}

export const IdentityProfileAllOfOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type IdentityProfileAllOfOwnerTypeEnum = typeof IdentityProfileAllOfOwnerTypeEnum[keyof typeof IdentityProfileAllOfOwnerTypeEnum];

/**
 * Identity profile exported object.
 * @export
 * @interface IdentityProfileExportedObject
 */
export interface IdentityProfileExportedObject {
    /**
     * Version or object from the target service.
     * @type {number}
     * @memberof IdentityProfileExportedObject
     */
    'version'?: number;
    /**
     * 
     * @type {IdentityProfileExportedObjectSelf}
     * @memberof IdentityProfileExportedObject
     */
    'self'?: IdentityProfileExportedObjectSelf;
    /**
     * 
     * @type {IdentityProfile}
     * @memberof IdentityProfileExportedObject
     */
    'object'?: IdentityProfile;
}
/**
 * Self block for exported object.
 * @export
 * @interface IdentityProfileExportedObjectSelf
 */
export interface IdentityProfileExportedObjectSelf {
    /**
     * Exported object\'s DTO type.
     * @type {string}
     * @memberof IdentityProfileExportedObjectSelf
     */
    'type'?: IdentityProfileExportedObjectSelfTypeEnum;
    /**
     * Exported object\'s ID.
     * @type {string}
     * @memberof IdentityProfileExportedObjectSelf
     */
    'id'?: string;
    /**
     * Exported object\'s display name.
     * @type {string}
     * @memberof IdentityProfileExportedObjectSelf
     */
    'name'?: string;
}

export const IdentityProfileExportedObjectSelfTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    Segment: 'SEGMENT',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflow: 'WORKFLOW'
} as const;

export type IdentityProfileExportedObjectSelfTypeEnum = typeof IdentityProfileExportedObjectSelfTypeEnum[keyof typeof IdentityProfileExportedObjectSelfTypeEnum];

/**
 * Arguments for Identity Profile Identity Error report (IDENTITY_PROFILE_IDENTITY_ERROR)
 * @export
 * @interface IdentityProfileIdentityErrorReportArguments
 */
export interface IdentityProfileIdentityErrorReportArguments {
    /**
     * Source Id to be checked on errors of identity profiles aggregation
     * @type {string}
     * @memberof IdentityProfileIdentityErrorReportArguments
     */
    'authoritativeSource': string;
}
/**
 * The manager for the identity.
 * @export
 * @interface IdentityReference
 */
export interface IdentityReference {
    /**
     * 
     * @type {DtoType}
     * @memberof IdentityReference
     */
    'type'?: DtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof IdentityReference
     */
    'id'?: string;
    /**
     * Human-readable display name of identity.
     * @type {string}
     * @memberof IdentityReference
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface IdentityReferenceWithNameAndEmail
 */
export interface IdentityReferenceWithNameAndEmail {
    /**
     * The type can only be IDENTITY. This is read-only.
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'type'?: string;
    /**
     * Identity ID.
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'id'?: string;
    /**
     * Identity\'s human-readable display name. This is read-only.
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'name'?: string;
    /**
     * Identity\'s email address. This is read-only.
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface IdentitySummary
 */
export interface IdentitySummary {
    /**
     * ID of this identity summary
     * @type {string}
     * @memberof IdentitySummary
     */
    'id'?: string;
    /**
     * Human-readable display name of identity
     * @type {string}
     * @memberof IdentitySummary
     */
    'name'?: string;
    /**
     * ID of the identity that this summary represents
     * @type {string}
     * @memberof IdentitySummary
     */
    'identityId'?: string;
    /**
     * Indicates if all access items for this summary have been decided on
     * @type {boolean}
     * @memberof IdentitySummary
     */
    'completed'?: boolean;
}
/**
 * An identity with a set of access to be added
 * @export
 * @interface IdentityWithNewAccess
 */
export interface IdentityWithNewAccess {
    /**
     * Identity id to be checked.
     * @type {string}
     * @memberof IdentityWithNewAccess
     */
    'identityId': string;
    /**
     * The list of entitlements to consider for possible violations in a preventive check.
     * @type {Array<IdentityWithNewAccessAccessRefsInner>}
     * @memberof IdentityWithNewAccess
     */
    'accessRefs': Array<IdentityWithNewAccessAccessRefsInner>;
}
/**
 * An identity with a set of access to be added
 * @export
 * @interface IdentityWithNewAccess1
 */
export interface IdentityWithNewAccess1 {
    /**
     * Set of identity IDs to be checked.
     * @type {string}
     * @memberof IdentityWithNewAccess1
     */
    'identityId': string;
    /**
     * The bundle of access profiles to be added to the identities specified. All references must be ENTITLEMENT type.
     * @type {Array<IdentityWithNewAccess1AccessRefsInner>}
     * @memberof IdentityWithNewAccess1
     */
    'accessRefs': Array<IdentityWithNewAccess1AccessRefsInner>;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on completion of the violation check.
     * @type {{ [key: string]: string; }}
     * @memberof IdentityWithNewAccess1
     */
    'clientMetadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface IdentityWithNewAccess1AccessRefsInner
 */
export interface IdentityWithNewAccess1AccessRefsInner {
    /**
     * Entitlement\'s DTO type.
     * @type {string}
     * @memberof IdentityWithNewAccess1AccessRefsInner
     */
    'type'?: IdentityWithNewAccess1AccessRefsInnerTypeEnum;
    /**
     * Entitlement\'s ID.
     * @type {string}
     * @memberof IdentityWithNewAccess1AccessRefsInner
     */
    'id'?: string;
    /**
     * Entitlement\'s display name.
     * @type {string}
     * @memberof IdentityWithNewAccess1AccessRefsInner
     */
    'name'?: string;
}

export const IdentityWithNewAccess1AccessRefsInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type IdentityWithNewAccess1AccessRefsInnerTypeEnum = typeof IdentityWithNewAccess1AccessRefsInnerTypeEnum[keyof typeof IdentityWithNewAccess1AccessRefsInnerTypeEnum];

/**
 * Entitlement including a specific set of access.
 * @export
 * @interface IdentityWithNewAccessAccessRefsInner
 */
export interface IdentityWithNewAccessAccessRefsInner {
    /**
     * Entitlement\'s DTO type.
     * @type {string}
     * @memberof IdentityWithNewAccessAccessRefsInner
     */
    'type'?: IdentityWithNewAccessAccessRefsInnerTypeEnum;
    /**
     * Entitlement\'s ID.
     * @type {string}
     * @memberof IdentityWithNewAccessAccessRefsInner
     */
    'id'?: string;
    /**
     * Entitlement\'s display name.
     * @type {string}
     * @memberof IdentityWithNewAccessAccessRefsInner
     */
    'name'?: string;
}

export const IdentityWithNewAccessAccessRefsInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type IdentityWithNewAccessAccessRefsInnerTypeEnum = typeof IdentityWithNewAccessAccessRefsInnerTypeEnum[keyof typeof IdentityWithNewAccessAccessRefsInnerTypeEnum];

/**
 * 
 * @export
 * @interface ImportNonEmployeeRecordsInBulkRequest
 */
export interface ImportNonEmployeeRecordsInBulkRequest {
    /**
     * 
     * @type {any}
     * @memberof ImportNonEmployeeRecordsInBulkRequest
     */
    'data': any;
}
/**
 * Object created or updated by import.
 * @export
 * @interface ImportObject
 */
export interface ImportObject {
    /**
     * DTO type of object created or updated by import.
     * @type {string}
     * @memberof ImportObject
     */
    'type'?: ImportObjectTypeEnum;
    /**
     * ID of object created or updated by import.
     * @type {string}
     * @memberof ImportObject
     */
    'id'?: string;
    /**
     * Display name of object created or updated by import.
     * @type {string}
     * @memberof ImportObject
     */
    'name'?: string;
}

export const ImportObjectTypeEnum = {
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    Rule: 'RULE',
    Source: 'SOURCE',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION'
} as const;

export type ImportObjectTypeEnum = typeof ImportObjectTypeEnum[keyof typeof ImportObjectTypeEnum];

/**
 * 
 * @export
 * @interface ImportUploadedBackupRequest
 */
export interface ImportUploadedBackupRequest {
    /**
     * JSON file containing the objects to be imported.
     * @type {any}
     * @memberof ImportUploadedBackupRequest
     */
    'data': any;
    /**
     * Name that will be assigned to the uploaded file.
     * @type {string}
     * @memberof ImportUploadedBackupRequest
     */
    'name': string;
}
/**
 * Enum representing the currently supported indices. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const Index = {
    Accessprofiles: 'accessprofiles',
    Accountactivities: 'accountactivities',
    Entitlements: 'entitlements',
    Events: 'events',
    Identities: 'identities',
    Roles: 'roles',
    Star: '*'
} as const;

export type Index = typeof Index[keyof typeof Index];


/**
 * 
 * @export
 * @interface IndexOf
 */
export interface IndexOf {
    /**
     * A substring to search for, searches the entire calling string, and returns the index of the first occurrence of the specified substring.
     * @type {string}
     * @memberof IndexOf
     */
    'substring': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof IndexOf
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof IndexOf
     */
    'input'?: { [key: string]: any; };
}
/**
 * Inner Hit query object that will cause the specified nested type to be returned as the result matching the supplied query.
 * @export
 * @interface InnerHit
 */
export interface InnerHit {
    /**
     * The search query using the Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL extended by SailPoint to support Nested queries.
     * @type {string}
     * @memberof InnerHit
     */
    'query': string;
    /**
     * The nested type to use in the inner hits query.  The nested type [Nested Type](https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html) refers to a document \"nested\" within another document. For example, an identity can have nested documents for access, accounts, and apps.
     * @type {string}
     * @memberof InnerHit
     */
    'type': string;
}
/**
 * A JSONPatch Operation as defined by [RFC 6902 - JSON Patch](https://tools.ietf.org/html/rfc6902)
 * @export
 * @interface JsonPatchOperation
 */
export interface JsonPatchOperation {
    /**
     * The operation to be performed
     * @type {string}
     * @memberof JsonPatchOperation
     */
    'op': JsonPatchOperationOpEnum;
    /**
     * A string JSON Pointer representing the target path to an element to be affected by the operation
     * @type {string}
     * @memberof JsonPatchOperation
     */
    'path': string;
    /**
     * 
     * @type {JsonPatchOperationValue}
     * @memberof JsonPatchOperation
     */
    'value'?: JsonPatchOperationValue;
}

export const JsonPatchOperationOpEnum = {
    Add: 'add',
    Remove: 'remove',
    Replace: 'replace',
    Move: 'move',
    Copy: 'copy',
    Test: 'test'
} as const;

export type JsonPatchOperationOpEnum = typeof JsonPatchOperationOpEnum[keyof typeof JsonPatchOperationOpEnum];

/**
 * @type JsonPatchOperationValue
 * The value to be used for the operation, required for \"add\" and \"replace\" operations
 * @export
 */
export type JsonPatchOperationValue = Array<ArrayInner> | boolean | number | object | string;

/**
 * 
 * @export
 * @interface KbaAnswerRequestItem
 */
export interface KbaAnswerRequestItem {
    /**
     * Question Id
     * @type {string}
     * @memberof KbaAnswerRequestItem
     */
    'id': string;
    /**
     * An answer for the KBA question
     * @type {string}
     * @memberof KbaAnswerRequestItem
     */
    'answer': string;
}
/**
 * 
 * @export
 * @interface KbaAnswerResponseItem
 */
export interface KbaAnswerResponseItem {
    /**
     * Question Id
     * @type {string}
     * @memberof KbaAnswerResponseItem
     */
    'id': string;
    /**
     * Question description
     * @type {string}
     * @memberof KbaAnswerResponseItem
     */
    'question': string;
    /**
     * Denotes whether the KBA question has an answer configured for the current user
     * @type {boolean}
     * @memberof KbaAnswerResponseItem
     */
    'hasAnswer': boolean;
}
/**
 * 
 * @export
 * @interface KbaAuthResponse
 */
export interface KbaAuthResponse {
    /**
     * 
     * @type {Array<KbaAuthResponseItem>}
     * @memberof KbaAuthResponse
     */
    'kbaAuthResponseItems'?: Array<KbaAuthResponseItem>;
    /**
     * MFA Authentication status
     * @type {string}
     * @memberof KbaAuthResponse
     */
    'status'?: KbaAuthResponseStatusEnum;
}

export const KbaAuthResponseStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Lockout: 'LOCKOUT',
    NotEnoughData: 'NOT_ENOUGH_DATA'
} as const;

export type KbaAuthResponseStatusEnum = typeof KbaAuthResponseStatusEnum[keyof typeof KbaAuthResponseStatusEnum];

/**
 * 
 * @export
 * @interface KbaAuthResponseItem
 */
export interface KbaAuthResponseItem {
    /**
     * The KBA question id
     * @type {string}
     * @memberof KbaAuthResponseItem
     */
    'questionId'?: string | null;
    /**
     * Return true if verified
     * @type {boolean}
     * @memberof KbaAuthResponseItem
     */
    'isVerified'?: boolean | null;
}
/**
 * KBA Configuration
 * @export
 * @interface KbaQuestion
 */
export interface KbaQuestion {
    /**
     * KBA Question Id
     * @type {string}
     * @memberof KbaQuestion
     */
    'id': string;
    /**
     * KBA Question description
     * @type {string}
     * @memberof KbaQuestion
     */
    'text': string;
    /**
     * Denotes whether the KBA question has an answer configured for any user in the tenant
     * @type {boolean}
     * @memberof KbaQuestion
     */
    'hasAnswer': boolean;
    /**
     * Denotes the number of KBA configurations for this question
     * @type {number}
     * @memberof KbaQuestion
     */
    'numAnswers': number;
}
/**
 * 
 * @export
 * @interface LeftPad
 */
export interface LeftPad {
    /**
     * An integer value for the desired length of the final output string
     * @type {string}
     * @memberof LeftPad
     */
    'length': string;
    /**
     * A string value representing the character that the incoming data should be padded with to get to the desired length   If not provided, the transform will default to a single space (\" \") character for padding 
     * @type {string}
     * @memberof LeftPad
     */
    'padding'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof LeftPad
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof LeftPad
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface LifecycleState
 */
export interface LifecycleState {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'modified'?: string;
    /**
     * Indicates whether the lifecycle state is enabled or disabled.
     * @type {boolean}
     * @memberof LifecycleState
     */
    'enabled'?: boolean;
    /**
     * The lifecycle state\'s technical name. This is for internal use.
     * @type {string}
     * @memberof LifecycleState
     */
    'technicalName': string;
    /**
     * Lifecycle state\'s description.
     * @type {string}
     * @memberof LifecycleState
     */
    'description'?: string;
    /**
     * Number of identities that have the lifecycle state.
     * @type {number}
     * @memberof LifecycleState
     */
    'identityCount'?: number;
    /**
     * 
     * @type {EmailNotificationOption}
     * @memberof LifecycleState
     */
    'emailNotificationOption'?: EmailNotificationOption;
    /**
     * 
     * @type {Array<AccountAction>}
     * @memberof LifecycleState
     */
    'accountActions'?: Array<AccountAction>;
    /**
     * List of unique access-profile IDs that are associated with the lifecycle state.
     * @type {Set<string>}
     * @memberof LifecycleState
     */
    'accessProfileIds'?: Set<string>;
    /**
     * The lifecycle state\'s associated identity state. This field is generally \'null\'.
     * @type {string}
     * @memberof LifecycleState
     */
    'identityState'?: string | null;
}
/**
 * 
 * @export
 * @interface LifecycleStateAllOf
 */
export interface LifecycleStateAllOf {
    /**
     * Indicates whether the lifecycle state is enabled or disabled.
     * @type {boolean}
     * @memberof LifecycleStateAllOf
     */
    'enabled'?: boolean;
    /**
     * The lifecycle state\'s technical name. This is for internal use.
     * @type {string}
     * @memberof LifecycleStateAllOf
     */
    'technicalName': string;
    /**
     * Lifecycle state\'s description.
     * @type {string}
     * @memberof LifecycleStateAllOf
     */
    'description'?: string;
    /**
     * Number of identities that have the lifecycle state.
     * @type {number}
     * @memberof LifecycleStateAllOf
     */
    'identityCount'?: number;
    /**
     * 
     * @type {EmailNotificationOption}
     * @memberof LifecycleStateAllOf
     */
    'emailNotificationOption'?: EmailNotificationOption;
    /**
     * 
     * @type {Array<AccountAction>}
     * @memberof LifecycleStateAllOf
     */
    'accountActions'?: Array<AccountAction>;
    /**
     * List of unique access-profile IDs that are associated with the lifecycle state.
     * @type {Set<string>}
     * @memberof LifecycleStateAllOf
     */
    'accessProfileIds'?: Set<string>;
    /**
     * The lifecycle state\'s associated identity state. This field is generally \'null\'.
     * @type {string}
     * @memberof LifecycleStateAllOf
     */
    'identityState'?: string | null;
}
/**
 * Deleted lifecycle state.
 * @export
 * @interface LifecyclestateDeleted
 */
export interface LifecyclestateDeleted {
    /**
     * Deleted lifecycle state\'s DTO type.
     * @type {string}
     * @memberof LifecyclestateDeleted
     */
    'type'?: LifecyclestateDeletedTypeEnum;
    /**
     * Deleted lifecycle state ID.
     * @type {string}
     * @memberof LifecyclestateDeleted
     */
    'id'?: string;
    /**
     * Deleted lifecycle state\'s display name.
     * @type {string}
     * @memberof LifecyclestateDeleted
     */
    'name'?: string;
}

export const LifecyclestateDeletedTypeEnum = {
    LifecycleState: 'LIFECYCLE_STATE'
} as const;

export type LifecyclestateDeletedTypeEnum = typeof LifecyclestateDeletedTypeEnum[keyof typeof LifecyclestateDeletedTypeEnum];

/**
 * 
 * @export
 * @interface ListAccessProfiles401Response
 */
export interface ListAccessProfiles401Response {
    /**
     * A message describing the error
     * @type {object}
     * @memberof ListAccessProfiles401Response
     */
    'error'?: object;
}
/**
 * 
 * @export
 * @interface ListAccessProfiles429Response
 */
export interface ListAccessProfiles429Response {
    /**
     * A message describing the error
     * @type {object}
     * @memberof ListAccessProfiles429Response
     */
    'message'?: object;
}
/**
 * 
 * @export
 * @interface ListCampaignFilters200Response
 */
export interface ListCampaignFilters200Response {
    /**
     * The list of campaign filters
     * @type {Array<CampaignFilterDetails>}
     * @memberof ListCampaignFilters200Response
     */
    'items'?: Array<CampaignFilterDetails>;
    /**
     * The number of filters returned
     * @type {number}
     * @memberof ListCampaignFilters200Response
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface ListCompleteWorkflowLibrary200ResponseInner
 */
export interface ListCompleteWorkflowLibrary200ResponseInner {
    /**
     * Operator ID.
     * @type {string}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'id'?: string;
    /**
     * Operator friendly name
     * @type {string}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'name'?: string;
    /**
     * Operator type
     * @type {string}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'type'?: string;
    /**
     * Description of the operator
     * @type {string}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'description'?: string;
    /**
     * One or more inputs that the operator accepts
     * @type {Array<WorkflowLibraryFormFields>}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'formFields'?: Array<WorkflowLibraryFormFields>;
    /**
     * Determines whether the dynamic output schema is returned in place of the action\'s output schema. The dynamic schema lists non-static properties, like properties of a workflow form where each form has different fields. These will be provided dynamically based on available form fields.
     * @type {boolean}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'isDynamicSchema'?: boolean;
    /**
     * Defines the output schema, if any, that this action produces.
     * @type {object}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'outputSchema'?: object;
    /**
     * Example trigger payload if applicable
     * @type {object}
     * @memberof ListCompleteWorkflowLibrary200ResponseInner
     */
    'inputExample'?: object | null;
}
/**
 * An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const LocaleOrigin = {
    Default: 'DEFAULT',
    Request: 'REQUEST',
    Null: 'null'
} as const;

export type LocaleOrigin = typeof LocaleOrigin[keyof typeof LocaleOrigin];


/**
 * 
 * @export
 * @interface Lookup
 */
export interface Lookup {
    /**
     * This is a JSON object of key-value pairs. The key is the string that will attempt to be matched to the input, and the value is the output string that should be returned if the key is matched   >**Note** the use of the optional default key value here; if none of the three countries in the above example match the input string, the transform will return \"Unknown Region\" for the attribute that is mapped to this transform. 
     * @type {{ [key: string]: any; }}
     * @memberof Lookup
     */
    'table': { [key: string]: any; };
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Lookup
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Lookup
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Lower
 */
export interface Lower {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Lower
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Lower
     */
    'input'?: { [key: string]: any; };
}
/**
 * Managed Client
 * @export
 * @interface ManagedClient
 */
export interface ManagedClient {
    /**
     * ManagedClient ID
     * @type {string}
     * @memberof ManagedClient
     */
    'id'?: string | null;
    /**
     * ManagedClient alert key
     * @type {string}
     * @memberof ManagedClient
     */
    'alertKey'?: string | null;
    /**
     * Previous CC ID to be used in data migration. (This field will be deleted after CC migration!)
     * @type {number}
     * @memberof ManagedClient
     */
    'ccId'?: number | null;
    /**
     * The client ID used in API management
     * @type {string}
     * @memberof ManagedClient
     */
    'clientId': string;
    /**
     * Cluster ID that the ManagedClient is linked to
     * @type {string}
     * @memberof ManagedClient
     */
    'clusterId': string;
    /**
     * ManagedClient description
     * @type {string}
     * @memberof ManagedClient
     */
    'description': string;
    /**
     * The public IP address of the ManagedClient
     * @type {string}
     * @memberof ManagedClient
     */
    'ipAddress'?: string | null;
    /**
     * When the ManagedClient was last seen by the server
     * @type {string}
     * @memberof ManagedClient
     */
    'lastSeen'?: string | null;
    /**
     * ManagedClient name
     * @type {string}
     * @memberof ManagedClient
     */
    'name'?: string | null;
    /**
     * Milliseconds since the ManagedClient has polled the server
     * @type {string}
     * @memberof ManagedClient
     */
    'sinceLastSeen'?: string | null;
    /**
     * Status of the ManagedClient
     * @type {string}
     * @memberof ManagedClient
     */
    'status'?: ManagedClientStatusEnum;
    /**
     * Type of the ManagedClient (VA, CCG)
     * @type {string}
     * @memberof ManagedClient
     */
    'type': string;
    /**
     * Cluster Type of the ManagedClient
     * @type {string}
     * @memberof ManagedClient
     */
    'clusterType'?: ManagedClientClusterTypeEnum;
    /**
     * ManagedClient VA download URL
     * @type {string}
     * @memberof ManagedClient
     */
    'vaDownloadUrl'?: string | null;
    /**
     * Version that the ManagedClient\'s VA is running
     * @type {string}
     * @memberof ManagedClient
     */
    'vaVersion'?: string | null;
    /**
     * Client\'s apiKey
     * @type {string}
     * @memberof ManagedClient
     */
    'secret'?: string | null;
    /**
     * The date/time this ManagedClient was created
     * @type {string}
     * @memberof ManagedClient
     */
    'createdAt'?: string | null;
    /**
     * The date/time this ManagedClient was last updated
     * @type {string}
     * @memberof ManagedClient
     */
    'updatedAt'?: string | null;
    /**
     * The provisioning status of the ManagedClient
     * @type {string}
     * @memberof ManagedClient
     */
    'provisionStatus'?: ManagedClientProvisionStatusEnum;
}

export const ManagedClientStatusEnum = {
    Normal: 'NORMAL',
    Undefined: 'UNDEFINED',
    NotConfigured: 'NOT_CONFIGURED',
    Configuring: 'CONFIGURING',
    Warning: 'WARNING',
    Error: 'ERROR',
    Failed: 'FAILED',
    Null: 'null'
} as const;

export type ManagedClientStatusEnum = typeof ManagedClientStatusEnum[keyof typeof ManagedClientStatusEnum];
export const ManagedClientClusterTypeEnum = {
    Null: 'null',
    Idn: 'idn',
    Iai: 'iai',
    SpConnectCluster: 'spConnectCluster',
    SqsCluster: 'sqsCluster',
    DasRc: 'das-rc',
    DasPc: 'das-pc',
    DasDc: 'das-dc'
} as const;

export type ManagedClientClusterTypeEnum = typeof ManagedClientClusterTypeEnum[keyof typeof ManagedClientClusterTypeEnum];
export const ManagedClientProvisionStatusEnum = {
    Null: 'null',
    Provisioned: 'PROVISIONED',
    Draft: 'DRAFT'
} as const;

export type ManagedClientProvisionStatusEnum = typeof ManagedClientProvisionStatusEnum[keyof typeof ManagedClientProvisionStatusEnum];

/**
 * Managed Client Request
 * @export
 * @interface ManagedClientRequest
 */
export interface ManagedClientRequest {
    /**
     * Cluster ID that the ManagedClient is linked to
     * @type {string}
     * @memberof ManagedClientRequest
     */
    'clusterId': string;
    /**
     * description for the ManagedClient to create
     * @type {string}
     * @memberof ManagedClientRequest
     */
    'description'?: string | null;
    /**
     * name for the ManagedClient to create
     * @type {string}
     * @memberof ManagedClientRequest
     */
    'name'?: string | null;
    /**
     * Type of the ManagedClient (VA, CCG) to create
     * @type {string}
     * @memberof ManagedClientRequest
     */
    'type'?: string | null;
}
/**
 * Managed Client Status
 * @export
 * @interface ManagedClientStatus
 */
export interface ManagedClientStatus {
    /**
     * ManagedClientStatus body information
     * @type {object}
     * @memberof ManagedClientStatus
     */
    'body': object;
    /**
     * 
     * @type {ManagedClientStatusCode}
     * @memberof ManagedClientStatus
     */
    'status': ManagedClientStatusCode;
    /**
     * 
     * @type {ManagedClientType}
     * @memberof ManagedClientStatus
     */
    'type': ManagedClientType | null;
    /**
     * timestamp on the Client Status update
     * @type {string}
     * @memberof ManagedClientStatus
     */
    'timestamp': string;
}
/**
 * Status of a Managed Client
 * @export
 * @enum {string}
 */

export const ManagedClientStatusCode = {
    Normal: 'NORMAL',
    Undefined: 'UNDEFINED',
    NotConfigured: 'NOT_CONFIGURED',
    Configuring: 'CONFIGURING',
    Warning: 'WARNING',
    Error: 'ERROR',
    Failed: 'FAILED'
} as const;

export type ManagedClientStatusCode = typeof ManagedClientStatusCode[keyof typeof ManagedClientStatusCode];


/**
 * Managed Client type
 * @export
 * @enum {string}
 */

export const ManagedClientType = {
    Ccg: 'CCG',
    Va: 'VA',
    Internal: 'INTERNAL',
    IiqHarvester: 'IIQ_HARVESTER',
    Null: 'null'
} as const;

export type ManagedClientType = typeof ManagedClientType[keyof typeof ManagedClientType];


/**
 * Managed Cluster
 * @export
 * @interface ManagedCluster
 */
export interface ManagedCluster {
    /**
     * ManagedCluster ID
     * @type {string}
     * @memberof ManagedCluster
     */
    'id': string;
    /**
     * ManagedCluster name
     * @type {string}
     * @memberof ManagedCluster
     */
    'name'?: string;
    /**
     * ManagedCluster pod
     * @type {string}
     * @memberof ManagedCluster
     */
    'pod'?: string;
    /**
     * ManagedCluster org
     * @type {string}
     * @memberof ManagedCluster
     */
    'org'?: string;
    /**
     * 
     * @type {ManagedClusterTypes}
     * @memberof ManagedCluster
     */
    'type'?: ManagedClusterTypes;
    /**
     * ManagedProcess configuration map
     * @type {{ [key: string]: string; }}
     * @memberof ManagedCluster
     */
    'configuration'?: { [key: string]: string; };
    /**
     * 
     * @type {ManagedClusterKeyPair}
     * @memberof ManagedCluster
     */
    'keyPair'?: ManagedClusterKeyPair;
    /**
     * 
     * @type {ManagedClusterAttributes}
     * @memberof ManagedCluster
     */
    'attributes'?: ManagedClusterAttributes;
    /**
     * ManagedCluster description
     * @type {string}
     * @memberof ManagedCluster
     */
    'description'?: string;
    /**
     * 
     * @type {ManagedClusterRedis}
     * @memberof ManagedCluster
     */
    'redis'?: ManagedClusterRedis;
    /**
     * 
     * @type {ManagedClientType}
     * @memberof ManagedCluster
     */
    'clientType': ManagedClientType | null;
    /**
     * CCG version used by the ManagedCluster
     * @type {string}
     * @memberof ManagedCluster
     */
    'ccgVersion': string;
    /**
     * boolean flag indiacting whether or not the cluster configuration is pinned
     * @type {boolean}
     * @memberof ManagedCluster
     */
    'pinnedConfig'?: boolean;
    /**
     * 
     * @type {ClientLogConfiguration}
     * @memberof ManagedCluster
     */
    'logConfiguration'?: ClientLogConfiguration | null;
    /**
     * Whether or not the cluster is operational or not
     * @type {boolean}
     * @memberof ManagedCluster
     */
    'operational'?: boolean;
    /**
     * Cluster status
     * @type {string}
     * @memberof ManagedCluster
     */
    'status'?: string;
    /**
     * Public key certificate
     * @type {string}
     * @memberof ManagedCluster
     */
    'publicKeyCertificate'?: string | null;
    /**
     * Public key thumbprint
     * @type {string}
     * @memberof ManagedCluster
     */
    'publicKeyThumbprint'?: string | null;
    /**
     * Public key
     * @type {string}
     * @memberof ManagedCluster
     */
    'publicKey'?: string | null;
    /**
     * Key describing any immediate cluster alerts
     * @type {string}
     * @memberof ManagedCluster
     */
    'alertKey'?: string;
    /**
     * List of clients in a cluster
     * @type {Array<string>}
     * @memberof ManagedCluster
     */
    'clientIds'?: Array<string>;
    /**
     * Number of services bound to a cluster
     * @type {number}
     * @memberof ManagedCluster
     */
    'serviceCount'?: number;
    /**
     * CC ID only used in calling CC, will be removed without notice when Migration to CEGS is finished
     * @type {string}
     * @memberof ManagedCluster
     */
    'ccId'?: string;
    /**
     * The date/time this cluster was created
     * @type {string}
     * @memberof ManagedCluster
     */
    'createdAt'?: string | null;
    /**
     * The date/time this cluster was last updated
     * @type {string}
     * @memberof ManagedCluster
     */
    'updatedAt'?: string | null;
}
/**
 * Managed Cluster Attributes for Cluster Configuration. Supported Cluster Types [sqsCluster, spConnectCluster]
 * @export
 * @interface ManagedClusterAttributes
 */
export interface ManagedClusterAttributes {
    /**
     * 
     * @type {ManagedClusterQueue}
     * @memberof ManagedClusterAttributes
     */
    'queue'?: ManagedClusterQueue;
    /**
     * ManagedCluster keystore for spConnectCluster type
     * @type {string}
     * @memberof ManagedClusterAttributes
     */
    'keystore'?: string | null;
}
/**
 * Managed Cluster key pair for Cluster
 * @export
 * @interface ManagedClusterKeyPair
 */
export interface ManagedClusterKeyPair {
    /**
     * ManagedCluster publicKey
     * @type {string}
     * @memberof ManagedClusterKeyPair
     */
    'publicKey'?: string | null;
    /**
     * ManagedCluster publicKeyThumbprint
     * @type {string}
     * @memberof ManagedClusterKeyPair
     */
    'publicKeyThumbprint'?: string | null;
    /**
     * ManagedCluster publicKeyCertificate
     * @type {string}
     * @memberof ManagedClusterKeyPair
     */
    'publicKeyCertificate'?: string | null;
}
/**
 * Managed Cluster key pair for Cluster
 * @export
 * @interface ManagedClusterQueue
 */
export interface ManagedClusterQueue {
    /**
     * ManagedCluster queue name
     * @type {string}
     * @memberof ManagedClusterQueue
     */
    'name'?: string;
    /**
     * ManagedCluster queue aws region
     * @type {string}
     * @memberof ManagedClusterQueue
     */
    'region'?: string;
}
/**
 * Managed Cluster Redis Configuration
 * @export
 * @interface ManagedClusterRedis
 */
export interface ManagedClusterRedis {
    /**
     * ManagedCluster redisHost
     * @type {string}
     * @memberof ManagedClusterRedis
     */
    'redisHost'?: string;
    /**
     * ManagedCluster redisPort
     * @type {number}
     * @memberof ManagedClusterRedis
     */
    'redisPort'?: number;
}
/**
 * Request to create Managed Cluster
 * @export
 * @interface ManagedClusterRequest
 */
export interface ManagedClusterRequest {
    /**
     * ManagedCluster name
     * @type {string}
     * @memberof ManagedClusterRequest
     */
    'name': string;
    /**
     * 
     * @type {ManagedClusterTypes}
     * @memberof ManagedClusterRequest
     */
    'type'?: ManagedClusterTypes;
    /**
     * ManagedProcess configuration map
     * @type {{ [key: string]: string; }}
     * @memberof ManagedClusterRequest
     */
    'configuration'?: { [key: string]: string; };
    /**
     * ManagedCluster description
     * @type {string}
     * @memberof ManagedClusterRequest
     */
    'description'?: string | null;
}
/**
 * The Type of Cluster
 * @export
 * @enum {string}
 */

export const ManagedClusterTypes = {
    Idn: 'idn',
    Iai: 'iai'
} as const;

export type ManagedClusterTypes = typeof ManagedClusterTypes[keyof typeof ManagedClusterTypes];


/**
 * 
 * @export
 * @interface ManagerCorrelationMapping
 */
export interface ManagerCorrelationMapping {
    /**
     * Name of the attribute to use for manager correlation. The value found on the account attribute will be used to lookup the manager\'s identity.
     * @type {string}
     * @memberof ManagerCorrelationMapping
     */
    'accountAttributeName'?: string;
    /**
     * Name of the identity attribute to search when trying to find a manager using the value from the accountAttribute.
     * @type {string}
     * @memberof ManagerCorrelationMapping
     */
    'identityAttributeName'?: string;
}
/**
 * 
 * @export
 * @interface ManualWorkItemDetails
 */
export interface ManualWorkItemDetails {
    /**
     * True if the request for this item was forwarded from one owner to another.
     * @type {boolean}
     * @memberof ManualWorkItemDetails
     */
    'forwarded'?: boolean;
    /**
     * 
     * @type {ManualWorkItemDetailsOriginalOwner}
     * @memberof ManualWorkItemDetails
     */
    'originalOwner'?: ManualWorkItemDetailsOriginalOwner | null;
    /**
     * 
     * @type {ManualWorkItemDetailsCurrentOwner}
     * @memberof ManualWorkItemDetails
     */
    'currentOwner'?: ManualWorkItemDetailsCurrentOwner | null;
    /**
     * Time at which item was modified.
     * @type {string}
     * @memberof ManualWorkItemDetails
     */
    'modified'?: string;
    /**
     * 
     * @type {ManualWorkItemState}
     * @memberof ManualWorkItemDetails
     */
    'status'?: ManualWorkItemState;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof ManualWorkItemDetails
     */
    'forwardHistory'?: Array<ApprovalForwardHistory> | null;
}
/**
 * Identity of current work item owner.
 * @export
 * @interface ManualWorkItemDetailsCurrentOwner
 */
export interface ManualWorkItemDetailsCurrentOwner {
    /**
     * DTO type of current work item owner\'s identity.
     * @type {string}
     * @memberof ManualWorkItemDetailsCurrentOwner
     */
    'type'?: ManualWorkItemDetailsCurrentOwnerTypeEnum;
    /**
     * ID of current work item owner\'s identity.
     * @type {string}
     * @memberof ManualWorkItemDetailsCurrentOwner
     */
    'id'?: string;
    /**
     * Display name of current work item owner.
     * @type {string}
     * @memberof ManualWorkItemDetailsCurrentOwner
     */
    'name'?: string;
}

export const ManualWorkItemDetailsCurrentOwnerTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type ManualWorkItemDetailsCurrentOwnerTypeEnum = typeof ManualWorkItemDetailsCurrentOwnerTypeEnum[keyof typeof ManualWorkItemDetailsCurrentOwnerTypeEnum];

/**
 * Identity of original work item owner, if the work item has been forwarded.
 * @export
 * @interface ManualWorkItemDetailsOriginalOwner
 */
export interface ManualWorkItemDetailsOriginalOwner {
    /**
     * DTO type of original work item owner\'s identity.
     * @type {string}
     * @memberof ManualWorkItemDetailsOriginalOwner
     */
    'type'?: ManualWorkItemDetailsOriginalOwnerTypeEnum;
    /**
     * ID of original work item owner\'s identity.
     * @type {string}
     * @memberof ManualWorkItemDetailsOriginalOwner
     */
    'id'?: string;
    /**
     * Display name of original work item owner.
     * @type {string}
     * @memberof ManualWorkItemDetailsOriginalOwner
     */
    'name'?: string;
}

export const ManualWorkItemDetailsOriginalOwnerTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type ManualWorkItemDetailsOriginalOwnerTypeEnum = typeof ManualWorkItemDetailsOriginalOwnerTypeEnum[keyof typeof ManualWorkItemDetailsOriginalOwnerTypeEnum];

/**
 * Indicates the state of the request processing for this item: * PENDING: The request for this item is awaiting processing. * APPROVED: The request for this item has been approved. * REJECTED: The request for this item was rejected. * EXPIRED: The request for this item expired with no action taken. * CANCELLED: The request for this item was cancelled with no user action. * ARCHIVED: The request for this item has been archived after completion.
 * @export
 * @enum {string}
 */

export const ManualWorkItemState = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED',
    Archived: 'ARCHIVED'
} as const;

export type ManualWorkItemState = typeof ManualWorkItemState[keyof typeof ManualWorkItemState];


/**
 * The calculation done on the results of the query
 * @export
 * @interface MetricAggregation
 */
export interface MetricAggregation {
    /**
     * The name of the metric aggregate to be included in the result. If the metric aggregation is omitted, the resulting aggregation will be a count of the documents in the search results.
     * @type {string}
     * @memberof MetricAggregation
     */
    'name': string;
    /**
     * 
     * @type {MetricType}
     * @memberof MetricAggregation
     */
    'type'?: MetricType;
    /**
     * The field the calculation is performed on.  Prefix the field name with \'@\' to reference a nested object. 
     * @type {string}
     * @memberof MetricAggregation
     */
    'field': string;
}
/**
 * Enum representing the currently supported metric aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const MetricType = {
    Count: 'COUNT',
    UniqueCount: 'UNIQUE_COUNT',
    Avg: 'AVG',
    Sum: 'SUM',
    Median: 'MEDIAN',
    Min: 'MIN',
    Max: 'MAX'
} as const;

export type MetricType = typeof MetricType[keyof typeof MetricType];


/**
 * Response model for configuration test of a given MFA method
 * @export
 * @interface MfaConfigTestResponse
 */
export interface MfaConfigTestResponse {
    /**
     * The configuration test result.
     * @type {string}
     * @memberof MfaConfigTestResponse
     */
    'state'?: MfaConfigTestResponseStateEnum;
    /**
     * The error message to indicate the failure of configuration test.
     * @type {string}
     * @memberof MfaConfigTestResponse
     */
    'error'?: string;
}

export const MfaConfigTestResponseStateEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type MfaConfigTestResponseStateEnum = typeof MfaConfigTestResponseStateEnum[keyof typeof MfaConfigTestResponseStateEnum];

/**
 * 
 * @export
 * @interface MfaDuoConfig
 */
export interface MfaDuoConfig {
    /**
     * Mfa method name
     * @type {string}
     * @memberof MfaDuoConfig
     */
    'mfaMethod'?: string | null;
    /**
     * If MFA method is enabled.
     * @type {boolean}
     * @memberof MfaDuoConfig
     */
    'enabled'?: boolean;
    /**
     * The server host name or IP address of the MFA provider.
     * @type {string}
     * @memberof MfaDuoConfig
     */
    'host'?: string | null;
    /**
     * The secret key for authenticating requests to the MFA provider.
     * @type {string}
     * @memberof MfaDuoConfig
     */
    'accessKey'?: string | null;
    /**
     * Optional. The name of the attribute for mapping IdentityNow identity to the MFA provider.
     * @type {string}
     * @memberof MfaDuoConfig
     */
    'identityAttribute'?: string | null;
    /**
     * A map with additional config properties for the given MFA method - duo-web.
     * @type {{ [key: string]: any; }}
     * @memberof MfaDuoConfig
     */
    'configProperties'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface MfaOktaConfig
 */
export interface MfaOktaConfig {
    /**
     * Mfa method name
     * @type {string}
     * @memberof MfaOktaConfig
     */
    'mfaMethod'?: string | null;
    /**
     * If MFA method is enabled.
     * @type {boolean}
     * @memberof MfaOktaConfig
     */
    'enabled'?: boolean;
    /**
     * The server host name or IP address of the MFA provider.
     * @type {string}
     * @memberof MfaOktaConfig
     */
    'host'?: string | null;
    /**
     * The secret key for authenticating requests to the MFA provider.
     * @type {string}
     * @memberof MfaOktaConfig
     */
    'accessKey'?: string | null;
    /**
     * Optional. The name of the attribute for mapping IdentityNow identity to the MFA provider.
     * @type {string}
     * @memberof MfaOktaConfig
     */
    'identityAttribute'?: string | null;
}
/**
 * 
 * @export
 * @interface MultiPolicyRequest
 */
export interface MultiPolicyRequest {
    /**
     * Multi-policy report will be run for this list of ids
     * @type {Array<string>}
     * @memberof MultiPolicyRequest
     */
    'filteredPolicyList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NameNormalizer
 */
export interface NameNormalizer {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof NameNormalizer
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof NameNormalizer
     */
    'input'?: { [key: string]: any; };
}
/**
 * | Construct       | Date Time Pattern | Description | | ---------       | ----------------- | ----------- | | ISO8601         | `yyyy-MM-dd\'T\'HH:mm:ss.SSSX` | The ISO8601 standard. |           | LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    | | PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. | | EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. | | EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. | 
 * @export
 * @enum {string}
 */

export const NamedConstructs = {
    Iso8601: 'ISO8601',
    Ldap: 'LDAP',
    PeopleSoft: 'PEOPLE_SOFT',
    EpochTimeJava: 'EPOCH_TIME_JAVA',
    EpochTimeWin32: 'EPOCH_TIME_WIN32'
} as const;

export type NamedConstructs = typeof NamedConstructs[keyof typeof NamedConstructs];


/**
 * The nested aggregation object.
 * @export
 * @interface NestedAggregation
 */
export interface NestedAggregation {
    /**
     * The name of the nested aggregate to be included in the result.
     * @type {string}
     * @memberof NestedAggregation
     */
    'name': string;
    /**
     * The type of the nested object.
     * @type {string}
     * @memberof NestedAggregation
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface NetworkConfiguration
 */
export interface NetworkConfiguration {
    /**
     * The collection of ip ranges.
     * @type {Array<string>}
     * @memberof NetworkConfiguration
     */
    'range'?: Array<string> | null;
    /**
     * The collection of country codes.
     * @type {Array<string>}
     * @memberof NetworkConfiguration
     */
    'geolocation'?: Array<string> | null;
    /**
     * Denotes whether the provided lists are whitelisted or blacklisted for geo location.
     * @type {boolean}
     * @memberof NetworkConfiguration
     */
    'whitelisted'?: boolean;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalDecision
 */
export interface NonEmployeeApprovalDecision {
    /**
     * Comment on the approval item.
     * @type {string}
     * @memberof NonEmployeeApprovalDecision
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItem
 */
export interface NonEmployeeApprovalItem {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItem
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItem
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItem
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeRequestLite}
     * @memberof NonEmployeeApprovalItem
     */
    'nonEmployeeRequest'?: NonEmployeeRequestLite;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemAllOf
 */
export interface NonEmployeeApprovalItemAllOf {
    /**
     * 
     * @type {NonEmployeeRequestLite}
     * @memberof NonEmployeeApprovalItemAllOf
     */
    'nonEmployeeRequest'?: NonEmployeeRequestLite;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemBase
 */
export interface NonEmployeeApprovalItemBase {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemDetail
 */
export interface NonEmployeeApprovalItemDetail {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeRequestWithoutApprovalItem}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'nonEmployeeRequest'?: NonEmployeeRequestWithoutApprovalItem;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemDetailAllOf
 */
export interface NonEmployeeApprovalItemDetailAllOf {
    /**
     * 
     * @type {NonEmployeeRequestWithoutApprovalItem}
     * @memberof NonEmployeeApprovalItemDetailAllOf
     */
    'nonEmployeeRequest'?: NonEmployeeRequestWithoutApprovalItem;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalSummary
 */
export interface NonEmployeeApprovalSummary {
    /**
     * The number of approved non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'approved'?: number;
    /**
     * The number of pending non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'pending'?: number;
    /**
     * The number of rejected non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'rejected'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeBulkUploadJob
 */
export interface NonEmployeeBulkUploadJob {
    /**
     * The bulk upload job\'s ID. (UUID)
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'id'?: string;
    /**
     * The ID of the source to bulk-upload non-employees to. (UUID)
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'sourceId'?: string;
    /**
     * The date-time the job was submitted.
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'created'?: string;
    /**
     * The date-time that the job was last updated.
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'modified'?: string;
    /**
     * Returns the following values indicating the progress or result of the bulk upload job. \"PENDING\" means the job is queued and waiting to be processed. \"IN_PROGRESS\" means the job is currently being processed. \"COMPLETED\" means the job has been completed without any errors. \"ERROR\" means the job failed to process with errors. 
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'status'?: NonEmployeeBulkUploadJobStatusEnum;
}

export const NonEmployeeBulkUploadJobStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
} as const;

export type NonEmployeeBulkUploadJobStatusEnum = typeof NonEmployeeBulkUploadJobStatusEnum[keyof typeof NonEmployeeBulkUploadJobStatusEnum];

/**
 * 
 * @export
 * @interface NonEmployeeBulkUploadStatus
 */
export interface NonEmployeeBulkUploadStatus {
    /**
     * Returns the following values indicating the progress or result of the bulk upload job. \"PENDING\" means the job is queued and waiting to be processed. \"IN_PROGRESS\" means the job is currently being processed. \"COMPLETED\" means the job has been completed without any errors. \"ERROR\" means the job failed to process with errors. null means job has been submitted to the source. 
     * @type {string}
     * @memberof NonEmployeeBulkUploadStatus
     */
    'status'?: NonEmployeeBulkUploadStatusStatusEnum;
}

export const NonEmployeeBulkUploadStatusStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
} as const;

export type NonEmployeeBulkUploadStatusStatusEnum = typeof NonEmployeeBulkUploadStatusStatusEnum[keyof typeof NonEmployeeBulkUploadStatusStatusEnum];

/**
 * Identifies if the identity is a normal identity or a governance group
 * @export
 * @enum {string}
 */

export const NonEmployeeIdentityDtoType = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type NonEmployeeIdentityDtoType = typeof NonEmployeeIdentityDtoType[keyof typeof NonEmployeeIdentityDtoType];


/**
 * 
 * @export
 * @interface NonEmployeeIdentityReferenceWithId
 */
export interface NonEmployeeIdentityReferenceWithId {
    /**
     * 
     * @type {NonEmployeeIdentityDtoType}
     * @memberof NonEmployeeIdentityReferenceWithId
     */
    'type'?: NonEmployeeIdentityDtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof NonEmployeeIdentityReferenceWithId
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeIdnUserRequest
 */
export interface NonEmployeeIdnUserRequest {
    /**
     * Identity id.
     * @type {string}
     * @memberof NonEmployeeIdnUserRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRecord
 */
export interface NonEmployeeRecord {
    /**
     * Non-Employee record id.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'id'?: string;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'manager'?: string;
    /**
     * Non-Employee\'s source id.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'sourceId'?: string;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRecord
     */
    'data'?: { [key: string]: string; };
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRejectApprovalDecision
 */
export interface NonEmployeeRejectApprovalDecision {
    /**
     * Comment on the approval item.
     * @type {string}
     * @memberof NonEmployeeRejectApprovalDecision
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequest
 */
export interface NonEmployeeRequest {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'description'?: string;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLite}
     * @memberof NonEmployeeRequest
     */
    'nonEmployeeSource'?: NonEmployeeSourceLite;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequest
     */
    'data'?: { [key: string]: string; };
    /**
     * List of approval item for the request
     * @type {Array<NonEmployeeApprovalItemBase>}
     * @memberof NonEmployeeRequest
     */
    'approvalItems'?: Array<NonEmployeeApprovalItemBase>;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequest
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestAllOf
 */
export interface NonEmployeeRequestAllOf {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLite}
     * @memberof NonEmployeeRequestAllOf
     */
    'nonEmployeeSource'?: NonEmployeeSourceLite;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestAllOf
     */
    'data'?: { [key: string]: string; };
    /**
     * List of approval item for the request
     * @type {Array<NonEmployeeApprovalItemBase>}
     * @memberof NonEmployeeRequestAllOf
     */
    'approvalItems'?: Array<NonEmployeeApprovalItemBase>;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequestAllOf
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestBody
 */
export interface NonEmployeeRequestBody {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'accountName': string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'firstName': string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'lastName': string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'email': string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'phone': string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'manager': string;
    /**
     * Non-Employee\'s source id.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'sourceId': string;
    /**
     * Attribute blob/bag for a non-employee, 10 attributes is the maximum size supported.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestBody
     */
    'data'?: { [key: string]: string; };
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'startDate': string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'endDate': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestLite
 */
export interface NonEmployeeRequestLite {
    /**
     * Non-Employee request id.
     * @type {string}
     * @memberof NonEmployeeRequestLite
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeRequestLite
     */
    'requester'?: NonEmployeeIdentityReferenceWithId;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestSummary
 */
export interface NonEmployeeRequestSummary {
    /**
     * The number of approved non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'approved'?: number;
    /**
     * The number of rejected non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'rejected'?: number;
    /**
     * The number of pending non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'pending'?: number;
    /**
     * The number of non-employee records on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'nonEmployeeCount'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestWithoutApprovalItem
 */
export interface NonEmployeeRequestWithoutApprovalItem {
    /**
     * Non-Employee request id.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'requester'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLiteWithSchemaAttributes}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'nonEmployeeSource'?: NonEmployeeSourceLiteWithSchemaAttributes;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestWithoutApprovalItemAllOf
 */
export interface NonEmployeeRequestWithoutApprovalItemAllOf {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLiteWithSchemaAttributes}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'nonEmployeeSource'?: NonEmployeeSourceLiteWithSchemaAttributes;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSchemaAttribute
 */
export interface NonEmployeeSchemaAttribute {
    /**
     * Schema Attribute Id
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'id'?: string;
    /**
     * True if this schema attribute is mandatory on all non-employees sources.
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttribute
     */
    'system'?: boolean;
    /**
     * When the schema attribute was last modified.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'modified'?: string;
    /**
     * When the schema attribute was created.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeSchemaAttributeType}
     * @memberof NonEmployeeSchemaAttribute
     */
    'type': NonEmployeeSchemaAttributeType;
    /**
     * Label displayed on the UI for this schema attribute.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'label': string;
    /**
     * The technical name of the attribute. Must be unique per source.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'technicalName': string;
    /**
     * help text displayed by UI.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'helpText'?: string;
    /**
     * Hint text that fills UI box.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'placeholder'?: string;
    /**
     * If true, the schema attribute is required for all non-employees in the source
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttribute
     */
    'required'?: boolean;
}
/**
 * 
 * @export
 * @interface NonEmployeeSchemaAttributeBody
 */
export interface NonEmployeeSchemaAttributeBody {
    /**
     * Type of the attribute. Only type \'TEXT\' is supported for custom attributes.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'type': string;
    /**
     * Label displayed on the UI for this schema attribute.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'label': string;
    /**
     * The technical name of the attribute. Must be unique per source.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'technicalName': string;
    /**
     * help text displayed by UI.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'helpText'?: string;
    /**
     * Hint text that fills UI box.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'placeholder'?: string;
    /**
     * If true, the schema attribute is required for all non-employees in the source
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'required'?: boolean;
}
/**
 * Enum representing the type of data a schema attribute accepts.
 * @export
 * @enum {string}
 */

export const NonEmployeeSchemaAttributeType = {
    Text: 'TEXT',
    Date: 'DATE',
    Identity: 'IDENTITY'
} as const;

export type NonEmployeeSchemaAttributeType = typeof NonEmployeeSchemaAttributeType[keyof typeof NonEmployeeSchemaAttributeType];


/**
 * 
 * @export
 * @interface NonEmployeeSource
 */
export interface NonEmployeeSource {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSource
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSource
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceAllOf
 */
export interface NonEmployeeSourceAllOf {
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceAllOf
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceAllOf
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceAllOf
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceAllOf
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLite
 */
export interface NonEmployeeSourceLite {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLiteWithSchemaAttributes
 */
export interface NonEmployeeSourceLiteWithSchemaAttributes {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'description'?: string;
    /**
     * List of schema attributes associated with this non-employee source.
     * @type {Array<NonEmployeeSchemaAttribute>}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'schemaAttributes'?: Array<NonEmployeeSchemaAttribute>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLiteWithSchemaAttributesAllOf
 */
export interface NonEmployeeSourceLiteWithSchemaAttributesAllOf {
    /**
     * List of schema attributes associated with this non-employee source.
     * @type {Array<NonEmployeeSchemaAttribute>}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributesAllOf
     */
    'schemaAttributes'?: Array<NonEmployeeSchemaAttribute>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceRequestBody
 */
export interface NonEmployeeSourceRequestBody {
    /**
     * Name of non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'name': string;
    /**
     * Description of non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'description': string;
    /**
     * 
     * @type {NonEmployeeIdnUserRequest}
     * @memberof NonEmployeeSourceRequestBody
     */
    'owner': NonEmployeeIdnUserRequest;
    /**
     * The ID for the management workgroup that contains source sub-admins
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'managementWorkgroup'?: string;
    /**
     * List of approvers.
     * @type {Array<NonEmployeeIdnUserRequest>}
     * @memberof NonEmployeeSourceRequestBody
     */
    'approvers'?: Array<NonEmployeeIdnUserRequest>;
    /**
     * List of account managers.
     * @type {Array<NonEmployeeIdnUserRequest>}
     * @memberof NonEmployeeSourceRequestBody
     */
    'accountManagers'?: Array<NonEmployeeIdnUserRequest>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithCloudExternalId
 */
export interface NonEmployeeSourceWithCloudExternalId {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'created'?: string;
    /**
     * Legacy ID used for sources from the V1 API. This attribute will be removed from a future version of the API and will not be considered a breaking change. No clients should rely on this ID always being present.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'cloudExternalId'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithCloudExternalIdAllOf
 */
export interface NonEmployeeSourceWithCloudExternalIdAllOf {
    /**
     * Legacy ID used for sources from the V1 API. This attribute will be removed from a future version of the API and will not be considered a breaking change. No clients should rely on this ID always being present.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalIdAllOf
     */
    'cloudExternalId'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithNECount
 */
export interface NonEmployeeSourceWithNECount {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithNECount
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithNECount
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'created'?: string;
    /**
     * Number of non-employee records associated with this source.
     * @type {number}
     * @memberof NonEmployeeSourceWithNECount
     */
    'nonEmployeeCount'?: number | null;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithNECountAllOf
 */
export interface NonEmployeeSourceWithNECountAllOf {
    /**
     * Number of non-employee records associated with this source.
     * @type {number}
     * @memberof NonEmployeeSourceWithNECountAllOf
     */
    'nonEmployeeCount'?: number | null;
}
/**
 * Response model for import of a single object.
 * @export
 * @interface ObjectImportResult
 */
export interface ObjectImportResult {
    /**
     * Informational messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'infos': Array<SpConfigMessage>;
    /**
     * Warning messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'warnings': Array<SpConfigMessage>;
    /**
     * Error messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'errors': Array<SpConfigMessage>;
    /**
     * References to objects that were created or updated by the import.
     * @type {Array<ImportObject>}
     * @memberof ObjectImportResult
     */
    'importedObjects': Array<ImportObject>;
}
/**
 * 
 * @export
 * @interface ObjectMappingBulkCreateRequest
 */
export interface ObjectMappingBulkCreateRequest {
    /**
     * 
     * @type {Array<ObjectMappingRequest>}
     * @memberof ObjectMappingBulkCreateRequest
     */
    'newObjectMappings': Array<ObjectMappingRequest>;
}
/**
 * 
 * @export
 * @interface ObjectMappingBulkCreateResponse
 */
export interface ObjectMappingBulkCreateResponse {
    /**
     * 
     * @type {Array<ObjectMappingResponse>}
     * @memberof ObjectMappingBulkCreateResponse
     */
    'addedObjects'?: Array<ObjectMappingResponse>;
}
/**
 * 
 * @export
 * @interface ObjectMappingBulkPatchRequest
 */
export interface ObjectMappingBulkPatchRequest {
    /**
     * Map of id of the object mapping to a JsonPatchOperation describing what to patch on that object mapping.
     * @type {{ [key: string]: Array<JsonPatchOperation>; }}
     * @memberof ObjectMappingBulkPatchRequest
     */
    'patches': { [key: string]: Array<JsonPatchOperation>; };
}
/**
 * 
 * @export
 * @interface ObjectMappingBulkPatchResponse
 */
export interface ObjectMappingBulkPatchResponse {
    /**
     * 
     * @type {Array<ObjectMappingResponse>}
     * @memberof ObjectMappingBulkPatchResponse
     */
    'patchedObjects'?: Array<ObjectMappingResponse>;
}
/**
 * 
 * @export
 * @interface ObjectMappingRequest
 */
export interface ObjectMappingRequest {
    /**
     * Type of the object the mapping value applies to, must be one from enum
     * @type {string}
     * @memberof ObjectMappingRequest
     */
    'objectType': ObjectMappingRequestObjectTypeEnum;
    /**
     * JSONPath expression denoting the path within the object where the mapping value should be applied
     * @type {string}
     * @memberof ObjectMappingRequest
     */
    'jsonPath': string;
    /**
     * Original value at the jsonPath location within the object
     * @type {string}
     * @memberof ObjectMappingRequest
     */
    'sourceValue': string;
    /**
     * Value to be assigned at the jsonPath location within the object
     * @type {string}
     * @memberof ObjectMappingRequest
     */
    'targetValue': string;
    /**
     * Whether or not this object mapping is enabled
     * @type {boolean}
     * @memberof ObjectMappingRequest
     */
    'enabled'?: boolean;
}

export const ObjectMappingRequestObjectTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    Entitlement: 'ENTITLEMENT',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    Segment: 'SEGMENT',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflow: 'WORKFLOW'
} as const;

export type ObjectMappingRequestObjectTypeEnum = typeof ObjectMappingRequestObjectTypeEnum[keyof typeof ObjectMappingRequestObjectTypeEnum];

/**
 * 
 * @export
 * @interface ObjectMappingResponse
 */
export interface ObjectMappingResponse {
    /**
     * Id of the object mapping
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'objectMappingId'?: string;
    /**
     * Type of the object the mapping value applies to
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'objectType'?: ObjectMappingResponseObjectTypeEnum;
    /**
     * JSONPath expression denoting the path within the object where the mapping value should be applied
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'jsonPath'?: string;
    /**
     * Original value at the jsonPath location within the object
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'sourceValue'?: string;
    /**
     * Value to be assigned at the jsonPath location within the object
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'targetValue'?: string;
    /**
     * Whether or not this object mapping is enabled
     * @type {boolean}
     * @memberof ObjectMappingResponse
     */
    'enabled'?: boolean;
    /**
     * Object mapping creation timestamp
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'created'?: string;
    /**
     * Object mapping latest update timestamp
     * @type {string}
     * @memberof ObjectMappingResponse
     */
    'modified'?: string;
}

export const ObjectMappingResponseObjectTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    Entitlement: 'ENTITLEMENT',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    Segment: 'SEGMENT',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflow: 'WORKFLOW'
} as const;

export type ObjectMappingResponseObjectTypeEnum = typeof ObjectMappingResponseObjectTypeEnum[keyof typeof ObjectMappingResponseObjectTypeEnum];

/**
 * 
 * @export
 * @interface OktaVerificationRequest
 */
export interface OktaVerificationRequest {
    /**
     * User identifier for Verification request. The value of the user\'s attribute.
     * @type {string}
     * @memberof OktaVerificationRequest
     */
    'userId': string;
}
/**
 * Operation on a specific criteria
 * @export
 * @enum {string}
 */

export const Operation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    And: 'AND',
    Or: 'OR',
    Null: 'null'
} as const;

export type Operation = typeof Operation[keyof typeof Operation];


/**
 * 
 * @export
 * @interface OriginalRequest
 */
export interface OriginalRequest {
    /**
     * Account ID.
     * @type {string}
     * @memberof OriginalRequest
     */
    'accountId'?: string;
    /**
     * Attribute changes requested for account.
     * @type {Array<AttributeRequest>}
     * @memberof OriginalRequest
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * Operation used.
     * @type {string}
     * @memberof OriginalRequest
     */
    'op'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof OriginalRequest
     */
    'source'?: AccountSource;
}
/**
 * Arguments for Orphan Identities report (ORPHAN_IDENTITIES) and Uncorrelated Accounts report (UNCORRELATED_ACCOUNTS)
 * @export
 * @interface OrphanUncorrelatedReportArguments
 */
export interface OrphanUncorrelatedReportArguments {
    /**
     * Output report file formats. This are formats for calling get endpoint as a query parameter \'fileFormat\'.  In case report won\'t have this argument there will be [\'CSV\', \'PDF\'] as default.
     * @type {Array<string>}
     * @memberof OrphanUncorrelatedReportArguments
     */
    'selectedFormats'?: Array<OrphanUncorrelatedReportArgumentsSelectedFormatsEnum>;
}

export const OrphanUncorrelatedReportArgumentsSelectedFormatsEnum = {
    Csv: 'CSV',
    Pdf: 'PDF'
} as const;

export type OrphanUncorrelatedReportArgumentsSelectedFormatsEnum = typeof OrphanUncorrelatedReportArgumentsSelectedFormatsEnum[keyof typeof OrphanUncorrelatedReportArgumentsSelectedFormatsEnum];

/**
 * Owner\'s identity.
 * @export
 * @interface OwnerDto
 */
export interface OwnerDto {
    /**
     * Owner\'s DTO type.
     * @type {string}
     * @memberof OwnerDto
     */
    'type'?: OwnerDtoTypeEnum;
    /**
     * Owner\'s identity ID.
     * @type {string}
     * @memberof OwnerDto
     */
    'id'?: string;
    /**
     * Owner\'s name.
     * @type {string}
     * @memberof OwnerDto
     */
    'name'?: string;
}

export const OwnerDtoTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type OwnerDtoTypeEnum = typeof OwnerDtoTypeEnum[keyof typeof OwnerDtoTypeEnum];

/**
 * The owner of this object.
 * @export
 * @interface OwnerReference
 */
export interface OwnerReference {
    /**
     * Owner type. This field must be either left null or set to \'IDENTITY\' on input, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReference
     */
    'type'?: OwnerReferenceTypeEnum;
    /**
     * Identity id
     * @type {string}
     * @memberof OwnerReference
     */
    'id'?: string;
    /**
     * Human-readable display name of the owner. It may be left null or omitted in a POST or PATCH. If set, it must match the current value of the owner\'s display name, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReference
     */
    'name'?: string;
}

export const OwnerReferenceTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type OwnerReferenceTypeEnum = typeof OwnerReferenceTypeEnum[keyof typeof OwnerReferenceTypeEnum];

/**
 * The owner of this object.
 * @export
 * @interface OwnerReferenceSegments
 */
export interface OwnerReferenceSegments {
    /**
     * Owner type. This field must be either left null or set to \'IDENTITY\' on input, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReferenceSegments
     */
    'type'?: OwnerReferenceSegmentsTypeEnum;
    /**
     * Identity id
     * @type {string}
     * @memberof OwnerReferenceSegments
     */
    'id'?: string;
    /**
     * Human-readable display name of the owner. It may be left null or omitted in a POST or PATCH. If set, it must match the current value of the owner\'s display name, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReferenceSegments
     */
    'name'?: string;
}

export const OwnerReferenceSegmentsTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type OwnerReferenceSegmentsTypeEnum = typeof OwnerReferenceSegmentsTypeEnum[keyof typeof OwnerReferenceSegmentsTypeEnum];

/**
 * 
 * @export
 * @interface Owns
 */
export interface Owns {
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'sources'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'entitlements'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'accessProfiles'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'roles'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'apps'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'governanceGroups'?: Array<Reference1>;
    /**
     * 
     * @type {boolean}
     * @memberof Owns
     */
    'fallbackApprover'?: boolean;
}
/**
 * 
 * @export
 * @interface PasswordChangeRequest
 */
export interface PasswordChangeRequest {
    /**
     * The identity ID that requested the password change
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'identityId'?: string;
    /**
     * The RSA encrypted password
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'encryptedPassword'?: string;
    /**
     * The encryption key ID
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'publicKeyId'?: string;
    /**
     * Account ID of the account This is specified per account schema in the source configuration. It is used to distinguish accounts. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-ID-for-a/ta-p/80350
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'accountId'?: string;
    /**
     * The ID of the source for which identity is requesting the password change
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'sourceId'?: string;
}
/**
 * 
 * @export
 * @interface PasswordChangeResponse
 */
export interface PasswordChangeResponse {
    /**
     * The password change request ID
     * @type {string}
     * @memberof PasswordChangeResponse
     */
    'requestId'?: string | null;
    /**
     * Password change state
     * @type {string}
     * @memberof PasswordChangeResponse
     */
    'state'?: PasswordChangeResponseStateEnum;
}

export const PasswordChangeResponseStateEnum = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
} as const;

export type PasswordChangeResponseStateEnum = typeof PasswordChangeResponseStateEnum[keyof typeof PasswordChangeResponseStateEnum];

/**
 * 
 * @export
 * @interface PasswordInfo
 */
export interface PasswordInfo {
    /**
     * Identity ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'identityId'?: string;
    /**
     * source ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'sourceId'?: string;
    /**
     * public key ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'publicKeyId'?: string;
    /**
     * User\'s public key with Base64 encoding
     * @type {string}
     * @memberof PasswordInfo
     */
    'publicKey'?: string;
    /**
     * Account info related to queried identity and source
     * @type {Array<PasswordInfoAccount>}
     * @memberof PasswordInfo
     */
    'accounts'?: Array<PasswordInfoAccount>;
    /**
     * Password constraints
     * @type {Array<string>}
     * @memberof PasswordInfo
     */
    'policies'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PasswordInfoAccount
 */
export interface PasswordInfoAccount {
    /**
     * Account ID of the account. This is specified per account schema in the source configuration. It is used to distinguish accounts. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-ID-for-a/ta-p/80350
     * @type {string}
     * @memberof PasswordInfoAccount
     */
    'accountId'?: string;
    /**
     * Display name of the account. This is specified per account schema in the source configuration. It is used to display name of the account. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-Name-for/ta-p/74008
     * @type {string}
     * @memberof PasswordInfoAccount
     */
    'accountName'?: string;
}
/**
 * 
 * @export
 * @interface PasswordInfoQueryDTO
 */
export interface PasswordInfoQueryDTO {
    /**
     * The login name of the user
     * @type {string}
     * @memberof PasswordInfoQueryDTO
     */
    'userName'?: string;
    /**
     * The display name of the source
     * @type {string}
     * @memberof PasswordInfoQueryDTO
     */
    'sourceName'?: string;
}
/**
 * 
 * @export
 * @interface PasswordOrgConfig
 */
export interface PasswordOrgConfig {
    /**
     * Indicator whether custom password instructions feature is enabled. The default value is false.
     * @type {boolean}
     * @memberof PasswordOrgConfig
     */
    'customInstructionsEnabled'?: boolean;
    /**
     * Indicator whether \"digit token\" feature is enabled. The default value is false.
     * @type {boolean}
     * @memberof PasswordOrgConfig
     */
    'digitTokenEnabled'?: boolean;
    /**
     * The duration of \"digit token\" in minutes. The default value is 5.
     * @type {number}
     * @memberof PasswordOrgConfig
     */
    'digitTokenDurationMinutes'?: number;
    /**
     * The length of \"digit token\". The default value is 6.
     * @type {number}
     * @memberof PasswordOrgConfig
     */
    'digitTokenLength'?: number;
}
/**
 * 
 * @export
 * @interface PasswordPolicyV3Dto
 */
export interface PasswordPolicyV3Dto {
    /**
     * The password policy Id.
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'id'?: string;
    /**
     * Description for current password policy.
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'description'?: string | null;
    /**
     * The name of the password policy.
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'name'?: string;
    /**
     * Date the Password Policy was created.
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'dateCreated'?: string;
    /**
     * Date the Password Policy was updated.
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'lastUpdated'?: string | null;
    /**
     * The number of days before expiration remaninder.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'firstExpirationReminder'?: number;
    /**
     * The minimun length of account Id. By default is equals to -1.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'accountIdMinWordLength'?: number;
    /**
     * The minimun length of account name. By default is equals to -1.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'accountNameMinWordLength'?: number;
    /**
     * Maximum alpha. By default is equals to 0.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minAlpha'?: number;
    /**
     * MinCharacterTypes. By default is equals to -1.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minCharacterTypes'?: number;
    /**
     * Maximum length of the password.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'maxLength'?: number;
    /**
     * Minimum length of the password. By default is equals to 0.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minLength'?: number;
    /**
     * Maximum repetition of the same character in the password. By default is equals to -1.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'maxRepeatedChars'?: number;
    /**
     * Minimum amount of lower case character in the password. By default is equals to 0.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minLower'?: number;
    /**
     * Minimum amount of numeric characters in the password. By default is equals to 0.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minNumeric'?: number;
    /**
     * Minimum amount of special symbols in the password. By default is equals to 0.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minSpecial'?: number;
    /**
     * Minimum amount of upper case symbols in the password. By default is equals to 0.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'minUpper'?: number;
    /**
     * Number of days before current password expires. By default is equals to 90.
     * @type {number}
     * @memberof PasswordPolicyV3Dto
     */
    'passwordExpiration'?: number;
    /**
     * Defines whether this policy is default or not. Default policy is created automatically when an org is setup. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'defaultPolicy'?: boolean;
    /**
     * Defines whether this policy is enabled to expire or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'enablePasswdExpiration'?: boolean;
    /**
     * Defines whether this policy require strong Auth or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'requireStrongAuthn'?: boolean;
    /**
     * Defines whether this policy require strong Auth of network or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'requireStrongAuthOffNetwork'?: boolean;
    /**
     * Defines whether this policy require strong Auth for untrusted geographies. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'requireStrongAuthUntrustedGeographies'?: boolean;
    /**
     * Defines whether this policy uses account attributes or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'useAccountAttributes'?: boolean;
    /**
     * Defines whether this policy uses dictionary or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'useDictionary'?: boolean;
    /**
     * Defines whether this policy uses identity attributes or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'useIdentityAttributes'?: boolean;
    /**
     * Defines whether this policy validate against account id or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'validateAgainstAccountId'?: boolean;
    /**
     * Defines whether this policy validate against account name or not. This field is false by default.
     * @type {boolean}
     * @memberof PasswordPolicyV3Dto
     */
    'validateAgainstAccountName'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'created'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PasswordPolicyV3Dto
     */
    'modified'?: string | null;
    /**
     * List of sources IDs managed by this password policy.
     * @type {Array<string>}
     * @memberof PasswordPolicyV3Dto
     */
    'sourceIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PasswordStatus
 */
export interface PasswordStatus {
    /**
     * The password change request ID
     * @type {string}
     * @memberof PasswordStatus
     */
    'requestId'?: string | null;
    /**
     * Password change state
     * @type {string}
     * @memberof PasswordStatus
     */
    'state'?: PasswordStatusStateEnum;
    /**
     * The errors during the password change request
     * @type {Array<string>}
     * @memberof PasswordStatus
     */
    'errors'?: Array<string>;
    /**
     * List of source IDs in the password change request
     * @type {Array<string>}
     * @memberof PasswordStatus
     */
    'sourceIds'?: Array<string>;
}

export const PasswordStatusStateEnum = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
} as const;

export type PasswordStatusStateEnum = typeof PasswordStatusStateEnum[keyof typeof PasswordStatusStateEnum];

/**
 * 
 * @export
 * @interface PasswordSyncGroup
 */
export interface PasswordSyncGroup {
    /**
     * ID of the sync group
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'id'?: string;
    /**
     * Name of the sync group
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'name'?: string;
    /**
     * ID of the password policy
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'passwordPolicyId'?: string;
    /**
     * List of password managed sources IDs
     * @type {Array<string>}
     * @memberof PasswordSyncGroup
     */
    'sourceIds'?: Array<string>;
    /**
     * The date and time this sync group was created
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'created'?: string | null;
    /**
     * The date and time this sync group was last modified
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'modified'?: string | null;
}
/**
 * Personal access token owner\'s identity.
 * @export
 * @interface PatOwner
 */
export interface PatOwner {
    /**
     * Personal access token owner\'s DTO type.
     * @type {string}
     * @memberof PatOwner
     */
    'type'?: PatOwnerTypeEnum;
    /**
     * Personal access token owner\'s identity ID.
     * @type {string}
     * @memberof PatOwner
     */
    'id'?: string;
    /**
     * Personal access token owner\'s human-readable display name.
     * @type {string}
     * @memberof PatOwner
     */
    'name'?: string;
}

export const PatOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type PatOwnerTypeEnum = typeof PatOwnerTypeEnum[keyof typeof PatOwnerTypeEnum];

/**
 * A JSONPatch document as defined by [RFC 6902 - JSON Patch](https://tools.ietf.org/html/rfc6902).  Only `replace` operations are accepted by this endpoint.
 * @export
 * @interface PatchServiceDeskIntegrationRequest
 */
export interface PatchServiceDeskIntegrationRequest {
    /**
     * Operations to be applied
     * @type {Array<JsonPatchOperation>}
     * @memberof PatchServiceDeskIntegrationRequest
     */
    'operations'?: Array<JsonPatchOperation>;
}
/**
 * 
 * @export
 * @interface PendingApproval
 */
export interface PendingApproval {
    /**
     * The approval id.
     * @type {string}
     * @memberof PendingApproval
     */
    'id'?: string;
    /**
     * The name of the approval.
     * @type {string}
     * @memberof PendingApproval
     */
    'name'?: string;
    /**
     * When the approval was created.
     * @type {string}
     * @memberof PendingApproval
     */
    'created'?: string;
    /**
     * When the approval was modified last time.
     * @type {string}
     * @memberof PendingApproval
     */
    'modified'?: string;
    /**
     * When the access-request was created.
     * @type {string}
     * @memberof PendingApproval
     */
    'requestCreated'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof PendingApproval
     */
    'requestType'?: AccessRequestType | null;
    /**
     * 
     * @type {AccessItemRequester}
     * @memberof PendingApproval
     */
    'requester'?: AccessItemRequester;
    /**
     * Identities access was requested for.
     * @type {Array<AccessItemRequestedFor>}
     * @memberof PendingApproval
     */
    'requestedFor'?: Array<AccessItemRequestedFor>;
    /**
     * 
     * @type {PendingApprovalOwner}
     * @memberof PendingApproval
     */
    'owner'?: PendingApprovalOwner;
    /**
     * 
     * @type {RequestableObjectReference}
     * @memberof PendingApproval
     */
    'requestedObject'?: RequestableObjectReference;
    /**
     * 
     * @type {CommentDto}
     * @memberof PendingApproval
     */
    'requesterComment'?: CommentDto;
    /**
     * The history of the previous reviewers comments.
     * @type {Array<CommentDto>}
     * @memberof PendingApproval
     */
    'previousReviewersComments'?: Array<CommentDto>;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof PendingApproval
     */
    'forwardHistory'?: Array<ApprovalForwardHistory>;
    /**
     * When true the rejector has to provide comments when rejecting
     * @type {boolean}
     * @memberof PendingApproval
     */
    'commentRequiredWhenRejected'?: boolean;
    /**
     * 
     * @type {PendingApprovalAction}
     * @memberof PendingApproval
     */
    'actionInProcess'?: PendingApprovalAction;
    /**
     * The date the role or access profile or entitlement is no longer assigned to the specified identity.
     * @type {string}
     * @memberof PendingApproval
     */
    'removeDate'?: string;
    /**
     * If true, then the request is to change the remove date or sunset date.
     * @type {boolean}
     * @memberof PendingApproval
     */
    'removeDateUpdateRequested'?: boolean;
    /**
     * The remove date or sunset date that was assigned at the time of the request.
     * @type {string}
     * @memberof PendingApproval
     */
    'currentRemoveDate'?: string;
    /**
     * 
     * @type {SodViolationContextCheckCompleted}
     * @memberof PendingApproval
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted;
}
/**
 * Enum represents action that is being processed on an approval.
 * @export
 * @enum {string}
 */

export const PendingApprovalAction = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Forwarded: 'FORWARDED'
} as const;

export type PendingApprovalAction = typeof PendingApprovalAction[keyof typeof PendingApprovalAction];


/**
 * Access item owner\'s identity.
 * @export
 * @interface PendingApprovalOwner
 */
export interface PendingApprovalOwner {
    /**
     * Access item owner\'s DTO type.
     * @type {string}
     * @memberof PendingApprovalOwner
     */
    'type'?: PendingApprovalOwnerTypeEnum;
    /**
     * Access item owner\'s identity ID.
     * @type {string}
     * @memberof PendingApprovalOwner
     */
    'id'?: string;
    /**
     * Access item owner\'s human-readable display name.
     * @type {string}
     * @memberof PendingApprovalOwner
     */
    'name'?: string;
}

export const PendingApprovalOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type PendingApprovalOwnerTypeEnum = typeof PendingApprovalOwnerTypeEnum[keyof typeof PendingApprovalOwnerTypeEnum];

/**
 * Simplified DTO for the Permission objects stored in SailPoint\'s database. The data is aggregated from customer systems and is free-form, so its appearance can vary largely between different clients/customers.
 * @export
 * @interface PermissionDto
 */
export interface PermissionDto {
    /**
     * All the rights (e.g. actions) that this permission allows on the target
     * @type {Array<string>}
     * @memberof PermissionDto
     */
    'rights'?: Array<string>;
    /**
     * The target the permission would grants rights on.
     * @type {string}
     * @memberof PermissionDto
     */
    'target'?: string;
}
/**
 * Provides additional details about the pre-approval trigger for this request.
 * @export
 * @interface PreApprovalTriggerDetails
 */
export interface PreApprovalTriggerDetails {
    /**
     * Comment left for the pre-approval decision
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'comment'?: string;
    /**
     * The reviewer of the pre-approval decision
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'reviewer'?: string;
    /**
     * The decision of the pre-approval trigger
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'decision'?: PreApprovalTriggerDetailsDecisionEnum;
}

export const PreApprovalTriggerDetailsDecisionEnum = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type PreApprovalTriggerDetailsDecisionEnum = typeof PreApprovalTriggerDetailsDecisionEnum[keyof typeof PreApprovalTriggerDetailsDecisionEnum];

/**
 * 
 * @export
 * @interface ProcessingDetails
 */
export interface ProcessingDetails {
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof ProcessingDetails
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'stage'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProcessingDetails
     */
    'retryCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'stackTrace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'message'?: string;
}
/**
 * Specification of a Service Desk integration provisioning configuration.
 * @export
 * @interface ProvisioningConfig
 */
export interface ProvisioningConfig {
    /**
     * Specifies whether this configuration is used to manage provisioning requests for all sources from the org.  If true, no managedResourceRefs are allowed.
     * @type {boolean}
     * @memberof ProvisioningConfig
     */
    'universalManager'?: boolean;
    /**
     * References to sources for the Service Desk integration template.  May only be specified if universalManager is false.
     * @type {Array<ProvisioningConfigManagedResourceRefsInner>}
     * @memberof ProvisioningConfig
     */
    'managedResourceRefs'?: Array<ProvisioningConfigManagedResourceRefsInner>;
    /**
     * 
     * @type {ProvisioningConfigPlanInitializerScript}
     * @memberof ProvisioningConfig
     */
    'planInitializerScript'?: ProvisioningConfigPlanInitializerScript | null;
    /**
     * Name of an attribute that when true disables the saving of ProvisioningRequest objects whenever plans are sent through this integration.
     * @type {boolean}
     * @memberof ProvisioningConfig
     */
    'noProvisioningRequests'?: boolean;
    /**
     * When saving pending requests is enabled, this defines the number of hours the request is allowed to live before it is considered expired and no longer affects plan compilation.
     * @type {number}
     * @memberof ProvisioningConfig
     */
    'provisioningRequestExpiration'?: number;
}
/**
 * 
 * @export
 * @interface ProvisioningConfigManagedResourceRefsInner
 */
export interface ProvisioningConfigManagedResourceRefsInner {
    /**
     * DTO type of source for service desk integration template.
     * @type {string}
     * @memberof ProvisioningConfigManagedResourceRefsInner
     */
    'type'?: ProvisioningConfigManagedResourceRefsInnerTypeEnum;
    /**
     * ID of source for service desk integration template.
     * @type {string}
     * @memberof ProvisioningConfigManagedResourceRefsInner
     */
    'id'?: string;
    /**
     * Human-readable name of source for service desk integration template.
     * @type {string}
     * @memberof ProvisioningConfigManagedResourceRefsInner
     */
    'name'?: string;
}

export const ProvisioningConfigManagedResourceRefsInnerTypeEnum = {
    Source: 'SOURCE'
} as const;

export type ProvisioningConfigManagedResourceRefsInnerTypeEnum = typeof ProvisioningConfigManagedResourceRefsInnerTypeEnum[keyof typeof ProvisioningConfigManagedResourceRefsInnerTypeEnum];

/**
 * This is a reference to a plan initializer script.
 * @export
 * @interface ProvisioningConfigPlanInitializerScript
 */
export interface ProvisioningConfigPlanInitializerScript {
    /**
     * This is a Rule that allows provisioning instruction changes.
     * @type {string}
     * @memberof ProvisioningConfigPlanInitializerScript
     */
    'source'?: string;
}
/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel1
 */
export interface ProvisioningCriteriaLevel1 {
    /**
     * 
     * @type {ProvisioningCriteriaOperation}
     * @memberof ProvisioningCriteriaLevel1
     */
    'operation'?: ProvisioningCriteriaOperation;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel1
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel1
     */
    'value'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes.
     * @type {Array<ProvisioningCriteriaLevel2>}
     * @memberof ProvisioningCriteriaLevel1
     */
    'children'?: Array<ProvisioningCriteriaLevel2> | null;
}
/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel2
 */
export interface ProvisioningCriteriaLevel2 {
    /**
     * 
     * @type {ProvisioningCriteriaOperation}
     * @memberof ProvisioningCriteriaLevel2
     */
    'operation'?: ProvisioningCriteriaOperation;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel2
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel2
     */
    'value'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes.
     * @type {Array<ProvisioningCriteriaLevel3>}
     * @memberof ProvisioningCriteriaLevel2
     */
    'children'?: Array<ProvisioningCriteriaLevel3> | null;
}
/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel3
 */
export interface ProvisioningCriteriaLevel3 {
    /**
     * 
     * @type {ProvisioningCriteriaOperation}
     * @memberof ProvisioningCriteriaLevel3
     */
    'operation'?: ProvisioningCriteriaOperation;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel3
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel3
     */
    'value'?: string;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel3
     */
    'children'?: string | null;
}
/**
 * Supported operations on ProvisioningCriteria
 * @export
 * @enum {string}
 */

export const ProvisioningCriteriaOperation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    Has: 'HAS',
    And: 'AND',
    Or: 'OR'
} as const;

export type ProvisioningCriteriaOperation = typeof ProvisioningCriteriaOperation[keyof typeof ProvisioningCriteriaOperation];


/**
 * Provides additional details about provisioning for this request.
 * @export
 * @interface ProvisioningDetails
 */
export interface ProvisioningDetails {
    /**
     * Ordered CSV of sub phase references to objects that contain more information about provisioning. For example, this can contain \"manualWorkItemDetails\" which indicate that there is further information in that object for this phase.
     * @type {string}
     * @memberof ProvisioningDetails
     */
    'orderedSubPhaseReferences'?: string;
}
/**
 * 
 * @export
 * @interface ProvisioningPolicy
 */
export interface ProvisioningPolicy {
    /**
     * the provisioning policy name
     * @type {string}
     * @memberof ProvisioningPolicy
     */
    'name': string;
    /**
     * the description of the provisioning policy
     * @type {string}
     * @memberof ProvisioningPolicy
     */
    'description'?: string;
    /**
     * 
     * @type {UsageType}
     * @memberof ProvisioningPolicy
     */
    'usageType'?: UsageType;
    /**
     * 
     * @type {Array<FieldDetailsDto>}
     * @memberof ProvisioningPolicy
     */
    'fields'?: Array<FieldDetailsDto>;
}
/**
 * 
 * @export
 * @interface ProvisioningPolicyDto
 */
export interface ProvisioningPolicyDto {
    /**
     * the provisioning policy name
     * @type {string}
     * @memberof ProvisioningPolicyDto
     */
    'name': string;
    /**
     * the description of the provisioning policy
     * @type {string}
     * @memberof ProvisioningPolicyDto
     */
    'description'?: string;
    /**
     * 
     * @type {UsageType}
     * @memberof ProvisioningPolicyDto
     */
    'usageType'?: UsageType;
    /**
     * 
     * @type {Array<FieldDetailsDto>}
     * @memberof ProvisioningPolicyDto
     */
    'fields'?: Array<FieldDetailsDto>;
}
/**
 * Provisioning state of an account activity item
 * @export
 * @enum {string}
 */

export const ProvisioningState = {
    Pending: 'PENDING',
    Finished: 'FINISHED',
    Unverifiable: 'UNVERIFIABLE',
    Commited: 'COMMITED',
    Failed: 'FAILED',
    Retry: 'RETRY'
} as const;

export type ProvisioningState = typeof ProvisioningState[keyof typeof ProvisioningState];


/**
 * Details about a public identity
 * @export
 * @interface PublicIdentity
 */
export interface PublicIdentity {
    /**
     * Identity id
     * @type {string}
     * @memberof PublicIdentity
     */
    'id'?: string;
    /**
     * Human-readable display name of identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'name'?: string;
    /**
     * Alternate unique identifier for the identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'alias'?: string;
    /**
     * Email address of identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'email'?: string | null;
    /**
     * The lifecycle status for the identity
     * @type {string}
     * @memberof PublicIdentity
     */
    'status'?: string | null;
    /**
     * The current state of the identity, which determines how Identity Security Cloud interacts with the identity. An identity that is Active will be included identity picklists in Request Center, identity processing, and more. Identities that are Inactive will be excluded from these features. 
     * @type {string}
     * @memberof PublicIdentity
     */
    'identityState'?: PublicIdentityIdentityStateEnum;
    /**
     * 
     * @type {IdentityReference}
     * @memberof PublicIdentity
     */
    'manager'?: IdentityReference | null;
    /**
     * The public identity attributes of the identity
     * @type {Array<IdentityAttribute1>}
     * @memberof PublicIdentity
     */
    'attributes'?: Array<IdentityAttribute1>;
}

export const PublicIdentityIdentityStateEnum = {
    Active: 'ACTIVE',
    InactiveShortTerm: 'INACTIVE_SHORT_TERM',
    InactiveLongTerm: 'INACTIVE_LONG_TERM',
    Null: 'null'
} as const;

export type PublicIdentityIdentityStateEnum = typeof PublicIdentityIdentityStateEnum[keyof typeof PublicIdentityIdentityStateEnum];

/**
 * Used to map an attribute key for an Identity to its display name.
 * @export
 * @interface PublicIdentityAttributeConfig
 */
export interface PublicIdentityAttributeConfig {
    /**
     * The attribute key
     * @type {string}
     * @memberof PublicIdentityAttributeConfig
     */
    'key'?: string;
    /**
     * The attribute display name
     * @type {string}
     * @memberof PublicIdentityAttributeConfig
     */
    'name'?: string;
}
/**
 * Details of up to 5 Identity attributes that will be publicly accessible for all Identities to anyone in the org.
 * @export
 * @interface PublicIdentityConfig
 */
export interface PublicIdentityConfig {
    /**
     * Up to 5 identity attributes that will be available to everyone in the org for all users in the org.
     * @type {Array<PublicIdentityAttributeConfig>}
     * @memberof PublicIdentityConfig
     */
    'attributes'?: Array<PublicIdentityAttributeConfig>;
    /**
     * When this configuration was last modified.
     * @type {string}
     * @memberof PublicIdentityConfig
     */
    'modified'?: string | null;
    /**
     * 
     * @type {IdentityReference}
     * @memberof PublicIdentityConfig
     */
    'modifiedBy'?: IdentityReference | null;
}
/**
 * 
 * @export
 * @interface PutCorrelationConfigRequest
 */
export interface PutCorrelationConfigRequest {
    /**
     * connector correlation config xml file
     * @type {any}
     * @memberof PutCorrelationConfigRequest
     */
    'file': any;
}
/**
 * 
 * @export
 * @interface PutPasswordDictionaryRequest
 */
export interface PutPasswordDictionaryRequest {
    /**
     * 
     * @type {any}
     * @memberof PutPasswordDictionaryRequest
     */
    'file'?: any;
}
/**
 * 
 * @export
 * @interface PutSourceConfigRequest
 */
export interface PutSourceConfigRequest {
    /**
     * connector source config xml file
     * @type {any}
     * @memberof PutSourceConfigRequest
     */
    'file': any;
}
/**
 * 
 * @export
 * @interface PutSourceTemplateRequest
 */
export interface PutSourceTemplateRequest {
    /**
     * connector source template xml file
     * @type {any}
     * @memberof PutSourceTemplateRequest
     */
    'file': any;
}
/**
 * Query parameters used to construct an Elasticsearch query object.
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * The query using the Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL extended by SailPoint to support Nested queries.
     * @type {string}
     * @memberof Query
     */
    'query'?: string;
    /**
     * The fields the query will be applied to.  Fields provide you with a simple way to add additional fields to search, without making the query too complicated.  For example, you can use the fields to specify that you want your query of \"a*\" to be applied to \"name\", \"firstName\", and the \"source.name\".  The response will include all results matching the \"a*\" query found in those three fields.  A field\'s availability depends on the indices being searched.  For example, if you are searching \"identities\", you can apply your search to the \"firstName\" field, but you couldn\'t use \"firstName\" with a search on \"access profiles\".  Refer to the response schema for the respective lists of available fields. 
     * @type {string}
     * @memberof Query
     */
    'fields'?: string;
    /**
     * The time zone to be applied to any range query related to dates.
     * @type {string}
     * @memberof Query
     */
    'timeZone'?: string;
    /**
     * 
     * @type {InnerHit}
     * @memberof Query
     */
    'innerHit'?: InnerHit;
}
/**
 * Allows the query results to be filtered by specifying a list of fields to include and/or exclude from the result documents.
 * @export
 * @interface QueryResultFilter
 */
export interface QueryResultFilter {
    /**
     * The list of field names to include in the result documents.
     * @type {Array<string>}
     * @memberof QueryResultFilter
     */
    'includes'?: Array<string>;
    /**
     * The list of field names to exclude from the result documents.
     * @type {Array<string>}
     * @memberof QueryResultFilter
     */
    'excludes'?: Array<string>;
}
/**
 * The type of query to use.  By default, the `SAILPOINT` query type is used, which requires the `query` object to be defined in the request body. To use the `queryDsl` or `typeAheadQuery` objects in the request, you must set the type to `DSL` or `TYPEAHEAD` accordingly. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const QueryType = {
    Dsl: 'DSL',
    Sailpoint: 'SAILPOINT',
    Text: 'TEXT',
    Typeahead: 'TYPEAHEAD'
} as const;

export type QueryType = typeof QueryType[keyof typeof QueryType];


/**
 * Configuration of maximum number days and interval for checking Service Desk integration queue status
 * @export
 * @interface QueuedCheckConfigDetails
 */
export interface QueuedCheckConfigDetails {
    /**
     * interval in minutes between status checks
     * @type {string}
     * @memberof QueuedCheckConfigDetails
     */
    'provisioningStatusCheckIntervalMinutes': string;
    /**
     * maximum number of days to check
     * @type {string}
     * @memberof QueuedCheckConfigDetails
     */
    'provisioningMaxStatusCheckDays': string;
}
/**
 * 
 * @export
 * @interface RandomAlphaNumeric
 */
export interface RandomAlphaNumeric {
    /**
     * This is an integer value specifying the size/number of characters the random string must contain   * This value must be a positive number and cannot be blank   * If no length is provided, the transform will default to a value of `32`   * Due to identity attribute data constraints, the maximum allowable value is `450` characters 
     * @type {string}
     * @memberof RandomAlphaNumeric
     */
    'length'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RandomAlphaNumeric
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RandomAlphaNumeric
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface RandomNumeric
 */
export interface RandomNumeric {
    /**
     * This is an integer value specifying the size/number of characters the random string must contain   * This value must be a positive number and cannot be blank   * If no length is provided, the transform will default to a value of `32`   * Due to identity attribute data constraints, the maximum allowable value is `450` characters 
     * @type {string}
     * @memberof RandomNumeric
     */
    'length'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RandomNumeric
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RandomNumeric
     */
    'input'?: { [key: string]: any; };
}
/**
 * The range of values to be filtered.
 * @export
 * @interface Range
 */
export interface Range {
    /**
     * 
     * @type {Bound}
     * @memberof Range
     */
    'lower'?: Bound;
    /**
     * 
     * @type {Bound}
     * @memberof Range
     */
    'upper'?: Bound;
}
/**
 * 
 * @export
 * @interface ReassignReference
 */
export interface ReassignReference {
    /**
     * The ID of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignReference
     */
    'id': string;
    /**
     * The type of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignReference
     */
    'type': ReassignReferenceTypeEnum;
}

export const ReassignReferenceTypeEnum = {
    TargetSummary: 'TARGET_SUMMARY',
    Item: 'ITEM',
    IdentitySummary: 'IDENTITY_SUMMARY'
} as const;

export type ReassignReferenceTypeEnum = typeof ReassignReferenceTypeEnum[keyof typeof ReassignReferenceTypeEnum];

/**
 * 
 * @export
 * @interface Reassignment
 */
export interface Reassignment {
    /**
     * 
     * @type {CertificationReference}
     * @memberof Reassignment
     */
    'from'?: CertificationReference;
    /**
     * The comment entered when the Certification was reassigned
     * @type {string}
     * @memberof Reassignment
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface ReassignmentReference
 */
export interface ReassignmentReference {
    /**
     * The ID of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignmentReference
     */
    'id': string;
    /**
     * The type of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignmentReference
     */
    'type': ReassignmentReferenceTypeEnum;
}

export const ReassignmentReferenceTypeEnum = {
    TargetSummary: 'TARGET_SUMMARY',
    Item: 'ITEM',
    IdentitySummary: 'IDENTITY_SUMMARY'
} as const;

export type ReassignmentReferenceTypeEnum = typeof ReassignmentReferenceTypeEnum[keyof typeof ReassignmentReferenceTypeEnum];

/**
 * 
 * @export
 * @interface ReassignmentTrailDTO
 */
export interface ReassignmentTrailDTO {
    /**
     * The ID of previous owner identity.
     * @type {string}
     * @memberof ReassignmentTrailDTO
     */
    'previousOwner'?: string;
    /**
     * The ID of new owner identity.
     * @type {string}
     * @memberof ReassignmentTrailDTO
     */
    'newOwner'?: string;
    /**
     * The type of reassignment.
     * @type {string}
     * @memberof ReassignmentTrailDTO
     */
    'reassignmentType'?: string;
}
/**
 * The approval reassignment type.  * MANUAL_REASSIGNMENT: An approval with this reassignment type has been specifically reassigned by the approval task\'s owner, from their queue to someone else\'s.  * AUTOMATIC_REASSIGNMENT: An approval with this reassignment type has been automatically reassigned from another approver\'s queue, according to that approver\'s reassignment configuration. The approver\'s reassignment configuration may be set up to automatically reassign approval tasks for a defined (or possibly open-ended) period of time. * AUTO_ESCALATION: An approval with this reassignment type has been automatically reassigned from another approver\'s queue, according to the request\'s escalation configuration. For more information about escalation configuration, refer to [Setting Global Reminders and Escalation Policies](https://documentation.sailpoint.com/saas/help/requests/config_emails.html). * SELF_REVIEW_DELEGATION: An approval with this reassignment type has been automatically reassigned by the system to prevent self-review. This helps prevent situations like a requester being tasked with approving their own request. For more information about preventing self-review, refer to [Self-review Prevention](https://documentation.sailpoint.com/saas/help/users/work_reassignment.html#self-review-prevention) and [Preventing Self-approval](https://documentation.sailpoint.com/saas/help/requests/config_ap_roles.html#preventing-self-approval).
 * @export
 * @enum {string}
 */

export const ReassignmentType = {
    ManualReassignment: 'MANUAL_REASSIGNMENT',
    AutomaticReassignment: 'AUTOMATIC_REASSIGNMENT',
    AutoEscalation: 'AUTO_ESCALATION',
    SelfReviewDelegation: 'SELF_REVIEW_DELEGATION'
} as const;

export type ReassignmentType = typeof ReassignmentType[keyof typeof ReassignmentType];


/**
 * 
 * @export
 * @interface Reference
 */
export interface Reference {
    /**
     * This ID specifies the name of the pre-existing transform which you want to use within your current transform
     * @type {string}
     * @memberof Reference
     */
    'id': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Reference
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Reference
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Reference1
 */
export interface Reference1 {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof Reference1
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof Reference1
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RemediationItemDetails
 */
export interface RemediationItemDetails {
    /**
     * The ID of the certification
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'id'?: string;
    /**
     * The ID of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetId'?: string;
    /**
     * The name of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetName'?: string;
    /**
     * The display name of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetDisplayName'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'applicationName'?: string;
    /**
     * The name of the attribute being certified
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeName'?: string;
    /**
     * The operation of the certification on the attribute
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute being certified
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeValue'?: string;
    /**
     * The native identity of the target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'nativeIdentity'?: string;
}
/**
 * 
 * @export
 * @interface RemediationItems
 */
export interface RemediationItems {
    /**
     * The ID of the certification
     * @type {string}
     * @memberof RemediationItems
     */
    'id'?: string;
    /**
     * The ID of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetId'?: string;
    /**
     * The name of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetName'?: string;
    /**
     * The display name of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetDisplayName'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof RemediationItems
     */
    'applicationName'?: string;
    /**
     * The name of the attribute being certified
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeName'?: string;
    /**
     * The operation of the certification on the attribute
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute being certified
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeValue'?: string;
    /**
     * The native identity of the target
     * @type {string}
     * @memberof RemediationItems
     */
    'nativeIdentity'?: string;
}
/**
 * 
 * @export
 * @interface Replace
 */
export interface Replace {
    /**
     * This can be a string or a regex pattern in which you want to replace.
     * @type {string}
     * @memberof Replace
     */
    'regex': string;
    /**
     * This is the replacement string that should be substituded wherever the string or pattern is found.
     * @type {string}
     * @memberof Replace
     */
    'replacement': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Replace
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Replace
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ReplaceAll
 */
export interface ReplaceAll {
    /**
     * An attribute of key-value pairs. Each pair identifies the pattern to search for as its key, and the replacement string as its value.
     * @type {{ [key: string]: any; }}
     * @memberof ReplaceAll
     */
    'table': { [key: string]: any; };
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof ReplaceAll
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof ReplaceAll
     */
    'input'?: { [key: string]: any; };
}
/**
 * Details about report to be processed.
 * @export
 * @interface ReportDetails
 */
export interface ReportDetails {
    /**
     * Use this property to define what report should be processed in the RDE service.
     * @type {string}
     * @memberof ReportDetails
     */
    'reportType'?: ReportDetailsReportTypeEnum;
    /**
     * 
     * @type {ReportDetailsArguments}
     * @memberof ReportDetails
     */
    'arguments'?: ReportDetailsArguments;
}

export const ReportDetailsReportTypeEnum = {
    Accounts: 'ACCOUNTS',
    IdentitiesDetails: 'IDENTITIES_DETAILS',
    Identities: 'IDENTITIES',
    IdentityProfileIdentityError: 'IDENTITY_PROFILE_IDENTITY_ERROR',
    OrphanIdentities: 'ORPHAN_IDENTITIES',
    SearchExport: 'SEARCH_EXPORT',
    UncorrelatedAccounts: 'UNCORRELATED_ACCOUNTS'
} as const;

export type ReportDetailsReportTypeEnum = typeof ReportDetailsReportTypeEnum[keyof typeof ReportDetailsReportTypeEnum];

/**
 * @type ReportDetailsArguments
 * The string-object map(dictionary) with the arguments needed for report processing.
 * @export
 */
export type ReportDetailsArguments = AccountsExportReportArguments | IdentitiesDetailsReportArguments | IdentitiesReportArguments | IdentityProfileIdentityErrorReportArguments | OrphanUncorrelatedReportArguments | SearchExportReportArguments;

/**
 * 
 * @export
 * @interface ReportResultReference
 */
export interface ReportResultReference {
    /**
     * SOD policy violation report result DTO type.
     * @type {string}
     * @memberof ReportResultReference
     */
    'type'?: ReportResultReferenceTypeEnum;
    /**
     * SOD policy violation report result ID.
     * @type {string}
     * @memberof ReportResultReference
     */
    'id'?: string;
    /**
     * Human-readable name of the SOD policy violation report result.
     * @type {string}
     * @memberof ReportResultReference
     */
    'name'?: string;
    /**
     * Status of a SOD policy violation report.
     * @type {string}
     * @memberof ReportResultReference
     */
    'status'?: ReportResultReferenceStatusEnum;
}

export const ReportResultReferenceTypeEnum = {
    ReportResult: 'REPORT_RESULT'
} as const;

export type ReportResultReferenceTypeEnum = typeof ReportResultReferenceTypeEnum[keyof typeof ReportResultReferenceTypeEnum];
export const ReportResultReferenceStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
} as const;

export type ReportResultReferenceStatusEnum = typeof ReportResultReferenceStatusEnum[keyof typeof ReportResultReferenceStatusEnum];

/**
 * 
 * @export
 * @interface ReportResultReferenceAllOf
 */
export interface ReportResultReferenceAllOf {
    /**
     * Status of a SOD policy violation report.
     * @type {string}
     * @memberof ReportResultReferenceAllOf
     */
    'status'?: ReportResultReferenceAllOfStatusEnum;
}

export const ReportResultReferenceAllOfStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
} as const;

export type ReportResultReferenceAllOfStatusEnum = typeof ReportResultReferenceAllOfStatusEnum[keyof typeof ReportResultReferenceAllOfStatusEnum];

/**
 * Details about report result or current state.
 * @export
 * @interface ReportResults
 */
export interface ReportResults {
    /**
     * Use this property to define what report should be processed in the RDE service.
     * @type {string}
     * @memberof ReportResults
     */
    'reportType'?: ReportResultsReportTypeEnum;
    /**
     * Name of the task definition which is started to process requesting report. Usually the same as report name
     * @type {string}
     * @memberof ReportResults
     */
    'taskDefName'?: string;
    /**
     * Unique task definition identifier.
     * @type {string}
     * @memberof ReportResults
     */
    'id'?: string;
    /**
     * Report processing start date
     * @type {string}
     * @memberof ReportResults
     */
    'created'?: string;
    /**
     * Report current state or result status.
     * @type {string}
     * @memberof ReportResults
     */
    'status'?: ReportResultsStatusEnum;
    /**
     * Report processing time in ms.
     * @type {number}
     * @memberof ReportResults
     */
    'duration'?: number;
    /**
     * Report size in rows.
     * @type {number}
     * @memberof ReportResults
     */
    'rows'?: number;
    /**
     * Output report file formats. This are formats for calling get endpoint as a query parameter \'fileFormat\'.  In case report won\'t have this argument there will be [\'CSV\', \'PDF\'] as default.
     * @type {Array<string>}
     * @memberof ReportResults
     */
    'availableFormats'?: Array<ReportResultsAvailableFormatsEnum>;
}

export const ReportResultsReportTypeEnum = {
    Accounts: 'ACCOUNTS',
    IdentitiesDetails: 'IDENTITIES_DETAILS',
    Identities: 'IDENTITIES',
    IdentityProfileIdentityError: 'IDENTITY_PROFILE_IDENTITY_ERROR',
    OrphanIdentities: 'ORPHAN_IDENTITIES',
    SearchExport: 'SEARCH_EXPORT',
    UncorrelatedAccounts: 'UNCORRELATED_ACCOUNTS'
} as const;

export type ReportResultsReportTypeEnum = typeof ReportResultsReportTypeEnum[keyof typeof ReportResultsReportTypeEnum];
export const ReportResultsStatusEnum = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Warning: 'WARNING',
    Terminated: 'TERMINATED'
} as const;

export type ReportResultsStatusEnum = typeof ReportResultsStatusEnum[keyof typeof ReportResultsStatusEnum];
export const ReportResultsAvailableFormatsEnum = {
    Csv: 'CSV',
    Pdf: 'PDF'
} as const;

export type ReportResultsAvailableFormatsEnum = typeof ReportResultsAvailableFormatsEnum[keyof typeof ReportResultsAvailableFormatsEnum];

/**
 * type of a Report
 * @export
 * @enum {string}
 */

export const ReportType = {
    CampaignCompositionReport: 'CAMPAIGN_COMPOSITION_REPORT',
    CampaignRemediationStatusReport: 'CAMPAIGN_REMEDIATION_STATUS_REPORT',
    CampaignStatusReport: 'CAMPAIGN_STATUS_REPORT',
    CertificationSignoffReport: 'CERTIFICATION_SIGNOFF_REPORT'
} as const;

export type ReportType = typeof ReportType[keyof typeof ReportType];


/**
 * 
 * @export
 * @interface RequestOnBehalfOfConfig
 */
export interface RequestOnBehalfOfConfig {
    /**
     * If this is true, anyone can request access for anyone.
     * @type {boolean}
     * @memberof RequestOnBehalfOfConfig
     */
    'allowRequestOnBehalfOfAnyoneByAnyone'?: boolean;
    /**
     * If this is true, a manager can request access for his or her direct reports.
     * @type {boolean}
     * @memberof RequestOnBehalfOfConfig
     */
    'allowRequestOnBehalfOfEmployeeByManager'?: boolean;
}
/**
 * 
 * @export
 * @interface Requestability
 */
export interface Requestability {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof Requestability
     */
    'commentsRequired'?: boolean | null;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof Requestability
     */
    'denialCommentsRequired'?: boolean | null;
    /**
     * List describing the steps in approving the request
     * @type {Array<AccessProfileApprovalScheme>}
     * @memberof Requestability
     */
    'approvalSchemes'?: Array<AccessProfileApprovalScheme> | null;
}
/**
 * 
 * @export
 * @interface RequestabilityForRole
 */
export interface RequestabilityForRole {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof RequestabilityForRole
     */
    'commentsRequired'?: boolean | null;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof RequestabilityForRole
     */
    'denialCommentsRequired'?: boolean | null;
    /**
     * List describing the steps in approving the request
     * @type {Array<ApprovalSchemeForRole>}
     * @memberof RequestabilityForRole
     */
    'approvalSchemes'?: Array<ApprovalSchemeForRole>;
}
/**
 * 
 * @export
 * @interface RequestableObject
 */
export interface RequestableObject {
    /**
     * Id of the requestable object itself
     * @type {string}
     * @memberof RequestableObject
     */
    'id'?: string;
    /**
     * Human-readable display name of the requestable object
     * @type {string}
     * @memberof RequestableObject
     */
    'name'?: string;
    /**
     * The time when the requestable object was created
     * @type {string}
     * @memberof RequestableObject
     */
    'created'?: string;
    /**
     * The time when the requestable object was last modified
     * @type {string}
     * @memberof RequestableObject
     */
    'modified'?: string | null;
    /**
     * Description of the requestable object.
     * @type {string}
     * @memberof RequestableObject
     */
    'description'?: string | null;
    /**
     * 
     * @type {RequestableObjectType}
     * @memberof RequestableObject
     */
    'type'?: RequestableObjectType;
    /**
     * 
     * @type {RequestableObjectRequestStatus & object}
     * @memberof RequestableObject
     */
    'requestStatus'?: RequestableObjectRequestStatus & object;
    /**
     * If *requestStatus* is *PENDING*, indicates the id of the associated account activity.
     * @type {string}
     * @memberof RequestableObject
     */
    'identityRequestId'?: string | null;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof RequestableObject
     */
    'ownerRef'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * Whether the requester must provide comments when requesting the object.
     * @type {boolean}
     * @memberof RequestableObject
     */
    'requestCommentsRequired'?: boolean;
}
/**
 * 
 * @export
 * @interface RequestableObjectReference
 */
export interface RequestableObjectReference {
    /**
     * Id of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'id'?: string;
    /**
     * Name of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'name'?: string;
    /**
     * Description of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'description'?: string;
    /**
     * Type of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'type'?: RequestableObjectReferenceTypeEnum;
}

export const RequestableObjectReferenceTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestableObjectReferenceTypeEnum = typeof RequestableObjectReferenceTypeEnum[keyof typeof RequestableObjectReferenceTypeEnum];

/**
 * Status indicating the ability of an access request for the object to be made by or on behalf of the identity specified by *identity-id*. *AVAILABLE* indicates the object is available to request. *PENDING* indicates the object is unavailable because the identity has a pending request in flight. *ASSIGNED* indicates the object is unavailable because the identity already has the indicated role or access profile. If *identity-id* is not specified (allowed only for admin users), then status will be *AVAILABLE* for all results.
 * @export
 * @enum {string}
 */

export const RequestableObjectRequestStatus = {
    Available: 'AVAILABLE',
    Pending: 'PENDING',
    Assigned: 'ASSIGNED',
    Null: 'null'
} as const;

export type RequestableObjectRequestStatus = typeof RequestableObjectRequestStatus[keyof typeof RequestableObjectRequestStatus];


/**
 * The currently supported requestable object types. 
 * @export
 * @enum {string}
 */

export const RequestableObjectType = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestableObjectType = typeof RequestableObjectType[keyof typeof RequestableObjectType];


/**
 * 
 * @export
 * @interface RequestedItemStatus
 */
export interface RequestedItemStatus {
    /**
     * Human-readable display name of the item being requested.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'name'?: string | null;
    /**
     * Type of requested object.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'type'?: RequestedItemStatusTypeEnum;
    /**
     * 
     * @type {RequestedItemStatusCancelledRequestDetails}
     * @memberof RequestedItemStatus
     */
    'cancelledRequestDetails'?: RequestedItemStatusCancelledRequestDetails;
    /**
     * List of list of localized error messages, if any, encountered during the approval/provisioning process.
     * @type {Array<Array<ErrorMessageDto>>}
     * @memberof RequestedItemStatus
     */
    'errorMessages'?: Array<Array<ErrorMessageDto>> | null;
    /**
     * 
     * @type {RequestedItemStatusRequestState}
     * @memberof RequestedItemStatus
     */
    'state'?: RequestedItemStatusRequestState;
    /**
     * Approval details for each item.
     * @type {Array<ApprovalStatusDto>}
     * @memberof RequestedItemStatus
     */
    'approvalDetails'?: Array<ApprovalStatusDto>;
    /**
     * Manual work items created for provisioning the item.
     * @type {Array<ManualWorkItemDetails>}
     * @memberof RequestedItemStatus
     */
    'manualWorkItemDetails'?: Array<ManualWorkItemDetails> | null;
    /**
     * Id of associated account activity item.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'accountActivityItemId'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof RequestedItemStatus
     */
    'requestType'?: AccessRequestType | null;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'modified'?: string | null;
    /**
     * When the request was created.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'created'?: string;
    /**
     * 
     * @type {AccessItemRequester}
     * @memberof RequestedItemStatus
     */
    'requester'?: AccessItemRequester;
    /**
     * 
     * @type {RequestedItemStatusRequestedFor}
     * @memberof RequestedItemStatus
     */
    'requestedFor'?: RequestedItemStatusRequestedFor;
    /**
     * 
     * @type {RequestedItemStatusRequesterComment}
     * @memberof RequestedItemStatus
     */
    'requesterComment'?: RequestedItemStatusRequesterComment;
    /**
     * 
     * @type {RequestedItemStatusSodViolationContext}
     * @memberof RequestedItemStatus
     */
    'sodViolationContext'?: RequestedItemStatusSodViolationContext;
    /**
     * 
     * @type {RequestedItemStatusProvisioningDetails}
     * @memberof RequestedItemStatus
     */
    'provisioningDetails'?: RequestedItemStatusProvisioningDetails;
    /**
     * 
     * @type {RequestedItemStatusPreApprovalTriggerDetails}
     * @memberof RequestedItemStatus
     */
    'preApprovalTriggerDetails'?: RequestedItemStatusPreApprovalTriggerDetails;
    /**
     * A list of Phases that the Access Request has gone through in order, to help determine the status of the request.
     * @type {Array<AccessRequestPhases>}
     * @memberof RequestedItemStatus
     */
    'accessRequestPhases'?: Array<AccessRequestPhases> | null;
    /**
     * Description associated to the requested object.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'description'?: string | null;
    /**
     * When the role access is scheduled for removal.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'removeDate'?: string | null;
    /**
     * True if the request can be canceled.
     * @type {boolean}
     * @memberof RequestedItemStatus
     */
    'cancelable'?: boolean;
    /**
     * This is the account activity id.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'accessRequestId'?: string;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request
     * @type {{ [key: string]: string; }}
     * @memberof RequestedItemStatus
     */
    'clientMetadata'?: { [key: string]: string; } | null;
}

export const RequestedItemStatusTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT',
    Null: 'null'
} as const;

export type RequestedItemStatusTypeEnum = typeof RequestedItemStatusTypeEnum[keyof typeof RequestedItemStatusTypeEnum];

/**
 * 
 * @export
 * @interface RequestedItemStatusCancelledRequestDetails
 */
export interface RequestedItemStatusCancelledRequestDetails {
    /**
     * Comment made by the owner when cancelling the associated request.
     * @type {string}
     * @memberof RequestedItemStatusCancelledRequestDetails
     */
    'comment'?: string;
    /**
     * 
     * @type {OwnerDto}
     * @memberof RequestedItemStatusCancelledRequestDetails
     */
    'owner'?: OwnerDto;
    /**
     * Date comment was added by the owner when cancelling the associated request.
     * @type {string}
     * @memberof RequestedItemStatusCancelledRequestDetails
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface RequestedItemStatusPreApprovalTriggerDetails
 */
export interface RequestedItemStatusPreApprovalTriggerDetails {
    /**
     * Comment left for the pre-approval decision
     * @type {string}
     * @memberof RequestedItemStatusPreApprovalTriggerDetails
     */
    'comment'?: string;
    /**
     * The reviewer of the pre-approval decision
     * @type {string}
     * @memberof RequestedItemStatusPreApprovalTriggerDetails
     */
    'reviewer'?: string;
    /**
     * The decision of the pre-approval trigger
     * @type {string}
     * @memberof RequestedItemStatusPreApprovalTriggerDetails
     */
    'decision'?: RequestedItemStatusPreApprovalTriggerDetailsDecisionEnum;
}

export const RequestedItemStatusPreApprovalTriggerDetailsDecisionEnum = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type RequestedItemStatusPreApprovalTriggerDetailsDecisionEnum = typeof RequestedItemStatusPreApprovalTriggerDetailsDecisionEnum[keyof typeof RequestedItemStatusPreApprovalTriggerDetailsDecisionEnum];

/**
 * 
 * @export
 * @interface RequestedItemStatusProvisioningDetails
 */
export interface RequestedItemStatusProvisioningDetails {
    /**
     * Ordered CSV of sub phase references to objects that contain more information about provisioning. For example, this can contain \"manualWorkItemDetails\" which indicate that there is further information in that object for this phase.
     * @type {string}
     * @memberof RequestedItemStatusProvisioningDetails
     */
    'orderedSubPhaseReferences'?: string;
}
/**
 * Indicates the state of an access request: * EXECUTING: The request is executing, which indicates the system is doing some processing. * REQUEST_COMPLETED: Indicates the request  has been completed. * CANCELLED: The request was cancelled with no user input. * TERMINATED: The request has been terminated before it was able to complete. * PROVISIONING_VERIFICATION_PENDING: The request has finished any approval steps and provisioning is waiting to be verified. * REJECTED: The request was rejected. * PROVISIONING_FAILED: The request has failed to complete. * NOT_ALL_ITEMS_PROVISIONED: One or more of the requested items failed to complete, but there were one or more  successes. * ERROR: An error occurred during request processing.
 * @export
 * @enum {string}
 */

export const RequestedItemStatusRequestState = {
    Executing: 'EXECUTING',
    RequestCompleted: 'REQUEST_COMPLETED',
    Cancelled: 'CANCELLED',
    Terminated: 'TERMINATED',
    ProvisioningVerificationPending: 'PROVISIONING_VERIFICATION_PENDING',
    Rejected: 'REJECTED',
    ProvisioningFailed: 'PROVISIONING_FAILED',
    NotAllItemsProvisioned: 'NOT_ALL_ITEMS_PROVISIONED',
    Error: 'ERROR'
} as const;

export type RequestedItemStatusRequestState = typeof RequestedItemStatusRequestState[keyof typeof RequestedItemStatusRequestState];


/**
 * Identity access was requested for.
 * @export
 * @interface RequestedItemStatusRequestedFor
 */
export interface RequestedItemStatusRequestedFor {
    /**
     * Type of the object to which this reference applies
     * @type {string}
     * @memberof RequestedItemStatusRequestedFor
     */
    'type'?: RequestedItemStatusRequestedForTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof RequestedItemStatusRequestedFor
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof RequestedItemStatusRequestedFor
     */
    'name'?: string;
}

export const RequestedItemStatusRequestedForTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type RequestedItemStatusRequestedForTypeEnum = typeof RequestedItemStatusRequestedForTypeEnum[keyof typeof RequestedItemStatusRequestedForTypeEnum];

/**
 * 
 * @export
 * @interface RequestedItemStatusRequesterComment
 */
export interface RequestedItemStatusRequesterComment {
    /**
     * Comment content.
     * @type {string}
     * @memberof RequestedItemStatusRequesterComment
     */
    'comment'?: string | null;
    /**
     * Date and time comment was created.
     * @type {string}
     * @memberof RequestedItemStatusRequesterComment
     */
    'created'?: string;
    /**
     * 
     * @type {CommentDtoAuthor}
     * @memberof RequestedItemStatusRequesterComment
     */
    'author'?: CommentDtoAuthor;
}
/**
 * 
 * @export
 * @interface RequestedItemStatusSodViolationContext
 */
export interface RequestedItemStatusSodViolationContext {
    /**
     * The status of SOD violation check
     * @type {string}
     * @memberof RequestedItemStatusSodViolationContext
     */
    'state'?: RequestedItemStatusSodViolationContextStateEnum;
    /**
     * The id of the Violation check event
     * @type {string}
     * @memberof RequestedItemStatusSodViolationContext
     */
    'uuid'?: string | null;
    /**
     * 
     * @type {SodViolationCheckResult}
     * @memberof RequestedItemStatusSodViolationContext
     */
    'violationCheckResult'?: SodViolationCheckResult;
}

export const RequestedItemStatusSodViolationContextStateEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR',
    Null: 'null'
} as const;

export type RequestedItemStatusSodViolationContextStateEnum = typeof RequestedItemStatusSodViolationContextStateEnum[keyof typeof RequestedItemStatusSodViolationContextStateEnum];

/**
 * 
 * @export
 * @interface ReviewDecision
 */
export interface ReviewDecision {
    /**
     * The id of the review decision
     * @type {string}
     * @memberof ReviewDecision
     */
    'id': string;
    /**
     * 
     * @type {CertificationDecision}
     * @memberof ReviewDecision
     */
    'decision': CertificationDecision;
    /**
     * The date at which a user\'s access should be taken away. Should only be set for `REVOKE` decisions.
     * @type {string}
     * @memberof ReviewDecision
     */
    'proposedEndDate'?: string;
    /**
     * Indicates whether decision should be marked as part of a larger bulk decision
     * @type {boolean}
     * @memberof ReviewDecision
     */
    'bulk': boolean;
    /**
     * 
     * @type {ReviewRecommendation}
     * @memberof ReviewDecision
     */
    'recommendation'?: ReviewRecommendation;
    /**
     * Comments recorded when the decision was made
     * @type {string}
     * @memberof ReviewDecision
     */
    'comments'?: string;
}
/**
 * 
 * @export
 * @interface ReviewReassign
 */
export interface ReviewReassign {
    /**
     * 
     * @type {Array<ReassignReference>}
     * @memberof ReviewReassign
     */
    'reassign': Array<ReassignReference>;
    /**
     * The ID of the identity to which the certification is reassigned
     * @type {string}
     * @memberof ReviewReassign
     */
    'reassignTo': string;
    /**
     * The reason comment for why the reassign was made
     * @type {string}
     * @memberof ReviewReassign
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface ReviewRecommendation
 */
export interface ReviewRecommendation {
    /**
     * The recommendation from IAI at the time of the decision. This field will be null if no recommendation was made.
     * @type {string}
     * @memberof ReviewRecommendation
     */
    'recommendation'?: string | null;
    /**
     * A list of reasons for the recommendation.
     * @type {Array<string>}
     * @memberof ReviewRecommendation
     */
    'reasons'?: Array<string>;
    /**
     * The time at which the recommendation was recorded.
     * @type {string}
     * @memberof ReviewRecommendation
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface ReviewableAccessProfile
 */
export interface ReviewableAccessProfile {
    /**
     * The id of the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'id'?: string;
    /**
     * Name of the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'name'?: string;
    /**
     * Information about the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'description'?: string;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableAccessProfile
     */
    'privileged'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof ReviewableAccessProfile
     */
    'cloudGoverned'?: boolean;
    /**
     * The date at which a user\'s access expires
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableAccessProfile
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * A list of entitlements associated with this Access Profile
     * @type {Array<ReviewableEntitlement>}
     * @memberof ReviewableAccessProfile
     */
    'entitlements'?: Array<ReviewableEntitlement>;
    /**
     * Date the Access Profile was created.
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'created'?: string;
    /**
     * Date the Access Profile was last modified.
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface ReviewableEntitlement
 */
export interface ReviewableEntitlement {
    /**
     * The id for the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'id'?: string;
    /**
     * The name of the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'name'?: string;
    /**
     * Information about the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'description'?: string | null;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableEntitlement
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * The name of the attribute on the source
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'attributeName'?: string;
    /**
     * The value of the attribute on the source
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'attributeValue'?: string;
    /**
     * The schema object type on the source used to represent the entitlement and its attributes
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceSchemaObjectType'?: string;
    /**
     * The name of the source for which this entitlement belongs
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceName'?: string;
    /**
     * The type of the source for which the entitlement belongs
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceType'?: string;
    /**
     * The ID of the source for which the entitlement belongs
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceId'?: string;
    /**
     * Indicates if the entitlement has permissions
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'hasPermissions'?: boolean;
    /**
     * Indicates if the entitlement is a representation of an account permission
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'isPermission'?: boolean;
    /**
     * Indicates whether the entitlement can be revoked
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'revocable'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'cloudGoverned'?: boolean;
    /**
     * True if the entitlement has DAS data
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'containsDataAccess'?: boolean;
    /**
     * 
     * @type {DataAccess}
     * @memberof ReviewableEntitlement
     */
    'dataAccess'?: DataAccess | null;
    /**
     * 
     * @type {ReviewableEntitlementAccount}
     * @memberof ReviewableEntitlement
     */
    'account'?: ReviewableEntitlementAccount | null;
}
/**
 * Information about the status of the entitlement
 * @export
 * @interface ReviewableEntitlementAccount
 */
export interface ReviewableEntitlementAccount {
    /**
     * The native identity for this account
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'nativeIdentity'?: string;
    /**
     * Indicates whether this account is currently disabled
     * @type {boolean}
     * @memberof ReviewableEntitlementAccount
     */
    'disabled'?: boolean;
    /**
     * Indicates whether this account is currently locked
     * @type {boolean}
     * @memberof ReviewableEntitlementAccount
     */
    'locked'?: boolean;
    /**
     * 
     * @type {DtoType}
     * @memberof ReviewableEntitlementAccount
     */
    'type'?: DtoType;
    /**
     * The id associated with the account
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'id'?: string | null;
    /**
     * The account name
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'name'?: string | null;
    /**
     * When the account was created
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'created'?: string | null;
    /**
     * When the account was last modified
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'modified'?: string | null;
    /**
     * 
     * @type {ActivityInsights}
     * @memberof ReviewableEntitlementAccount
     */
    'activityInsights'?: ActivityInsights;
}
/**
 * 
 * @export
 * @interface ReviewableRole
 */
export interface ReviewableRole {
    /**
     * The id for the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'id'?: string;
    /**
     * The name of the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'name'?: string;
    /**
     * Information about the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'description'?: string;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableRole
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableRole
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * Indicates whether the Role can be revoked or requested
     * @type {boolean}
     * @memberof ReviewableRole
     */
    'revocable'?: boolean;
    /**
     * The date when a user\'s access expires.
     * @type {string}
     * @memberof ReviewableRole
     */
    'endDate'?: string;
    /**
     * The list of Access Profiles associated with this Role
     * @type {Array<ReviewableAccessProfile>}
     * @memberof ReviewableRole
     */
    'accessProfiles'?: Array<ReviewableAccessProfile>;
    /**
     * The list of entitlements associated with this Role
     * @type {Array<ReviewableEntitlement>}
     * @memberof ReviewableRole
     */
    'entitlements'?: Array<ReviewableEntitlement>;
}
/**
 * 
 * @export
 * @interface Reviewer
 */
export interface Reviewer {
    /**
     * The id of the reviewer.
     * @type {string}
     * @memberof Reviewer
     */
    'id'?: string;
    /**
     * The name of the reviewer.
     * @type {string}
     * @memberof Reviewer
     */
    'name'?: string;
    /**
     * The email of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'email'?: string;
    /**
     * The type of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'type'?: ReviewerTypeEnum;
    /**
     * The created date of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'created'?: string | null;
    /**
     * The modified date of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'modified'?: string | null;
}

export const ReviewerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type ReviewerTypeEnum = typeof ReviewerTypeEnum[keyof typeof ReviewerTypeEnum];

/**
 * 
 * @export
 * @interface Revocability
 */
export interface Revocability {
    /**
     * List describing the steps in approving the revocation request
     * @type {Array<AccessProfileApprovalScheme>}
     * @memberof Revocability
     */
    'approvalSchemes'?: Array<AccessProfileApprovalScheme> | null;
}
/**
 * 
 * @export
 * @interface RevocabilityForRole
 */
export interface RevocabilityForRole {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof RevocabilityForRole
     */
    'commentsRequired'?: boolean | null;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof RevocabilityForRole
     */
    'denialCommentsRequired'?: boolean | null;
    /**
     * List describing the steps in approving the revocation request
     * @type {Array<ApprovalSchemeForRole>}
     * @memberof RevocabilityForRole
     */
    'approvalSchemes'?: Array<ApprovalSchemeForRole>;
}
/**
 * 
 * @export
 * @interface RightPad
 */
export interface RightPad {
    /**
     * An integer value for the desired length of the final output string
     * @type {string}
     * @memberof RightPad
     */
    'length': string;
    /**
     * A string value representing the character that the incoming data should be padded with to get to the desired length   If not provided, the transform will default to a single space (\" \") character for padding 
     * @type {string}
     * @memberof RightPad
     */
    'padding'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RightPad
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RightPad
     */
    'input'?: { [key: string]: any; };
}
/**
 * A Role
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * The id of the Role. This field must be left null when creating an Role, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof Role
     */
    'id'?: string;
    /**
     * The human-readable display name of the Role
     * @type {string}
     * @memberof Role
     */
    'name': string;
    /**
     * Date the Role was created
     * @type {string}
     * @memberof Role
     */
    'created'?: string;
    /**
     * Date the Role was last modified.
     * @type {string}
     * @memberof Role
     */
    'modified'?: string;
    /**
     * A human-readable description of the Role
     * @type {string}
     * @memberof Role
     */
    'description'?: string | null;
    /**
     * 
     * @type {OwnerReference}
     * @memberof Role
     */
    'owner': OwnerReference;
    /**
     * 
     * @type {Array<AccessProfileRef>}
     * @memberof Role
     */
    'accessProfiles'?: Array<AccessProfileRef> | null;
    /**
     * 
     * @type {Array<EntitlementRef>}
     * @memberof Role
     */
    'entitlements'?: Array<EntitlementRef>;
    /**
     * 
     * @type {RoleMembershipSelector}
     * @memberof Role
     */
    'membership'?: RoleMembershipSelector | null;
    /**
     * This field is not directly modifiable and is generally expected to be *null*. In very rare instances, some Roles may have been created using membership selection criteria that are no longer fully supported. While these Roles will still work, they should be migrated to STANDARD or IDENTITY_LIST selection criteria. This field exists for informational purposes as an aid to such migration.
     * @type {{ [key: string]: any; }}
     * @memberof Role
     */
    'legacyMembershipInfo'?: { [key: string]: any; } | null;
    /**
     * Whether the Role is enabled or not.
     * @type {boolean}
     * @memberof Role
     */
    'enabled'?: boolean;
    /**
     * Whether the Role can be the target of access requests.
     * @type {boolean}
     * @memberof Role
     */
    'requestable'?: boolean;
    /**
     * 
     * @type {RequestabilityForRole}
     * @memberof Role
     */
    'accessRequestConfig'?: RequestabilityForRole;
    /**
     * 
     * @type {RevocabilityForRole}
     * @memberof Role
     */
    'revocationRequestConfig'?: RevocabilityForRole;
    /**
     * List of IDs of segments, if any, to which this Role is assigned.
     * @type {Array<string>}
     * @memberof Role
     */
    'segments'?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof Role
     */
    'dimensional'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'dimensionRefs'?: string | null;
}
/**
 * Type which indicates how a particular Identity obtained a particular Role
 * @export
 * @enum {string}
 */

export const RoleAssignmentSourceType = {
    AccessRequest: 'ACCESS_REQUEST',
    RoleMembership: 'ROLE_MEMBERSHIP'
} as const;

export type RoleAssignmentSourceType = typeof RoleAssignmentSourceType[keyof typeof RoleAssignmentSourceType];


/**
 * 
 * @export
 * @interface RoleBulkDeleteRequest
 */
export interface RoleBulkDeleteRequest {
    /**
     * List of IDs of Roles to be deleted.
     * @type {Array<string>}
     * @memberof RoleBulkDeleteRequest
     */
    'roleIds': Array<string>;
}
/**
 * Refers to a specific Identity attribute, Account attibute, or Entitlement used in Role membership criteria
 * @export
 * @interface RoleCriteriaKey
 */
export interface RoleCriteriaKey {
    /**
     * 
     * @type {RoleCriteriaKeyType}
     * @memberof RoleCriteriaKey
     */
    'type': RoleCriteriaKeyType;
    /**
     * The name of the attribute or entitlement to which the associated criteria applies.
     * @type {string}
     * @memberof RoleCriteriaKey
     */
    'property': string;
    /**
     * ID of the Source from which an account attribute or entitlement is drawn. Required if type is ACCOUNT or ENTITLEMENT
     * @type {string}
     * @memberof RoleCriteriaKey
     */
    'sourceId'?: string | null;
}
/**
 * Indicates whether the associated criteria represents an expression on identity attributes, account attributes, or entitlements, respectively.
 * @export
 * @enum {string}
 */

export const RoleCriteriaKeyType = {
    Identity: 'IDENTITY',
    Account: 'ACCOUNT',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RoleCriteriaKeyType = typeof RoleCriteriaKeyType[keyof typeof RoleCriteriaKeyType];


/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel1
 */
export interface RoleCriteriaLevel1 {
    /**
     * 
     * @type {RoleCriteriaOperation}
     * @memberof RoleCriteriaLevel1
     */
    'operation'?: RoleCriteriaOperation;
    /**
     * 
     * @type {RoleCriteriaKey}
     * @memberof RoleCriteriaLevel1
     */
    'key'?: RoleCriteriaKey | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel1
     */
    'stringValue'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes. Additionally, AND nodes can only be children or OR nodes and vice-versa.
     * @type {Array<RoleCriteriaLevel2>}
     * @memberof RoleCriteriaLevel1
     */
    'children'?: Array<RoleCriteriaLevel2> | null;
}
/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel2
 */
export interface RoleCriteriaLevel2 {
    /**
     * 
     * @type {RoleCriteriaOperation}
     * @memberof RoleCriteriaLevel2
     */
    'operation'?: RoleCriteriaOperation;
    /**
     * 
     * @type {RoleCriteriaKey}
     * @memberof RoleCriteriaLevel2
     */
    'key'?: RoleCriteriaKey | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel2
     */
    'stringValue'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes. Additionally, AND nodes can only be children or OR nodes and vice-versa.
     * @type {Array<RoleCriteriaLevel3>}
     * @memberof RoleCriteriaLevel2
     */
    'children'?: Array<RoleCriteriaLevel3> | null;
}
/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel3
 */
export interface RoleCriteriaLevel3 {
    /**
     * 
     * @type {RoleCriteriaOperation}
     * @memberof RoleCriteriaLevel3
     */
    'operation'?: RoleCriteriaOperation;
    /**
     * 
     * @type {RoleCriteriaKey}
     * @memberof RoleCriteriaLevel3
     */
    'key'?: RoleCriteriaKey | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel3
     */
    'stringValue'?: string;
}
/**
 * An operation
 * @export
 * @enum {string}
 */

export const RoleCriteriaOperation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    And: 'AND',
    Or: 'OR'
} as const;

export type RoleCriteriaOperation = typeof RoleCriteriaOperation[keyof typeof RoleCriteriaOperation];


/**
 * Role
 * @export
 * @interface RoleDocument
 */
export interface RoleDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof RoleDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof RoleDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof RoleDocument
     */
    '_type': DocumentType;
    /**
     * Access item\'s description.
     * @type {string}
     * @memberof RoleDocument
     */
    'description'?: string;
    /**
     * ISO-8601 date-time referring to the time when the object was created.
     * @type {string}
     * @memberof RoleDocument
     */
    'created'?: string | null;
    /**
     * ISO-8601 date-time referring to the time when the object was last modified.
     * @type {string}
     * @memberof RoleDocument
     */
    'modified'?: string | null;
    /**
     * ISO-8601 date-time referring to the date-time when object was queued to be synced into search database for use in the search API.   This date-time changes anytime there is an update to the object, which triggers a synchronization event being sent to the search database.  There may be some delay between the `synced` time and the time when the updated data is actually available in the search API. 
     * @type {string}
     * @memberof RoleDocument
     */
    'synced'?: string | null;
    /**
     * Indicates whether the access item is currently enabled.
     * @type {boolean}
     * @memberof RoleDocument
     */
    'enabled'?: boolean;
    /**
     * Indicates whether the access item can be requested.
     * @type {boolean}
     * @memberof RoleDocument
     */
    'requestable'?: boolean;
    /**
     * Indicates whether comments are required for requests to access the item.
     * @type {boolean}
     * @memberof RoleDocument
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {BaseAccessAllOfOwner}
     * @memberof RoleDocument
     */
    'owner'?: BaseAccessAllOfOwner;
    /**
     * Access profiles included with the role.
     * @type {Array<BaseAccessProfile>}
     * @memberof RoleDocument
     */
    'accessProfiles'?: Array<BaseAccessProfile>;
    /**
     * Number of access profiles included with the role.
     * @type {number}
     * @memberof RoleDocument
     */
    'accessProfileCount'?: number;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof RoleDocument
     */
    'tags'?: Array<string>;
    /**
     * Segments with the role.
     * @type {Array<BaseSegment>}
     * @memberof RoleDocument
     */
    'segments'?: Array<BaseSegment>;
    /**
     * Number of segments with the role.
     * @type {number}
     * @memberof RoleDocument
     */
    'segmentCount'?: number;
    /**
     * Entitlements included with the role.
     * @type {Array<BaseEntitlement>}
     * @memberof RoleDocument
     */
    'entitlements'?: Array<BaseEntitlement>;
    /**
     * Number of entitlements included with the role.
     * @type {number}
     * @memberof RoleDocument
     */
    'entitlementCount'?: number;
}
/**
 * 
 * @export
 * @interface RoleDocumentAllOf
 */
export interface RoleDocumentAllOf {
    /**
     * Access profiles included with the role.
     * @type {Array<BaseAccessProfile>}
     * @memberof RoleDocumentAllOf
     */
    'accessProfiles'?: Array<BaseAccessProfile>;
    /**
     * Number of access profiles included with the role.
     * @type {number}
     * @memberof RoleDocumentAllOf
     */
    'accessProfileCount'?: number;
    /**
     * Tags that have been applied to the object.
     * @type {Array<string>}
     * @memberof RoleDocumentAllOf
     */
    'tags'?: Array<string>;
    /**
     * Segments with the role.
     * @type {Array<BaseSegment>}
     * @memberof RoleDocumentAllOf
     */
    'segments'?: Array<BaseSegment>;
    /**
     * Number of segments with the role.
     * @type {number}
     * @memberof RoleDocumentAllOf
     */
    'segmentCount'?: number;
    /**
     * Entitlements included with the role.
     * @type {Array<BaseEntitlement>}
     * @memberof RoleDocumentAllOf
     */
    'entitlements'?: Array<BaseEntitlement>;
    /**
     * Number of entitlements included with the role.
     * @type {number}
     * @memberof RoleDocumentAllOf
     */
    'entitlementCount'?: number;
}
/**
 * A subset of the fields of an Identity which is a member of a Role.
 * @export
 * @interface RoleIdentity
 */
export interface RoleIdentity {
    /**
     * The ID of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'id'?: string;
    /**
     * The alias / username of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'aliasName'?: string;
    /**
     * The human-readable display name of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'name'?: string;
    /**
     * Email address of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'email'?: string;
    /**
     * 
     * @type {RoleAssignmentSourceType}
     * @memberof RoleIdentity
     */
    'roleAssignmentSource'?: RoleAssignmentSourceType;
}
/**
 * A reference to an Identity in an IDENTITY_LIST role membership criteria.
 * @export
 * @interface RoleMembershipIdentity
 */
export interface RoleMembershipIdentity {
    /**
     * 
     * @type {DtoType}
     * @memberof RoleMembershipIdentity
     */
    'type'?: DtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof RoleMembershipIdentity
     */
    'id'?: string;
    /**
     * Human-readable display name of the Identity.
     * @type {string}
     * @memberof RoleMembershipIdentity
     */
    'name'?: string | null;
    /**
     * User name of the Identity
     * @type {string}
     * @memberof RoleMembershipIdentity
     */
    'aliasName'?: string | null;
}
/**
 * When present, specifies that the Role is to be granted to Identities which either satisfy specific criteria or which are members of a given list of Identities.
 * @export
 * @interface RoleMembershipSelector
 */
export interface RoleMembershipSelector {
    /**
     * 
     * @type {RoleMembershipSelectorType}
     * @memberof RoleMembershipSelector
     */
    'type'?: RoleMembershipSelectorType;
    /**
     * 
     * @type {RoleCriteriaLevel1}
     * @memberof RoleMembershipSelector
     */
    'criteria'?: RoleCriteriaLevel1 | null;
    /**
     * Defines role membership as being exclusive to the specified Identities, when type is IDENTITY_LIST.
     * @type {Array<RoleMembershipIdentity>}
     * @memberof RoleMembershipSelector
     */
    'identities'?: Array<RoleMembershipIdentity> | null;
}
/**
 * This enum characterizes the type of a Role\'s membership selector. Only the following two are fully supported:  STANDARD: Indicates that Role membership is defined in terms of a criteria expression  IDENTITY_LIST: Indicates that Role membership is conferred on the specific identities listed
 * @export
 * @enum {string}
 */

export const RoleMembershipSelectorType = {
    Standard: 'STANDARD',
    IdentityList: 'IDENTITY_LIST'
} as const;

export type RoleMembershipSelectorType = typeof RoleMembershipSelectorType[keyof typeof RoleMembershipSelectorType];


/**
 * Role
 * @export
 * @interface RoleSummary
 */
export interface RoleSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof RoleSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof RoleSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleSummary
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof RoleSummary
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof RoleSummary
     */
    'description'?: string | null;
    /**
     * 
     * @type {DisplayReference}
     * @memberof RoleSummary
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummary
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummary
     */
    'revocable'?: boolean;
}
/**
 * 
 * @export
 * @interface RoleSummaryAllOf
 */
export interface RoleSummaryAllOf {
    /**
     * 
     * @type {DisplayReference}
     * @memberof RoleSummaryAllOf
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummaryAllOf
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummaryAllOf
     */
    'revocable'?: boolean;
}
/**
 * @type Rule
 * @export
 */
export type Rule = GenerateRandomString | GenericRule | GetReferenceIdentityAttribute;

/**
 * 
 * @export
 * @interface SavedSearch
 */
export interface SavedSearch {
    /**
     * The saved search ID. 
     * @type {string}
     * @memberof SavedSearch
     */
    'id'?: string;
    /**
     * 
     * @type {TypedReference}
     * @memberof SavedSearch
     */
    'owner'?: TypedReference;
    /**
     * The ID of the identity that owns this saved search.
     * @type {string}
     * @memberof SavedSearch
     */
    'ownerId'?: string;
    /**
     * Whether this saved search is visible to anyone but the owner. This field will always be false as there is no way to set a saved search as public at this time.
     * @type {boolean}
     * @memberof SavedSearch
     */
    'public'?: boolean;
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof SavedSearch
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof SavedSearch
     */
    'description'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearch
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearch
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof SavedSearch
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof SavedSearch
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof SavedSearch
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof SavedSearch
     */
    'fields'?: Array<string> | null;
    /**
     * Sort by index. This takes precedence over the `sort` property. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof SavedSearch
     */
    'orderBy'?: { [key: string]: Array<string>; } | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof SavedSearch
     */
    'sort'?: Array<string> | null;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof SavedSearch
     */
    'filters'?: SavedSearchDetailFilters | null;
}
/**
 * 
 * @export
 * @interface SavedSearchAllOf
 */
export interface SavedSearchAllOf {
    /**
     * The saved search ID. 
     * @type {string}
     * @memberof SavedSearchAllOf
     */
    'id'?: string;
    /**
     * 
     * @type {TypedReference}
     * @memberof SavedSearchAllOf
     */
    'owner'?: TypedReference;
    /**
     * The ID of the identity that owns this saved search.
     * @type {string}
     * @memberof SavedSearchAllOf
     */
    'ownerId'?: string;
    /**
     * Whether this saved search is visible to anyone but the owner. This field will always be false as there is no way to set a saved search as public at this time.
     * @type {boolean}
     * @memberof SavedSearchAllOf
     */
    'public'?: boolean;
}
/**
 * 
 * @export
 * @interface SavedSearchDetail
 */
export interface SavedSearchDetail {
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof SavedSearchDetail
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof SavedSearchDetail
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof SavedSearchDetail
     */
    'fields'?: Array<string> | null;
    /**
     * Sort by index. This takes precedence over the `sort` property. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof SavedSearchDetail
     */
    'orderBy'?: { [key: string]: Array<string>; } | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof SavedSearchDetail
     */
    'sort'?: Array<string> | null;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof SavedSearchDetail
     */
    'filters'?: SavedSearchDetailFilters | null;
}
/**
 * 
 * @export
 * @interface SavedSearchDetailFilters
 */
export interface SavedSearchDetailFilters {
    /**
     * 
     * @type {FilterType}
     * @memberof SavedSearchDetailFilters
     */
    'type'?: FilterType;
    /**
     * 
     * @type {Range}
     * @memberof SavedSearchDetailFilters
     */
    'range'?: Range;
    /**
     * The terms to be filtered.
     * @type {Array<string>}
     * @memberof SavedSearchDetailFilters
     */
    'terms'?: Array<string>;
    /**
     * Indicates if the filter excludes results.
     * @type {boolean}
     * @memberof SavedSearchDetailFilters
     */
    'exclude'?: boolean;
}
/**
 * 
 * @export
 * @interface SavedSearchName
 */
export interface SavedSearchName {
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof SavedSearchName
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof SavedSearchName
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * Determines the overall schedule cadence. In general, all time period fields smaller than the chosen type can be configured. For example, a DAILY schedule can have \'hours\' set, but not \'days\'; a WEEKLY schedule can have both \'hours\' and \'days\' set.
     * @type {string}
     * @memberof Schedule
     */
    'type': ScheduleTypeEnum;
    /**
     * 
     * @type {ScheduleMonths}
     * @memberof Schedule
     */
    'months'?: ScheduleMonths;
    /**
     * 
     * @type {ScheduleDays}
     * @memberof Schedule
     */
    'days'?: ScheduleDays;
    /**
     * 
     * @type {ScheduleHours}
     * @memberof Schedule
     */
    'hours': ScheduleHours;
    /**
     * Specifies the time after which this schedule will no longer occur.
     * @type {string}
     * @memberof Schedule
     */
    'expiration'?: string;
    /**
     * The time zone to use when running the schedule. For instance, if the schedule is scheduled to run at 1AM, and this field is set to \"CST\", the schedule will run at 1AM CST.
     * @type {string}
     * @memberof Schedule
     */
    'timeZoneId'?: string;
}

export const ScheduleTypeEnum = {
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Annually: 'ANNUALLY',
    Calendar: 'CALENDAR'
} as const;

export type ScheduleTypeEnum = typeof ScheduleTypeEnum[keyof typeof ScheduleTypeEnum];

/**
 * The schedule information.
 * @export
 * @interface Schedule1
 */
export interface Schedule1 {
    /**
     * 
     * @type {ScheduleType}
     * @memberof Schedule1
     */
    'type': ScheduleType;
    /**
     * 
     * @type {Schedule1Months}
     * @memberof Schedule1
     */
    'months'?: Schedule1Months;
    /**
     * 
     * @type {Schedule1Days}
     * @memberof Schedule1
     */
    'days'?: Schedule1Days;
    /**
     * 
     * @type {Schedule1Hours}
     * @memberof Schedule1
     */
    'hours': Schedule1Hours;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Schedule1
     */
    'expiration'?: string | null;
    /**
     * The canonical TZ identifier the schedule will run in (ex. America/New_York).  If no timezone is specified, the org\'s default timezone is used.
     * @type {string}
     * @memberof Schedule1
     */
    'timeZoneId'?: string | null;
}
/**
 * 
 * @export
 * @interface Schedule1Days
 */
export interface Schedule1Days {
    /**
     * 
     * @type {SelectorType}
     * @memberof Schedule1Days
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Schedule1Days
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Schedule1Days
     */
    'interval'?: number | null;
}
/**
 * 
 * @export
 * @interface Schedule1Hours
 */
export interface Schedule1Hours {
    /**
     * 
     * @type {SelectorType}
     * @memberof Schedule1Hours
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Schedule1Hours
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Schedule1Hours
     */
    'interval'?: number | null;
}
/**
 * 
 * @export
 * @interface Schedule1Months
 */
export interface Schedule1Months {
    /**
     * 
     * @type {SelectorType}
     * @memberof Schedule1Months
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Schedule1Months
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Schedule1Months
     */
    'interval'?: number | null;
}
/**
 * Specifies which day(s) a schedule is active for. This is required for all schedule types. The \"values\" field holds different data depending on the type of schedule: * WEEKLY: days of the week (1-7) * MONTHLY: days of the month (1-31, L, L-1...) * ANNUALLY: if the \"months\" field is also set: days of the month (1-31, L, L-1...); otherwise: ISO-8601 dates without year (\"--12-31\") * CALENDAR: ISO-8601 dates (\"2020-12-31\")  Note that CALENDAR only supports the LIST type, and ANNUALLY does not support the RANGE type when provided with ISO-8601 dates without year.  Examples:  On Sundays: * type LIST * values \"1\"  The second to last day of the month: * type LIST * values \"L-1\"  From the 20th to the last day of the month: * type RANGE * values \"20\", \"L\"  Every March 2nd: * type LIST * values \"--03-02\"  On March 2nd, 2021: * type: LIST * values \"2021-03-02\" 
 * @export
 * @interface ScheduleDays
 */
export interface ScheduleDays {
    /**
     * Enum type to specify days value
     * @type {string}
     * @memberof ScheduleDays
     */
    'type': ScheduleDaysTypeEnum;
    /**
     * Values of the days based on the enum type mentioned above
     * @type {Array<string>}
     * @memberof ScheduleDays
     */
    'values': Array<string>;
    /**
     * Interval between the cert generations
     * @type {number}
     * @memberof ScheduleDays
     */
    'interval'?: number;
}

export const ScheduleDaysTypeEnum = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type ScheduleDaysTypeEnum = typeof ScheduleDaysTypeEnum[keyof typeof ScheduleDaysTypeEnum];

/**
 * Specifies which hour(s) a schedule is active for. Examples:  Every three hours starting from 8AM, inclusive: * type LIST * values \"8\" * interval 3  During business hours: * type RANGE * values \"9\", \"5\"  At 5AM, noon, and 5PM: * type LIST * values \"5\", \"12\", \"17\" 
 * @export
 * @interface ScheduleHours
 */
export interface ScheduleHours {
    /**
     * Enum type to specify hours value
     * @type {string}
     * @memberof ScheduleHours
     */
    'type': ScheduleHoursTypeEnum;
    /**
     * Values of the days based on the enum type mentioned above
     * @type {Array<string>}
     * @memberof ScheduleHours
     */
    'values': Array<string>;
    /**
     * Interval between the cert generations
     * @type {number}
     * @memberof ScheduleHours
     */
    'interval'?: number;
}

export const ScheduleHoursTypeEnum = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type ScheduleHoursTypeEnum = typeof ScheduleHoursTypeEnum[keyof typeof ScheduleHoursTypeEnum];

/**
 * Specifies which months of a schedule are active. Only valid for ANNUALLY schedule types. Examples:  On February and March: * type LIST * values \"2\", \"3\"  Every 3 months, starting in January (quarterly): * type LIST * values \"1\" * interval 3  Every two months between July and December: * type RANGE * values \"7\", \"12\" * interval 2 
 * @export
 * @interface ScheduleMonths
 */
export interface ScheduleMonths {
    /**
     * Enum type to specify months value
     * @type {string}
     * @memberof ScheduleMonths
     */
    'type': ScheduleMonthsTypeEnum;
    /**
     * Values of the months based on the enum type mentioned above
     * @type {Array<string>}
     * @memberof ScheduleMonths
     */
    'values': Array<string>;
    /**
     * Interval between the cert generations
     * @type {number}
     * @memberof ScheduleMonths
     */
    'interval'?: number;
}

export const ScheduleMonthsTypeEnum = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type ScheduleMonthsTypeEnum = typeof ScheduleMonthsTypeEnum[keyof typeof ScheduleMonthsTypeEnum];

/**
 * Enum representing the currently supported schedule types.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const ScheduleType = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Calendar: 'CALENDAR',
    Annually: 'ANNUALLY'
} as const;

export type ScheduleType = typeof ScheduleType[keyof typeof ScheduleType];


/**
 * Attributes related to a scheduled trigger
 * @export
 * @interface ScheduledAttributes
 */
export interface ScheduledAttributes {
    /**
     * A valid CRON expression
     * @type {string}
     * @memberof ScheduledAttributes
     */
    'cronString': string;
}
/**
 * 
 * @export
 * @interface ScheduledSearch
 */
export interface ScheduledSearch {
    /**
     * The scheduled search ID.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'id': string;
    /**
     * 
     * @type {ScheduledSearchAllOfOwner}
     * @memberof ScheduledSearch
     */
    'owner': ScheduledSearchAllOfOwner;
    /**
     * The ID of the scheduled search owner.  Please use the `id` in the `owner` object instead. 
     * @type {string}
     * @memberof ScheduledSearch
     * @deprecated
     */
    'ownerId': string;
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearch
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearch
     */
    'description'?: string | null;
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'savedSearchId': string;
    /**
     * The date the scheduled search was initially created.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'created'?: string;
    /**
     * The last date the scheduled search was modified.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'modified'?: string;
    /**
     * 
     * @type {Schedule1}
     * @memberof ScheduledSearch
     */
    'schedule': Schedule1;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof ScheduledSearch
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should occur when search returns no results. 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'displayQueryDetails'?: boolean;
}
/**
 * 
 * @export
 * @interface ScheduledSearchAllOf
 */
export interface ScheduledSearchAllOf {
    /**
     * The scheduled search ID.
     * @type {string}
     * @memberof ScheduledSearchAllOf
     */
    'id'?: string;
    /**
     * 
     * @type {ScheduledSearchAllOfOwner}
     * @memberof ScheduledSearchAllOf
     */
    'owner'?: ScheduledSearchAllOfOwner;
    /**
     * The ID of the scheduled search owner.  Please use the `id` in the `owner` object instead. 
     * @type {string}
     * @memberof ScheduledSearchAllOf
     * @deprecated
     */
    'ownerId'?: string;
}
/**
 * The owner of the scheduled search
 * @export
 * @interface ScheduledSearchAllOfOwner
 */
export interface ScheduledSearchAllOfOwner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof ScheduledSearchAllOfOwner
     */
    'type': ScheduledSearchAllOfOwnerTypeEnum;
    /**
     * The ID of the referenced object
     * @type {string}
     * @memberof ScheduledSearchAllOfOwner
     */
    'id': string;
}

export const ScheduledSearchAllOfOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type ScheduledSearchAllOfOwnerTypeEnum = typeof ScheduledSearchAllOfOwnerTypeEnum[keyof typeof ScheduledSearchAllOfOwnerTypeEnum];

/**
 * 
 * @export
 * @interface ScheduledSearchName
 */
export interface ScheduledSearchName {
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearchName
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearchName
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * The id of the Schema.
     * @type {string}
     * @memberof Schema
     */
    'id'?: string;
    /**
     * The name of the Schema.
     * @type {string}
     * @memberof Schema
     */
    'name'?: string;
    /**
     * The name of the object type on the native system that the schema represents.
     * @type {string}
     * @memberof Schema
     */
    'nativeObjectType'?: string;
    /**
     * The name of the attribute used to calculate the unique identifier for an object in the schema.
     * @type {string}
     * @memberof Schema
     */
    'identityAttribute'?: string;
    /**
     * The name of the attribute used to calculate the display value for an object in the schema.
     * @type {string}
     * @memberof Schema
     */
    'displayAttribute'?: string;
    /**
     * The name of the attribute whose values represent other objects in a hierarchy. Only relevant to group schemas.
     * @type {string}
     * @memberof Schema
     */
    'hierarchyAttribute'?: string;
    /**
     * Flag indicating whether or not the include permissions with the object data when aggregating the schema.
     * @type {boolean}
     * @memberof Schema
     */
    'includePermissions'?: boolean;
    /**
     * Optional features that can be supported by a source. Modifying the features array may cause source configuration errors that are unsupportable. It is recommended to not modify this array for SailPoint supported connectors. * AUTHENTICATE: The source supports pass-through authentication. * COMPOSITE: The source supports composite source creation. * DIRECT_PERMISSIONS: The source supports returning DirectPermissions. * DISCOVER_SCHEMA: The source supports discovering schemas for users and groups. * ENABLE The source supports reading if an account is enabled or disabled. * MANAGER_LOOKUP: The source supports looking up managers as they are encountered in a feed. This is the opposite of NO_RANDOM_ACCESS. * NO_RANDOM_ACCESS: The source does not support random access and the getObject() methods should not be called and expected to perform. * PROXY: The source can serve as a proxy for another source. When an source has a proxy, all connector calls made with that source are redirected through the connector for the proxy source. * SEARCH * TEMPLATE * UNLOCK: The source supports reading if an account is locked or unlocked. * UNSTRUCTURED_TARGETS: The source supports returning unstructured Targets. * SHAREPOINT_TARGET: The source supports returning unstructured Target data for SharePoint. It will be typically used by AD, LDAP sources. * PROVISIONING: The source can both read and write accounts. Having this feature implies that the provision() method is implemented. It also means that direct and target permissions can also be provisioned if they can be returned by aggregation. * GROUP_PROVISIONING: The source can both read and write groups. Having this feature implies that the provision() method is implemented. * SYNC_PROVISIONING: The source can provision accounts synchronously. * PASSWORD: The source can provision password changes. Since sources can never read passwords, this is should only be used in conjunction with the PROVISIONING feature. * CURRENT_PASSWORD: Some source types support verification of the current password * ACCOUNT_ONLY_REQUEST: The source supports requesting accounts without entitlements. * ADDITIONAL_ACCOUNT_REQUEST: The source supports requesting additional accounts. * NO_AGGREGATION: A source that does not support aggregation. * GROUPS_HAVE_MEMBERS: The source models group memberships with a member attribute on the group object rather than a groups attribute on the account object. This effects the implementation of delta account aggregation. * NO_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for accounts. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for accounts. * NO_GROUP_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for groups. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for groups. * NO_UNSTRUCTURED_TARGETS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING. * NO_DIRECT_PERMISSIONS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING. * USES_UUID: Connectivity 2.0 flag used to indicate that the connector supports a compound naming structure. * PREFER_UUID: Used in ISC Provisioning AND Aggregation to decide if it should prefer account.uuid to account.nativeIdentity when data is read in through aggregation OR pushed out through provisioning. * ARM_SECURITY_EXTRACT: Indicates the application supports Security extracts for ARM * ARM_UTILIZATION_EXTRACT: Indicates the application supports Utilization extracts for ARM * ARM_CHANGELOG_EXTRACT: Indicates the application supports Change-log extracts for ARM
     * @type {Array<string>}
     * @memberof Schema
     */
    'features'?: Array<SchemaFeaturesEnum>;
    /**
     * Holds any extra configuration data that the schema may require.
     * @type {object}
     * @memberof Schema
     */
    'configuration'?: object;
    /**
     * The attribute definitions which form the schema.
     * @type {Array<AttributeDefinition>}
     * @memberof Schema
     */
    'attributes'?: Array<AttributeDefinition>;
    /**
     * The date the Schema was created.
     * @type {string}
     * @memberof Schema
     */
    'created'?: string;
    /**
     * The date the Schema was last modified.
     * @type {string}
     * @memberof Schema
     */
    'modified'?: string;
}

export const SchemaFeaturesEnum = {
    Authenticate: 'AUTHENTICATE',
    Composite: 'COMPOSITE',
    DirectPermissions: 'DIRECT_PERMISSIONS',
    DiscoverSchema: 'DISCOVER_SCHEMA',
    Enable: 'ENABLE',
    ManagerLookup: 'MANAGER_LOOKUP',
    NoRandomAccess: 'NO_RANDOM_ACCESS',
    Proxy: 'PROXY',
    Search: 'SEARCH',
    Template: 'TEMPLATE',
    Unlock: 'UNLOCK',
    UnstructuredTargets: 'UNSTRUCTURED_TARGETS',
    SharepointTarget: 'SHAREPOINT_TARGET',
    Provisioning: 'PROVISIONING',
    GroupProvisioning: 'GROUP_PROVISIONING',
    SyncProvisioning: 'SYNC_PROVISIONING',
    Password: 'PASSWORD',
    CurrentPassword: 'CURRENT_PASSWORD',
    AccountOnlyRequest: 'ACCOUNT_ONLY_REQUEST',
    AdditionalAccountRequest: 'ADDITIONAL_ACCOUNT_REQUEST',
    NoAggregation: 'NO_AGGREGATION',
    GroupsHaveMembers: 'GROUPS_HAVE_MEMBERS',
    NoPermissionsProvisioning: 'NO_PERMISSIONS_PROVISIONING',
    NoGroupPermissionsProvisioning: 'NO_GROUP_PERMISSIONS_PROVISIONING',
    NoUnstructuredTargetsProvisioning: 'NO_UNSTRUCTURED_TARGETS_PROVISIONING',
    NoDirectPermissionsProvisioning: 'NO_DIRECT_PERMISSIONS_PROVISIONING',
    PreferUuid: 'PREFER_UUID',
    ArmSecurityExtract: 'ARM_SECURITY_EXTRACT',
    ArmUtilizationExtract: 'ARM_UTILIZATION_EXTRACT',
    ArmChangelogExtract: 'ARM_CHANGELOG_EXTRACT',
    UsesUuid: 'USES_UUID'
} as const;

export type SchemaFeaturesEnum = typeof SchemaFeaturesEnum[keyof typeof SchemaFeaturesEnum];

/**
 * 
 * @export
 * @interface Search
 */
export interface Search {
    /**
     * The names of the Elasticsearch indices in which to search. If none are provided, then all indices will be searched.
     * @type {Array<Index>}
     * @memberof Search
     */
    'indices'?: Array<Index>;
    /**
     * 
     * @type {QueryType}
     * @memberof Search
     */
    'queryType'?: QueryType;
    /**
     * 
     * @type {string}
     * @memberof Search
     */
    'queryVersion'?: string;
    /**
     * 
     * @type {Query}
     * @memberof Search
     */
    'query'?: Query;
    /**
     * The search query using the Elasticsearch [Query DSL](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl.html) syntax.
     * @type {object}
     * @memberof Search
     */
    'queryDsl'?: object;
    /**
     * 
     * @type {TextQuery}
     * @memberof Search
     */
    'textQuery'?: TextQuery;
    /**
     * 
     * @type {TypeAheadQuery}
     * @memberof Search
     */
    'typeAheadQuery'?: TypeAheadQuery;
    /**
     * Indicates whether nested objects from returned search results should be included.
     * @type {boolean}
     * @memberof Search
     */
    'includeNested'?: boolean;
    /**
     * 
     * @type {QueryResultFilter}
     * @memberof Search
     */
    'queryResultFilter'?: QueryResultFilter;
    /**
     * 
     * @type {AggregationType}
     * @memberof Search
     */
    'aggregationType'?: AggregationType;
    /**
     * 
     * @type {string}
     * @memberof Search
     */
    'aggregationsVersion'?: string;
    /**
     * The aggregation search query using Elasticsearch [Aggregations](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations.html) syntax.
     * @type {object}
     * @memberof Search
     */
    'aggregationsDsl'?: object;
    /**
     * 
     * @type {SearchAggregationSpecification}
     * @memberof Search
     */
    'aggregations'?: SearchAggregationSpecification;
    /**
     * The fields to be used to sort the search results. Use + or - to specify the sort direction.
     * @type {Array<string>}
     * @memberof Search
     */
    'sort'?: Array<string>;
    /**
     * Used to begin the search window at the values specified. This parameter consists of the last values of the sorted fields in the current record set. This is used to expand the Elasticsearch limit of 10K records by shifting the 10K window to begin at this value. It is recommended that you always include the ID of the object in addition to any other fields on this parameter in order to ensure you don\'t get duplicate results while paging. For example, when searching for identities, if you are sorting by displayName you will also want to include ID, for example [\"displayName\", \"id\"].  If the last identity ID in the search result is 2c91808375d8e80a0175e1f88a575221 and the last displayName is \"John Doe\", then using that displayName and ID will start a new search after this identity. The searchAfter value will look like [\"John Doe\",\"2c91808375d8e80a0175e1f88a575221\"]
     * @type {Array<string>}
     * @memberof Search
     */
    'searchAfter'?: Array<string>;
    /**
     * The filters to be applied for each filtered field name.
     * @type {{ [key: string]: Filter; }}
     * @memberof Search
     */
    'filters'?: { [key: string]: Filter; };
}
/**
 * 
 * @export
 * @interface SearchAggregationSpecification
 */
export interface SearchAggregationSpecification {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof SearchAggregationSpecification
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof SearchAggregationSpecification
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof SearchAggregationSpecification
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof SearchAggregationSpecification
     */
    'bucket'?: BucketAggregation;
    /**
     * 
     * @type {SubSearchAggregationSpecification}
     * @memberof SearchAggregationSpecification
     */
    'subAggregation'?: SubSearchAggregationSpecification;
}
/**
 * 
 * @export
 * @interface SearchAggregationSpecificationAllOf
 */
export interface SearchAggregationSpecificationAllOf {
    /**
     * 
     * @type {SubSearchAggregationSpecification}
     * @memberof SearchAggregationSpecificationAllOf
     */
    'subAggregation'?: SubSearchAggregationSpecification;
}
/**
 * 
 * @export
 * @interface SearchArguments
 */
export interface SearchArguments {
    /**
     * The ID of the scheduled search that triggered the saved search execution. 
     * @type {string}
     * @memberof SearchArguments
     */
    'scheduleId'?: string;
    /**
     * 
     * @type {SearchArgumentsOwner}
     * @memberof SearchArguments
     */
    'owner'?: SearchArgumentsOwner;
    /**
     * The email recipients of the scheduled search being tested. 
     * @type {Array<TypedReference>}
     * @memberof SearchArguments
     */
    'recipients'?: Array<TypedReference>;
}
/**
 * The owner of the scheduled search being tested. 
 * @export
 * @interface SearchArgumentsOwner
 */
export interface SearchArgumentsOwner {
    /**
     * 
     * @type {DtoType}
     * @memberof SearchArgumentsOwner
     */
    'type': DtoType;
    /**
     * The id of the object. 
     * @type {string}
     * @memberof SearchArgumentsOwner
     */
    'id': string;
}
/**
 * @type SearchDocument
 * @export
 */
export type SearchDocument = AccessProfileDocument | AccountActivityDocument | EntitlementDocument | EventDocument | IdentityDocument | RoleDocument;

/**
 * Arguments for Search Export report (SEARCH_EXPORT)
 * @export
 * @interface SearchExportReportArguments
 */
export interface SearchExportReportArguments {
    /**
     * The names of the Elasticsearch indices in which to search. If none are provided, then all indices will be searched.
     * @type {Array<Index>}
     * @memberof SearchExportReportArguments
     */
    'indices'?: Array<Index>;
    /**
     * The filters to be applied for each filtered field name.
     * @type {{ [key: string]: Filter; }}
     * @memberof SearchExportReportArguments
     */
    'filters'?: { [key: string]: Filter; };
    /**
     * 
     * @type {Query}
     * @memberof SearchExportReportArguments
     */
    'query': Query;
    /**
     * Indicates whether nested objects from returned search results should be included.
     * @type {boolean}
     * @memberof SearchExportReportArguments
     */
    'includeNested'?: boolean;
    /**
     * The fields to be used to sort the search results. Use + or - to specify the sort direction.
     * @type {Array<string>}
     * @memberof SearchExportReportArguments
     */
    'sort'?: Array<string>;
}
/**
 * Enum representing the currently supported filter aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const SearchFilterType = {
    Term: 'TERM'
} as const;

export type SearchFilterType = typeof SearchFilterType[keyof typeof SearchFilterType];


/**
 * 
 * @export
 * @interface SearchSchedule
 */
export interface SearchSchedule {
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof SearchSchedule
     */
    'savedSearchId': string;
    /**
     * The date the scheduled search was initially created.
     * @type {string}
     * @memberof SearchSchedule
     */
    'created'?: string;
    /**
     * The last date the scheduled search was modified.
     * @type {string}
     * @memberof SearchSchedule
     */
    'modified'?: string;
    /**
     * 
     * @type {Schedule1}
     * @memberof SearchSchedule
     */
    'schedule': Schedule1;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof SearchSchedule
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should occur when search returns no results. 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'displayQueryDetails'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchScheduleRecipientsInner
 */
export interface SearchScheduleRecipientsInner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SearchScheduleRecipientsInner
     */
    'type': SearchScheduleRecipientsInnerTypeEnum;
    /**
     * The ID of the referenced object
     * @type {string}
     * @memberof SearchScheduleRecipientsInner
     */
    'id': string;
}

export const SearchScheduleRecipientsInnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SearchScheduleRecipientsInnerTypeEnum = typeof SearchScheduleRecipientsInnerTypeEnum[keyof typeof SearchScheduleRecipientsInnerTypeEnum];

/**
 * 
 * @export
 * @interface SectionDetails
 */
export interface SectionDetails {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof SectionDetails
     */
    'name'?: string;
    /**
     * Label of the section
     * @type {string}
     * @memberof SectionDetails
     */
    'label'?: string;
    /**
     * List of FormItems. FormItems can be SectionDetails and/or FieldDetails
     * @type {Array<object>}
     * @memberof SectionDetails
     */
    'formItems'?: Array<object>;
}
/**
 * 
 * @export
 * @interface SectionDetailsAllOf
 */
export interface SectionDetailsAllOf {
    /**
     * Label of the section
     * @type {string}
     * @memberof SectionDetailsAllOf
     */
    'label'?: string;
    /**
     * List of FormItems. FormItems can be SectionDetails and/or FieldDetails
     * @type {Array<object>}
     * @memberof SectionDetailsAllOf
     */
    'formItems'?: Array<object>;
}
/**
 * 
 * @export
 * @interface Segment
 */
export interface Segment {
    /**
     * The segment\'s ID.
     * @type {string}
     * @memberof Segment
     */
    'id'?: string;
    /**
     * The segment\'s business name.
     * @type {string}
     * @memberof Segment
     */
    'name'?: string;
    /**
     * The time when the segment is created.
     * @type {string}
     * @memberof Segment
     */
    'created'?: string;
    /**
     * The time when the segment is modified.
     * @type {string}
     * @memberof Segment
     */
    'modified'?: string;
    /**
     * The segment\'s optional description.
     * @type {string}
     * @memberof Segment
     */
    'description'?: string;
    /**
     * 
     * @type {OwnerReferenceSegments}
     * @memberof Segment
     */
    'owner'?: OwnerReferenceSegments | null;
    /**
     * 
     * @type {SegmentVisibilityCriteria}
     * @memberof Segment
     */
    'visibilityCriteria'?: SegmentVisibilityCriteria;
    /**
     * This boolean indicates whether the segment is currently active. Inactive segments have no effect.
     * @type {boolean}
     * @memberof Segment
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface SegmentVisibilityCriteria
 */
export interface SegmentVisibilityCriteria {
    /**
     * 
     * @type {Expression}
     * @memberof SegmentVisibilityCriteria
     */
    'expression'?: Expression;
}
/**
 * 
 * @export
 * @interface Selector
 */
export interface Selector {
    /**
     * 
     * @type {SelectorType}
     * @memberof Selector
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Selector
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Selector
     */
    'interval'?: number | null;
}
/**
 * Enum representing the currently supported selector types.  LIST - the *values* array contains one or more distinct values.  RANGE - the *values* array contains two values: the start and end of the range, inclusive.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const SelectorType = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type SelectorType = typeof SelectorType[keyof typeof SelectorType];


/**
 * 
 * @export
 * @interface SendTokenRequest
 */
export interface SendTokenRequest {
    /**
     * User alias from table spt_identity field named \'name\'
     * @type {string}
     * @memberof SendTokenRequest
     */
    'userAlias': string;
    /**
     * Token delivery type
     * @type {string}
     * @memberof SendTokenRequest
     */
    'deliveryType': SendTokenRequestDeliveryTypeEnum;
}

export const SendTokenRequestDeliveryTypeEnum = {
    SmsPersonal: 'SMS_PERSONAL',
    VoicePersonal: 'VOICE_PERSONAL',
    SmsWork: 'SMS_WORK',
    VoiceWork: 'VOICE_WORK',
    EmailWork: 'EMAIL_WORK',
    EmailPersonal: 'EMAIL_PERSONAL'
} as const;

export type SendTokenRequestDeliveryTypeEnum = typeof SendTokenRequestDeliveryTypeEnum[keyof typeof SendTokenRequestDeliveryTypeEnum];

/**
 * 
 * @export
 * @interface SendTokenResponse
 */
export interface SendTokenResponse {
    /**
     * The token request ID
     * @type {string}
     * @memberof SendTokenResponse
     */
    'requestId'?: string | null;
    /**
     * Status of sending token
     * @type {string}
     * @memberof SendTokenResponse
     */
    'status'?: SendTokenResponseStatusEnum;
    /**
     * Error messages from token send request
     * @type {string}
     * @memberof SendTokenResponse
     */
    'errorMessage'?: string | null;
}

export const SendTokenResponseStatusEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type SendTokenResponseStatusEnum = typeof SendTokenResponseStatusEnum[keyof typeof SendTokenResponseStatusEnum];

/**
 * 
 * @export
 * @interface ServiceDeskIntegrationDto
 */
export interface ServiceDeskIntegrationDto {
    /**
     * Unique identifier for the Service Desk integration
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'id'?: string;
    /**
     * Service Desk integration\'s name. The name must be unique.
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'name': string;
    /**
     * The date and time the Service Desk integration was created
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'created'?: string;
    /**
     * The date and time the Service Desk integration was last modified
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'modified'?: string;
    /**
     * Service Desk integration\'s description.
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'description': string;
    /**
     * Service Desk integration types:  - ServiceNowSDIM - ServiceNow 
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'type': string;
    /**
     * 
     * @type {OwnerDto}
     * @memberof ServiceDeskIntegrationDto
     */
    'ownerRef'?: OwnerDto;
    /**
     * 
     * @type {SourceClusterDto}
     * @memberof ServiceDeskIntegrationDto
     */
    'clusterRef'?: SourceClusterDto;
    /**
     * Cluster ID for the Service Desk integration (replaced by clusterRef, retained for backward compatibility).
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     * @deprecated
     */
    'cluster'?: string | null;
    /**
     * Source IDs for the Service Desk integration (replaced by provisioningConfig.managedSResourceRefs, but retained here for backward compatibility).
     * @type {Array<string>}
     * @memberof ServiceDeskIntegrationDto
     * @deprecated
     */
    'managedSources'?: Array<string>;
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationDto
     */
    'provisioningConfig'?: ProvisioningConfig;
    /**
     * Service Desk integration\'s attributes. Validation constraints enforced by the implementation.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationDto
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {BeforeProvisioningRuleDto}
     * @memberof ServiceDeskIntegrationDto
     */
    'beforeProvisioningRule'?: BeforeProvisioningRuleDto;
}
/**
 * Service Desk integration\'s specification.
 * @export
 * @interface ServiceDeskIntegrationDtoAllOf
 */
export interface ServiceDeskIntegrationDtoAllOf {
    /**
     * Unique identifier for the Service Desk integration
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'id'?: string;
    /**
     * Service Desk integration\'s name. The name must be unique.
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'name': string;
    /**
     * The date and time the Service Desk integration was created
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'created'?: string;
    /**
     * The date and time the Service Desk integration was last modified
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'modified'?: string;
    /**
     * Service Desk integration\'s description.
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'description': string;
    /**
     * Service Desk integration types:  - ServiceNowSDIM - ServiceNow 
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'type': string;
    /**
     * 
     * @type {OwnerDto}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'ownerRef'?: OwnerDto;
    /**
     * 
     * @type {SourceClusterDto}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'clusterRef'?: SourceClusterDto;
    /**
     * Cluster ID for the Service Desk integration (replaced by clusterRef, retained for backward compatibility).
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOf
     * @deprecated
     */
    'cluster'?: string | null;
    /**
     * Source IDs for the Service Desk integration (replaced by provisioningConfig.managedSResourceRefs, but retained here for backward compatibility).
     * @type {Array<string>}
     * @memberof ServiceDeskIntegrationDtoAllOf
     * @deprecated
     */
    'managedSources'?: Array<string>;
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'provisioningConfig'?: ProvisioningConfig;
    /**
     * Service Desk integration\'s attributes. Validation constraints enforced by the implementation.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {BeforeProvisioningRuleDto}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'beforeProvisioningRule'?: BeforeProvisioningRuleDto;
}
/**
 * 
 * @export
 * @interface ServiceDeskIntegrationTemplateDto
 */
export interface ServiceDeskIntegrationTemplateDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'modified'?: string;
    /**
     * The \'type\' property specifies the type of the Service Desk integration template.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'type': string;
    /**
     * The \'attributes\' property value is a map of attributes available for integrations using this Service Desk integration template.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'provisioningConfig': ProvisioningConfig;
}
/**
 * This is the model for a Service Desk integration template, used to create and edit Service Desk Integrations.
 * @export
 * @interface ServiceDeskIntegrationTemplateDtoAllOf
 */
export interface ServiceDeskIntegrationTemplateDtoAllOf {
    /**
     * The \'type\' property specifies the type of the Service Desk integration template.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDtoAllOf
     */
    'type': string;
    /**
     * The \'attributes\' property value is a map of attributes available for integrations using this Service Desk integration template.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationTemplateDtoAllOf
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationTemplateDtoAllOf
     */
    'provisioningConfig': ProvisioningConfig;
}
/**
 * This represents a Service Desk Integration template type.
 * @export
 * @interface ServiceDeskIntegrationTemplateType
 */
export interface ServiceDeskIntegrationTemplateType {
    /**
     * This is the name of the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'name'?: string;
    /**
     * This is the type value for the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'type': string;
    /**
     * This is the scriptName attribute value for the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'scriptName': string;
}
/**
 * Source for Service Desk integration template.
 * @export
 * @interface ServiceDeskSource
 */
export interface ServiceDeskSource {
    /**
     * DTO type of source for service desk integration template.
     * @type {string}
     * @memberof ServiceDeskSource
     */
    'type'?: ServiceDeskSourceTypeEnum;
    /**
     * ID of source for service desk integration template.
     * @type {string}
     * @memberof ServiceDeskSource
     */
    'id'?: string;
    /**
     * Human-readable name of source for service desk integration template.
     * @type {string}
     * @memberof ServiceDeskSource
     */
    'name'?: string;
}

export const ServiceDeskSourceTypeEnum = {
    Source: 'SOURCE'
} as const;

export type ServiceDeskSourceTypeEnum = typeof ServiceDeskSourceTypeEnum[keyof typeof ServiceDeskSourceTypeEnum];

/**
 * 
 * @export
 * @interface SetLifecycleState200Response
 */
export interface SetLifecycleState200Response {
    /**
     * The ID of the IdentityRequest object that is generated when the workflow launches. To follow the IdentityRequest, you can provide this ID with a [Get Account Activity request](https://developer.sailpoint.com/docs/api/v3/get-account-activity/). The response will contain relevant information about the IdentityRequest, such as its status.
     * @type {string}
     * @memberof SetLifecycleState200Response
     */
    'accountActivityId'?: string;
}
/**
 * 
 * @export
 * @interface SetLifecycleStateRequest
 */
export interface SetLifecycleStateRequest {
    /**
     * The ID of the lifecycle state to set.
     * @type {string}
     * @memberof SetLifecycleStateRequest
     */
    'lifecycleStateId'?: string;
}
/**
 * 
 * @export
 * @interface SlimCampaign
 */
export interface SlimCampaign {
    /**
     * Id of the campaign
     * @type {string}
     * @memberof SlimCampaign
     */
    'id'?: string;
    /**
     * The campaign name. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof SlimCampaign
     */
    'name': string;
    /**
     * The campaign description. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof SlimCampaign
     */
    'description': string;
    /**
     * The campaign\'s completion deadline.  This date must be in the future in order to activate the campaign.  If you try to activate a campaign with a deadline of today or in the past, you will receive a 400 error response.
     * @type {string}
     * @memberof SlimCampaign
     */
    'deadline'?: string;
    /**
     * The type of campaign. Could be extended in the future.
     * @type {string}
     * @memberof SlimCampaign
     */
    'type': SlimCampaignTypeEnum;
    /**
     * Enables email notification for this campaign
     * @type {boolean}
     * @memberof SlimCampaign
     */
    'emailNotificationEnabled'?: boolean;
    /**
     * Allows auto revoke for this campaign
     * @type {boolean}
     * @memberof SlimCampaign
     */
    'autoRevokeAllowed'?: boolean;
    /**
     * Enables IAI for this campaign. Accepts true even if the IAI product feature is off. If IAI is turned off then campaigns generated from this template will indicate false. The real value will then be returned if IAI is ever enabled for the org in the future.
     * @type {boolean}
     * @memberof SlimCampaign
     */
    'recommendationsEnabled'?: boolean;
    /**
     * The campaign\'s current status.
     * @type {string}
     * @memberof SlimCampaign
     */
    'status'?: SlimCampaignStatusEnum;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {string}
     * @memberof SlimCampaign
     */
    'correlatedStatus'?: SlimCampaignCorrelatedStatusEnum;
    /**
     * Created time of the campaign
     * @type {string}
     * @memberof SlimCampaign
     */
    'created'?: string;
    /**
     * The total number of certifications in this campaign.
     * @type {number}
     * @memberof SlimCampaign
     */
    'totalCertifications'?: number;
    /**
     * The number of completed certifications in this campaign.
     * @type {number}
     * @memberof SlimCampaign
     */
    'completedCertifications'?: number;
    /**
     * A list of errors and warnings that have accumulated.
     * @type {Array<CampaignAlert>}
     * @memberof SlimCampaign
     */
    'alerts'?: Array<CampaignAlert>;
}

export const SlimCampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
} as const;

export type SlimCampaignTypeEnum = typeof SlimCampaignTypeEnum[keyof typeof SlimCampaignTypeEnum];
export const SlimCampaignStatusEnum = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
} as const;

export type SlimCampaignStatusEnum = typeof SlimCampaignStatusEnum[keyof typeof SlimCampaignStatusEnum];
export const SlimCampaignCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type SlimCampaignCorrelatedStatusEnum = typeof SlimCampaignCorrelatedStatusEnum[keyof typeof SlimCampaignCorrelatedStatusEnum];

/**
 * Details of the Entitlement criteria
 * @export
 * @interface SodExemptCriteria
 */
export interface SodExemptCriteria {
    /**
     * If the entitlement already belonged to the user or not.
     * @type {boolean}
     * @memberof SodExemptCriteria
     */
    'existing'?: boolean;
    /**
     * 
     * @type {DtoType}
     * @memberof SodExemptCriteria
     */
    'type'?: DtoType;
    /**
     * Entitlement ID
     * @type {string}
     * @memberof SodExemptCriteria
     */
    'id'?: string;
    /**
     * Entitlement name
     * @type {string}
     * @memberof SodExemptCriteria
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface SodPolicy
 */
export interface SodPolicy {
    /**
     * Policy id
     * @type {string}
     * @memberof SodPolicy
     */
    'id'?: string;
    /**
     * Policy Business Name
     * @type {string}
     * @memberof SodPolicy
     */
    'name'?: string;
    /**
     * The time when this SOD policy is created.
     * @type {string}
     * @memberof SodPolicy
     */
    'created'?: string;
    /**
     * The time when this SOD policy is modified.
     * @type {string}
     * @memberof SodPolicy
     */
    'modified'?: string;
    /**
     * Optional description of the SOD policy
     * @type {string}
     * @memberof SodPolicy
     */
    'description'?: string | null;
    /**
     * 
     * @type {SodPolicyOwnerRef}
     * @memberof SodPolicy
     */
    'ownerRef'?: SodPolicyOwnerRef;
    /**
     * Optional External Policy Reference
     * @type {string}
     * @memberof SodPolicy
     */
    'externalPolicyReference'?: string | null;
    /**
     * Search query of the SOD policy
     * @type {string}
     * @memberof SodPolicy
     */
    'policyQuery'?: string;
    /**
     * Optional compensating controls(Mitigating Controls)
     * @type {string}
     * @memberof SodPolicy
     */
    'compensatingControls'?: string | null;
    /**
     * Optional correction advice
     * @type {string}
     * @memberof SodPolicy
     */
    'correctionAdvice'?: string | null;
    /**
     * whether the policy is enforced or not
     * @type {string}
     * @memberof SodPolicy
     */
    'state'?: SodPolicyStateEnum;
    /**
     * tags for this policy object
     * @type {Array<string>}
     * @memberof SodPolicy
     */
    'tags'?: Array<string>;
    /**
     * Policy\'s creator ID
     * @type {string}
     * @memberof SodPolicy
     */
    'creatorId'?: string;
    /**
     * Policy\'s modifier ID
     * @type {string}
     * @memberof SodPolicy
     */
    'modifierId'?: string | null;
    /**
     * 
     * @type {ViolationOwnerAssignmentConfig}
     * @memberof SodPolicy
     */
    'violationOwnerAssignmentConfig'?: ViolationOwnerAssignmentConfig;
    /**
     * defines whether a policy has been scheduled or not
     * @type {boolean}
     * @memberof SodPolicy
     */
    'scheduled'?: boolean;
    /**
     * whether a policy is query based or conflicting access based
     * @type {string}
     * @memberof SodPolicy
     */
    'type'?: SodPolicyTypeEnum;
    /**
     * 
     * @type {SodPolicyConflictingAccessCriteria}
     * @memberof SodPolicy
     */
    'conflictingAccessCriteria'?: SodPolicyConflictingAccessCriteria;
}

export const SodPolicyStateEnum = {
    Enforced: 'ENFORCED',
    NotEnforced: 'NOT_ENFORCED'
} as const;

export type SodPolicyStateEnum = typeof SodPolicyStateEnum[keyof typeof SodPolicyStateEnum];
export const SodPolicyTypeEnum = {
    General: 'GENERAL',
    ConflictingAccessBased: 'CONFLICTING_ACCESS_BASED'
} as const;

export type SodPolicyTypeEnum = typeof SodPolicyTypeEnum[keyof typeof SodPolicyTypeEnum];

/**
 * 
 * @export
 * @interface SodPolicyConflictingAccessCriteria
 */
export interface SodPolicyConflictingAccessCriteria {
    /**
     * 
     * @type {AccessCriteria}
     * @memberof SodPolicyConflictingAccessCriteria
     */
    'leftCriteria'?: AccessCriteria;
    /**
     * 
     * @type {AccessCriteria}
     * @memberof SodPolicyConflictingAccessCriteria
     */
    'rightCriteria'?: AccessCriteria;
}
/**
 * SOD policy.
 * @export
 * @interface SodPolicyDto
 */
export interface SodPolicyDto {
    /**
     * SOD policy DTO type.
     * @type {string}
     * @memberof SodPolicyDto
     */
    'type'?: SodPolicyDtoTypeEnum;
    /**
     * SOD policy ID.
     * @type {string}
     * @memberof SodPolicyDto
     */
    'id'?: string;
    /**
     * SOD policy display name.
     * @type {string}
     * @memberof SodPolicyDto
     */
    'name'?: string;
}

export const SodPolicyDtoTypeEnum = {
    SodPolicy: 'SOD_POLICY'
} as const;

export type SodPolicyDtoTypeEnum = typeof SodPolicyDtoTypeEnum[keyof typeof SodPolicyDtoTypeEnum];

/**
 * The owner of the SOD policy.
 * @export
 * @interface SodPolicyOwnerRef
 */
export interface SodPolicyOwnerRef {
    /**
     * Owner type.
     * @type {string}
     * @memberof SodPolicyOwnerRef
     */
    'type'?: SodPolicyOwnerRefTypeEnum;
    /**
     * Owner\'s ID.
     * @type {string}
     * @memberof SodPolicyOwnerRef
     */
    'id'?: string;
    /**
     * Owner\'s name.
     * @type {string}
     * @memberof SodPolicyOwnerRef
     */
    'name'?: string;
}

export const SodPolicyOwnerRefTypeEnum = {
    Identity: 'IDENTITY',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type SodPolicyOwnerRefTypeEnum = typeof SodPolicyOwnerRefTypeEnum[keyof typeof SodPolicyOwnerRefTypeEnum];

/**
 * 
 * @export
 * @interface SodPolicySchedule
 */
export interface SodPolicySchedule {
    /**
     * SOD Policy schedule name
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'name'?: string;
    /**
     * The time when this SOD policy schedule is created.
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'created'?: string;
    /**
     * The time when this SOD policy schedule is modified.
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'modified'?: string;
    /**
     * SOD Policy schedule description
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'description'?: string;
    /**
     * 
     * @type {Schedule1}
     * @memberof SodPolicySchedule
     */
    'schedule'?: Schedule1;
    /**
     * 
     * @type {Array<SodRecipient>}
     * @memberof SodPolicySchedule
     */
    'recipients'?: Array<SodRecipient>;
    /**
     * Indicates if empty results need to be emailed
     * @type {boolean}
     * @memberof SodPolicySchedule
     */
    'emailEmptyResults'?: boolean;
    /**
     * Policy\'s creator ID
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'creatorId'?: string;
    /**
     * Policy\'s modifier ID
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'modifierId'?: string;
}
/**
 * SOD policy recipient.
 * @export
 * @interface SodRecipient
 */
export interface SodRecipient {
    /**
     * SOD policy recipient DTO type.
     * @type {string}
     * @memberof SodRecipient
     */
    'type'?: SodRecipientTypeEnum;
    /**
     * SOD policy recipient\'s identity ID.
     * @type {string}
     * @memberof SodRecipient
     */
    'id'?: string;
    /**
     * SOD policy recipient\'s display name.
     * @type {string}
     * @memberof SodRecipient
     */
    'name'?: string;
}

export const SodRecipientTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SodRecipientTypeEnum = typeof SodRecipientTypeEnum[keyof typeof SodRecipientTypeEnum];

/**
 * SOD policy violation report result.
 * @export
 * @interface SodReportResultDto
 */
export interface SodReportResultDto {
    /**
     * SOD policy violation report result DTO type.
     * @type {string}
     * @memberof SodReportResultDto
     */
    'type'?: SodReportResultDtoTypeEnum;
    /**
     * SOD policy violation report result ID.
     * @type {string}
     * @memberof SodReportResultDto
     */
    'id'?: string;
    /**
     * Human-readable name of the SOD policy violation report result.
     * @type {string}
     * @memberof SodReportResultDto
     */
    'name'?: string;
}

export const SodReportResultDtoTypeEnum = {
    ReportResult: 'REPORT_RESULT'
} as const;

export type SodReportResultDtoTypeEnum = typeof SodReportResultDtoTypeEnum[keyof typeof SodReportResultDtoTypeEnum];

/**
 * An object referencing an SOD violation check
 * @export
 * @interface SodViolationCheck
 */
export interface SodViolationCheck {
    /**
     * The id of the original request
     * @type {string}
     * @memberof SodViolationCheck
     */
    'requestId': string;
    /**
     * The date-time when this request was created.
     * @type {string}
     * @memberof SodViolationCheck
     */
    'created'?: string;
}
/**
 * The inner object representing the completed SOD Violation check
 * @export
 * @interface SodViolationCheckResult
 */
export interface SodViolationCheckResult {
    /**
     * 
     * @type {ErrorMessageDto}
     * @memberof SodViolationCheckResult
     */
    'message'?: ErrorMessageDto;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on completion of the violation check.
     * @type {{ [key: string]: string; }}
     * @memberof SodViolationCheckResult
     */
    'clientMetadata'?: { [key: string]: string; } | null;
    /**
     * 
     * @type {Array<SodViolationContext>}
     * @memberof SodViolationCheckResult
     */
    'violationContexts'?: Array<SodViolationContext> | null;
    /**
     * A list of the SOD policies that were violated.
     * @type {Array<SodPolicyDto>}
     * @memberof SodViolationCheckResult
     */
    'violatedPolicies'?: Array<SodPolicyDto> | null;
}
/**
 * The contextual information of the violated criteria
 * @export
 * @interface SodViolationContext
 */
export interface SodViolationContext {
    /**
     * 
     * @type {SodPolicyDto}
     * @memberof SodViolationContext
     */
    'policy'?: SodPolicyDto;
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteria}
     * @memberof SodViolationContext
     */
    'conflictingAccessCriteria'?: SodViolationContextConflictingAccessCriteria;
}
/**
 * An object referencing a completed SOD violation check
 * @export
 * @interface SodViolationContextCheckCompleted
 */
export interface SodViolationContextCheckCompleted {
    /**
     * The status of SOD violation check
     * @type {string}
     * @memberof SodViolationContextCheckCompleted
     */
    'state'?: SodViolationContextCheckCompletedStateEnum;
    /**
     * The id of the Violation check event
     * @type {string}
     * @memberof SodViolationContextCheckCompleted
     */
    'uuid'?: string | null;
    /**
     * 
     * @type {SodViolationCheckResult}
     * @memberof SodViolationContextCheckCompleted
     */
    'violationCheckResult'?: SodViolationCheckResult;
}

export const SodViolationContextCheckCompletedStateEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR',
    Null: 'null'
} as const;

export type SodViolationContextCheckCompletedStateEnum = typeof SodViolationContextCheckCompletedStateEnum[keyof typeof SodViolationContextCheckCompletedStateEnum];

/**
 * The object which contains the left and right hand side of the entitlements that got violated according to the policy.
 * @export
 * @interface SodViolationContextConflictingAccessCriteria
 */
export interface SodViolationContextConflictingAccessCriteria {
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteriaLeftCriteria}
     * @memberof SodViolationContextConflictingAccessCriteria
     */
    'leftCriteria'?: SodViolationContextConflictingAccessCriteriaLeftCriteria;
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteriaLeftCriteria}
     * @memberof SodViolationContextConflictingAccessCriteria
     */
    'rightCriteria'?: SodViolationContextConflictingAccessCriteriaLeftCriteria;
}
/**
 * 
 * @export
 * @interface SodViolationContextConflictingAccessCriteriaLeftCriteria
 */
export interface SodViolationContextConflictingAccessCriteriaLeftCriteria {
    /**
     * 
     * @type {Array<SodExemptCriteria>}
     * @memberof SodViolationContextConflictingAccessCriteriaLeftCriteria
     */
    'criteriaList'?: Array<SodExemptCriteria>;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * Source ID.
     * @type {string}
     * @memberof Source
     */
    'id'?: string;
    /**
     * Source\'s human-readable name.
     * @type {string}
     * @memberof Source
     */
    'name': string;
    /**
     * Source\'s human-readable description.
     * @type {string}
     * @memberof Source
     */
    'description'?: string;
    /**
     * 
     * @type {SourceOwner}
     * @memberof Source
     */
    'owner': SourceOwner;
    /**
     * 
     * @type {SourceCluster}
     * @memberof Source
     */
    'cluster'?: SourceCluster | null;
    /**
     * 
     * @type {SourceAccountCorrelationConfig}
     * @memberof Source
     */
    'accountCorrelationConfig'?: SourceAccountCorrelationConfig | null;
    /**
     * 
     * @type {SourceAccountCorrelationRule}
     * @memberof Source
     */
    'accountCorrelationRule'?: SourceAccountCorrelationRule | null;
    /**
     * 
     * @type {SourceManagerCorrelationMapping}
     * @memberof Source
     */
    'managerCorrelationMapping'?: SourceManagerCorrelationMapping;
    /**
     * 
     * @type {SourceManagerCorrelationRule}
     * @memberof Source
     */
    'managerCorrelationRule'?: SourceManagerCorrelationRule | null;
    /**
     * 
     * @type {SourceBeforeProvisioningRule}
     * @memberof Source
     */
    'beforeProvisioningRule'?: SourceBeforeProvisioningRule | null;
    /**
     * List of references to schema objects.
     * @type {Array<SourceSchemasInner>}
     * @memberof Source
     */
    'schemas'?: Array<SourceSchemasInner>;
    /**
     * List of references to the associated PasswordPolicy objects.
     * @type {Array<SourcePasswordPoliciesInner>}
     * @memberof Source
     */
    'passwordPolicies'?: Array<SourcePasswordPoliciesInner> | null;
    /**
     * Optional features that can be supported by a source. Modifying the features array may cause source configuration errors that are unsupportable. It is recommended to not modify this array for SailPoint supported connectors. * AUTHENTICATE: The source supports pass-through authentication. * COMPOSITE: The source supports composite source creation. * DIRECT_PERMISSIONS: The source supports returning DirectPermissions. * DISCOVER_SCHEMA: The source supports discovering schemas for users and groups. * ENABLE The source supports reading if an account is enabled or disabled. * MANAGER_LOOKUP: The source supports looking up managers as they are encountered in a feed. This is the opposite of NO_RANDOM_ACCESS. * NO_RANDOM_ACCESS: The source does not support random access and the getObject() methods should not be called and expected to perform. * PROXY: The source can serve as a proxy for another source. When an source has a proxy, all connector calls made with that source are redirected through the connector for the proxy source. * SEARCH * TEMPLATE * UNLOCK: The source supports reading if an account is locked or unlocked. * UNSTRUCTURED_TARGETS: The source supports returning unstructured Targets. * SHAREPOINT_TARGET: The source supports returning unstructured Target data for SharePoint. It will be typically used by AD, LDAP sources. * PROVISIONING: The source can both read and write accounts. Having this feature implies that the provision() method is implemented. It also means that direct and target permissions can also be provisioned if they can be returned by aggregation. * GROUP_PROVISIONING: The source can both read and write groups. Having this feature implies that the provision() method is implemented. * SYNC_PROVISIONING: The source can provision accounts synchronously. * PASSWORD: The source can provision password changes. Since sources can never read passwords, this is should only be used in conjunction with the PROVISIONING feature. * CURRENT_PASSWORD: Some source types support verification of the current password * ACCOUNT_ONLY_REQUEST: The source supports requesting accounts without entitlements. * ADDITIONAL_ACCOUNT_REQUEST: The source supports requesting additional accounts. * NO_AGGREGATION: A source that does not support aggregation. * GROUPS_HAVE_MEMBERS: The source models group memberships with a member attribute on the group object rather than a groups attribute on the account object. This effects the implementation of delta account aggregation. * NO_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for accounts. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for accounts. * NO_GROUP_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for groups. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for groups. * NO_UNSTRUCTURED_TARGETS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING. * NO_DIRECT_PERMISSIONS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING. * USES_UUID: Connectivity 2.0 flag used to indicate that the connector supports a compound naming structure. * PREFER_UUID: Used in ISC Provisioning AND Aggregation to decide if it should prefer account.uuid to account.nativeIdentity when data is read in through aggregation OR pushed out through provisioning. * ARM_SECURITY_EXTRACT: Indicates the application supports Security extracts for ARM * ARM_UTILIZATION_EXTRACT: Indicates the application supports Utilization extracts for ARM * ARM_CHANGELOG_EXTRACT: Indicates the application supports Change-log extracts for ARM
     * @type {Array<string>}
     * @memberof Source
     */
    'features'?: Array<SourceFeaturesEnum>;
    /**
     * Specifies the type of system being managed e.g. Active Directory, Workday, etc.. If you are creating a delimited file source, you must set the `provisionasCsv` query parameter to `true`. 
     * @type {string}
     * @memberof Source
     */
    'type'?: string;
    /**
     * Connector script name.
     * @type {string}
     * @memberof Source
     */
    'connector': string;
    /**
     * Fully qualified name of the Java class that implements the connector interface.
     * @type {string}
     * @memberof Source
     */
    'connectorClass'?: string;
    /**
     * Connector specific configuration. This configuration will differ from type to type.
     * @type {object}
     * @memberof Source
     */
    'connectorAttributes'?: object;
    /**
     * Number from 0 to 100 that specifies when to skip the delete phase.
     * @type {number}
     * @memberof Source
     */
    'deleteThreshold'?: number;
    /**
     * When this is true, it indicates that the source is referenced by an identity profile.
     * @type {boolean}
     * @memberof Source
     */
    'authoritative'?: boolean;
    /**
     * 
     * @type {SourceManagementWorkgroup}
     * @memberof Source
     */
    'managementWorkgroup'?: SourceManagementWorkgroup | null;
    /**
     * When this is true, it indicates that the source is healthy.
     * @type {boolean}
     * @memberof Source
     */
    'healthy'?: boolean;
    /**
     * Status identifier that gives specific information about why a source is or isn\'t healthy. 
     * @type {string}
     * @memberof Source
     */
    'status'?: SourceStatusEnum;
    /**
     * Timestamp that shows when a source health check was last performed.
     * @type {string}
     * @memberof Source
     */
    'since'?: string;
    /**
     * Connector ID
     * @type {string}
     * @memberof Source
     */
    'connectorId'?: string;
    /**
     * Name of the connector that was chosen during source creation.
     * @type {string}
     * @memberof Source
     */
    'connectorName'?: string;
    /**
     * Type of connection (direct or file).
     * @type {string}
     * @memberof Source
     */
    'connectionType'?: string;
    /**
     * Connector implementation ID.
     * @type {string}
     * @memberof Source
     */
    'connectorImplementationId'?: string;
    /**
     * Date-time when the source was created
     * @type {string}
     * @memberof Source
     */
    'created'?: string;
    /**
     * Date-time when the source was last modified.
     * @type {string}
     * @memberof Source
     */
    'modified'?: string;
    /**
     * If this is true, it enables a credential provider for the source. If credentialProvider is turned on,  then the source can use credential provider(s) to fetch credentials.
     * @type {boolean}
     * @memberof Source
     */
    'credentialProviderEnabled'?: boolean;
    /**
     * Source category (e.g. null, CredentialProvider).
     * @type {string}
     * @memberof Source
     */
    'category'?: string | null;
}

export const SourceFeaturesEnum = {
    Authenticate: 'AUTHENTICATE',
    Composite: 'COMPOSITE',
    DirectPermissions: 'DIRECT_PERMISSIONS',
    DiscoverSchema: 'DISCOVER_SCHEMA',
    Enable: 'ENABLE',
    ManagerLookup: 'MANAGER_LOOKUP',
    NoRandomAccess: 'NO_RANDOM_ACCESS',
    Proxy: 'PROXY',
    Search: 'SEARCH',
    Template: 'TEMPLATE',
    Unlock: 'UNLOCK',
    UnstructuredTargets: 'UNSTRUCTURED_TARGETS',
    SharepointTarget: 'SHAREPOINT_TARGET',
    Provisioning: 'PROVISIONING',
    GroupProvisioning: 'GROUP_PROVISIONING',
    SyncProvisioning: 'SYNC_PROVISIONING',
    Password: 'PASSWORD',
    CurrentPassword: 'CURRENT_PASSWORD',
    AccountOnlyRequest: 'ACCOUNT_ONLY_REQUEST',
    AdditionalAccountRequest: 'ADDITIONAL_ACCOUNT_REQUEST',
    NoAggregation: 'NO_AGGREGATION',
    GroupsHaveMembers: 'GROUPS_HAVE_MEMBERS',
    NoPermissionsProvisioning: 'NO_PERMISSIONS_PROVISIONING',
    NoGroupPermissionsProvisioning: 'NO_GROUP_PERMISSIONS_PROVISIONING',
    NoUnstructuredTargetsProvisioning: 'NO_UNSTRUCTURED_TARGETS_PROVISIONING',
    NoDirectPermissionsProvisioning: 'NO_DIRECT_PERMISSIONS_PROVISIONING',
    PreferUuid: 'PREFER_UUID',
    ArmSecurityExtract: 'ARM_SECURITY_EXTRACT',
    ArmUtilizationExtract: 'ARM_UTILIZATION_EXTRACT',
    ArmChangelogExtract: 'ARM_CHANGELOG_EXTRACT',
    UsesUuid: 'USES_UUID'
} as const;

export type SourceFeaturesEnum = typeof SourceFeaturesEnum[keyof typeof SourceFeaturesEnum];
export const SourceStatusEnum = {
    ErrorCluster: 'SOURCE_STATE_ERROR_CLUSTER',
    ErrorSource: 'SOURCE_STATE_ERROR_SOURCE',
    ErrorVa: 'SOURCE_STATE_ERROR_VA',
    FailureCluster: 'SOURCE_STATE_FAILURE_CLUSTER',
    FailureSource: 'SOURCE_STATE_FAILURE_SOURCE',
    Healthy: 'SOURCE_STATE_HEALTHY',
    UncheckedCluster: 'SOURCE_STATE_UNCHECKED_CLUSTER',
    UncheckedClusterNoSources: 'SOURCE_STATE_UNCHECKED_CLUSTER_NO_SOURCES',
    UncheckedSource: 'SOURCE_STATE_UNCHECKED_SOURCE',
    UncheckedSourceNoAccounts: 'SOURCE_STATE_UNCHECKED_SOURCE_NO_ACCOUNTS'
} as const;

export type SourceStatusEnum = typeof SourceStatusEnum[keyof typeof SourceStatusEnum];

/**
 * Reference to account correlation config object.
 * @export
 * @interface SourceAccountCorrelationConfig
 */
export interface SourceAccountCorrelationConfig {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'type'?: SourceAccountCorrelationConfigTypeEnum;
    /**
     * Account correlation config ID.
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'id'?: string;
    /**
     * Account correlation config\'s human-readable display name.
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'name'?: string;
}

export const SourceAccountCorrelationConfigTypeEnum = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG'
} as const;

export type SourceAccountCorrelationConfigTypeEnum = typeof SourceAccountCorrelationConfigTypeEnum[keyof typeof SourceAccountCorrelationConfigTypeEnum];

/**
 * Reference to a rule that can do COMPLEX correlation. Only use this rule when you can\'t use accountCorrelationConfig.
 * @export
 * @interface SourceAccountCorrelationRule
 */
export interface SourceAccountCorrelationRule {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'type'?: SourceAccountCorrelationRuleTypeEnum;
    /**
     * Rule ID.
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'id'?: string;
    /**
     * Rule\'s human-readable display name.
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'name'?: string;
}

export const SourceAccountCorrelationRuleTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceAccountCorrelationRuleTypeEnum = typeof SourceAccountCorrelationRuleTypeEnum[keyof typeof SourceAccountCorrelationRuleTypeEnum];

/**
 * Rule that runs on the CCG and allows for customization of provisioning plans before the API calls the connector. 
 * @export
 * @interface SourceBeforeProvisioningRule
 */
export interface SourceBeforeProvisioningRule {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'type'?: SourceBeforeProvisioningRuleTypeEnum;
    /**
     * Rule ID.
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'id'?: string;
    /**
     * Rule\'s human-readable display name.
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'name'?: string;
}

export const SourceBeforeProvisioningRuleTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceBeforeProvisioningRuleTypeEnum = typeof SourceBeforeProvisioningRuleTypeEnum[keyof typeof SourceBeforeProvisioningRuleTypeEnum];

/**
 * Reference to the source\'s associated cluster.
 * @export
 * @interface SourceCluster
 */
export interface SourceCluster {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceCluster
     */
    'type': SourceClusterTypeEnum;
    /**
     * Cluster ID.
     * @type {string}
     * @memberof SourceCluster
     */
    'id': string;
    /**
     * Cluster\'s human-readable display name.
     * @type {string}
     * @memberof SourceCluster
     */
    'name': string;
}

export const SourceClusterTypeEnum = {
    Cluster: 'CLUSTER'
} as const;

export type SourceClusterTypeEnum = typeof SourceClusterTypeEnum[keyof typeof SourceClusterTypeEnum];

/**
 * Source cluster.
 * @export
 * @interface SourceClusterDto
 */
export interface SourceClusterDto {
    /**
     * Source cluster DTO type.
     * @type {string}
     * @memberof SourceClusterDto
     */
    'type'?: SourceClusterDtoTypeEnum;
    /**
     * Source cluster ID.
     * @type {string}
     * @memberof SourceClusterDto
     */
    'id'?: string;
    /**
     * Source cluster display name.
     * @type {string}
     * @memberof SourceClusterDto
     */
    'name'?: string;
}

export const SourceClusterDtoTypeEnum = {
    Cluster: 'CLUSTER'
} as const;

export type SourceClusterDtoTypeEnum = typeof SourceClusterDtoTypeEnum[keyof typeof SourceClusterDtoTypeEnum];

/**
 * Dto for source health data
 * @export
 * @interface SourceHealthDto
 */
export interface SourceHealthDto {
    /**
     * the id of the Source
     * @type {string}
     * @memberof SourceHealthDto
     */
    'id'?: string;
    /**
     * Specifies the type of system being managed e.g. Active Directory, Workday, etc.. If you are creating a Delimited File source, you must set the `provisionasCsv` query parameter to `true`. 
     * @type {string}
     * @memberof SourceHealthDto
     */
    'type'?: string;
    /**
     * the name of the source
     * @type {string}
     * @memberof SourceHealthDto
     */
    'name'?: string;
    /**
     * source\'s org
     * @type {string}
     * @memberof SourceHealthDto
     */
    'org'?: string;
    /**
     * Is the source authoritative
     * @type {boolean}
     * @memberof SourceHealthDto
     */
    'isAuthoritative'?: boolean;
    /**
     * Is the source in a cluster
     * @type {boolean}
     * @memberof SourceHealthDto
     */
    'isCluster'?: boolean;
    /**
     * source\'s hostname
     * @type {string}
     * @memberof SourceHealthDto
     */
    'hostname'?: string;
    /**
     * source\'s pod
     * @type {string}
     * @memberof SourceHealthDto
     */
    'pod'?: string;
    /**
     * The version of the iqService
     * @type {string}
     * @memberof SourceHealthDto
     */
    'iqServiceVersion'?: string;
    /**
     * connection test result
     * @type {string}
     * @memberof SourceHealthDto
     */
    'status'?: SourceHealthDtoStatusEnum;
}

export const SourceHealthDtoStatusEnum = {
    ErrorCluster: 'SOURCE_STATE_ERROR_CLUSTER',
    ErrorSource: 'SOURCE_STATE_ERROR_SOURCE',
    ErrorVa: 'SOURCE_STATE_ERROR_VA',
    FailureCluster: 'SOURCE_STATE_FAILURE_CLUSTER',
    FailureSource: 'SOURCE_STATE_FAILURE_SOURCE',
    Healthy: 'SOURCE_STATE_HEALTHY',
    UncheckedCluster: 'SOURCE_STATE_UNCHECKED_CLUSTER',
    UncheckedClusterNoSources: 'SOURCE_STATE_UNCHECKED_CLUSTER_NO_SOURCES',
    UncheckedSource: 'SOURCE_STATE_UNCHECKED_SOURCE',
    UncheckedSourceNoAccounts: 'SOURCE_STATE_UNCHECKED_SOURCE_NO_ACCOUNTS'
} as const;

export type SourceHealthDtoStatusEnum = typeof SourceHealthDtoStatusEnum[keyof typeof SourceHealthDtoStatusEnum];

/**
 * Reference to management workgroup for the source.
 * @export
 * @interface SourceManagementWorkgroup
 */
export interface SourceManagementWorkgroup {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'type'?: SourceManagementWorkgroupTypeEnum;
    /**
     * Management workgroup ID.
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'id'?: string;
    /**
     * Management workgroup\'s human-readable display name.
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'name'?: string;
}

export const SourceManagementWorkgroupTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type SourceManagementWorkgroupTypeEnum = typeof SourceManagementWorkgroupTypeEnum[keyof typeof SourceManagementWorkgroupTypeEnum];

/**
 * 
 * @export
 * @interface SourceManagerCorrelationMapping
 */
export interface SourceManagerCorrelationMapping {
    /**
     * Name of the attribute to use for manager correlation. The value found on the account attribute will be used to lookup the manager\'s identity.
     * @type {string}
     * @memberof SourceManagerCorrelationMapping
     */
    'accountAttributeName'?: string;
    /**
     * Name of the identity attribute to search when trying to find a manager using the value from the accountAttribute.
     * @type {string}
     * @memberof SourceManagerCorrelationMapping
     */
    'identityAttributeName'?: string;
}
/**
 * Reference to the ManagerCorrelationRule. Only use this rule when a simple filter isn\'t sufficient.
 * @export
 * @interface SourceManagerCorrelationRule
 */
export interface SourceManagerCorrelationRule {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'type'?: SourceManagerCorrelationRuleTypeEnum;
    /**
     * Rule ID.
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'id'?: string;
    /**
     * Rule\'s human-readable display name.
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'name'?: string;
}

export const SourceManagerCorrelationRuleTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceManagerCorrelationRuleTypeEnum = typeof SourceManagerCorrelationRuleTypeEnum[keyof typeof SourceManagerCorrelationRuleTypeEnum];

/**
 * Reference to identity object who owns the source.
 * @export
 * @interface SourceOwner
 */
export interface SourceOwner {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceOwner
     */
    'type'?: SourceOwnerTypeEnum;
    /**
     * Owner identity\'s ID.
     * @type {string}
     * @memberof SourceOwner
     */
    'id'?: string;
    /**
     * Owner identity\'s human-readable display name.
     * @type {string}
     * @memberof SourceOwner
     */
    'name'?: string;
}

export const SourceOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SourceOwnerTypeEnum = typeof SourceOwnerTypeEnum[keyof typeof SourceOwnerTypeEnum];

/**
 * 
 * @export
 * @interface SourcePasswordPoliciesInner
 */
export interface SourcePasswordPoliciesInner {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'type'?: SourcePasswordPoliciesInnerTypeEnum;
    /**
     * Policy ID.
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'id'?: string;
    /**
     * Policy\'s human-readable display name.
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'name'?: string;
}

export const SourcePasswordPoliciesInnerTypeEnum = {
    PasswordPolicy: 'PASSWORD_POLICY'
} as const;

export type SourcePasswordPoliciesInnerTypeEnum = typeof SourcePasswordPoliciesInnerTypeEnum[keyof typeof SourcePasswordPoliciesInnerTypeEnum];

/**
 * 
 * @export
 * @interface SourceSchemasInner
 */
export interface SourceSchemasInner {
    /**
     * Type of object being referenced.
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'type'?: SourceSchemasInnerTypeEnum;
    /**
     * Schema ID.
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'id'?: string;
    /**
     * Schema\'s human-readable display name.
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'name'?: string;
}

export const SourceSchemasInnerTypeEnum = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
} as const;

export type SourceSchemasInnerTypeEnum = typeof SourceSchemasInnerTypeEnum[keyof typeof SourceSchemasInnerTypeEnum];

/**
 * 
 * @export
 * @interface SourceUsage
 */
export interface SourceUsage {
    /**
     * The first day of the month for which activity is aggregated.
     * @type {string}
     * @memberof SourceUsage
     */
    'date'?: string;
    /**
     * The average number of days that accounts were active within this source, for the month.
     * @type {number}
     * @memberof SourceUsage
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface SourceUsageStatus
 */
export interface SourceUsageStatus {
    /**
     * Source Usage Status. Acceptable values are:   - COMPLETE       - This status means that an activity data source has been setup and usage insights are available for the source.   - INCOMPLETE       - This status means that an activity data source has not been setup and usage insights are not available for the source.
     * @type {string}
     * @memberof SourceUsageStatus
     */
    'status'?: SourceUsageStatusStatusEnum;
}

export const SourceUsageStatusStatusEnum = {
    Complete: 'COMPLETE',
    Incomplete: 'INCOMPLETE'
} as const;

export type SourceUsageStatusStatusEnum = typeof SourceUsageStatusStatusEnum[keyof typeof SourceUsageStatusStatusEnum];

/**
 * Message model for Config Import/Export.
 * @export
 * @interface SpConfigMessage
 */
export interface SpConfigMessage {
    /**
     * Message key.
     * @type {string}
     * @memberof SpConfigMessage
     */
    'key': string;
    /**
     * Message text.
     * @type {string}
     * @memberof SpConfigMessage
     */
    'text': string;
    /**
     * Message details if any, in key:value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof SpConfigMessage
     */
    'details': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Split
 */
export interface Split {
    /**
     * This can be either a single character or a regex expression, and is used by the transform to identify the break point between two substrings in the incoming data
     * @type {string}
     * @memberof Split
     */
    'delimiter': string;
    /**
     * An integer value for the desired array element after the incoming data has been split into a list; the array is a 0-based object, so the first array element would be index 0, the second element would be index 1, etc.
     * @type {string}
     * @memberof Split
     */
    'index': string;
    /**
     * A boolean (true/false) value which indicates whether an exception should be thrown and returned as an output when an index is out of bounds with the resultant array (i.e., the provided index value is larger than the size of the array)   `true` - The transform should return \"IndexOutOfBoundsException\"   `false` - The transform should return null   If not provided, the transform will default to false and return a null 
     * @type {boolean}
     * @memberof Split
     */
    'throws'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Split
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Split
     */
    'input'?: { [key: string]: any; };
}
/**
 * Standard Log4j log level
 * @export
 * @enum {string}
 */

export const StandardLevel = {
    False: 'false',
    Fatal: 'FATAL',
    Error: 'ERROR',
    Warn: 'WARN',
    Info: 'INFO',
    Debug: 'DEBUG',
    Trace: 'TRACE'
} as const;

export type StandardLevel = typeof StandardLevel[keyof typeof StandardLevel];


/**
 * 
 * @export
 * @interface Static
 */
export interface Static {
    /**
     * This must evaluate to a JSON string, either through a fixed value or through conditional logic using the Apache Velocity Template Language.
     * @type {string}
     * @memberof Static
     */
    'values': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Static
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface SubSearchAggregationSpecification
 */
export interface SubSearchAggregationSpecification {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'bucket'?: BucketAggregation;
    /**
     * 
     * @type {Aggregations}
     * @memberof SubSearchAggregationSpecification
     */
    'subAggregation'?: Aggregations;
}
/**
 * 
 * @export
 * @interface SubSearchAggregationSpecificationAllOf
 */
export interface SubSearchAggregationSpecificationAllOf {
    /**
     * 
     * @type {Aggregations}
     * @memberof SubSearchAggregationSpecificationAllOf
     */
    'subAggregation'?: Aggregations;
}
/**
 * 
 * @export
 * @interface Substring
 */
export interface Substring {
    /**
     * The index of the first character to include in the returned substring.   If `begin` is set to -1, the transform will begin at character 0 of the input data 
     * @type {number}
     * @memberof Substring
     */
    'begin': number;
    /**
     * This integer value is the number of characters to add to the begin attribute when returning a substring.   This attribute is only used if begin is not -1. 
     * @type {number}
     * @memberof Substring
     */
    'beginOffset'?: number;
    /**
     * The index of the first character to exclude from the returned substring.  If end is -1 or not provided at all, the substring transform will return everything up to the end of the input string. 
     * @type {number}
     * @memberof Substring
     */
    'end'?: number;
    /**
     * This integer value is the number of characters to add to the end attribute when returning a substring.   This attribute is only used if end is provided and is not -1. 
     * @type {number}
     * @memberof Substring
     */
    'endOffset'?: number;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Substring
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Substring
     */
    'input'?: { [key: string]: any; };
}
/**
 * Tagged object.
 * @export
 * @interface TaggedObject
 */
export interface TaggedObject {
    /**
     * 
     * @type {TaggedObjectDto}
     * @memberof TaggedObject
     */
    'objectRef'?: TaggedObjectDto;
    /**
     * Labels to be applied to an Object
     * @type {Array<string>}
     * @memberof TaggedObject
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TaggedObjectDto
 */
export interface TaggedObjectDto {
    /**
     * DTO type
     * @type {string}
     * @memberof TaggedObjectDto
     */
    'type'?: TaggedObjectDtoTypeEnum;
    /**
     * ID of the object this reference applies to
     * @type {string}
     * @memberof TaggedObjectDto
     */
    'id'?: string;
    /**
     * Human-readable display name of the object this reference applies to
     * @type {string}
     * @memberof TaggedObjectDto
     */
    'name'?: string | null;
}

export const TaggedObjectDtoTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    Entitlement: 'ENTITLEMENT',
    Identity: 'IDENTITY',
    Role: 'ROLE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE'
} as const;

export type TaggedObjectDtoTypeEnum = typeof TaggedObjectDtoTypeEnum[keyof typeof TaggedObjectDtoTypeEnum];

/**
 * Details about job or task type, state and lifecycle.
 * @export
 * @interface TaskResultDetails
 */
export interface TaskResultDetails {
    /**
     * Type of the job or task underlying in the report processing. It could be a quartz task, QPOC or MENTOS jobs or a refresh/sync task.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'type'?: TaskResultDetailsTypeEnum;
    /**
     * Unique task definition identifier.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'id'?: string;
    /**
     * Use this property to define what report should be processed in the RDE service.
     * @type {object}
     * @memberof TaskResultDetails
     */
    'reportType'?: TaskResultDetailsReportTypeEnum;
    /**
     * Description of the report purpose and/or contents.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'description'?: string;
    /**
     * Name of the parent task/report if exists.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'parentName'?: string | null;
    /**
     * Name of the report processing initiator.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'launcher'?: string;
    /**
     * Report creation date
     * @type {string}
     * @memberof TaskResultDetails
     */
    'created'?: string;
    /**
     * Report start date
     * @type {string}
     * @memberof TaskResultDetails
     */
    'launched'?: string | null;
    /**
     * Report completion date
     * @type {string}
     * @memberof TaskResultDetails
     */
    'completed'?: string | null;
    /**
     * Report completion status.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'completionStatus'?: TaskResultDetailsCompletionStatusEnum;
    /**
     * List of the messages dedicated to the report.  From task definition perspective here usually should be warnings or errors.
     * @type {Array<TaskResultDetailsMessagesInner>}
     * @memberof TaskResultDetails
     */
    'messages'?: Array<TaskResultDetailsMessagesInner>;
    /**
     * Task definition results, if necessary.
     * @type {Array<TaskResultDetailsReturnsInner>}
     * @memberof TaskResultDetails
     */
    'returns'?: Array<TaskResultDetailsReturnsInner>;
    /**
     * Extra attributes map(dictionary) needed for the report.
     * @type {{ [key: string]: object; }}
     * @memberof TaskResultDetails
     */
    'attributes'?: { [key: string]: object; };
    /**
     * Current report state.
     * @type {string}
     * @memberof TaskResultDetails
     */
    'progress'?: string | null;
}

export const TaskResultDetailsTypeEnum = {
    Quartz: 'QUARTZ',
    Qpoc: 'QPOC',
    Mentos: 'MENTOS',
    QueuedTask: 'QUEUED_TASK'
} as const;

export type TaskResultDetailsTypeEnum = typeof TaskResultDetailsTypeEnum[keyof typeof TaskResultDetailsTypeEnum];
export const TaskResultDetailsReportTypeEnum = {
    Accounts: 'ACCOUNTS',
    IdentitiesDetails: 'IDENTITIES_DETAILS',
    Identities: 'IDENTITIES',
    IdentityProfileIdentityError: 'IDENTITY_PROFILE_IDENTITY_ERROR',
    OrphanIdentities: 'ORPHAN_IDENTITIES',
    SearchExport: 'SEARCH_EXPORT',
    UncorrelatedAccounts: 'UNCORRELATED_ACCOUNTS'
} as const;

export type TaskResultDetailsReportTypeEnum = typeof TaskResultDetailsReportTypeEnum[keyof typeof TaskResultDetailsReportTypeEnum];
export const TaskResultDetailsCompletionStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR'
} as const;

export type TaskResultDetailsCompletionStatusEnum = typeof TaskResultDetailsCompletionStatusEnum[keyof typeof TaskResultDetailsCompletionStatusEnum];

/**
 * 
 * @export
 * @interface TaskResultDetailsMessagesInner
 */
export interface TaskResultDetailsMessagesInner {
    /**
     * Type of the message.
     * @type {string}
     * @memberof TaskResultDetailsMessagesInner
     */
    'type'?: TaskResultDetailsMessagesInnerTypeEnum;
    /**
     * Flag whether message is an error.
     * @type {boolean}
     * @memberof TaskResultDetailsMessagesInner
     */
    'error'?: boolean;
    /**
     * Flag whether message is a warning.
     * @type {boolean}
     * @memberof TaskResultDetailsMessagesInner
     */
    'warning'?: boolean;
    /**
     * Message string identifier.
     * @type {string}
     * @memberof TaskResultDetailsMessagesInner
     */
    'key'?: string;
    /**
     * Message context with the locale based language.
     * @type {string}
     * @memberof TaskResultDetailsMessagesInner
     */
    'localizedText'?: string;
}

export const TaskResultDetailsMessagesInnerTypeEnum = {
    Info: 'INFO',
    Warn: 'WARN',
    Error: 'ERROR'
} as const;

export type TaskResultDetailsMessagesInnerTypeEnum = typeof TaskResultDetailsMessagesInnerTypeEnum[keyof typeof TaskResultDetailsMessagesInnerTypeEnum];

/**
 * 
 * @export
 * @interface TaskResultDetailsReturnsInner
 */
export interface TaskResultDetailsReturnsInner {
    /**
     * Attribute description.
     * @type {string}
     * @memberof TaskResultDetailsReturnsInner
     */
    'displayLabel'?: string;
    /**
     * System or database attribute name.
     * @type {string}
     * @memberof TaskResultDetailsReturnsInner
     */
    'attributeName'?: string;
}
/**
 * Task result.
 * @export
 * @interface TaskResultDto
 */
export interface TaskResultDto {
    /**
     * Task result DTO type.
     * @type {string}
     * @memberof TaskResultDto
     */
    'type'?: TaskResultDtoTypeEnum;
    /**
     * Task result ID.
     * @type {string}
     * @memberof TaskResultDto
     */
    'id'?: string;
    /**
     * Task result display name.
     * @type {string}
     * @memberof TaskResultDto
     */
    'name'?: string | null;
}

export const TaskResultDtoTypeEnum = {
    TaskResult: 'TASK_RESULT'
} as const;

export type TaskResultDtoTypeEnum = typeof TaskResultDtoTypeEnum[keyof typeof TaskResultDtoTypeEnum];

/**
 * 
 * @export
 * @interface TaskResultSimplified
 */
export interface TaskResultSimplified {
    /**
     * Task identifier
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'id'?: string;
    /**
     * Task name
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'name'?: string;
    /**
     * Task description
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'description'?: string;
    /**
     * User or process who launched the task
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'launcher'?: string;
    /**
     * Date time of completion
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'completed'?: string;
    /**
     * Date time when the task was launched
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'launched'?: string;
    /**
     * Task result status
     * @type {string}
     * @memberof TaskResultSimplified
     */
    'completionStatus'?: TaskResultSimplifiedCompletionStatusEnum;
}

export const TaskResultSimplifiedCompletionStatusEnum = {
    Success: 'Success',
    Warning: 'Warning',
    Error: 'Error',
    Terminated: 'Terminated',
    TempError: 'TempError'
} as const;

export type TaskResultSimplifiedCompletionStatusEnum = typeof TaskResultSimplifiedCompletionStatusEnum[keyof typeof TaskResultSimplifiedCompletionStatusEnum];

/**
 * 
 * @export
 * @interface TestExternalExecuteWorkflow200Response
 */
export interface TestExternalExecuteWorkflow200Response {
    /**
     * The input that was received
     * @type {object}
     * @memberof TestExternalExecuteWorkflow200Response
     */
    'payload'?: object;
}
/**
 * 
 * @export
 * @interface TestExternalExecuteWorkflowRequest
 */
export interface TestExternalExecuteWorkflowRequest {
    /**
     * The test input for the workflow
     * @type {object}
     * @memberof TestExternalExecuteWorkflowRequest
     */
    'input'?: object;
}
/**
 * 
 * @export
 * @interface TestWorkflow200Response
 */
export interface TestWorkflow200Response {
    /**
     * The workflow execution id
     * @type {string}
     * @memberof TestWorkflow200Response
     */
    'workflowExecutionId'?: string;
}
/**
 * 
 * @export
 * @interface TestWorkflowRequest
 */
export interface TestWorkflowRequest {
    /**
     * The test input for the workflow.
     * @type {object}
     * @memberof TestWorkflowRequest
     */
    'input': object;
}
/**
 * Query parameters used to construct an Elasticsearch text query object.
 * @export
 * @interface TextQuery
 */
export interface TextQuery {
    /**
     * Words or characters that specify a particular thing to be searched for.
     * @type {Array<string>}
     * @memberof TextQuery
     */
    'terms': Array<string>;
    /**
     * The fields to be searched.
     * @type {Array<string>}
     * @memberof TextQuery
     */
    'fields': Array<string>;
    /**
     * Indicates that at least one of the terms must be found in the specified fields;  otherwise, all terms must be found.
     * @type {boolean}
     * @memberof TextQuery
     */
    'matchAny'?: boolean;
    /**
     * Indicates that the terms can be located anywhere in the specified fields;  otherwise, the fields must begin with the terms.
     * @type {boolean}
     * @memberof TextQuery
     */
    'contains'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenAuthRequest
 */
export interface TokenAuthRequest {
    /**
     * Token value
     * @type {string}
     * @memberof TokenAuthRequest
     */
    'token': string;
    /**
     * User alias from table spt_identity field named \'name\'
     * @type {string}
     * @memberof TokenAuthRequest
     */
    'userAlias': string;
    /**
     * Token delivery type
     * @type {string}
     * @memberof TokenAuthRequest
     */
    'deliveryType': TokenAuthRequestDeliveryTypeEnum;
}

export const TokenAuthRequestDeliveryTypeEnum = {
    SmsPersonal: 'SMS_PERSONAL',
    VoicePersonal: 'VOICE_PERSONAL',
    SmsWork: 'SMS_WORK',
    VoiceWork: 'VOICE_WORK',
    EmailWork: 'EMAIL_WORK',
    EmailPersonal: 'EMAIL_PERSONAL'
} as const;

export type TokenAuthRequestDeliveryTypeEnum = typeof TokenAuthRequestDeliveryTypeEnum[keyof typeof TokenAuthRequestDeliveryTypeEnum];

/**
 * 
 * @export
 * @interface TokenAuthResponse
 */
export interface TokenAuthResponse {
    /**
     * MFA Authentication status
     * @type {string}
     * @memberof TokenAuthResponse
     */
    'status'?: TokenAuthResponseStatusEnum;
}

export const TokenAuthResponseStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Lockout: 'LOCKOUT',
    NotEnoughData: 'NOT_ENOUGH_DATA'
} as const;

export type TokenAuthResponseStatusEnum = typeof TokenAuthResponseStatusEnum[keyof typeof TokenAuthResponseStatusEnum];

/**
 * The representation of an internally- or customer-defined transform.
 * @export
 * @interface Transform
 */
export interface Transform {
    /**
     * Unique name of this transform
     * @type {string}
     * @memberof Transform
     */
    'name': string;
    /**
     * The type of transform operation
     * @type {string}
     * @memberof Transform
     */
    'type': TransformTypeEnum;
    /**
     * 
     * @type {TransformAttributes}
     * @memberof Transform
     */
    'attributes': TransformAttributes | null;
}

export const TransformTypeEnum = {
    AccountAttribute: 'accountAttribute',
    Base64Decode: 'base64Decode',
    Base64Encode: 'base64Encode',
    Concat: 'concat',
    Conditional: 'conditional',
    DateCompare: 'dateCompare',
    DateFormat: 'dateFormat',
    DateMath: 'dateMath',
    DecomposeDiacriticalMarks: 'decomposeDiacriticalMarks',
    E164phone: 'e164phone',
    FirstValid: 'firstValid',
    Rule: 'rule',
    IdentityAttribute: 'identityAttribute',
    IndexOf: 'indexOf',
    Iso3166: 'iso3166',
    LastIndexOf: 'lastIndexOf',
    LeftPad: 'leftPad',
    Lookup: 'lookup',
    Lower: 'lower',
    NormalizeNames: 'normalizeNames',
    RandomAlphaNumeric: 'randomAlphaNumeric',
    RandomNumeric: 'randomNumeric',
    Reference: 'reference',
    ReplaceAll: 'replaceAll',
    Replace: 'replace',
    RightPad: 'rightPad',
    Split: 'split',
    Static: 'static',
    Substring: 'substring',
    Trim: 'trim',
    Upper: 'upper',
    UsernameGenerator: 'usernameGenerator',
    Uuid: 'uuid',
    DisplayName: 'displayName',
    Rfc5646: 'rfc5646'
} as const;

export type TransformTypeEnum = typeof TransformTypeEnum[keyof typeof TransformTypeEnum];

/**
 * @type TransformAttributes
 * Meta-data about the transform. Values in this list are specific to the type of transform to be executed.
 * @export
 */
export type TransformAttributes = AccountAttribute | Base64Decode | Base64Encode | Concatenation | Conditional | DateCompare | DateFormat | DateMath | DecomposeDiacriticalMarks | E164phone | FirstValid | ISO3166 | IdentityAttribute | IndexOf | LeftPad | Lookup | Lower | NameNormalizer | RandomAlphaNumeric | RandomNumeric | Reference | Replace | ReplaceAll | RightPad | Rule | Split | Static | Substring | Trim | UUIDGenerator | Upper;

/**
 * 
 * @export
 * @interface TransformDefinition
 */
export interface TransformDefinition {
    /**
     * The type of the transform definition.
     * @type {string}
     * @memberof TransformDefinition
     */
    'type'?: string;
    /**
     * Arbitrary key-value pairs to store any metadata for the object
     * @type {{ [key: string]: TransformDefinitionAttributesValue; }}
     * @memberof TransformDefinition
     */
    'attributes'?: { [key: string]: TransformDefinitionAttributesValue; };
}
/**
 * 
 * @export
 * @interface TransformDefinitionAttributesValue
 */
export interface TransformDefinitionAttributesValue {
}
/**
 * 
 * @export
 * @interface TransformRead
 */
export interface TransformRead {
    /**
     * Unique name of this transform
     * @type {string}
     * @memberof TransformRead
     */
    'name': string;
    /**
     * The type of transform operation
     * @type {string}
     * @memberof TransformRead
     */
    'type': TransformReadTypeEnum;
    /**
     * 
     * @type {TransformAttributes}
     * @memberof TransformRead
     */
    'attributes': TransformAttributes | null;
    /**
     * Unique ID of this transform
     * @type {string}
     * @memberof TransformRead
     */
    'id': string;
    /**
     * Indicates whether this is an internal SailPoint-created transform or a customer-created transform
     * @type {boolean}
     * @memberof TransformRead
     */
    'internal': boolean;
}

export const TransformReadTypeEnum = {
    AccountAttribute: 'accountAttribute',
    Base64Decode: 'base64Decode',
    Base64Encode: 'base64Encode',
    Concat: 'concat',
    Conditional: 'conditional',
    DateCompare: 'dateCompare',
    DateFormat: 'dateFormat',
    DateMath: 'dateMath',
    DecomposeDiacriticalMarks: 'decomposeDiacriticalMarks',
    E164phone: 'e164phone',
    FirstValid: 'firstValid',
    Rule: 'rule',
    IdentityAttribute: 'identityAttribute',
    IndexOf: 'indexOf',
    Iso3166: 'iso3166',
    LastIndexOf: 'lastIndexOf',
    LeftPad: 'leftPad',
    Lookup: 'lookup',
    Lower: 'lower',
    NormalizeNames: 'normalizeNames',
    RandomAlphaNumeric: 'randomAlphaNumeric',
    RandomNumeric: 'randomNumeric',
    Reference: 'reference',
    ReplaceAll: 'replaceAll',
    Replace: 'replace',
    RightPad: 'rightPad',
    Split: 'split',
    Static: 'static',
    Substring: 'substring',
    Trim: 'trim',
    Upper: 'upper',
    UsernameGenerator: 'usernameGenerator',
    Uuid: 'uuid',
    DisplayName: 'displayName',
    Rfc5646: 'rfc5646'
} as const;

export type TransformReadTypeEnum = typeof TransformReadTypeEnum[keyof typeof TransformReadTypeEnum];

/**
 * 
 * @export
 * @interface TransformReadAllOf
 */
export interface TransformReadAllOf {
    /**
     * Unique ID of this transform
     * @type {string}
     * @memberof TransformReadAllOf
     */
    'id': string;
    /**
     * Indicates whether this is an internal SailPoint-created transform or a customer-created transform
     * @type {boolean}
     * @memberof TransformReadAllOf
     */
    'internal': boolean;
}
/**
 * 
 * @export
 * @interface Trim
 */
export interface Trim {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Trim
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Trim
     */
    'input'?: { [key: string]: any; };
}
/**
 * Query parameters used to construct an Elasticsearch type ahead query object.  The typeAheadQuery performs a search for top values beginning with the typed values. For example, typing \"Jo\" results in top hits matching \"Jo.\" Typing \"Job\" results in top hits matching \"Job.\" 
 * @export
 * @interface TypeAheadQuery
 */
export interface TypeAheadQuery {
    /**
     * The type ahead query string used to construct a phrase prefix match query.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'query': string;
    /**
     * The field on which to perform the type ahead search.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'field': string;
    /**
     * The nested type.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'nestedType'?: string;
    /**
     * The number of suffixes the last term will be expanded into. Influences the performance of the query and the number results returned. Valid values: 1 to 1000.
     * @type {number}
     * @memberof TypeAheadQuery
     */
    'maxExpansions'?: number;
    /**
     * The max amount of records the search will return.
     * @type {number}
     * @memberof TypeAheadQuery
     */
    'size'?: number;
    /**
     * The sort order of the returned records.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'sort'?: string;
    /**
     * The flag that defines the sort type, by count or value.
     * @type {boolean}
     * @memberof TypeAheadQuery
     */
    'sortByValue'?: boolean;
}
/**
 * A typed reference to the object. 
 * @export
 * @interface TypedReference
 */
export interface TypedReference {
    /**
     * 
     * @type {DtoType}
     * @memberof TypedReference
     */
    'type': DtoType;
    /**
     * The id of the object. 
     * @type {string}
     * @memberof TypedReference
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface UUIDGenerator
 */
export interface UUIDGenerator {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof UUIDGenerator
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateDetail
 */
export interface UpdateDetail {
    /**
     * The detailed message for an update. Typically the relevent error message when status is error.
     * @type {string}
     * @memberof UpdateDetail
     */
    'message'?: string;
    /**
     * The connector script name
     * @type {string}
     * @memberof UpdateDetail
     */
    'scriptName'?: string;
    /**
     * The list of updated files supported by the connector
     * @type {Array<string>}
     * @memberof UpdateDetail
     */
    'updatedFiles'?: Array<string> | null;
    /**
     * The connector update status
     * @type {string}
     * @memberof UpdateDetail
     */
    'status'?: UpdateDetailStatusEnum;
}

export const UpdateDetailStatusEnum = {
    Error: 'ERROR',
    Updated: 'UPDATED',
    Unchanged: 'UNCHANGED',
    Skipped: 'SKIPPED'
} as const;

export type UpdateDetailStatusEnum = typeof UpdateDetailStatusEnum[keyof typeof UpdateDetailStatusEnum];

/**
 * 
 * @export
 * @interface UploadsRequest
 */
export interface UploadsRequest {
    /**
     * Unique id assigned to this job.
     * @type {string}
     * @memberof UploadsRequest
     */
    'jobId': string;
    /**
     * Status of the job.
     * @type {string}
     * @memberof UploadsRequest
     */
    'status': UploadsRequestStatusEnum;
    /**
     * Type of the job, either Backup or Draft.
     * @type {string}
     * @memberof UploadsRequest
     */
    'type': UploadsRequestTypeEnum;
    /**
     * The name of the tenant performing the upload
     * @type {string}
     * @memberof UploadsRequest
     */
    'tenant'?: string;
    /**
     * The name of the requester.
     * @type {string}
     * @memberof UploadsRequest
     */
    'requesterName'?: string;
    /**
     * The time the job was started.
     * @type {string}
     * @memberof UploadsRequest
     */
    'created': string;
    /**
     * The time of the last update to the job.
     * @type {string}
     * @memberof UploadsRequest
     */
    'modified': string;
    /**
     * The name assigned to the upload file in the request body.
     * @type {string}
     * @memberof UploadsRequest
     */
    'name'?: string;
    /**
     * Is the job a regular backup job, if so is the user allowed to delete the backup file. Since this is an upload job it remains as false.
     * @type {boolean}
     * @memberof UploadsRequest
     */
    'userCanDelete'?: boolean;
    /**
     * Is the job a regular backup job, if so is it partial. Since this is an upload job it remains as false.
     * @type {boolean}
     * @memberof UploadsRequest
     */
    'isPartial'?: boolean;
    /**
     * What kind of backup is this being treated as.
     * @type {string}
     * @memberof UploadsRequest
     */
    'backupType'?: UploadsRequestBackupTypeEnum;
    /**
     * have the objects contained in the upload file been hydrated.
     * @type {string}
     * @memberof UploadsRequest
     */
    'hydrationStatus'?: UploadsRequestHydrationStatusEnum;
}

export const UploadsRequestStatusEnum = {
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    Complete: 'COMPLETE',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED'
} as const;

export type UploadsRequestStatusEnum = typeof UploadsRequestStatusEnum[keyof typeof UploadsRequestStatusEnum];
export const UploadsRequestTypeEnum = {
    Backup: 'BACKUP',
    Draft: 'DRAFT'
} as const;

export type UploadsRequestTypeEnum = typeof UploadsRequestTypeEnum[keyof typeof UploadsRequestTypeEnum];
export const UploadsRequestBackupTypeEnum = {
    Uploaded: 'UPLOADED',
    Automated: 'AUTOMATED',
    Manual: 'MANUAL'
} as const;

export type UploadsRequestBackupTypeEnum = typeof UploadsRequestBackupTypeEnum[keyof typeof UploadsRequestBackupTypeEnum];
export const UploadsRequestHydrationStatusEnum = {
    Hydrated: 'HYDRATED',
    NotHydrated: 'NOT_HYDRATED'
} as const;

export type UploadsRequestHydrationStatusEnum = typeof UploadsRequestHydrationStatusEnum[keyof typeof UploadsRequestHydrationStatusEnum];

/**
 * 
 * @export
 * @interface UploadsResponse
 */
export interface UploadsResponse {
    /**
     * Unique id assigned to this job.
     * @type {string}
     * @memberof UploadsResponse
     */
    'jobId': string;
    /**
     * Status of the job.
     * @type {string}
     * @memberof UploadsResponse
     */
    'status': UploadsResponseStatusEnum;
    /**
     * Type of the job, either Backup or Draft.
     * @type {string}
     * @memberof UploadsResponse
     */
    'type': UploadsResponseTypeEnum;
    /**
     * The name of the tenant performing the upload
     * @type {string}
     * @memberof UploadsResponse
     */
    'tenant'?: string;
    /**
     * The name of the requester.
     * @type {string}
     * @memberof UploadsResponse
     */
    'requesterName'?: string;
    /**
     * The time the job was started.
     * @type {string}
     * @memberof UploadsResponse
     */
    'created': string;
    /**
     * The time of the last update to the job.
     * @type {string}
     * @memberof UploadsResponse
     */
    'modified': string;
    /**
     * The name assigned to the upload file in the request body.
     * @type {string}
     * @memberof UploadsResponse
     */
    'name'?: string;
    /**
     * Is the job a regular backup job, if so is the user allowed to delete the backup file. Since this is an upload job it remains as false.
     * @type {boolean}
     * @memberof UploadsResponse
     */
    'userCanDelete'?: boolean;
    /**
     * Is the job a regular backup job, if so is it partial. Since this is an upload job it remains as false.
     * @type {boolean}
     * @memberof UploadsResponse
     */
    'isPartial'?: boolean;
    /**
     * What kind of backup is this being treated as.
     * @type {string}
     * @memberof UploadsResponse
     */
    'backupType'?: UploadsResponseBackupTypeEnum;
    /**
     * have the objects contained in the upload file been hydrated.
     * @type {string}
     * @memberof UploadsResponse
     */
    'hydrationStatus'?: UploadsResponseHydrationStatusEnum;
}

export const UploadsResponseStatusEnum = {
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    Complete: 'COMPLETE',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED'
} as const;

export type UploadsResponseStatusEnum = typeof UploadsResponseStatusEnum[keyof typeof UploadsResponseStatusEnum];
export const UploadsResponseTypeEnum = {
    Backup: 'BACKUP',
    Draft: 'DRAFT'
} as const;

export type UploadsResponseTypeEnum = typeof UploadsResponseTypeEnum[keyof typeof UploadsResponseTypeEnum];
export const UploadsResponseBackupTypeEnum = {
    Uploaded: 'UPLOADED',
    Automated: 'AUTOMATED',
    Manual: 'MANUAL'
} as const;

export type UploadsResponseBackupTypeEnum = typeof UploadsResponseBackupTypeEnum[keyof typeof UploadsResponseBackupTypeEnum];
export const UploadsResponseHydrationStatusEnum = {
    Hydrated: 'HYDRATED',
    NotHydrated: 'NOT_HYDRATED'
} as const;

export type UploadsResponseHydrationStatusEnum = typeof UploadsResponseHydrationStatusEnum[keyof typeof UploadsResponseHydrationStatusEnum];

/**
 * 
 * @export
 * @interface Upper
 */
export interface Upper {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Upper
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Upper
     */
    'input'?: { [key: string]: any; };
}
/**
 * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \'Create Account Profile\', the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \'Update Account Profile\', the provisioning template for the \'Update\' connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \'Enable Account Profile\', the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\'s account is created.  DISABLE - This usage type relates to \'Disable Account Profile\', the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
 * @export
 * @enum {string}
 */

export const UsageType = {
    Create: 'CREATE',
    Update: 'UPDATE',
    Enable: 'ENABLE',
    Disable: 'DISABLE',
    Delete: 'DELETE',
    Assign: 'ASSIGN',
    Unassign: 'UNASSIGN',
    CreateGroup: 'CREATE_GROUP',
    UpdateGroup: 'UPDATE_GROUP',
    DeleteGroup: 'DELETE_GROUP',
    Register: 'REGISTER',
    CreateIdentity: 'CREATE_IDENTITY',
    UpdateIdentity: 'UPDATE_IDENTITY',
    EditGroup: 'EDIT_GROUP',
    Unlock: 'UNLOCK',
    ChangePassword: 'CHANGE_PASSWORD'
} as const;

export type UsageType = typeof UsageType[keyof typeof UsageType];


/**
 * 
 * @export
 * @interface V3ConnectorDto
 */
export interface V3ConnectorDto {
    /**
     * The connector name
     * @type {string}
     * @memberof V3ConnectorDto
     */
    'name'?: string;
    /**
     * The connector type
     * @type {string}
     * @memberof V3ConnectorDto
     */
    'type'?: string;
    /**
     * The connector script name
     * @type {string}
     * @memberof V3ConnectorDto
     */
    'scriptName'?: string;
    /**
     * The connector class name.
     * @type {string}
     * @memberof V3ConnectorDto
     */
    'className'?: string | null;
    /**
     * The list of features supported by the connector
     * @type {Array<string>}
     * @memberof V3ConnectorDto
     */
    'features'?: Array<string> | null;
    /**
     * true if the source is a direct connect source
     * @type {boolean}
     * @memberof V3ConnectorDto
     */
    'directConnect'?: boolean;
    /**
     * A map containing metadata pertinent to the connector
     * @type {{ [key: string]: any; }}
     * @memberof V3ConnectorDto
     */
    'connectorMetadata'?: { [key: string]: any; };
    /**
     * The connector status
     * @type {string}
     * @memberof V3ConnectorDto
     */
    'status'?: V3ConnectorDtoStatusEnum;
}

export const V3ConnectorDtoStatusEnum = {
    Deprecated: 'DEPRECATED',
    Development: 'DEVELOPMENT',
    Demo: 'DEMO',
    Released: 'RELEASED'
} as const;

export type V3ConnectorDtoStatusEnum = typeof V3ConnectorDtoStatusEnum[keyof typeof V3ConnectorDtoStatusEnum];

/**
 * 
 * @export
 * @interface V3CreateConnectorDto
 */
export interface V3CreateConnectorDto {
    /**
     * The connector name. Need to be unique per tenant. The name will able be used to derive a url friendly unique scriptname that will be in response. Script name can then be used for all update endpoints
     * @type {string}
     * @memberof V3CreateConnectorDto
     */
    'name': string;
    /**
     * The connector type. If not specified will be defaulted to \'custom \'+name
     * @type {string}
     * @memberof V3CreateConnectorDto
     */
    'type'?: string;
    /**
     * The connector class name. If you are implementing openconnector standard (what is recommended), then this need to be set to sailpoint.connector.OpenConnectorAdapter
     * @type {string}
     * @memberof V3CreateConnectorDto
     */
    'className': string;
    /**
     * true if the source is a direct connect source
     * @type {boolean}
     * @memberof V3CreateConnectorDto
     */
    'directConnect'?: boolean;
    /**
     * The connector status
     * @type {string}
     * @memberof V3CreateConnectorDto
     */
    'status'?: V3CreateConnectorDtoStatusEnum;
}

export const V3CreateConnectorDtoStatusEnum = {
    Development: 'DEVELOPMENT',
    Demo: 'DEMO',
    Released: 'RELEASED'
} as const;

export type V3CreateConnectorDtoStatusEnum = typeof V3CreateConnectorDtoStatusEnum[keyof typeof V3CreateConnectorDtoStatusEnum];

/**
 * 
 * @export
 * @interface Value
 */
export interface Value {
    /**
     * The type of attribute value
     * @type {string}
     * @memberof Value
     */
    'type'?: string;
    /**
     * The attribute value
     * @type {string}
     * @memberof Value
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface VerificationPollRequest
 */
export interface VerificationPollRequest {
    /**
     * Verification request Id
     * @type {string}
     * @memberof VerificationPollRequest
     */
    'requestId': string;
}
/**
 * 
 * @export
 * @interface VerificationResponse
 */
export interface VerificationResponse {
    /**
     * The verificationPollRequest request ID
     * @type {string}
     * @memberof VerificationResponse
     */
    'requestId'?: string | null;
    /**
     * MFA Authentication status
     * @type {string}
     * @memberof VerificationResponse
     */
    'status'?: VerificationResponseStatusEnum;
    /**
     * Error messages from MFA verification request
     * @type {string}
     * @memberof VerificationResponse
     */
    'error'?: string | null;
}

export const VerificationResponseStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Lockout: 'LOCKOUT',
    NotEnoughData: 'NOT_ENOUGH_DATA'
} as const;

export type VerificationResponseStatusEnum = typeof VerificationResponseStatusEnum[keyof typeof VerificationResponseStatusEnum];

/**
 * 
 * @export
 * @interface ViolationContext
 */
export interface ViolationContext {
    /**
     * 
     * @type {ViolationContextPolicy}
     * @memberof ViolationContext
     */
    'policy'?: ViolationContextPolicy;
    /**
     * 
     * @type {ExceptionAccessCriteria}
     * @memberof ViolationContext
     */
    'conflictingAccessCriteria'?: ExceptionAccessCriteria;
}
/**
 * The types of objects supported for SOD violations
 * @export
 * @interface ViolationContextPolicy
 */
export interface ViolationContextPolicy {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof ViolationContextPolicy
     */
    'type'?: ViolationContextPolicyTypeEnum;
    /**
     * SOD policy ID.
     * @type {string}
     * @memberof ViolationContextPolicy
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViolationContextPolicy
     */
    'name'?: string;
}

export const ViolationContextPolicyTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type ViolationContextPolicyTypeEnum = typeof ViolationContextPolicyTypeEnum[keyof typeof ViolationContextPolicyTypeEnum];

/**
 * 
 * @export
 * @interface ViolationContextPolicyAllOf
 */
export interface ViolationContextPolicyAllOf {
    /**
     * 
     * @type {string}
     * @memberof ViolationContextPolicyAllOf
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViolationContextPolicyAllOf
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ViolationOwnerAssignmentConfig
 */
export interface ViolationOwnerAssignmentConfig {
    /**
     * Details about the violations owner. MANAGER - identity\'s manager STATIC - Governance Group or Identity
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfig
     */
    'assignmentRule'?: ViolationOwnerAssignmentConfigAssignmentRuleEnum;
    /**
     * 
     * @type {ViolationOwnerAssignmentConfigOwnerRef}
     * @memberof ViolationOwnerAssignmentConfig
     */
    'ownerRef'?: ViolationOwnerAssignmentConfigOwnerRef | null;
}

export const ViolationOwnerAssignmentConfigAssignmentRuleEnum = {
    Manager: 'MANAGER',
    Static: 'STATIC',
    Null: 'null'
} as const;

export type ViolationOwnerAssignmentConfigAssignmentRuleEnum = typeof ViolationOwnerAssignmentConfigAssignmentRuleEnum[keyof typeof ViolationOwnerAssignmentConfigAssignmentRuleEnum];

/**
 * The owner of the violation assignment config.
 * @export
 * @interface ViolationOwnerAssignmentConfigOwnerRef
 */
export interface ViolationOwnerAssignmentConfigOwnerRef {
    /**
     * Owner type.
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigOwnerRef
     */
    'type'?: ViolationOwnerAssignmentConfigOwnerRefTypeEnum;
    /**
     * Owner\'s ID.
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigOwnerRef
     */
    'id'?: string;
    /**
     * Owner\'s name.
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigOwnerRef
     */
    'name'?: string;
}

export const ViolationOwnerAssignmentConfigOwnerRefTypeEnum = {
    Identity: 'IDENTITY',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Manager: 'MANAGER',
    Null: 'null'
} as const;

export type ViolationOwnerAssignmentConfigOwnerRefTypeEnum = typeof ViolationOwnerAssignmentConfigOwnerRefTypeEnum[keyof typeof ViolationOwnerAssignmentConfigOwnerRefTypeEnum];

/**
 * An object containing a listing of the SOD violation reasons detected by this check.
 * @export
 * @interface ViolationPrediction
 */
export interface ViolationPrediction {
    /**
     * List of Violation Contexts
     * @type {Array<ViolationContext>}
     * @memberof ViolationPrediction
     */
    'violationContexts'?: Array<ViolationContext>;
}
/**
 * 
 * @export
 * @interface VisibilityCriteria
 */
export interface VisibilityCriteria {
    /**
     * 
     * @type {Expression}
     * @memberof VisibilityCriteria
     */
    'expression'?: Expression;
}
/**
 * The state of a work item
 * @export
 * @enum {string}
 */

export const WorkItemState = {
    Finished: 'Finished',
    Rejected: 'Rejected',
    Returned: 'Returned',
    Expired: 'Expired',
    Pending: 'Pending',
    Canceled: 'Canceled',
    Null: 'null'
} as const;

export type WorkItemState = typeof WorkItemState[keyof typeof WorkItemState];


/**
 * The state of a work item
 * @export
 * @enum {string}
 */

export const WorkItemStateManualWorkItems = {
    Finished: 'Finished',
    Rejected: 'Rejected',
    Returned: 'Returned',
    Expired: 'Expired',
    Pending: 'Pending',
    Canceled: 'Canceled'
} as const;

export type WorkItemStateManualWorkItems = typeof WorkItemStateManualWorkItems[keyof typeof WorkItemStateManualWorkItems];


/**
 * The type of the work item
 * @export
 * @enum {string}
 */

export const WorkItemTypeManualWorkItems = {
    Generic: 'Generic',
    Certification: 'Certification',
    Remediation: 'Remediation',
    Delegation: 'Delegation',
    Approval: 'Approval',
    ViolationReview: 'ViolationReview',
    Form: 'Form',
    PolicyVioloation: 'PolicyVioloation',
    Challenge: 'Challenge',
    ImpactAnalysis: 'ImpactAnalysis',
    Signoff: 'Signoff',
    Event: 'Event',
    ManualAction: 'ManualAction',
    Test: 'Test'
} as const;

export type WorkItemTypeManualWorkItems = typeof WorkItemTypeManualWorkItems[keyof typeof WorkItemTypeManualWorkItems];


/**
 * 
 * @export
 * @interface WorkItems
 */
export interface WorkItems {
    /**
     * ID of the work item
     * @type {string}
     * @memberof WorkItems
     */
    'id'?: string;
    /**
     * ID of the requester
     * @type {string}
     * @memberof WorkItems
     */
    'requesterId'?: string | null;
    /**
     * The displayname of the requester
     * @type {string}
     * @memberof WorkItems
     */
    'requesterDisplayName'?: string | null;
    /**
     * The ID of the owner
     * @type {string}
     * @memberof WorkItems
     */
    'ownerId'?: string | null;
    /**
     * The name of the owner
     * @type {string}
     * @memberof WorkItems
     */
    'ownerName'?: string;
    /**
     * Time when the work item was created
     * @type {string}
     * @memberof WorkItems
     */
    'created'?: string;
    /**
     * Time when the work item was last updated
     * @type {string}
     * @memberof WorkItems
     */
    'modified'?: string | null;
    /**
     * The description of the work item
     * @type {string}
     * @memberof WorkItems
     */
    'description'?: string;
    /**
     * 
     * @type {WorkItemStateManualWorkItems}
     * @memberof WorkItems
     */
    'state'?: WorkItemStateManualWorkItems;
    /**
     * 
     * @type {WorkItemTypeManualWorkItems}
     * @memberof WorkItems
     */
    'type'?: WorkItemTypeManualWorkItems;
    /**
     * A list of remediation items
     * @type {Array<RemediationItemDetails>}
     * @memberof WorkItems
     */
    'remediationItems'?: Array<RemediationItemDetails> | null;
    /**
     * A list of items that need to be approved
     * @type {Array<ApprovalItemDetails>}
     * @memberof WorkItems
     */
    'approvalItems'?: Array<ApprovalItemDetails> | null;
    /**
     * The work item name
     * @type {string}
     * @memberof WorkItems
     */
    'name'?: string | null;
    /**
     * The time at which the work item completed
     * @type {string}
     * @memberof WorkItems
     */
    'completed'?: string | null;
    /**
     * The number of items in the work item
     * @type {number}
     * @memberof WorkItems
     */
    'numItems'?: number | null;
    /**
     * 
     * @type {WorkItemsForm}
     * @memberof WorkItems
     */
    'form'?: WorkItemsForm;
    /**
     * An array of errors that ocurred during the work item
     * @type {Array<string>}
     * @memberof WorkItems
     */
    'errors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WorkItemsCount
 */
export interface WorkItemsCount {
    /**
     * The count of work items
     * @type {number}
     * @memberof WorkItemsCount
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface WorkItemsForm
 */
export interface WorkItemsForm {
    /**
     * ID of the form
     * @type {string}
     * @memberof WorkItemsForm
     */
    'id'?: string | null;
    /**
     * Name of the form
     * @type {string}
     * @memberof WorkItemsForm
     */
    'name'?: string | null;
    /**
     * The form title
     * @type {string}
     * @memberof WorkItemsForm
     */
    'title'?: string;
    /**
     * The form subtitle.
     * @type {string}
     * @memberof WorkItemsForm
     */
    'subtitle'?: string;
    /**
     * The name of the user that should be shown this form
     * @type {string}
     * @memberof WorkItemsForm
     */
    'targetUser'?: string;
    /**
     * Sections of the form
     * @type {Array<SectionDetails>}
     * @memberof WorkItemsForm
     */
    'sections'?: Array<SectionDetails>;
}
/**
 * 
 * @export
 * @interface WorkItemsSummary
 */
export interface WorkItemsSummary {
    /**
     * The count of open work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'open'?: number;
    /**
     * The count of completed work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'completed'?: number;
    /**
     * The count of total work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface Workflow
 */
export interface Workflow {
    /**
     * Workflow ID. This is a UUID generated upon creation.
     * @type {string}
     * @memberof Workflow
     */
    'id'?: string;
    /**
     * The number of times this workflow has been executed.
     * @type {number}
     * @memberof Workflow
     */
    'executionCount'?: number;
    /**
     * The number of times this workflow has failed during execution.
     * @type {number}
     * @memberof Workflow
     */
    'failureCount'?: number;
    /**
     * The date and time the workflow was created.
     * @type {string}
     * @memberof Workflow
     */
    'created'?: string;
    /**
     * The date and time the workflow was modified.
     * @type {string}
     * @memberof Workflow
     */
    'modified'?: string;
    /**
     * 
     * @type {WorkflowAllOfCreator}
     * @memberof Workflow
     */
    'creator'?: WorkflowAllOfCreator;
    /**
     * The name of the workflow
     * @type {string}
     * @memberof Workflow
     */
    'name'?: string;
    /**
     * 
     * @type {WorkflowBodyOwner}
     * @memberof Workflow
     */
    'owner'?: WorkflowBodyOwner;
    /**
     * Description of what the workflow accomplishes
     * @type {string}
     * @memberof Workflow
     */
    'description'?: string;
    /**
     * 
     * @type {WorkflowDefinition}
     * @memberof Workflow
     */
    'definition'?: WorkflowDefinition;
    /**
     * Enable or disable the workflow.  Workflows cannot be created in an enabled state.
     * @type {boolean}
     * @memberof Workflow
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {WorkflowTrigger}
     * @memberof Workflow
     */
    'trigger'?: WorkflowTrigger;
}
/**
 * 
 * @export
 * @interface WorkflowAllOf
 */
export interface WorkflowAllOf {
    /**
     * Workflow ID. This is a UUID generated upon creation.
     * @type {string}
     * @memberof WorkflowAllOf
     */
    'id'?: string;
    /**
     * The number of times this workflow has been executed.
     * @type {number}
     * @memberof WorkflowAllOf
     */
    'executionCount'?: number;
    /**
     * The number of times this workflow has failed during execution.
     * @type {number}
     * @memberof WorkflowAllOf
     */
    'failureCount'?: number;
    /**
     * The date and time the workflow was created.
     * @type {string}
     * @memberof WorkflowAllOf
     */
    'created'?: string;
    /**
     * The date and time the workflow was modified.
     * @type {string}
     * @memberof WorkflowAllOf
     */
    'modified'?: string;
    /**
     * 
     * @type {WorkflowAllOfCreator}
     * @memberof WorkflowAllOf
     */
    'creator'?: WorkflowAllOfCreator;
}
/**
 * Workflow creator\'s identity.
 * @export
 * @interface WorkflowAllOfCreator
 */
export interface WorkflowAllOfCreator {
    /**
     * Workflow creator\'s DTO type.
     * @type {string}
     * @memberof WorkflowAllOfCreator
     */
    'type'?: WorkflowAllOfCreatorTypeEnum;
    /**
     * Workflow creator\'s identity ID.
     * @type {string}
     * @memberof WorkflowAllOfCreator
     */
    'id'?: string;
    /**
     * Workflow creator\'s display name.
     * @type {string}
     * @memberof WorkflowAllOfCreator
     */
    'name'?: string;
}

export const WorkflowAllOfCreatorTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type WorkflowAllOfCreatorTypeEnum = typeof WorkflowAllOfCreatorTypeEnum[keyof typeof WorkflowAllOfCreatorTypeEnum];

/**
 * 
 * @export
 * @interface WorkflowBody
 */
export interface WorkflowBody {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof WorkflowBody
     */
    'name'?: string;
    /**
     * 
     * @type {WorkflowBodyOwner}
     * @memberof WorkflowBody
     */
    'owner'?: WorkflowBodyOwner;
    /**
     * Description of what the workflow accomplishes
     * @type {string}
     * @memberof WorkflowBody
     */
    'description'?: string;
    /**
     * 
     * @type {WorkflowDefinition}
     * @memberof WorkflowBody
     */
    'definition'?: WorkflowDefinition;
    /**
     * Enable or disable the workflow.  Workflows cannot be created in an enabled state.
     * @type {boolean}
     * @memberof WorkflowBody
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {WorkflowTrigger}
     * @memberof WorkflowBody
     */
    'trigger'?: WorkflowTrigger;
}
/**
 * The identity that owns the workflow.  The owner\'s permissions in IDN will determine what actions the workflow is allowed to perform.  Ownership can be changed by updating the owner in a PUT or PATCH request.
 * @export
 * @interface WorkflowBodyOwner
 */
export interface WorkflowBodyOwner {
    /**
     * The type of object that is referenced
     * @type {string}
     * @memberof WorkflowBodyOwner
     */
    'type'?: WorkflowBodyOwnerTypeEnum;
    /**
     * The unique ID of the object
     * @type {string}
     * @memberof WorkflowBodyOwner
     */
    'id'?: string;
    /**
     * The name of the object
     * @type {string}
     * @memberof WorkflowBodyOwner
     */
    'name'?: string;
}

export const WorkflowBodyOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type WorkflowBodyOwnerTypeEnum = typeof WorkflowBodyOwnerTypeEnum[keyof typeof WorkflowBodyOwnerTypeEnum];

/**
 * The map of steps that the workflow will execute.
 * @export
 * @interface WorkflowDefinition
 */
export interface WorkflowDefinition {
    /**
     * The name of the starting step.
     * @type {string}
     * @memberof WorkflowDefinition
     */
    'start'?: string;
    /**
     * One or more step objects that comprise this workflow.  Please see the Workflow documentation to see the JSON schema for each step type.
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowDefinition
     */
    'steps'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface WorkflowExecution
 */
export interface WorkflowExecution {
    /**
     * Workflow execution ID.
     * @type {string}
     * @memberof WorkflowExecution
     */
    'id'?: string;
    /**
     * Workflow ID.
     * @type {string}
     * @memberof WorkflowExecution
     */
    'workflowId'?: string;
    /**
     * Backend ID that tracks a workflow request in the system. Provide this ID in a customer support ticket for debugging purposes.
     * @type {string}
     * @memberof WorkflowExecution
     */
    'requestId'?: string;
    /**
     * Date/time when the workflow started.
     * @type {string}
     * @memberof WorkflowExecution
     */
    'startTime'?: string;
    /**
     * Date/time when the workflow ended.
     * @type {string}
     * @memberof WorkflowExecution
     */
    'closeTime'?: string;
    /**
     * Workflow execution status.
     * @type {string}
     * @memberof WorkflowExecution
     */
    'status'?: WorkflowExecutionStatusEnum;
}

export const WorkflowExecutionStatusEnum = {
    Completed: 'Completed',
    Failed: 'Failed',
    Canceled: 'Canceled',
    Executing: 'Executing'
} as const;

export type WorkflowExecutionStatusEnum = typeof WorkflowExecutionStatusEnum[keyof typeof WorkflowExecutionStatusEnum];

/**
 * 
 * @export
 * @interface WorkflowExecutionEvent
 */
export interface WorkflowExecutionEvent {
    /**
     * The type of event
     * @type {object}
     * @memberof WorkflowExecutionEvent
     */
    'type'?: WorkflowExecutionEventTypeEnum;
    /**
     * The date-time when the event occurred
     * @type {string}
     * @memberof WorkflowExecutionEvent
     */
    'timestamp'?: string;
    /**
     * Additional attributes associated with the event
     * @type {object}
     * @memberof WorkflowExecutionEvent
     */
    'attributes'?: object;
}

export const WorkflowExecutionEventTypeEnum = {
    WorkflowExecutionScheduled: 'WorkflowExecutionScheduled',
    WorkflowExecutionStarted: 'WorkflowExecutionStarted',
    WorkflowExecutionCompleted: 'WorkflowExecutionCompleted',
    WorkflowExecutionFailed: 'WorkflowExecutionFailed',
    WorkflowTaskScheduled: 'WorkflowTaskScheduled',
    WorkflowTaskStarted: 'WorkflowTaskStarted',
    WorkflowTaskCompleted: 'WorkflowTaskCompleted',
    WorkflowTaskFailed: 'WorkflowTaskFailed',
    ActivityTaskScheduled: 'ActivityTaskScheduled',
    ActivityTaskStarted: 'ActivityTaskStarted',
    ActivityTaskCompleted: 'ActivityTaskCompleted',
    ActivityTaskFailed: 'ActivityTaskFailed'
} as const;

export type WorkflowExecutionEventTypeEnum = typeof WorkflowExecutionEventTypeEnum[keyof typeof WorkflowExecutionEventTypeEnum];

/**
 * 
 * @export
 * @interface WorkflowLibraryAction
 */
export interface WorkflowLibraryAction {
    /**
     * Action ID. This is a static namespaced ID for the action
     * @type {string}
     * @memberof WorkflowLibraryAction
     */
    'id'?: string;
    /**
     * Action Name
     * @type {string}
     * @memberof WorkflowLibraryAction
     */
    'name'?: string;
    /**
     * Action type
     * @type {string}
     * @memberof WorkflowLibraryAction
     */
    'type'?: string;
    /**
     * Action Description
     * @type {string}
     * @memberof WorkflowLibraryAction
     */
    'description'?: string;
    /**
     * One or more inputs that the action accepts
     * @type {Array<WorkflowLibraryFormFields>}
     * @memberof WorkflowLibraryAction
     */
    'formFields'?: Array<WorkflowLibraryFormFields>;
    /**
     * Determines whether the dynamic output schema is returned in place of the action\'s output schema. The dynamic schema lists non-static properties, like properties of a workflow form where each form has different fields. These will be provided dynamically based on available form fields.
     * @type {boolean}
     * @memberof WorkflowLibraryAction
     */
    'isDynamicSchema'?: boolean;
    /**
     * Defines the output schema, if any, that this action produces.
     * @type {object}
     * @memberof WorkflowLibraryAction
     */
    'outputSchema'?: object;
}
/**
 * 
 * @export
 * @interface WorkflowLibraryFormFields
 */
export interface WorkflowLibraryFormFields {
    /**
     * Describes the form field in the UI
     * @type {string}
     * @memberof WorkflowLibraryFormFields
     */
    'helpText'?: string;
    /**
     * A human readable name for this form field in the UI
     * @type {string}
     * @memberof WorkflowLibraryFormFields
     */
    'label'?: string;
    /**
     * The name of the input attribute
     * @type {string}
     * @memberof WorkflowLibraryFormFields
     */
    'name'?: string;
    /**
     * Denotes if this field is a required attribute
     * @type {boolean}
     * @memberof WorkflowLibraryFormFields
     */
    'required'?: boolean;
    /**
     * The type of the form field
     * @type {object}
     * @memberof WorkflowLibraryFormFields
     */
    'type'?: WorkflowLibraryFormFieldsTypeEnum;
}

export const WorkflowLibraryFormFieldsTypeEnum = {
    Text: 'text',
    Textarea: 'textarea',
    Boolean: 'boolean',
    Email: 'email',
    Url: 'url',
    Number: 'number',
    Json: 'json',
    Checkbox: 'checkbox',
    Jsonpath: 'jsonpath',
    Select: 'select',
    MultiType: 'multiType',
    Duration: 'duration',
    Toggle: 'toggle',
    IdentityPicker: 'identityPicker',
    GovernanceGroupPicker: 'governanceGroupPicker',
    String: 'string',
    Object: 'object',
    Array: 'array',
    Secret: 'secret',
    KeyValuePairs: 'keyValuePairs',
    EmailPicker: 'emailPicker',
    AdvancedToggle: 'advancedToggle'
} as const;

export type WorkflowLibraryFormFieldsTypeEnum = typeof WorkflowLibraryFormFieldsTypeEnum[keyof typeof WorkflowLibraryFormFieldsTypeEnum];

/**
 * 
 * @export
 * @interface WorkflowLibraryOperator
 */
export interface WorkflowLibraryOperator {
    /**
     * Operator ID.
     * @type {string}
     * @memberof WorkflowLibraryOperator
     */
    'id'?: string;
    /**
     * Operator friendly name
     * @type {string}
     * @memberof WorkflowLibraryOperator
     */
    'name'?: string;
    /**
     * Operator type
     * @type {string}
     * @memberof WorkflowLibraryOperator
     */
    'type'?: string;
    /**
     * Description of the operator
     * @type {string}
     * @memberof WorkflowLibraryOperator
     */
    'description'?: string;
    /**
     * One or more inputs that the operator accepts
     * @type {Array<WorkflowLibraryFormFields>}
     * @memberof WorkflowLibraryOperator
     */
    'formFields'?: Array<WorkflowLibraryFormFields>;
}
/**
 * 
 * @export
 * @interface WorkflowLibraryTrigger
 */
export interface WorkflowLibraryTrigger {
    /**
     * Trigger ID. This is a static namespaced ID for the trigger.
     * @type {string}
     * @memberof WorkflowLibraryTrigger
     */
    'id'?: string;
    /**
     * Trigger type
     * @type {object}
     * @memberof WorkflowLibraryTrigger
     */
    'type'?: WorkflowLibraryTriggerTypeEnum;
    /**
     * Trigger Name
     * @type {string}
     * @memberof WorkflowLibraryTrigger
     */
    'name'?: string;
    /**
     * Trigger Description
     * @type {string}
     * @memberof WorkflowLibraryTrigger
     */
    'description'?: string;
    /**
     * Determines whether the dynamic output schema is returned in place of the action\'s output schema. The dynamic schema lists non-static properties, like properties of a workflow form where each form has different fields. These will be provided dynamically based on available form fields.
     * @type {boolean}
     * @memberof WorkflowLibraryTrigger
     */
    'isDynamicSchema'?: boolean;
    /**
     * Example trigger payload if applicable
     * @type {object}
     * @memberof WorkflowLibraryTrigger
     */
    'inputExample'?: object | null;
    /**
     * One or more inputs that the trigger accepts
     * @type {Array<WorkflowLibraryFormFields>}
     * @memberof WorkflowLibraryTrigger
     */
    'formFields'?: Array<WorkflowLibraryFormFields> | null;
}

export const WorkflowLibraryTriggerTypeEnum = {
    Event: 'EVENT',
    Scheduled: 'SCHEDULED',
    External: 'EXTERNAL'
} as const;

export type WorkflowLibraryTriggerTypeEnum = typeof WorkflowLibraryTriggerTypeEnum[keyof typeof WorkflowLibraryTriggerTypeEnum];

/**
 * 
 * @export
 * @interface WorkflowOAuthClient
 */
export interface WorkflowOAuthClient {
    /**
     * OAuth client ID for the trigger. This is a UUID generated upon creation.
     * @type {string}
     * @memberof WorkflowOAuthClient
     */
    'id'?: string;
    /**
     * OAuthClient secret.
     * @type {string}
     * @memberof WorkflowOAuthClient
     */
    'secret'?: string;
    /**
     * URL for the external trigger to invoke
     * @type {string}
     * @memberof WorkflowOAuthClient
     */
    'url'?: string;
}
/**
 * The trigger that starts the workflow
 * @export
 * @interface WorkflowTrigger
 */
export interface WorkflowTrigger {
    /**
     * The trigger type
     * @type {string}
     * @memberof WorkflowTrigger
     */
    'type': WorkflowTriggerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTrigger
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {WorkflowTriggerAttributes}
     * @memberof WorkflowTrigger
     */
    'attributes': WorkflowTriggerAttributes;
}

export const WorkflowTriggerTypeEnum = {
    Event: 'EVENT',
    External: 'EXTERNAL',
    Scheduled: 'SCHEDULED'
} as const;

export type WorkflowTriggerTypeEnum = typeof WorkflowTriggerTypeEnum[keyof typeof WorkflowTriggerTypeEnum];

/**
 * @type WorkflowTriggerAttributes
 * Workflow Trigger Attributes.
 * @export
 */
export type WorkflowTriggerAttributes = EventAttributes | ExternalAttributes | ScheduledAttributes;


/**
 * AccessProfilesApi - axios parameter creator
 * @export
 */
export const AccessProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to create an access profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the access profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles. However, any new access profiles as well as any updates to existing descriptions are limited to 2000 characters.
         * @summary Create Access Profile
         * @param {AccessProfile} accessProfile 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessProfile: async (accessProfile: AccessProfile, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessProfile' is not null or undefined
            assertParamExists('createAccessProfile', 'accessProfile', accessProfile)
            const localVarPath = `/access-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessProfile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {string} id ID of the Access Profile to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfile: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAccessProfile', 'id', id)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint initiates a bulk deletion of one or more access profiles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 access profiles per request.  By default, if any of the indicated access profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated access profiles will be deleted. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this endpoint. In addition, a SOURCE_SUBADMIN can only use this endpoint to delete access profiles associated with sources they\'re able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequest} accessProfileBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfilesInBulk: async (accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessProfileBulkDeleteRequest' is not null or undefined
            assertParamExists('deleteAccessProfilesInBulk', 'accessProfileBulkDeleteRequest', accessProfileBulkDeleteRequest)
            const localVarPath = `/access-profiles/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessProfileBulkDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfile: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccessProfile', 'id', id)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the containing Access Profile
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfileEntitlements: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccessProfileEntitlements', 'id', id)
            const localVarPath = `/access-profiles/{id}/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get a list of access profiles. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*  Composite operators supported: *and, or*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names. 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters access profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Indicates whether the response list should contain unsegmented access profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessProfiles: async (forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSegmentIds !== undefined) {
                localVarQueryParameter['for-segment-ids'] = forSegmentIds;
            }

            if (includeUnsegmented !== undefined) {
                localVarQueryParameter['include-unsegmented'] = includeUnsegmented;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessProfile: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchAccessProfile', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchAccessProfile', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessProfilesApi - functional programming interface
 * @export
 */
export const AccessProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to create an access profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the access profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles. However, any new access profiles as well as any updates to existing descriptions are limited to 2000 characters.
         * @summary Create Access Profile
         * @param {AccessProfile} accessProfile 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessProfile(accessProfile: AccessProfile, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessProfile(accessProfile, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {string} id ID of the Access Profile to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccessProfile(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccessProfile(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint initiates a bulk deletion of one or more access profiles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 access profiles per request.  By default, if any of the indicated access profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated access profiles will be deleted. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this endpoint. In addition, a SOURCE_SUBADMIN can only use this endpoint to delete access profiles associated with sources they\'re able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequest} accessProfileBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfileBulkDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessProfile(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessProfile(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the containing Access Profile
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessProfileEntitlements(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Entitlement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessProfileEntitlements(id, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to get a list of access profiles. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*  Composite operators supported: *and, or*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names. 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters access profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Indicates whether the response list should contain unsegmented access profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessProfiles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessProfiles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccessProfile(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAccessProfile(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessProfilesApi - factory interface
 * @export
 */
export const AccessProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessProfilesApiFp(configuration)
    return {
        /**
         * Use this API to create an access profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the access profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles. However, any new access profiles as well as any updates to existing descriptions are limited to 2000 characters.
         * @summary Create Access Profile
         * @param {AccessProfile} accessProfile 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessProfile(accessProfile: AccessProfile, axiosOptions?: any): AxiosPromise<AccessProfile> {
            return localVarFp.createAccessProfile(accessProfile, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {string} id ID of the Access Profile to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfile(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteAccessProfile(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint initiates a bulk deletion of one or more access profiles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 access profiles per request.  By default, if any of the indicated access profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated access profiles will be deleted. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this endpoint. In addition, a SOURCE_SUBADMIN can only use this endpoint to delete access profiles associated with sources they\'re able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequest} accessProfileBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest, axiosOptions?: any): AxiosPromise<AccessProfileBulkDeleteResponse> {
            return localVarFp.deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfile(id: string, axiosOptions?: any): AxiosPromise<AccessProfile> {
            return localVarFp.getAccessProfile(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the containing Access Profile
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfileEntitlements(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<Entitlement>> {
            return localVarFp.getAccessProfileEntitlements(id, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get a list of access profiles. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*  Composite operators supported: *and, or*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names. 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters access profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Indicates whether the response list should contain unsegmented access profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessProfiles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: any): AxiosPromise<Array<AccessProfile>> {
            return localVarFp.listAccessProfiles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessProfile(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<AccessProfile> {
            return localVarFp.patchAccessProfile(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiCreateAccessProfileRequest
 */
export interface AccessProfilesApiCreateAccessProfileRequest {
    /**
     * 
     * @type {AccessProfile}
     * @memberof AccessProfilesApiCreateAccessProfile
     */
    readonly accessProfile: AccessProfile
}

/**
 * Request parameters for deleteAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiDeleteAccessProfileRequest
 */
export interface AccessProfilesApiDeleteAccessProfileRequest {
    /**
     * ID of the Access Profile to delete
     * @type {string}
     * @memberof AccessProfilesApiDeleteAccessProfile
     */
    readonly id: string
}

/**
 * Request parameters for deleteAccessProfilesInBulk operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiDeleteAccessProfilesInBulkRequest
 */
export interface AccessProfilesApiDeleteAccessProfilesInBulkRequest {
    /**
     * 
     * @type {AccessProfileBulkDeleteRequest}
     * @memberof AccessProfilesApiDeleteAccessProfilesInBulk
     */
    readonly accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest
}

/**
 * Request parameters for getAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiGetAccessProfileRequest
 */
export interface AccessProfilesApiGetAccessProfileRequest {
    /**
     * ID of the Access Profile
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfile
     */
    readonly id: string
}

/**
 * Request parameters for getAccessProfileEntitlements operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiGetAccessProfileEntitlementsRequest
 */
export interface AccessProfilesApiGetAccessProfileEntitlementsRequest {
    /**
     * ID of the containing Access Profile
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly sorters?: string
}

/**
 * Request parameters for listAccessProfiles operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiListAccessProfilesRequest
 */
export interface AccessProfilesApiListAccessProfilesRequest {
    /**
     * If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly forSubadmin?: string

    /**
     * Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*  Composite operators supported: *and, or*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names. 
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly sorters?: string

    /**
     * If present and not empty, additionally filters access profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly forSegmentIds?: string

    /**
     * Indicates whether the response list should contain unsegmented access profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
     * @type {boolean}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly includeUnsegmented?: boolean
}

/**
 * Request parameters for patchAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiPatchAccessProfileRequest
 */
export interface AccessProfilesApiPatchAccessProfileRequest {
    /**
     * ID of the Access Profile to patch
     * @type {string}
     * @memberof AccessProfilesApiPatchAccessProfile
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperation>}
     * @memberof AccessProfilesApiPatchAccessProfile
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * AccessProfilesApi - object-oriented interface
 * @export
 * @class AccessProfilesApi
 * @extends {BaseAPI}
 */
export class AccessProfilesApi extends BaseAPI {
    /**
     * Use this API to create an access profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the access profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles. However, any new access profiles as well as any updates to existing descriptions are limited to 2000 characters.
     * @summary Create Access Profile
     * @param {AccessProfilesApiCreateAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public createAccessProfile(requestParameters: AccessProfilesApiCreateAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).createAccessProfile(requestParameters.accessProfile, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
     * @summary Delete the specified Access Profile
     * @param {AccessProfilesApiDeleteAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public deleteAccessProfile(requestParameters: AccessProfilesApiDeleteAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).deleteAccessProfile(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint initiates a bulk deletion of one or more access profiles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 access profiles per request.  By default, if any of the indicated access profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated access profiles will be deleted. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this endpoint. In addition, a SOURCE_SUBADMIN can only use this endpoint to delete access profiles associated with sources they\'re able to administer.
     * @summary Delete Access Profile(s)
     * @param {AccessProfilesApiDeleteAccessProfilesInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public deleteAccessProfilesInBulk(requestParameters: AccessProfilesApiDeleteAccessProfilesInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).deleteAccessProfilesInBulk(requestParameters.accessProfileBulkDeleteRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get an Access Profile
     * @param {AccessProfilesApiGetAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public getAccessProfile(requestParameters: AccessProfilesApiGetAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).getAccessProfile(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
     * @summary List Access Profile\'s Entitlements
     * @param {AccessProfilesApiGetAccessProfileEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public getAccessProfileEntitlements(requestParameters: AccessProfilesApiGetAccessProfileEntitlementsRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).getAccessProfileEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get a list of access profiles. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary List Access Profiles
     * @param {AccessProfilesApiListAccessProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public listAccessProfiles(requestParameters: AccessProfilesApiListAccessProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).listAccessProfiles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.
     * @summary Patch a specified Access Profile
     * @param {AccessProfilesApiPatchAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public patchAccessProfile(requestParameters: AccessProfilesApiPatchAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).patchAccessProfile(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccessRequestApprovalsApi - axios parameter creator
 * @export
 */
export const AccessRequestApprovalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to approve an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approve Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveAccessRequest: async (approvalId: string, commentDto: CommentDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('approveAccessRequest', 'approvalId', approvalId)
            // verify required parameter 'commentDto' is not null or undefined
            assertParamExists('approveAccessRequest', 'commentDto', commentDto)
            const localVarPath = `/access-request-approvals/{approvalId}/approve`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to forward an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forward Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardAccessRequest: async (approvalId: string, forwardApprovalDto: ForwardApprovalDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('forwardAccessRequest', 'approvalId', approvalId)
            // verify required parameter 'forwardApprovalDto' is not null or undefined
            assertParamExists('forwardAccessRequest', 'forwardApprovalDto', forwardApprovalDto)
            const localVarPath = `/access-request-approvals/{approvalId}/forward`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forwardApprovalDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to return the number of pending, approved and rejected access requests approvals. See the \"owner-id\" query parameter for authorization information. info.
         * @summary Get Access Requests Approvals Number
         * @param {string} [ownerId] The ID of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] This is the date and time the results will be shown from. It must be in a valid ISO-8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestApprovalSummary: async (ownerId?: string, fromDate?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/approval-summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = fromDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **requestedFor.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le, eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to reject an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Reject Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectAccessRequest: async (approvalId: string, commentDto: CommentDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('rejectAccessRequest', 'approvalId', approvalId)
            // verify required parameter 'commentDto' is not null or undefined
            assertParamExists('rejectAccessRequest', 'commentDto', commentDto)
            const localVarPath = `/access-request-approvals/{approvalId}/reject`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRequestApprovalsApi - functional programming interface
 * @export
 */
export const AccessRequestApprovalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessRequestApprovalsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to approve an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approve Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveAccessRequest(approvalId: string, commentDto: CommentDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveAccessRequest(approvalId, commentDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to forward an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forward Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async forwardAccessRequest(approvalId: string, forwardApprovalDto: ForwardApprovalDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forwardAccessRequest(approvalId, forwardApprovalDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to return the number of pending, approved and rejected access requests approvals. See the \"owner-id\" query parameter for authorization information. info.
         * @summary Get Access Requests Approvals Number
         * @param {string} [ownerId] The ID of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] This is the date and time the results will be shown from. It must be in a valid ISO-8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestApprovalSummary(ownerId?: string, fromDate?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestApprovalSummary(ownerId, fromDate, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **requestedFor.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCompletedApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompletedApproval>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCompletedApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le, eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPendingApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PendingApproval>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPendingApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to reject an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Reject Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectAccessRequest(approvalId: string, commentDto: CommentDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectAccessRequest(approvalId, commentDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessRequestApprovalsApi - factory interface
 * @export
 */
export const AccessRequestApprovalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessRequestApprovalsApiFp(configuration)
    return {
        /**
         * Use this endpoint to approve an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approve Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveAccessRequest(approvalId: string, commentDto: CommentDto, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.approveAccessRequest(approvalId, commentDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to forward an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forward Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardAccessRequest(approvalId: string, forwardApprovalDto: ForwardApprovalDto, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.forwardAccessRequest(approvalId, forwardApprovalDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to return the number of pending, approved and rejected access requests approvals. See the \"owner-id\" query parameter for authorization information. info.
         * @summary Get Access Requests Approvals Number
         * @param {string} [ownerId] The ID of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] This is the date and time the results will be shown from. It must be in a valid ISO-8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestApprovalSummary(ownerId?: string, fromDate?: string, axiosOptions?: any): AxiosPromise<ApprovalSummary> {
            return localVarFp.getAccessRequestApprovalSummary(ownerId, fromDate, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **requestedFor.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<CompletedApproval>> {
            return localVarFp.listCompletedApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le, eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<PendingApproval>> {
            return localVarFp.listPendingApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to reject an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Reject Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectAccessRequest(approvalId: string, commentDto: CommentDto, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.rejectAccessRequest(approvalId, commentDto, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveAccessRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiApproveAccessRequestRequest
 */
export interface AccessRequestApprovalsApiApproveAccessRequestRequest {
    /**
     * Approval ID.
     * @type {string}
     * @memberof AccessRequestApprovalsApiApproveAccessRequest
     */
    readonly approvalId: string

    /**
     * Reviewer\&#39;s comment.
     * @type {CommentDto}
     * @memberof AccessRequestApprovalsApiApproveAccessRequest
     */
    readonly commentDto: CommentDto
}

/**
 * Request parameters for forwardAccessRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiForwardAccessRequestRequest
 */
export interface AccessRequestApprovalsApiForwardAccessRequestRequest {
    /**
     * Approval ID.
     * @type {string}
     * @memberof AccessRequestApprovalsApiForwardAccessRequest
     */
    readonly approvalId: string

    /**
     * Information about the forwarded approval.
     * @type {ForwardApprovalDto}
     * @memberof AccessRequestApprovalsApiForwardAccessRequest
     */
    readonly forwardApprovalDto: ForwardApprovalDto
}

/**
 * Request parameters for getAccessRequestApprovalSummary operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest
 */
export interface AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest {
    /**
     * The ID of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiGetAccessRequestApprovalSummary
     */
    readonly ownerId?: string

    /**
     * This is the date and time the results will be shown from. It must be in a valid ISO-8601 format.
     * @type {string}
     * @memberof AccessRequestApprovalsApiGetAccessRequestApprovalSummary
     */
    readonly fromDate?: string
}

/**
 * Request parameters for listCompletedApprovals operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiListCompletedApprovalsRequest
 */
export interface AccessRequestApprovalsApiListCompletedApprovalsRequest {
    /**
     * If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **requestedFor.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, sw*
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for listPendingApprovals operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiListPendingApprovalsRequest
 */
export interface AccessRequestApprovalsApiListPendingApprovalsRequest {
    /**
     * If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le, eq, in*
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for rejectAccessRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiRejectAccessRequestRequest
 */
export interface AccessRequestApprovalsApiRejectAccessRequestRequest {
    /**
     * Approval ID.
     * @type {string}
     * @memberof AccessRequestApprovalsApiRejectAccessRequest
     */
    readonly approvalId: string

    /**
     * Reviewer\&#39;s comment.
     * @type {CommentDto}
     * @memberof AccessRequestApprovalsApiRejectAccessRequest
     */
    readonly commentDto: CommentDto
}

/**
 * AccessRequestApprovalsApi - object-oriented interface
 * @export
 * @class AccessRequestApprovalsApi
 * @extends {BaseAPI}
 */
export class AccessRequestApprovalsApi extends BaseAPI {
    /**
     * Use this endpoint to approve an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Approve Access Request Approval
     * @param {AccessRequestApprovalsApiApproveAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public approveAccessRequest(requestParameters: AccessRequestApprovalsApiApproveAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).approveAccessRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to forward an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Forward Access Request Approval
     * @param {AccessRequestApprovalsApiForwardAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public forwardAccessRequest(requestParameters: AccessRequestApprovalsApiForwardAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).forwardAccessRequest(requestParameters.approvalId, requestParameters.forwardApprovalDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to return the number of pending, approved and rejected access requests approvals. See the \"owner-id\" query parameter for authorization information. info.
     * @summary Get Access Requests Approvals Number
     * @param {AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public getAccessRequestApprovalSummary(requestParameters: AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).getAccessRequestApprovalSummary(requestParameters.ownerId, requestParameters.fromDate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
     * @summary Completed Access Request Approvals List
     * @param {AccessRequestApprovalsApiListCompletedApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public listCompletedApprovals(requestParameters: AccessRequestApprovalsApiListCompletedApprovalsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).listCompletedApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
     * @summary Pending Access Request Approvals List
     * @param {AccessRequestApprovalsApiListPendingApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public listPendingApprovals(requestParameters: AccessRequestApprovalsApiListPendingApprovalsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).listPendingApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to reject an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
     * @summary Reject Access Request Approval
     * @param {AccessRequestApprovalsApiRejectAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public rejectAccessRequest(requestParameters: AccessRequestApprovalsApiRejectAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).rejectAccessRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccessRequestsApi - axios parameter creator
 * @export
 */
export const AccessRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest: async (cancelAccessRequest: CancelAccessRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelAccessRequest' is not null or undefined
            assertParamExists('cancelAccessRequest', 'cancelAccessRequest', cancelAccessRequest)
            const localVarPath = `/access-requests/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelAccessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to submit an access request in Identity Security Cloud (ISC), where it follows any ISC approval processes.  Access requests are processed asynchronously by ISC. A successful response from this endpoint means that the request has been submitted to ISC and is queued for processing. Because this endpoint is asynchronous, it doesn\'t return an error if you submit duplicate access requests in quick succession or submit an access request for access that is already in progress, approved, or rejected.  It\'s best practice to check for any existing access requests that reference the same access items before submitting a new access request. This can be accomplished by using the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [Pending Access Request Approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) APIs. You can also use the [Search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items an identity has before submitting an access request to ensure that you aren\'t requesting access that is already granted. If you use this API to request access that an identity already has, the API will ignore the request.  These ignored requests do not display when you use the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) API.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * You cannot use an access request to revoke access from an identity if that access has been granted by role membership or by birthright provisioning.  * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles, access profiles and entitlements. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit Access Request
         * @param {AccessRequest} accessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest: async (accessRequest: AccessRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequest' is not null or undefined
            assertParamExists('createAccessRequest', 'accessRequest', accessRequest)
            const localVarPath = `/access-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to return a list of access request statuses based on the specified query parameters. If an access request was made for access that an identity already has, the API ignores the access request.  These ignored requests do not display in the list of access request statuses. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity the requests were made for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity twho made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity who is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {string} [assignedTo] Filter the results by the specified identity who is the owner of the Identity Request Work Item. *me* indicates the current user.
         * @param {boolean} [count] If this is true, the *X-Total-Count* response header populates with the number of results that would be returned if limit and offset were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId, name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus: async (requestedFor?: string, requestedBy?: string, regardingIdentity?: string, assignedTo?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (requestedBy !== undefined) {
                localVarQueryParameter['requested-by'] = requestedBy;
            }

            if (regardingIdentity !== undefined) {
                localVarQueryParameter['regarding-identity'] = regardingIdentity;
            }

            if (assignedTo !== undefined) {
                localVarQueryParameter['assigned-to'] = assignedTo;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setAccessRequestConfig: async (accessRequestConfig: AccessRequestConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequestConfig' is not null or undefined
            assertParamExists('setAccessRequestConfig', 'accessRequestConfig', accessRequestConfig)
            const localVarPath = `/access-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequestConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRequestsApi - functional programming interface
 * @export
 */
export const AccessRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelAccessRequest(cancelAccessRequest: CancelAccessRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelAccessRequest(cancelAccessRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to submit an access request in Identity Security Cloud (ISC), where it follows any ISC approval processes.  Access requests are processed asynchronously by ISC. A successful response from this endpoint means that the request has been submitted to ISC and is queued for processing. Because this endpoint is asynchronous, it doesn\'t return an error if you submit duplicate access requests in quick succession or submit an access request for access that is already in progress, approved, or rejected.  It\'s best practice to check for any existing access requests that reference the same access items before submitting a new access request. This can be accomplished by using the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [Pending Access Request Approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) APIs. You can also use the [Search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items an identity has before submitting an access request to ensure that you aren\'t requesting access that is already granted. If you use this API to request access that an identity already has, the API will ignore the request.  These ignored requests do not display when you use the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) API.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * You cannot use an access request to revoke access from an identity if that access has been granted by role membership or by birthright provisioning.  * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles, access profiles and entitlements. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit Access Request
         * @param {AccessRequest} accessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessRequest(accessRequest: AccessRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessRequest(accessRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to return a list of access request statuses based on the specified query parameters. If an access request was made for access that an identity already has, the API ignores the access request.  These ignored requests do not display in the list of access request statuses. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity the requests were made for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity twho made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity who is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {string} [assignedTo] Filter the results by the specified identity who is the owner of the Identity Request Work Item. *me* indicates the current user.
         * @param {boolean} [count] If this is true, the *X-Total-Count* response header populates with the number of results that would be returned if limit and offset were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId, name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessRequestStatus(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, assignedTo?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RequestedItemStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessRequestStatus(requestedFor, requestedBy, regardingIdentity, assignedTo, count, limit, offset, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setAccessRequestConfig(accessRequestConfig: AccessRequestConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAccessRequestConfig(accessRequestConfig, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessRequestsApi - factory interface
 * @export
 */
export const AccessRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessRequestsApiFp(configuration)
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest(cancelAccessRequest: CancelAccessRequest, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.cancelAccessRequest(cancelAccessRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to submit an access request in Identity Security Cloud (ISC), where it follows any ISC approval processes.  Access requests are processed asynchronously by ISC. A successful response from this endpoint means that the request has been submitted to ISC and is queued for processing. Because this endpoint is asynchronous, it doesn\'t return an error if you submit duplicate access requests in quick succession or submit an access request for access that is already in progress, approved, or rejected.  It\'s best practice to check for any existing access requests that reference the same access items before submitting a new access request. This can be accomplished by using the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [Pending Access Request Approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) APIs. You can also use the [Search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items an identity has before submitting an access request to ensure that you aren\'t requesting access that is already granted. If you use this API to request access that an identity already has, the API will ignore the request.  These ignored requests do not display when you use the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) API.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * You cannot use an access request to revoke access from an identity if that access has been granted by role membership or by birthright provisioning.  * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles, access profiles and entitlements. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit Access Request
         * @param {AccessRequest} accessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest(accessRequest: AccessRequest, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.createAccessRequest(accessRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig(axiosOptions?: any): AxiosPromise<AccessRequestConfig> {
            return localVarFp.getAccessRequestConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to return a list of access request statuses based on the specified query parameters. If an access request was made for access that an identity already has, the API ignores the access request.  These ignored requests do not display in the list of access request statuses. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity the requests were made for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity twho made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity who is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {string} [assignedTo] Filter the results by the specified identity who is the owner of the Identity Request Work Item. *me* indicates the current user.
         * @param {boolean} [count] If this is true, the *X-Total-Count* response header populates with the number of results that would be returned if limit and offset were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId, name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, assignedTo?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<RequestedItemStatus>> {
            return localVarFp.listAccessRequestStatus(requestedFor, requestedBy, regardingIdentity, assignedTo, count, limit, offset, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setAccessRequestConfig(accessRequestConfig: AccessRequestConfig, axiosOptions?: any): AxiosPromise<AccessRequestConfig> {
            return localVarFp.setAccessRequestConfig(accessRequestConfig, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelAccessRequest operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiCancelAccessRequestRequest
 */
export interface AccessRequestsApiCancelAccessRequestRequest {
    /**
     * 
     * @type {CancelAccessRequest}
     * @memberof AccessRequestsApiCancelAccessRequest
     */
    readonly cancelAccessRequest: CancelAccessRequest
}

/**
 * Request parameters for createAccessRequest operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiCreateAccessRequestRequest
 */
export interface AccessRequestsApiCreateAccessRequestRequest {
    /**
     * 
     * @type {AccessRequest}
     * @memberof AccessRequestsApiCreateAccessRequest
     */
    readonly accessRequest: AccessRequest
}

/**
 * Request parameters for listAccessRequestStatus operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiListAccessRequestStatusRequest
 */
export interface AccessRequestsApiListAccessRequestStatusRequest {
    /**
     * Filter the results by the identity the requests were made for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly requestedFor?: string

    /**
     * Filter the results by the identity twho made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly requestedBy?: string

    /**
     * Filter the results by the specified identity who is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly regardingIdentity?: string

    /**
     * Filter the results by the specified identity who is the owner of the Identity Request Work Item. *me* indicates the current user.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly assignedTo?: string

    /**
     * If this is true, the *X-Total-Count* response header populates with the number of results that would be returned if limit and offset were ignored.
     * @type {boolean}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly count?: boolean

    /**
     * Max number of results to return.
     * @type {number}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
     * @type {number}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId, name**
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly sorters?: string
}

/**
 * Request parameters for setAccessRequestConfig operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiSetAccessRequestConfigRequest
 */
export interface AccessRequestsApiSetAccessRequestConfigRequest {
    /**
     * 
     * @type {AccessRequestConfig}
     * @memberof AccessRequestsApiSetAccessRequestConfig
     */
    readonly accessRequestConfig: AccessRequestConfig
}

/**
 * AccessRequestsApi - object-oriented interface
 * @export
 * @class AccessRequestsApi
 * @extends {BaseAPI}
 */
export class AccessRequestsApi extends BaseAPI {
    /**
     * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
     * @summary Cancel Access Request
     * @param {AccessRequestsApiCancelAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public cancelAccessRequest(requestParameters: AccessRequestsApiCancelAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).cancelAccessRequest(requestParameters.cancelAccessRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to submit an access request in Identity Security Cloud (ISC), where it follows any ISC approval processes.  Access requests are processed asynchronously by ISC. A successful response from this endpoint means that the request has been submitted to ISC and is queued for processing. Because this endpoint is asynchronous, it doesn\'t return an error if you submit duplicate access requests in quick succession or submit an access request for access that is already in progress, approved, or rejected.  It\'s best practice to check for any existing access requests that reference the same access items before submitting a new access request. This can be accomplished by using the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [Pending Access Request Approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) APIs. You can also use the [Search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items an identity has before submitting an access request to ensure that you aren\'t requesting access that is already granted. If you use this API to request access that an identity already has, the API will ignore the request.  These ignored requests do not display when you use the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) API.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * You cannot use an access request to revoke access from an identity if that access has been granted by role membership or by birthright provisioning.  * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles, access profiles and entitlements. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  A token with API authority cannot be used to call this endpoint.  
     * @summary Submit Access Request
     * @param {AccessRequestsApiCreateAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public createAccessRequest(requestParameters: AccessRequestsApiCreateAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).createAccessRequest(requestParameters.accessRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the current access-request configuration.
     * @summary Get Access Request Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public getAccessRequestConfig(axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).getAccessRequestConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to return a list of access request statuses based on the specified query parameters. If an access request was made for access that an identity already has, the API ignores the access request.  These ignored requests do not display in the list of access request statuses. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
     * @summary Access Request Status
     * @param {AccessRequestsApiListAccessRequestStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public listAccessRequestStatus(requestParameters: AccessRequestsApiListAccessRequestStatusRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).listAccessRequestStatus(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.assignedTo, requestParameters.count, requestParameters.limit, requestParameters.offset, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Access Request Configuration
     * @param {AccessRequestsApiSetAccessRequestConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public setAccessRequestConfig(requestParameters: AccessRequestsApiSetAccessRequestConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).setAccessRequestConfig(requestParameters.accessRequestConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountActivitiesApi - axios parameter creator
 * @export
 */
export const AccountActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountActivity', 'id', id)
            const localVarPath = `/account-activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **created**: *gt, lt, ge, le, eq, in, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities: async (requestedFor?: string, requestedBy?: string, regardingIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account-activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (requestedBy !== undefined) {
                localVarQueryParameter['requested-by'] = requestedBy;
            }

            if (regardingIdentity !== undefined) {
                localVarQueryParameter['regarding-identity'] = regardingIdentity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountActivitiesApi - functional programming interface
 * @export
 */
export const AccountActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountActivity(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountActivity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountActivity(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **created**: *gt, lt, ge, le, eq, in, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountActivities(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountActivity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountActivities(requestedFor, requestedBy, regardingIdentity, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountActivitiesApi - factory interface
 * @export
 */
export const AccountActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountActivitiesApiFp(configuration)
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity(id: string, axiosOptions?: any): AxiosPromise<AccountActivity> {
            return localVarFp.getAccountActivity(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **created**: *gt, lt, ge, le, eq, in, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<AccountActivity>> {
            return localVarFp.listAccountActivities(requestedFor, requestedBy, regardingIdentity, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAccountActivity operation in AccountActivitiesApi.
 * @export
 * @interface AccountActivitiesApiGetAccountActivityRequest
 */
export interface AccountActivitiesApiGetAccountActivityRequest {
    /**
     * The account activity id
     * @type {string}
     * @memberof AccountActivitiesApiGetAccountActivity
     */
    readonly id: string
}

/**
 * Request parameters for listAccountActivities operation in AccountActivitiesApi.
 * @export
 * @interface AccountActivitiesApiListAccountActivitiesRequest
 */
export interface AccountActivitiesApiListAccountActivitiesRequest {
    /**
     * The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly requestedFor?: string

    /**
     * The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly requestedBy?: string

    /**
     * The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly regardingIdentity?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **created**: *gt, lt, ge, le, eq, in, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, isnull, sw*
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly sorters?: string
}

/**
 * AccountActivitiesApi - object-oriented interface
 * @export
 * @class AccountActivitiesApi
 * @extends {BaseAPI}
 */
export class AccountActivitiesApi extends BaseAPI {
    /**
     * This gets a single account activity by its id.
     * @summary Get an Account Activity
     * @param {AccountActivitiesApiGetAccountActivityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesApi
     */
    public getAccountActivity(requestParameters: AccountActivitiesApiGetAccountActivityRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountActivitiesApiFp(this.configuration).getAccountActivity(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of account activities that satisfy the given query parameters.
     * @summary List Account Activities
     * @param {AccountActivitiesApiListAccountActivitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesApi
     */
    public listAccountActivities(requestParameters: AccountActivitiesApiListAccountActivitiesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccountActivitiesApiFp(this.configuration).listAccountActivities(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountUsagesApi - axios parameter creator
 * @export
 */
export const AccountUsagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns a summary of account usage insights for past 12 months.
         * @summary Returns account usage insights
         * @param {string} accountId ID of IDN account
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesByAccountId: async (accountId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getUsagesByAccountId', 'accountId', accountId)
            const localVarPath = `/account-usages/{accountId}/summaries`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountUsagesApi - functional programming interface
 * @export
 */
export const AccountUsagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountUsagesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns a summary of account usage insights for past 12 months.
         * @summary Returns account usage insights
         * @param {string} accountId ID of IDN account
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getUsagesByAccountId(accountId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountUsage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsagesByAccountId(accountId, limit, offset, count, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountUsagesApi - factory interface
 * @export
 */
export const AccountUsagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountUsagesApiFp(configuration)
    return {
        /**
         * This API returns a summary of account usage insights for past 12 months.
         * @summary Returns account usage insights
         * @param {string} accountId ID of IDN account
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesByAccountId(accountId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: any): AxiosPromise<Array<AccountUsage>> {
            return localVarFp.getUsagesByAccountId(accountId, limit, offset, count, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUsagesByAccountId operation in AccountUsagesApi.
 * @export
 * @interface AccountUsagesApiGetUsagesByAccountIdRequest
 */
export interface AccountUsagesApiGetUsagesByAccountIdRequest {
    /**
     * ID of IDN account
     * @type {string}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly accountId: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
     * @type {string}
     * @memberof AccountUsagesApiGetUsagesByAccountId
     */
    readonly sorters?: string
}

/**
 * AccountUsagesApi - object-oriented interface
 * @export
 * @class AccountUsagesApi
 * @extends {BaseAPI}
 */
export class AccountUsagesApi extends BaseAPI {
    /**
     * This API returns a summary of account usage insights for past 12 months.
     * @summary Returns account usage insights
     * @param {AccountUsagesApiGetUsagesByAccountIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsagesApi
     */
    public getUsagesByAccountId(requestParameters: AccountUsagesApiGetUsagesByAccountIdRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountUsagesApiFp(this.configuration).getUsagesByAccountId(requestParameters.accountId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API submits an account creation task and returns the task ID.   You must include the `sourceId` where the account will be created in the `attributes` object. This endpoint creates an account on the source record in your ISC tenant. This is useful for Flat File (`DelimitedFile`) type sources because it allows you to aggregate new accounts without needing to import a new CSV file every time.  However, if you use this endpoint to create an account for a Direct Connection type source, you must ensure that the account also exists on the target source.  The endpoint doesn\'t actually provision the account on the target source, which means that if the account doesn\'t also exist on the target source, an aggregation between the source and your tenant will remove it from your tenant.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (accountAttributesCreate: AccountAttributesCreate, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountAttributesCreate' is not null or undefined
            assertParamExists('createAccount', 'accountAttributesCreate', accountAttributesCreate)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAttributesCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to delete an account.  This endpoint submits an account delete task and returns the task ID.  This endpoint only deletes the account from IdentityNow, not the source itself, which can result in the account\'s returning with the next aggregation between the source and IdentityNow.  To avoid this scenario, it is recommended that you [disable accounts](https://developer.sailpoint.com/idn/api/v3/disable-account) rather than delete them. This will also allow you to reenable the accounts in the future.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**NOTE: You can only delete accounts from sources of the \"DelimitedFile\" type.**
         * @summary Delete Account
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAccount', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount: async (id: string, accountToggleRequest: AccountToggleRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('disableAccount', 'id', id)
            // verify required parameter 'accountToggleRequest' is not null or undefined
            assertParamExists('disableAccount', 'accountToggleRequest', accountToggleRequest)
            const localVarPath = `/accounts/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountToggleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount: async (id: string, accountToggleRequest: AccountToggleRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enableAccount', 'id', id)
            // verify required parameter 'accountToggleRequest' is not null or undefined
            assertParamExists('enableAccount', 'accountToggleRequest', accountToggleRequest)
            const localVarPath = `/accounts/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountToggleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to return the details for a single account by its ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Account Details
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements: async (id: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountEntitlements', 'id', id)
            const localVarPath = `/accounts/{id}/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, sw*  **identityId**: *eq, in, sw*  **name**: *eq, in, sw*  **nativeIdentity**: *eq, in, sw*  **sourceId**: *eq, in, sw*  **uncorrelated**: *eq*  **entitlements**: *eq*  **origin**: *eq, in*  **manuallyCorrelated**: *eq*  **identity.name**: *eq, in, sw*  **identity.correlated**: *eq*  **identity.identityState**: *eq, in*  **source.displayableName**: *eq, in*  **source.authoritative**: *eq*  **source.connectionType**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, sourceId, identityId, identity.id, nativeIdentity, uuid, manuallyCorrelated, entitlements, origin, identity.name, identity.identityState, identity.correlated, source.displayableName, source.authoritative, source.connectionType**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update an account with a PUT request.  This endpoint submits an account update task and returns the task ID.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**NOTE: You can only use this PUT endpoint to update accounts from sources of the \"DelimitedFile\" type.**
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {AccountAttributes} accountAttributes 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount: async (id: string, accountAttributes: AccountAttributes, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putAccount', 'id', id)
            // verify required parameter 'accountAttributes' is not null or undefined
            assertParamExists('putAccount', 'accountAttributes', accountAttributes)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAttributes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReloadAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitReloadAccount', 'id', id)
            const localVarPath = `/accounts/{id}/reload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   To use this endpoint to unlock an account that has the `forceProvisioning` option set to true, the `idn:accounts-provisioning:manage` scope is required.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account ID.
         * @param {AccountUnlockRequest} accountUnlockRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount: async (id: string, accountUnlockRequest: AccountUnlockRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlockAccount', 'id', id)
            // verify required parameter 'accountUnlockRequest' is not null or undefined
            assertParamExists('unlockAccount', 'accountUnlockRequest', accountUnlockRequest)
            const localVarPath = `/accounts/{id}/unlock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUnlockRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates account details. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. This endpoint supports updating an account\'s correlation. The identityId and manuallyCorrelated fields can be modified for any account. The attributes fields can be modified just for flat file accounts.  To re-assign an account from one identity to another, replace the current identityId with a new value.  If the account you\'re assigning was provisioned by IdentityNow, it\'s possible IdentityNow could create a new account  for the previous identity as soon as the account is moved. If the account you\'re assigning is authoritative,  this will cause the previous identity to become uncorrelated and could even result in its deletion. All accounts that are reassigned will be set to manuallyCorrelated: true unless otherwise specified
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAccount', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateAccount', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API submits an account creation task and returns the task ID.   You must include the `sourceId` where the account will be created in the `attributes` object. This endpoint creates an account on the source record in your ISC tenant. This is useful for Flat File (`DelimitedFile`) type sources because it allows you to aggregate new accounts without needing to import a new CSV file every time.  However, if you use this endpoint to create an account for a Direct Connection type source, you must ensure that the account also exists on the target source.  The endpoint doesn\'t actually provision the account on the target source, which means that if the account doesn\'t also exist on the target source, an aggregation between the source and your tenant will remove it from your tenant.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(accountAttributesCreate: AccountAttributesCreate, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(accountAttributesCreate, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to delete an account.  This endpoint submits an account delete task and returns the task ID.  This endpoint only deletes the account from IdentityNow, not the source itself, which can result in the account\'s returning with the next aggregation between the source and IdentityNow.  To avoid this scenario, it is recommended that you [disable accounts](https://developer.sailpoint.com/idn/api/v3/disable-account) rather than delete them. This will also allow you to reenable the accounts in the future.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**NOTE: You can only delete accounts from sources of the \"DelimitedFile\" type.**
         * @summary Delete Account
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async disableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableAccount(id, accountToggleRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async enableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableAccount(id, accountToggleRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to return the details for a single account by its ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Account Details
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountEntitlements(id: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntitlementDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountEntitlements(id, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, sw*  **identityId**: *eq, in, sw*  **name**: *eq, in, sw*  **nativeIdentity**: *eq, in, sw*  **sourceId**: *eq, in, sw*  **uncorrelated**: *eq*  **entitlements**: *eq*  **origin**: *eq, in*  **manuallyCorrelated**: *eq*  **identity.name**: *eq, in, sw*  **identity.correlated**: *eq*  **identity.identityState**: *eq, in*  **source.displayableName**: *eq, in*  **source.authoritative**: *eq*  **source.connectionType**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, sourceId, identityId, identity.id, nativeIdentity, uuid, manuallyCorrelated, entitlements, origin, identity.name, identity.identityState, identity.correlated, source.displayableName, source.authoritative, source.connectionType**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to update an account with a PUT request.  This endpoint submits an account update task and returns the task ID.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**NOTE: You can only use this PUT endpoint to update accounts from sources of the \"DelimitedFile\" type.**
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {AccountAttributes} accountAttributes 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putAccount(id: string, accountAttributes: AccountAttributes, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAccount(id, accountAttributes, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async submitReloadAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitReloadAccount(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   To use this endpoint to unlock an account that has the `forceProvisioning` option set to true, the `idn:accounts-provisioning:manage` scope is required.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account ID.
         * @param {AccountUnlockRequest} accountUnlockRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async unlockAccount(id: string, accountUnlockRequest: AccountUnlockRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockAccount(id, accountUnlockRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates account details. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. This endpoint supports updating an account\'s correlation. The identityId and manuallyCorrelated fields can be modified for any account. The attributes fields can be modified just for flat file accounts.  To re-assign an account from one identity to another, replace the current identityId with a new value.  If the account you\'re assigning was provisioned by IdentityNow, it\'s possible IdentityNow could create a new account  for the previous identity as soon as the account is moved. If the account you\'re assigning is authoritative,  this will cause the previous identity to become uncorrelated and could even result in its deletion. All accounts that are reassigned will be set to manuallyCorrelated: true unless otherwise specified
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * This API submits an account creation task and returns the task ID.   You must include the `sourceId` where the account will be created in the `attributes` object. This endpoint creates an account on the source record in your ISC tenant. This is useful for Flat File (`DelimitedFile`) type sources because it allows you to aggregate new accounts without needing to import a new CSV file every time.  However, if you use this endpoint to create an account for a Direct Connection type source, you must ensure that the account also exists on the target source.  The endpoint doesn\'t actually provision the account on the target source, which means that if the account doesn\'t also exist on the target source, an aggregation between the source and your tenant will remove it from your tenant.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(accountAttributesCreate: AccountAttributesCreate, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.createAccount(accountAttributesCreate, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to delete an account.  This endpoint submits an account delete task and returns the task ID.  This endpoint only deletes the account from IdentityNow, not the source itself, which can result in the account\'s returning with the next aggregation between the source and IdentityNow.  To avoid this scenario, it is recommended that you [disable accounts](https://developer.sailpoint.com/idn/api/v3/disable-account) rather than delete them. This will also allow you to reenable the accounts in the future.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**NOTE: You can only delete accounts from sources of the \"DelimitedFile\" type.**
         * @summary Delete Account
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(id: string, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.deleteAccount(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.disableAccount(id, accountToggleRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.enableAccount(id, accountToggleRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to return the details for a single account by its ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Account Details
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: string, axiosOptions?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements(id: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<EntitlementDto>> {
            return localVarFp.getAccountEntitlements(id, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, sw*  **identityId**: *eq, in, sw*  **name**: *eq, in, sw*  **nativeIdentity**: *eq, in, sw*  **sourceId**: *eq, in, sw*  **uncorrelated**: *eq*  **entitlements**: *eq*  **origin**: *eq, in*  **manuallyCorrelated**: *eq*  **identity.name**: *eq, in, sw*  **identity.correlated**: *eq*  **identity.identityState**: *eq, in*  **source.displayableName**: *eq, in*  **source.authoritative**: *eq*  **source.connectionType**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, sourceId, identityId, identity.id, nativeIdentity, uuid, manuallyCorrelated, entitlements, origin, identity.name, identity.identityState, identity.correlated, source.displayableName, source.authoritative, source.connectionType**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<Account>> {
            return localVarFp.listAccounts(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to update an account with a PUT request.  This endpoint submits an account update task and returns the task ID.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**NOTE: You can only use this PUT endpoint to update accounts from sources of the \"DelimitedFile\" type.**
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {AccountAttributes} accountAttributes 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount(id: string, accountAttributes: AccountAttributes, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.putAccount(id, accountAttributes, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReloadAccount(id: string, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.submitReloadAccount(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   To use this endpoint to unlock an account that has the `forceProvisioning` option set to true, the `idn:accounts-provisioning:manage` scope is required.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account ID.
         * @param {AccountUnlockRequest} accountUnlockRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount(id: string, accountUnlockRequest: AccountUnlockRequest, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.unlockAccount(id, accountUnlockRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates account details. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. This endpoint supports updating an account\'s correlation. The identityId and manuallyCorrelated fields can be modified for any account. The attributes fields can be modified just for flat file accounts.  To re-assign an account from one identity to another, replace the current identityId with a new value.  If the account you\'re assigning was provisioned by IdentityNow, it\'s possible IdentityNow could create a new account  for the previous identity as soon as the account is moved. If the account you\'re assigning is authoritative,  this will cause the previous identity to become uncorrelated and could even result in its deletion. All accounts that are reassigned will be set to manuallyCorrelated: true unless otherwise specified
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.updateAccount(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiCreateAccountRequest
 */
export interface AccountsApiCreateAccountRequest {
    /**
     * 
     * @type {AccountAttributesCreate}
     * @memberof AccountsApiCreateAccount
     */
    readonly accountAttributesCreate: AccountAttributesCreate
}

/**
 * Request parameters for deleteAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDeleteAccountRequest
 */
export interface AccountsApiDeleteAccountRequest {
    /**
     * Account ID.
     * @type {string}
     * @memberof AccountsApiDeleteAccount
     */
    readonly id: string
}

/**
 * Request parameters for disableAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDisableAccountRequest
 */
export interface AccountsApiDisableAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiDisableAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountToggleRequest}
     * @memberof AccountsApiDisableAccount
     */
    readonly accountToggleRequest: AccountToggleRequest
}

/**
 * Request parameters for enableAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiEnableAccountRequest
 */
export interface AccountsApiEnableAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiEnableAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountToggleRequest}
     * @memberof AccountsApiEnableAccount
     */
    readonly accountToggleRequest: AccountToggleRequest
}

/**
 * Request parameters for getAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountRequest
 */
export interface AccountsApiGetAccountRequest {
    /**
     * Account ID.
     * @type {string}
     * @memberof AccountsApiGetAccount
     */
    readonly id: string
}

/**
 * Request parameters for getAccountEntitlements operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountEntitlementsRequest
 */
export interface AccountsApiGetAccountEntitlementsRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly count?: boolean
}

/**
 * Request parameters for listAccounts operation in AccountsApi.
 * @export
 * @interface AccountsApiListAccountsRequest
 */
export interface AccountsApiListAccountsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiListAccounts
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiListAccounts
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountsApiListAccounts
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, sw*  **identityId**: *eq, in, sw*  **name**: *eq, in, sw*  **nativeIdentity**: *eq, in, sw*  **sourceId**: *eq, in, sw*  **uncorrelated**: *eq*  **entitlements**: *eq*  **origin**: *eq, in*  **manuallyCorrelated**: *eq*  **identity.name**: *eq, in, sw*  **identity.correlated**: *eq*  **identity.identityState**: *eq, in*  **source.displayableName**: *eq, in*  **source.authoritative**: *eq*  **source.connectionType**: *eq, in*
     * @type {string}
     * @memberof AccountsApiListAccounts
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, sourceId, identityId, identity.id, nativeIdentity, uuid, manuallyCorrelated, entitlements, origin, identity.name, identity.identityState, identity.correlated, source.displayableName, source.authoritative, source.connectionType**
     * @type {string}
     * @memberof AccountsApiListAccounts
     */
    readonly sorters?: string
}

/**
 * Request parameters for putAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiPutAccountRequest
 */
export interface AccountsApiPutAccountRequest {
    /**
     * Account ID.
     * @type {string}
     * @memberof AccountsApiPutAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountAttributes}
     * @memberof AccountsApiPutAccount
     */
    readonly accountAttributes: AccountAttributes
}

/**
 * Request parameters for submitReloadAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiSubmitReloadAccountRequest
 */
export interface AccountsApiSubmitReloadAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiSubmitReloadAccount
     */
    readonly id: string
}

/**
 * Request parameters for unlockAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiUnlockAccountRequest
 */
export interface AccountsApiUnlockAccountRequest {
    /**
     * The account ID.
     * @type {string}
     * @memberof AccountsApiUnlockAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountUnlockRequest}
     * @memberof AccountsApiUnlockAccount
     */
    readonly accountUnlockRequest: AccountUnlockRequest
}

/**
 * Request parameters for updateAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiUpdateAccountRequest
 */
export interface AccountsApiUpdateAccountRequest {
    /**
     * Account ID.
     * @type {string}
     * @memberof AccountsApiUpdateAccount
     */
    readonly id: string

    /**
     * A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperation>}
     * @memberof AccountsApiUpdateAccount
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * This API submits an account creation task and returns the task ID.   You must include the `sourceId` where the account will be created in the `attributes` object. This endpoint creates an account on the source record in your ISC tenant. This is useful for Flat File (`DelimitedFile`) type sources because it allows you to aggregate new accounts without needing to import a new CSV file every time.  However, if you use this endpoint to create an account for a Direct Connection type source, you must ensure that the account also exists on the target source.  The endpoint doesn\'t actually provision the account on the target source, which means that if the account doesn\'t also exist on the target source, an aggregation between the source and your tenant will remove it from your tenant.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Create Account
     * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(requestParameters: AccountsApiCreateAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(requestParameters.accountAttributesCreate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to delete an account.  This endpoint submits an account delete task and returns the task ID.  This endpoint only deletes the account from IdentityNow, not the source itself, which can result in the account\'s returning with the next aggregation between the source and IdentityNow.  To avoid this scenario, it is recommended that you [disable accounts](https://developer.sailpoint.com/idn/api/v3/disable-account) rather than delete them. This will also allow you to reenable the accounts in the future.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**NOTE: You can only delete accounts from sources of the \"DelimitedFile\" type.**
     * @summary Delete Account
     * @param {AccountsApiDeleteAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(requestParameters: AccountsApiDeleteAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Disable Account
     * @param {AccountsApiDisableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public disableAccount(requestParameters: AccountsApiDisableAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).disableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Enable Account
     * @param {AccountsApiEnableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public enableAccount(requestParameters: AccountsApiEnableAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).enableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to return the details for a single account by its ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Account Details
     * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(requestParameters: AccountsApiGetAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns entitlements of the account.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Account Entitlements
     * @param {AccountsApiGetAccountEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountEntitlements(requestParameters: AccountsApiGetAccountEntitlementsRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a list of accounts.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Accounts List
     * @param {AccountsApiListAccountsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccounts(requestParameters: AccountsApiListAccountsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccounts(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to update an account with a PUT request.  This endpoint submits an account update task and returns the task ID.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**NOTE: You can only use this PUT endpoint to update accounts from sources of the \"DelimitedFile\" type.**
     * @summary Update Account
     * @param {AccountsApiPutAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public putAccount(requestParameters: AccountsApiPutAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).putAccount(requestParameters.id, requestParameters.accountAttributes, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Reload Account
     * @param {AccountsApiSubmitReloadAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public submitReloadAccount(requestParameters: AccountsApiSubmitReloadAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).submitReloadAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to unlock an account and returns the task ID.   To use this endpoint to unlock an account that has the `forceProvisioning` option set to true, the `idn:accounts-provisioning:manage` scope is required.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Unlock Account
     * @param {AccountsApiUnlockAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public unlockAccount(requestParameters: AccountsApiUnlockAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).unlockAccount(requestParameters.id, requestParameters.accountUnlockRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates account details. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. This endpoint supports updating an account\'s correlation. The identityId and manuallyCorrelated fields can be modified for any account. The attributes fields can be modified just for flat file accounts.  To re-assign an account from one identity to another, replace the current identityId with a new value.  If the account you\'re assigning was provisioned by IdentityNow, it\'s possible IdentityNow could create a new account  for the previous identity as soon as the account is moved. If the account you\'re assigning is authoritative,  this will cause the previous identity to become uncorrelated and could even result in its deletion. All accounts that are reassigned will be set to manuallyCorrelated: true unless otherwise specified
     * @summary Update Account
     * @param {AccountsApiUpdateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(requestParameters: AccountsApiUpdateAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthUsersApi - axios parameter creator
 * @export
 */
export const AuthUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the specified user\'s authentication system details.
         * @summary Auth User Details
         * @param {string} id Identity ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthUser: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAuthUser', 'id', id)
            const localVarPath = `/auth-users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use a PATCH request to update an existing user in the authentication system. Use this endpoint to modify these fields:    * `capabilities`  A \'400.1.1 Illegal update attempt\' detail code indicates that you attempted to PATCH a field that is not allowed.
         * @summary Auth User Update
         * @param {string} id Identity ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth user update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthUser: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchAuthUser', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchAuthUser', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/auth-users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthUsersApi - functional programming interface
 * @export
 */
export const AuthUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Return the specified user\'s authentication system details.
         * @summary Auth User Details
         * @param {string} id Identity ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthUser(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthUser(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use a PATCH request to update an existing user in the authentication system. Use this endpoint to modify these fields:    * `capabilities`  A \'400.1.1 Illegal update attempt\' detail code indicates that you attempted to PATCH a field that is not allowed.
         * @summary Auth User Update
         * @param {string} id Identity ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth user update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAuthUser(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAuthUser(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthUsersApi - factory interface
 * @export
 */
export const AuthUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthUsersApiFp(configuration)
    return {
        /**
         * Return the specified user\'s authentication system details.
         * @summary Auth User Details
         * @param {string} id Identity ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthUser(id: string, axiosOptions?: any): AxiosPromise<AuthUser> {
            return localVarFp.getAuthUser(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use a PATCH request to update an existing user in the authentication system. Use this endpoint to modify these fields:    * `capabilities`  A \'400.1.1 Illegal update attempt\' detail code indicates that you attempted to PATCH a field that is not allowed.
         * @summary Auth User Update
         * @param {string} id Identity ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth user update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthUser(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<AuthUser> {
            return localVarFp.patchAuthUser(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAuthUser operation in AuthUsersApi.
 * @export
 * @interface AuthUsersApiGetAuthUserRequest
 */
export interface AuthUsersApiGetAuthUserRequest {
    /**
     * Identity ID
     * @type {string}
     * @memberof AuthUsersApiGetAuthUser
     */
    readonly id: string
}

/**
 * Request parameters for patchAuthUser operation in AuthUsersApi.
 * @export
 * @interface AuthUsersApiPatchAuthUserRequest
 */
export interface AuthUsersApiPatchAuthUserRequest {
    /**
     * Identity ID
     * @type {string}
     * @memberof AuthUsersApiPatchAuthUser
     */
    readonly id: string

    /**
     * A list of auth user update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperation>}
     * @memberof AuthUsersApiPatchAuthUser
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * AuthUsersApi - object-oriented interface
 * @export
 * @class AuthUsersApi
 * @extends {BaseAPI}
 */
export class AuthUsersApi extends BaseAPI {
    /**
     * Return the specified user\'s authentication system details.
     * @summary Auth User Details
     * @param {AuthUsersApiGetAuthUserRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthUsersApi
     */
    public getAuthUser(requestParameters: AuthUsersApiGetAuthUserRequest, axiosOptions?: AxiosRequestConfig) {
        return AuthUsersApiFp(this.configuration).getAuthUser(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use a PATCH request to update an existing user in the authentication system. Use this endpoint to modify these fields:    * `capabilities`  A \'400.1.1 Illegal update attempt\' detail code indicates that you attempted to PATCH a field that is not allowed.
     * @summary Auth User Update
     * @param {AuthUsersApiPatchAuthUserRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthUsersApi
     */
    public patchAuthUser(requestParameters: AuthUsersApiPatchAuthUserRequest, axiosOptions?: AxiosRequestConfig) {
        return AuthUsersApiFp(this.configuration).patchAuthUser(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BrandingApi - axios parameter creator
 * @export
 */
export const BrandingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API endpoint creates a branding item. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Create a branding item
         * @param {string} name name of branding item
         * @param {string} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {any} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createBrandingItem: async (name: string, productName: string, actionButtonColor?: string, activeLinkColor?: string, navigationColor?: string, emailFromAddress?: string, loginInformationalMessage?: string, fileStandard?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createBrandingItem', 'name', name)
            // verify required parameter 'productName' is not null or undefined
            assertParamExists('createBrandingItem', 'productName', productName)
            const localVarPath = `/brandings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (productName !== undefined) { 
                localVarFormParams.append('productName', productName as any);
            }
    
            if (actionButtonColor !== undefined) { 
                localVarFormParams.append('actionButtonColor', actionButtonColor as any);
            }
    
            if (activeLinkColor !== undefined) { 
                localVarFormParams.append('activeLinkColor', activeLinkColor as any);
            }
    
            if (navigationColor !== undefined) { 
                localVarFormParams.append('navigationColor', navigationColor as any);
            }
    
            if (emailFromAddress !== undefined) { 
                localVarFormParams.append('emailFromAddress', emailFromAddress as any);
            }
    
            if (loginInformationalMessage !== undefined) { 
                localVarFormParams.append('loginInformationalMessage', loginInformationalMessage as any);
            }
    
            if (fileStandard !== undefined) { 
                localVarFormParams.append('fileStandard', fileStandard as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint delete information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Delete a branding item
         * @param {string} name The name of the branding item to be deleted
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranding: async (name: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteBranding', 'name', name)
            const localVarPath = `/brandings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint retrieves information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Get a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBranding: async (name: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getBranding', 'name', name)
            const localVarPath = `/brandings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns a list of branding items.  A token with API, ORG_ADMIN authority is required to call this API.
         * @summary List of branding items
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingList: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/brandings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint updates information for an existing branding item. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Update a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {string} name2 name of branding item
         * @param {string} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {any} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setBrandingItem: async (name: string, name2: string, productName: string, actionButtonColor?: string, activeLinkColor?: string, navigationColor?: string, emailFromAddress?: string, loginInformationalMessage?: string, fileStandard?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('setBrandingItem', 'name', name)
            // verify required parameter 'name2' is not null or undefined
            assertParamExists('setBrandingItem', 'name2', name2)
            // verify required parameter 'productName' is not null or undefined
            assertParamExists('setBrandingItem', 'productName', productName)
            const localVarPath = `/brandings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (name2 !== undefined) { 
                localVarFormParams.append('name', name2 as any);
            }
    
            if (productName !== undefined) { 
                localVarFormParams.append('productName', productName as any);
            }
    
            if (actionButtonColor !== undefined) { 
                localVarFormParams.append('actionButtonColor', actionButtonColor as any);
            }
    
            if (activeLinkColor !== undefined) { 
                localVarFormParams.append('activeLinkColor', activeLinkColor as any);
            }
    
            if (navigationColor !== undefined) { 
                localVarFormParams.append('navigationColor', navigationColor as any);
            }
    
            if (emailFromAddress !== undefined) { 
                localVarFormParams.append('emailFromAddress', emailFromAddress as any);
            }
    
            if (loginInformationalMessage !== undefined) { 
                localVarFormParams.append('loginInformationalMessage', loginInformationalMessage as any);
            }
    
            if (fileStandard !== undefined) { 
                localVarFormParams.append('fileStandard', fileStandard as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrandingApi - functional programming interface
 * @export
 */
export const BrandingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrandingApiAxiosParamCreator(configuration)
    return {
        /**
         * This API endpoint creates a branding item. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Create a branding item
         * @param {string} name name of branding item
         * @param {string} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {any} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createBrandingItem(name: string, productName: string, actionButtonColor?: string, activeLinkColor?: string, navigationColor?: string, emailFromAddress?: string, loginInformationalMessage?: string, fileStandard?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandingItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBrandingItem(name, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API endpoint delete information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Delete a branding item
         * @param {string} name The name of the branding item to be deleted
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBranding(name: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBranding(name, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API endpoint retrieves information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Get a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getBranding(name: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandingItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranding(name, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API endpoint returns a list of branding items.  A token with API, ORG_ADMIN authority is required to call this API.
         * @summary List of branding items
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getBrandingList(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BrandingItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBrandingList(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API endpoint updates information for an existing branding item. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Update a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {string} name2 name of branding item
         * @param {string} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {any} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setBrandingItem(name: string, name2: string, productName: string, actionButtonColor?: string, activeLinkColor?: string, navigationColor?: string, emailFromAddress?: string, loginInformationalMessage?: string, fileStandard?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandingItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBrandingItem(name, name2, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BrandingApi - factory interface
 * @export
 */
export const BrandingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrandingApiFp(configuration)
    return {
        /**
         * This API endpoint creates a branding item. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Create a branding item
         * @param {string} name name of branding item
         * @param {string} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {any} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createBrandingItem(name: string, productName: string, actionButtonColor?: string, activeLinkColor?: string, navigationColor?: string, emailFromAddress?: string, loginInformationalMessage?: string, fileStandard?: any, axiosOptions?: any): AxiosPromise<BrandingItem> {
            return localVarFp.createBrandingItem(name, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint delete information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Delete a branding item
         * @param {string} name The name of the branding item to be deleted
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranding(name: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteBranding(name, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint retrieves information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Get a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBranding(name: string, axiosOptions?: any): AxiosPromise<BrandingItem> {
            return localVarFp.getBranding(name, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns a list of branding items.  A token with API, ORG_ADMIN authority is required to call this API.
         * @summary List of branding items
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingList(axiosOptions?: any): AxiosPromise<Array<BrandingItem>> {
            return localVarFp.getBrandingList(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint updates information for an existing branding item. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Update a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {string} name2 name of branding item
         * @param {string} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {any} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setBrandingItem(name: string, name2: string, productName: string, actionButtonColor?: string, activeLinkColor?: string, navigationColor?: string, emailFromAddress?: string, loginInformationalMessage?: string, fileStandard?: any, axiosOptions?: any): AxiosPromise<BrandingItem> {
            return localVarFp.setBrandingItem(name, name2, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createBrandingItem operation in BrandingApi.
 * @export
 * @interface BrandingApiCreateBrandingItemRequest
 */
export interface BrandingApiCreateBrandingItemRequest {
    /**
     * name of branding item
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly name: string

    /**
     * product name
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly productName: string

    /**
     * hex value of color for action button
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly actionButtonColor?: string

    /**
     * hex value of color for link
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly activeLinkColor?: string

    /**
     * hex value of color for navigation bar
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly navigationColor?: string

    /**
     * email from address
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly emailFromAddress?: string

    /**
     * login information message
     * @type {string}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly loginInformationalMessage?: string

    /**
     * png file with logo
     * @type {any}
     * @memberof BrandingApiCreateBrandingItem
     */
    readonly fileStandard?: any
}

/**
 * Request parameters for deleteBranding operation in BrandingApi.
 * @export
 * @interface BrandingApiDeleteBrandingRequest
 */
export interface BrandingApiDeleteBrandingRequest {
    /**
     * The name of the branding item to be deleted
     * @type {string}
     * @memberof BrandingApiDeleteBranding
     */
    readonly name: string
}

/**
 * Request parameters for getBranding operation in BrandingApi.
 * @export
 * @interface BrandingApiGetBrandingRequest
 */
export interface BrandingApiGetBrandingRequest {
    /**
     * The name of the branding item to be retrieved
     * @type {string}
     * @memberof BrandingApiGetBranding
     */
    readonly name: string
}

/**
 * Request parameters for setBrandingItem operation in BrandingApi.
 * @export
 * @interface BrandingApiSetBrandingItemRequest
 */
export interface BrandingApiSetBrandingItemRequest {
    /**
     * The name of the branding item to be retrieved
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly name: string

    /**
     * name of branding item
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly name2: string

    /**
     * product name
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly productName: string

    /**
     * hex value of color for action button
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly actionButtonColor?: string

    /**
     * hex value of color for link
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly activeLinkColor?: string

    /**
     * hex value of color for navigation bar
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly navigationColor?: string

    /**
     * email from address
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly emailFromAddress?: string

    /**
     * login information message
     * @type {string}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly loginInformationalMessage?: string

    /**
     * png file with logo
     * @type {any}
     * @memberof BrandingApiSetBrandingItem
     */
    readonly fileStandard?: any
}

/**
 * BrandingApi - object-oriented interface
 * @export
 * @class BrandingApi
 * @extends {BaseAPI}
 */
export class BrandingApi extends BaseAPI {
    /**
     * This API endpoint creates a branding item. A token with API, ORG_ADMIN authority is required to call this API.
     * @summary Create a branding item
     * @param {BrandingApiCreateBrandingItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public createBrandingItem(requestParameters: BrandingApiCreateBrandingItemRequest, axiosOptions?: AxiosRequestConfig) {
        return BrandingApiFp(this.configuration).createBrandingItem(requestParameters.name, requestParameters.productName, requestParameters.actionButtonColor, requestParameters.activeLinkColor, requestParameters.navigationColor, requestParameters.emailFromAddress, requestParameters.loginInformationalMessage, requestParameters.fileStandard, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint delete information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
     * @summary Delete a branding item
     * @param {BrandingApiDeleteBrandingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public deleteBranding(requestParameters: BrandingApiDeleteBrandingRequest, axiosOptions?: AxiosRequestConfig) {
        return BrandingApiFp(this.configuration).deleteBranding(requestParameters.name, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint retrieves information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
     * @summary Get a branding item
     * @param {BrandingApiGetBrandingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public getBranding(requestParameters: BrandingApiGetBrandingRequest, axiosOptions?: AxiosRequestConfig) {
        return BrandingApiFp(this.configuration).getBranding(requestParameters.name, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns a list of branding items.  A token with API, ORG_ADMIN authority is required to call this API.
     * @summary List of branding items
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public getBrandingList(axiosOptions?: AxiosRequestConfig) {
        return BrandingApiFp(this.configuration).getBrandingList(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint updates information for an existing branding item. A token with API, ORG_ADMIN authority is required to call this API.
     * @summary Update a branding item
     * @param {BrandingApiSetBrandingItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public setBrandingItem(requestParameters: BrandingApiSetBrandingItemRequest, axiosOptions?: AxiosRequestConfig) {
        return BrandingApiFp(this.configuration).setBrandingItem(requestParameters.name, requestParameters.name2, requestParameters.productName, requestParameters.actionButtonColor, requestParameters.activeLinkColor, requestParameters.navigationColor, requestParameters.emailFromAddress, requestParameters.loginInformationalMessage, requestParameters.fileStandard, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificationCampaignFiltersApi - axios parameter creator
 * @export
 */
export const CertificationCampaignFiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a campaign Filter based on filter details and criteria.
         * @summary Create a Campaign Filter
         * @param {CampaignFilterDetails} campaignFilterDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignFilter: async (campaignFilterDetails: CampaignFilterDetails, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignFilterDetails' is not null or undefined
            assertParamExists('createCampaignFilter', 'campaignFilterDetails', campaignFilterDetails)
            const localVarPath = `/campaign-filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignFilterDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaign Filters
         * @param {Array<string>} requestBody A json list of IDs of campaign filters to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignFilters: async (requestBody: Array<string>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('deleteCampaignFilters', 'requestBody', requestBody)
            const localVarPath = `/campaign-filters/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information for an existing campaign filter using the filter\'s ID.
         * @summary Get Campaign Filter by ID
         * @param {string} filterId The ID of the campaign filter to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignFilterById: async (filterId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterId' is not null or undefined
            assertParamExists('getCampaignFilterById', 'filterId', filterId)
            const localVarPath = `/campaign-filters/{id}`
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Lists all Campaign Filters. Scope can be reduced via standard V3 query params.  All Campaign Filters matching the query params
         * @summary List Campaign Filters
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [start] Start/Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [includeSystemFilters] If true, include system filters in the count and results, exclude them otherwise. If not provided any value for it then by default it is true.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCampaignFilters: async (limit?: number, start?: number, includeSystemFilters?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaign-filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (includeSystemFilters !== undefined) {
                localVarQueryParameter['includeSystemFilters'] = includeSystemFilters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing campaign filter using the filter\'s ID.
         * @summary Updates a Campaign Filter
         * @param {string} filterId The ID of the campaign filter being modified.
         * @param {CampaignFilterDetails} campaignFilterDetails A campaign filter details with updated field values.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaignFilter: async (filterId: string, campaignFilterDetails: CampaignFilterDetails, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterId' is not null or undefined
            assertParamExists('updateCampaignFilter', 'filterId', filterId)
            // verify required parameter 'campaignFilterDetails' is not null or undefined
            assertParamExists('updateCampaignFilter', 'campaignFilterDetails', campaignFilterDetails)
            const localVarPath = `/campaign-filters/{id}`
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignFilterDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationCampaignFiltersApi - functional programming interface
 * @export
 */
export const CertificationCampaignFiltersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationCampaignFiltersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a campaign Filter based on filter details and criteria.
         * @summary Create a Campaign Filter
         * @param {CampaignFilterDetails} campaignFilterDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaignFilter(campaignFilterDetails: CampaignFilterDetails, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignFilterDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaignFilter(campaignFilterDetails, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaign Filters
         * @param {Array<string>} requestBody A json list of IDs of campaign filters to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaignFilters(requestBody: Array<string>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaignFilters(requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves information for an existing campaign filter using the filter\'s ID.
         * @summary Get Campaign Filter by ID
         * @param {string} filterId The ID of the campaign filter to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignFilterById(filterId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignFilterDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignFilterById(filterId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all Campaign Filters. Scope can be reduced via standard V3 query params.  All Campaign Filters matching the query params
         * @summary List Campaign Filters
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [start] Start/Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [includeSystemFilters] If true, include system filters in the count and results, exclude them otherwise. If not provided any value for it then by default it is true.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCampaignFilters(limit?: number, start?: number, includeSystemFilters?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCampaignFilters200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCampaignFilters(limit, start, includeSystemFilters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing campaign filter using the filter\'s ID.
         * @summary Updates a Campaign Filter
         * @param {string} filterId The ID of the campaign filter being modified.
         * @param {CampaignFilterDetails} campaignFilterDetails A campaign filter details with updated field values.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateCampaignFilter(filterId: string, campaignFilterDetails: CampaignFilterDetails, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignFilterDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCampaignFilter(filterId, campaignFilterDetails, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificationCampaignFiltersApi - factory interface
 * @export
 */
export const CertificationCampaignFiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationCampaignFiltersApiFp(configuration)
    return {
        /**
         * Create a campaign Filter based on filter details and criteria.
         * @summary Create a Campaign Filter
         * @param {CampaignFilterDetails} campaignFilterDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignFilter(campaignFilterDetails: CampaignFilterDetails, axiosOptions?: any): AxiosPromise<CampaignFilterDetails> {
            return localVarFp.createCampaignFilter(campaignFilterDetails, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaign Filters
         * @param {Array<string>} requestBody A json list of IDs of campaign filters to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignFilters(requestBody: Array<string>, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteCampaignFilters(requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves information for an existing campaign filter using the filter\'s ID.
         * @summary Get Campaign Filter by ID
         * @param {string} filterId The ID of the campaign filter to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignFilterById(filterId: string, axiosOptions?: any): AxiosPromise<Array<CampaignFilterDetails>> {
            return localVarFp.getCampaignFilterById(filterId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Lists all Campaign Filters. Scope can be reduced via standard V3 query params.  All Campaign Filters matching the query params
         * @summary List Campaign Filters
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [start] Start/Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [includeSystemFilters] If true, include system filters in the count and results, exclude them otherwise. If not provided any value for it then by default it is true.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCampaignFilters(limit?: number, start?: number, includeSystemFilters?: boolean, axiosOptions?: any): AxiosPromise<ListCampaignFilters200Response> {
            return localVarFp.listCampaignFilters(limit, start, includeSystemFilters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing campaign filter using the filter\'s ID.
         * @summary Updates a Campaign Filter
         * @param {string} filterId The ID of the campaign filter being modified.
         * @param {CampaignFilterDetails} campaignFilterDetails A campaign filter details with updated field values.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaignFilter(filterId: string, campaignFilterDetails: CampaignFilterDetails, axiosOptions?: any): AxiosPromise<CampaignFilterDetails> {
            return localVarFp.updateCampaignFilter(filterId, campaignFilterDetails, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCampaignFilter operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiCreateCampaignFilterRequest
 */
export interface CertificationCampaignFiltersApiCreateCampaignFilterRequest {
    /**
     * 
     * @type {CampaignFilterDetails}
     * @memberof CertificationCampaignFiltersApiCreateCampaignFilter
     */
    readonly campaignFilterDetails: CampaignFilterDetails
}

/**
 * Request parameters for deleteCampaignFilters operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiDeleteCampaignFiltersRequest
 */
export interface CertificationCampaignFiltersApiDeleteCampaignFiltersRequest {
    /**
     * A json list of IDs of campaign filters to delete.
     * @type {Array<string>}
     * @memberof CertificationCampaignFiltersApiDeleteCampaignFilters
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for getCampaignFilterById operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiGetCampaignFilterByIdRequest
 */
export interface CertificationCampaignFiltersApiGetCampaignFilterByIdRequest {
    /**
     * The ID of the campaign filter to be retrieved.
     * @type {string}
     * @memberof CertificationCampaignFiltersApiGetCampaignFilterById
     */
    readonly filterId: string
}

/**
 * Request parameters for listCampaignFilters operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiListCampaignFiltersRequest
 */
export interface CertificationCampaignFiltersApiListCampaignFiltersRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignFiltersApiListCampaignFilters
     */
    readonly limit?: number

    /**
     * Start/Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignFiltersApiListCampaignFilters
     */
    readonly start?: number

    /**
     * If true, include system filters in the count and results, exclude them otherwise. If not provided any value for it then by default it is true.
     * @type {boolean}
     * @memberof CertificationCampaignFiltersApiListCampaignFilters
     */
    readonly includeSystemFilters?: boolean
}

/**
 * Request parameters for updateCampaignFilter operation in CertificationCampaignFiltersApi.
 * @export
 * @interface CertificationCampaignFiltersApiUpdateCampaignFilterRequest
 */
export interface CertificationCampaignFiltersApiUpdateCampaignFilterRequest {
    /**
     * The ID of the campaign filter being modified.
     * @type {string}
     * @memberof CertificationCampaignFiltersApiUpdateCampaignFilter
     */
    readonly filterId: string

    /**
     * A campaign filter details with updated field values.
     * @type {CampaignFilterDetails}
     * @memberof CertificationCampaignFiltersApiUpdateCampaignFilter
     */
    readonly campaignFilterDetails: CampaignFilterDetails
}

/**
 * CertificationCampaignFiltersApi - object-oriented interface
 * @export
 * @class CertificationCampaignFiltersApi
 * @extends {BaseAPI}
 */
export class CertificationCampaignFiltersApi extends BaseAPI {
    /**
     * Create a campaign Filter based on filter details and criteria.
     * @summary Create a Campaign Filter
     * @param {CertificationCampaignFiltersApiCreateCampaignFilterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public createCampaignFilter(requestParameters: CertificationCampaignFiltersApiCreateCampaignFilterRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).createCampaignFilter(requestParameters.campaignFilterDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
     * @summary Deletes Campaign Filters
     * @param {CertificationCampaignFiltersApiDeleteCampaignFiltersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public deleteCampaignFilters(requestParameters: CertificationCampaignFiltersApiDeleteCampaignFiltersRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).deleteCampaignFilters(requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves information for an existing campaign filter using the filter\'s ID.
     * @summary Get Campaign Filter by ID
     * @param {CertificationCampaignFiltersApiGetCampaignFilterByIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public getCampaignFilterById(requestParameters: CertificationCampaignFiltersApiGetCampaignFilterByIdRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).getCampaignFilterById(requestParameters.filterId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all Campaign Filters. Scope can be reduced via standard V3 query params.  All Campaign Filters matching the query params
     * @summary List Campaign Filters
     * @param {CertificationCampaignFiltersApiListCampaignFiltersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public listCampaignFilters(requestParameters: CertificationCampaignFiltersApiListCampaignFiltersRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).listCampaignFilters(requestParameters.limit, requestParameters.start, requestParameters.includeSystemFilters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing campaign filter using the filter\'s ID.
     * @summary Updates a Campaign Filter
     * @param {CertificationCampaignFiltersApiUpdateCampaignFilterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    public updateCampaignFilter(requestParameters: CertificationCampaignFiltersApiUpdateCampaignFilterRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignFiltersApiFp(this.configuration).updateCampaignFilter(requestParameters.filterId, requestParameters.campaignFilterDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificationCampaignsApi - axios parameter creator
 * @export
 */
export const CertificationCampaignsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Use this API to complete a certification campaign. This functionality is provided to admins so that they can complete a certification even if all items have not been completed.  Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN. 
         * @summary Complete a Campaign
         * @param {string} id Campaign ID.
         * @param {CampaignCompleteOptions} [campaignCompleteOptions] Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeCampaign: async (id: string, campaignCompleteOptions?: CampaignCompleteOptions, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignCompleteOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to create a certification campaign with the information provided in the request body.
         * @summary Create a campaign
         * @param {Campaign} campaign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign: async (campaign: Campaign, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaign' is not null or undefined
            assertParamExists('createCampaign', 'campaign', campaign)
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to create a certification campaign template based on campaign.
         * @summary Create a Campaign Template
         * @param {CampaignTemplate} campaignTemplate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignTemplate: async (campaignTemplate: CampaignTemplate, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignTemplate' is not null or undefined
            assertParamExists('createCampaignTemplate', 'campaignTemplate', campaignTemplate)
            const localVarPath = `/campaign-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to delete a certification campaign template by ID.
         * @summary Delete a Campaign Template
         * @param {string} id ID of the campaign template being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCampaignTemplate', 'id', id)
            const localVarPath = `/campaign-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to delete the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.
         * @summary Delete Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplateSchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCampaignTemplateSchedule', 'id', id)
            const localVarPath = `/campaign-templates/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to delete certification campaigns whose IDs are specified in the provided list of campaign IDs.  Authorized callers must be ORG_ADMINs or CERT_ADMINs.
         * @summary Delete Campaigns
         * @param {CampaignsDeleteRequest} campaignsDeleteRequest IDs of the campaigns to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaigns: async (campaignsDeleteRequest: CampaignsDeleteRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignsDeleteRequest' is not null or undefined
            assertParamExists('deleteCampaigns', 'campaignsDeleteRequest', campaignsDeleteRequest)
            const localVarPath = `/campaigns/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignsDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get a list of campaigns. This API can provide increased level of detail for each campaign for the correct provided query. 
         * @summary List Campaigns
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCampaigns: async (detail?: 'SLIM' | 'FULL', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (detail !== undefined) {
                localVarQueryParameter['detail'] = detail;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get information for an existing certification campaign by the campaign\'s ID.  Authorized callers must be reviewers for this campaign, ORG_ADMINs, or a CERT_ADMINs.
         * @summary Get Campaign
         * @param {string} id ID of the campaign to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to fetch all reports for a certification campaign by campaign ID. Calling this endpoint requires roles of CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
         * @summary Get Campaign Reports
         * @param {string} id ID of the campaign whose reports are being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReports: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignReports', 'id', id)
            const localVarPath = `/campaigns/{id}/reports`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to fetch the configuration for certification campaign reports. The configuration includes only one element - identity attributes defined as custom report columns.  Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReportsConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns/reports-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to fetch a certification campaign template by ID.
         * @summary Get a Campaign Template
         * @param {string} id Requested campaign template\&#39;s ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignTemplate', 'id', id)
            const localVarPath = `/campaign-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.
         * @summary Get Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplateSchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignTemplateSchedule', 'id', id)
            const localVarPath = `/campaign-templates/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get a list of all campaign templates. Scope can be reduced through standard V3 query params. The API returns all campaign templates matching the query parameters. 
         * @summary List Campaign Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *eq, ge, gt, in, le, lt, ne, sw*  **id**: *eq, ge, gt, in, le, lt, ne, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplates: async (limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaign-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassign} adminReviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        move: async (id: string, adminReviewReassign: AdminReviewReassign, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('move', 'id', id)
            // verify required parameter 'adminReviewReassign' is not null or undefined
            assertParamExists('move', 'adminReviewReassign', adminReviewReassign)
            const localVarPath = `/campaigns/{id}/reassign`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminReviewReassign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update individual fields on a certification campaign template, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign Template
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchCampaignTemplate: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchCampaignTemplate', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchCampaignTemplate', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/campaign-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to overwrite the configuration for campaign reports.  Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Set Campaign Reports Configuration
         * @param {CampaignReportsConfig} campaignReportsConfig Campaign report configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignReportsConfig: async (campaignReportsConfig: CampaignReportsConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignReportsConfig' is not null or undefined
            assertParamExists('setCampaignReportsConfig', 'campaignReportsConfig', campaignReportsConfig)
            const localVarPath = `/campaigns/reports-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignReportsConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to set the schedule for a certification campaign template. If a schedule already exists, the API overwrites it with the new one. 
         * @summary Set Campaign Template Schedule
         * @param {string} id ID of the campaign template being scheduled.
         * @param {Schedule} [schedule] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignTemplateSchedule: async (id: string, schedule?: Schedule, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setCampaignTemplateSchedule', 'id', id)
            const localVarPath = `/campaign-templates/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schedule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to submit a job to activate the certified campaign with the specified ID. The campaign must be staged. Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Activate a Campaign
         * @param {string} id Campaign ID.
         * @param {ActivateCampaignOptions} [activateCampaignOptions] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign: async (id: string, activateCampaignOptions?: ActivateCampaignOptions, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activateCampaignOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to run a remediation scan task for a certification campaign. Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Run Campaign Remediation Scan
         * @param {string} id ID of the campaign the remediation scan is being run for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignRemediationScan: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startCampaignRemediationScan', 'id', id)
            const localVarPath = `/campaigns/{id}/run-remediation-scan`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to run a report for a certification campaign. Calling this endpoint requires the following roles: CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
         * @summary Run Campaign Report
         * @param {string} id ID of the campaign the report is being run for.
         * @param {ReportType} type Type of the report to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignReport: async (id: string, type: ReportType, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startCampaignReport', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('startCampaignReport', 'type', type)
            const localVarPath = `/campaigns/{id}/run-report/{type}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to generate a new certification campaign from a campaign template. The campaign object contained in the template has special formatting applied to its name and description fields that determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation. Placeholders consist of a percent sign followed by a letter indicating what should be inserted. For example, \"%Y\" inserts the current year, and a campaign template named \"Campaign for %y\" generates a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020). Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). Calling this endpoint requires the ORG_ADMIN role.
         * @summary Generate a Campaign from Template
         * @param {string} id ID of the campaign template to use for generation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startGenerateCampaignTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startGenerateCampaignTemplate', 'id', id)
            const localVarPath = `/campaign-templates/{id}/generate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update individual fields on a certification campaign, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  When the campaign is in the *STAGED* status, you can patch these fields: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  When the campaign is in the *ACTIVE* status, you can patch these fields: * deadline 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCampaign', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateCampaign', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/campaigns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationCampaignsApi - functional programming interface
 * @export
 */
export const CertificationCampaignsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationCampaignsApiAxiosParamCreator(configuration)
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Use this API to complete a certification campaign. This functionality is provided to admins so that they can complete a certification even if all items have not been completed.  Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN. 
         * @summary Complete a Campaign
         * @param {string} id Campaign ID.
         * @param {CampaignCompleteOptions} [campaignCompleteOptions] Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async completeCampaign(id: string, campaignCompleteOptions?: CampaignCompleteOptions, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeCampaign(id, campaignCompleteOptions, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to create a certification campaign with the information provided in the request body.
         * @summary Create a campaign
         * @param {Campaign} campaign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaign(campaign: Campaign, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaign(campaign, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to create a certification campaign template based on campaign.
         * @summary Create a Campaign Template
         * @param {CampaignTemplate} campaignTemplate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaignTemplate(campaignTemplate: CampaignTemplate, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaignTemplate(campaignTemplate, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to delete a certification campaign template by ID.
         * @summary Delete a Campaign Template
         * @param {string} id ID of the campaign template being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaignTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaignTemplate(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to delete the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.
         * @summary Delete Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaignTemplateSchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaignTemplateSchedule(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to delete certification campaigns whose IDs are specified in the provided list of campaign IDs.  Authorized callers must be ORG_ADMINs or CERT_ADMINs.
         * @summary Delete Campaigns
         * @param {CampaignsDeleteRequest} campaignsDeleteRequest IDs of the campaigns to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaigns(campaignsDeleteRequest: CampaignsDeleteRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaigns(campaignsDeleteRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to get a list of campaigns. This API can provide increased level of detail for each campaign for the correct provided query. 
         * @summary List Campaigns
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveCampaigns(detail?: 'SLIM' | 'FULL', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetActiveCampaigns200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveCampaigns(detail, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to get information for an existing certification campaign by the campaign\'s ID.  Authorized callers must be reviewers for this campaign, ORG_ADMINs, or a CERT_ADMINs.
         * @summary Get Campaign
         * @param {string} id ID of the campaign to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaign(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlimCampaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaign(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to fetch all reports for a certification campaign by campaign ID. Calling this endpoint requires roles of CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
         * @summary Get Campaign Reports
         * @param {string} id ID of the campaign whose reports are being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignReports(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignReport>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignReports(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to fetch the configuration for certification campaign reports. The configuration includes only one element - identity attributes defined as custom report columns.  Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignReportsConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignReportsConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignReportsConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to fetch a certification campaign template by ID.
         * @summary Get a Campaign Template
         * @param {string} id Requested campaign template\&#39;s ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignTemplate(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to get the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.
         * @summary Get Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignTemplateSchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignTemplateSchedule(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to get a list of all campaign templates. Scope can be reduced through standard V3 query params. The API returns all campaign templates matching the query parameters. 
         * @summary List Campaign Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *eq, ge, gt, in, le, lt, ne, sw*  **id**: *eq, ge, gt, in, le, lt, ne, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignTemplates(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignTemplates(limit, offset, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassign} adminReviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async move(id: string, adminReviewReassign: AdminReviewReassign, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.move(id, adminReviewReassign, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to update individual fields on a certification campaign template, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign Template
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchCampaignTemplate(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCampaignTemplate(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to overwrite the configuration for campaign reports.  Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Set Campaign Reports Configuration
         * @param {CampaignReportsConfig} campaignReportsConfig Campaign report configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setCampaignReportsConfig(campaignReportsConfig: CampaignReportsConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignReportsConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCampaignReportsConfig(campaignReportsConfig, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to set the schedule for a certification campaign template. If a schedule already exists, the API overwrites it with the new one. 
         * @summary Set Campaign Template Schedule
         * @param {string} id ID of the campaign template being scheduled.
         * @param {Schedule} [schedule] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setCampaignTemplateSchedule(id: string, schedule?: Schedule, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCampaignTemplateSchedule(id, schedule, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to submit a job to activate the certified campaign with the specified ID. The campaign must be staged. Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Activate a Campaign
         * @param {string} id Campaign ID.
         * @param {ActivateCampaignOptions} [activateCampaignOptions] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startCampaign(id: string, activateCampaignOptions?: ActivateCampaignOptions, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCampaign(id, activateCampaignOptions, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to run a remediation scan task for a certification campaign. Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Run Campaign Remediation Scan
         * @param {string} id ID of the campaign the remediation scan is being run for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startCampaignRemediationScan(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCampaignRemediationScan(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to run a report for a certification campaign. Calling this endpoint requires the following roles: CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
         * @summary Run Campaign Report
         * @param {string} id ID of the campaign the report is being run for.
         * @param {ReportType} type Type of the report to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startCampaignReport(id: string, type: ReportType, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCampaignReport(id, type, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to generate a new certification campaign from a campaign template. The campaign object contained in the template has special formatting applied to its name and description fields that determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation. Placeholders consist of a percent sign followed by a letter indicating what should be inserted. For example, \"%Y\" inserts the current year, and a campaign template named \"Campaign for %y\" generates a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020). Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). Calling this endpoint requires the ORG_ADMIN role.
         * @summary Generate a Campaign from Template
         * @param {string} id ID of the campaign template to use for generation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startGenerateCampaignTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startGenerateCampaignTemplate(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to update individual fields on a certification campaign, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  When the campaign is in the *STAGED* status, you can patch these fields: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  When the campaign is in the *ACTIVE* status, you can patch these fields: * deadline 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateCampaign(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlimCampaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCampaign(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificationCampaignsApi - factory interface
 * @export
 */
export const CertificationCampaignsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationCampaignsApiFp(configuration)
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Use this API to complete a certification campaign. This functionality is provided to admins so that they can complete a certification even if all items have not been completed.  Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN. 
         * @summary Complete a Campaign
         * @param {string} id Campaign ID.
         * @param {CampaignCompleteOptions} [campaignCompleteOptions] Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeCampaign(id: string, campaignCompleteOptions?: CampaignCompleteOptions, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.completeCampaign(id, campaignCompleteOptions, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to create a certification campaign with the information provided in the request body.
         * @summary Create a campaign
         * @param {Campaign} campaign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign(campaign: Campaign, axiosOptions?: any): AxiosPromise<Campaign> {
            return localVarFp.createCampaign(campaign, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to create a certification campaign template based on campaign.
         * @summary Create a Campaign Template
         * @param {CampaignTemplate} campaignTemplate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignTemplate(campaignTemplate: CampaignTemplate, axiosOptions?: any): AxiosPromise<CampaignTemplate> {
            return localVarFp.createCampaignTemplate(campaignTemplate, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to delete a certification campaign template by ID.
         * @summary Delete a Campaign Template
         * @param {string} id ID of the campaign template being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplate(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteCampaignTemplate(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to delete the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.
         * @summary Delete Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplateSchedule(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteCampaignTemplateSchedule(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to delete certification campaigns whose IDs are specified in the provided list of campaign IDs.  Authorized callers must be ORG_ADMINs or CERT_ADMINs.
         * @summary Delete Campaigns
         * @param {CampaignsDeleteRequest} campaignsDeleteRequest IDs of the campaigns to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaigns(campaignsDeleteRequest: CampaignsDeleteRequest, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.deleteCampaigns(campaignsDeleteRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get a list of campaigns. This API can provide increased level of detail for each campaign for the correct provided query. 
         * @summary List Campaigns
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCampaigns(detail?: 'SLIM' | 'FULL', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<GetActiveCampaigns200ResponseInner>> {
            return localVarFp.getActiveCampaigns(detail, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get information for an existing certification campaign by the campaign\'s ID.  Authorized callers must be reviewers for this campaign, ORG_ADMINs, or a CERT_ADMINs.
         * @summary Get Campaign
         * @param {string} id ID of the campaign to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign(id: string, axiosOptions?: any): AxiosPromise<SlimCampaign> {
            return localVarFp.getCampaign(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to fetch all reports for a certification campaign by campaign ID. Calling this endpoint requires roles of CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
         * @summary Get Campaign Reports
         * @param {string} id ID of the campaign whose reports are being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReports(id: string, axiosOptions?: any): AxiosPromise<Array<CampaignReport>> {
            return localVarFp.getCampaignReports(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to fetch the configuration for certification campaign reports. The configuration includes only one element - identity attributes defined as custom report columns.  Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReportsConfig(axiosOptions?: any): AxiosPromise<CampaignReportsConfig> {
            return localVarFp.getCampaignReportsConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to fetch a certification campaign template by ID.
         * @summary Get a Campaign Template
         * @param {string} id Requested campaign template\&#39;s ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplate(id: string, axiosOptions?: any): AxiosPromise<CampaignTemplate> {
            return localVarFp.getCampaignTemplate(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.
         * @summary Get Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplateSchedule(id: string, axiosOptions?: any): AxiosPromise<Schedule> {
            return localVarFp.getCampaignTemplateSchedule(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get a list of all campaign templates. Scope can be reduced through standard V3 query params. The API returns all campaign templates matching the query parameters. 
         * @summary List Campaign Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *eq, ge, gt, in, le, lt, ne, sw*  **id**: *eq, ge, gt, in, le, lt, ne, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplates(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<CampaignTemplate>> {
            return localVarFp.getCampaignTemplates(limit, offset, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassign} adminReviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        move(id: string, adminReviewReassign: AdminReviewReassign, axiosOptions?: any): AxiosPromise<CertificationTask> {
            return localVarFp.move(id, adminReviewReassign, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to update individual fields on a certification campaign template, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign Template
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchCampaignTemplate(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<CampaignTemplate> {
            return localVarFp.patchCampaignTemplate(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to overwrite the configuration for campaign reports.  Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Set Campaign Reports Configuration
         * @param {CampaignReportsConfig} campaignReportsConfig Campaign report configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignReportsConfig(campaignReportsConfig: CampaignReportsConfig, axiosOptions?: any): AxiosPromise<CampaignReportsConfig> {
            return localVarFp.setCampaignReportsConfig(campaignReportsConfig, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to set the schedule for a certification campaign template. If a schedule already exists, the API overwrites it with the new one. 
         * @summary Set Campaign Template Schedule
         * @param {string} id ID of the campaign template being scheduled.
         * @param {Schedule} [schedule] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignTemplateSchedule(id: string, schedule?: Schedule, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.setCampaignTemplateSchedule(id, schedule, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to submit a job to activate the certified campaign with the specified ID. The campaign must be staged. Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Activate a Campaign
         * @param {string} id Campaign ID.
         * @param {ActivateCampaignOptions} [activateCampaignOptions] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign(id: string, activateCampaignOptions?: ActivateCampaignOptions, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.startCampaign(id, activateCampaignOptions, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to run a remediation scan task for a certification campaign. Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
         * @summary Run Campaign Remediation Scan
         * @param {string} id ID of the campaign the remediation scan is being run for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignRemediationScan(id: string, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.startCampaignRemediationScan(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to run a report for a certification campaign. Calling this endpoint requires the following roles: CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
         * @summary Run Campaign Report
         * @param {string} id ID of the campaign the report is being run for.
         * @param {ReportType} type Type of the report to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignReport(id: string, type: ReportType, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.startCampaignReport(id, type, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to generate a new certification campaign from a campaign template. The campaign object contained in the template has special formatting applied to its name and description fields that determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation. Placeholders consist of a percent sign followed by a letter indicating what should be inserted. For example, \"%Y\" inserts the current year, and a campaign template named \"Campaign for %y\" generates a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020). Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). Calling this endpoint requires the ORG_ADMIN role.
         * @summary Generate a Campaign from Template
         * @param {string} id ID of the campaign template to use for generation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startGenerateCampaignTemplate(id: string, axiosOptions?: any): AxiosPromise<CampaignReference> {
            return localVarFp.startGenerateCampaignTemplate(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to update individual fields on a certification campaign, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @summary Update a Campaign
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  When the campaign is in the *STAGED* status, you can patch these fields: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  When the campaign is in the *ACTIVE* status, you can patch these fields: * deadline 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<SlimCampaign> {
            return localVarFp.updateCampaign(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for completeCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiCompleteCampaignRequest
 */
export interface CertificationCampaignsApiCompleteCampaignRequest {
    /**
     * Campaign ID.
     * @type {string}
     * @memberof CertificationCampaignsApiCompleteCampaign
     */
    readonly id: string

    /**
     * Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
     * @type {CampaignCompleteOptions}
     * @memberof CertificationCampaignsApiCompleteCampaign
     */
    readonly campaignCompleteOptions?: CampaignCompleteOptions
}

/**
 * Request parameters for createCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiCreateCampaignRequest
 */
export interface CertificationCampaignsApiCreateCampaignRequest {
    /**
     * 
     * @type {Campaign}
     * @memberof CertificationCampaignsApiCreateCampaign
     */
    readonly campaign: Campaign
}

/**
 * Request parameters for createCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiCreateCampaignTemplateRequest
 */
export interface CertificationCampaignsApiCreateCampaignTemplateRequest {
    /**
     * 
     * @type {CampaignTemplate}
     * @memberof CertificationCampaignsApiCreateCampaignTemplate
     */
    readonly campaignTemplate: CampaignTemplate
}

/**
 * Request parameters for deleteCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiDeleteCampaignTemplateRequest
 */
export interface CertificationCampaignsApiDeleteCampaignTemplateRequest {
    /**
     * ID of the campaign template being deleted.
     * @type {string}
     * @memberof CertificationCampaignsApiDeleteCampaignTemplate
     */
    readonly id: string
}

/**
 * Request parameters for deleteCampaignTemplateSchedule operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest
 */
export interface CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest {
    /**
     * ID of the campaign template whose schedule is being deleted.
     * @type {string}
     * @memberof CertificationCampaignsApiDeleteCampaignTemplateSchedule
     */
    readonly id: string
}

/**
 * Request parameters for deleteCampaigns operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiDeleteCampaignsRequest
 */
export interface CertificationCampaignsApiDeleteCampaignsRequest {
    /**
     * IDs of the campaigns to delete.
     * @type {CampaignsDeleteRequest}
     * @memberof CertificationCampaignsApiDeleteCampaigns
     */
    readonly campaignsDeleteRequest: CampaignsDeleteRequest
}

/**
 * Request parameters for getActiveCampaigns operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetActiveCampaignsRequest
 */
export interface CertificationCampaignsApiGetActiveCampaignsRequest {
    /**
     * Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
     * @type {'SLIM' | 'FULL'}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly detail?: 'SLIM' | 'FULL'

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
     * @type {string}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created**
     * @type {string}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly sorters?: string
}

/**
 * Request parameters for getCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignRequest
 */
export interface CertificationCampaignsApiGetCampaignRequest {
    /**
     * ID of the campaign to be retrieved.
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaign
     */
    readonly id: string
}

/**
 * Request parameters for getCampaignReports operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignReportsRequest
 */
export interface CertificationCampaignsApiGetCampaignReportsRequest {
    /**
     * ID of the campaign whose reports are being fetched.
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaignReports
     */
    readonly id: string
}

/**
 * Request parameters for getCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignTemplateRequest
 */
export interface CertificationCampaignsApiGetCampaignTemplateRequest {
    /**
     * Requested campaign template\&#39;s ID.
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaignTemplate
     */
    readonly id: string
}

/**
 * Request parameters for getCampaignTemplateSchedule operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignTemplateScheduleRequest
 */
export interface CertificationCampaignsApiGetCampaignTemplateScheduleRequest {
    /**
     * ID of the campaign template whose schedule is being fetched.
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaignTemplateSchedule
     */
    readonly id: string
}

/**
 * Request parameters for getCampaignTemplates operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignTemplatesRequest
 */
export interface CertificationCampaignsApiGetCampaignTemplatesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiGetCampaignTemplates
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiGetCampaignTemplates
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationCampaignsApiGetCampaignTemplates
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaignTemplates
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *eq, ge, gt, in, le, lt, ne, sw*  **id**: *eq, ge, gt, in, le, lt, ne, sw*
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaignTemplates
     */
    readonly filters?: string
}

/**
 * Request parameters for move operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiMoveRequest
 */
export interface CertificationCampaignsApiMoveRequest {
    /**
     * The certification campaign ID
     * @type {string}
     * @memberof CertificationCampaignsApiMove
     */
    readonly id: string

    /**
     * 
     * @type {AdminReviewReassign}
     * @memberof CertificationCampaignsApiMove
     */
    readonly adminReviewReassign: AdminReviewReassign
}

/**
 * Request parameters for patchCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiPatchCampaignTemplateRequest
 */
export interface CertificationCampaignsApiPatchCampaignTemplateRequest {
    /**
     * ID of the campaign template being modified.
     * @type {string}
     * @memberof CertificationCampaignsApiPatchCampaignTemplate
     */
    readonly id: string

    /**
     * A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create) 
     * @type {Array<JsonPatchOperation>}
     * @memberof CertificationCampaignsApiPatchCampaignTemplate
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for setCampaignReportsConfig operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiSetCampaignReportsConfigRequest
 */
export interface CertificationCampaignsApiSetCampaignReportsConfigRequest {
    /**
     * Campaign report configuration.
     * @type {CampaignReportsConfig}
     * @memberof CertificationCampaignsApiSetCampaignReportsConfig
     */
    readonly campaignReportsConfig: CampaignReportsConfig
}

/**
 * Request parameters for setCampaignTemplateSchedule operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiSetCampaignTemplateScheduleRequest
 */
export interface CertificationCampaignsApiSetCampaignTemplateScheduleRequest {
    /**
     * ID of the campaign template being scheduled.
     * @type {string}
     * @memberof CertificationCampaignsApiSetCampaignTemplateSchedule
     */
    readonly id: string

    /**
     * 
     * @type {Schedule}
     * @memberof CertificationCampaignsApiSetCampaignTemplateSchedule
     */
    readonly schedule?: Schedule
}

/**
 * Request parameters for startCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiStartCampaignRequest
 */
export interface CertificationCampaignsApiStartCampaignRequest {
    /**
     * Campaign ID.
     * @type {string}
     * @memberof CertificationCampaignsApiStartCampaign
     */
    readonly id: string

    /**
     * Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
     * @type {ActivateCampaignOptions}
     * @memberof CertificationCampaignsApiStartCampaign
     */
    readonly activateCampaignOptions?: ActivateCampaignOptions
}

/**
 * Request parameters for startCampaignRemediationScan operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiStartCampaignRemediationScanRequest
 */
export interface CertificationCampaignsApiStartCampaignRemediationScanRequest {
    /**
     * ID of the campaign the remediation scan is being run for.
     * @type {string}
     * @memberof CertificationCampaignsApiStartCampaignRemediationScan
     */
    readonly id: string
}

/**
 * Request parameters for startCampaignReport operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiStartCampaignReportRequest
 */
export interface CertificationCampaignsApiStartCampaignReportRequest {
    /**
     * ID of the campaign the report is being run for.
     * @type {string}
     * @memberof CertificationCampaignsApiStartCampaignReport
     */
    readonly id: string

    /**
     * Type of the report to run.
     * @type {ReportType}
     * @memberof CertificationCampaignsApiStartCampaignReport
     */
    readonly type: ReportType
}

/**
 * Request parameters for startGenerateCampaignTemplate operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiStartGenerateCampaignTemplateRequest
 */
export interface CertificationCampaignsApiStartGenerateCampaignTemplateRequest {
    /**
     * ID of the campaign template to use for generation.
     * @type {string}
     * @memberof CertificationCampaignsApiStartGenerateCampaignTemplate
     */
    readonly id: string
}

/**
 * Request parameters for updateCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiUpdateCampaignRequest
 */
export interface CertificationCampaignsApiUpdateCampaignRequest {
    /**
     * ID of the campaign template being modified.
     * @type {string}
     * @memberof CertificationCampaignsApiUpdateCampaign
     */
    readonly id: string

    /**
     * A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  When the campaign is in the *STAGED* status, you can patch these fields: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  When the campaign is in the *ACTIVE* status, you can patch these fields: * deadline 
     * @type {Array<JsonPatchOperation>}
     * @memberof CertificationCampaignsApiUpdateCampaign
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * CertificationCampaignsApi - object-oriented interface
 * @export
 * @class CertificationCampaignsApi
 * @extends {BaseAPI}
 */
export class CertificationCampaignsApi extends BaseAPI {
    /**
     * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Use this API to complete a certification campaign. This functionality is provided to admins so that they can complete a certification even if all items have not been completed.  Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN. 
     * @summary Complete a Campaign
     * @param {CertificationCampaignsApiCompleteCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public completeCampaign(requestParameters: CertificationCampaignsApiCompleteCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).completeCampaign(requestParameters.id, requestParameters.campaignCompleteOptions, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to create a certification campaign with the information provided in the request body.
     * @summary Create a campaign
     * @param {CertificationCampaignsApiCreateCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public createCampaign(requestParameters: CertificationCampaignsApiCreateCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).createCampaign(requestParameters.campaign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to create a certification campaign template based on campaign.
     * @summary Create a Campaign Template
     * @param {CertificationCampaignsApiCreateCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public createCampaignTemplate(requestParameters: CertificationCampaignsApiCreateCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).createCampaignTemplate(requestParameters.campaignTemplate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to delete a certification campaign template by ID.
     * @summary Delete a Campaign Template
     * @param {CertificationCampaignsApiDeleteCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public deleteCampaignTemplate(requestParameters: CertificationCampaignsApiDeleteCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).deleteCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to delete the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.
     * @summary Delete Campaign Template Schedule
     * @param {CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public deleteCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).deleteCampaignTemplateSchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to delete certification campaigns whose IDs are specified in the provided list of campaign IDs.  Authorized callers must be ORG_ADMINs or CERT_ADMINs.
     * @summary Delete Campaigns
     * @param {CertificationCampaignsApiDeleteCampaignsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public deleteCampaigns(requestParameters: CertificationCampaignsApiDeleteCampaignsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).deleteCampaigns(requestParameters.campaignsDeleteRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get a list of campaigns. This API can provide increased level of detail for each campaign for the correct provided query. 
     * @summary List Campaigns
     * @param {CertificationCampaignsApiGetActiveCampaignsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getActiveCampaigns(requestParameters: CertificationCampaignsApiGetActiveCampaignsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getActiveCampaigns(requestParameters.detail, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get information for an existing certification campaign by the campaign\'s ID.  Authorized callers must be reviewers for this campaign, ORG_ADMINs, or a CERT_ADMINs.
     * @summary Get Campaign
     * @param {CertificationCampaignsApiGetCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaign(requestParameters: CertificationCampaignsApiGetCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaign(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to fetch all reports for a certification campaign by campaign ID. Calling this endpoint requires roles of CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
     * @summary Get Campaign Reports
     * @param {CertificationCampaignsApiGetCampaignReportsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignReports(requestParameters: CertificationCampaignsApiGetCampaignReportsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignReports(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to fetch the configuration for certification campaign reports. The configuration includes only one element - identity attributes defined as custom report columns.  Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
     * @summary Get Campaign Reports Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignReportsConfig(axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignReportsConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to fetch a certification campaign template by ID.
     * @summary Get a Campaign Template
     * @param {CertificationCampaignsApiGetCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignTemplate(requestParameters: CertificationCampaignsApiGetCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.
     * @summary Get Campaign Template Schedule
     * @param {CertificationCampaignsApiGetCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiGetCampaignTemplateScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignTemplateSchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get a list of all campaign templates. Scope can be reduced through standard V3 query params. The API returns all campaign templates matching the query parameters. 
     * @summary List Campaign Templates
     * @param {CertificationCampaignsApiGetCampaignTemplatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaignTemplates(requestParameters: CertificationCampaignsApiGetCampaignTemplatesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaignTemplates(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Reassign Certifications
     * @param {CertificationCampaignsApiMoveRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public move(requestParameters: CertificationCampaignsApiMoveRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).move(requestParameters.id, requestParameters.adminReviewReassign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to update individual fields on a certification campaign template, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @summary Update a Campaign Template
     * @param {CertificationCampaignsApiPatchCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public patchCampaignTemplate(requestParameters: CertificationCampaignsApiPatchCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).patchCampaignTemplate(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to overwrite the configuration for campaign reports.  Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
     * @summary Set Campaign Reports Configuration
     * @param {CertificationCampaignsApiSetCampaignReportsConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public setCampaignReportsConfig(requestParameters: CertificationCampaignsApiSetCampaignReportsConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).setCampaignReportsConfig(requestParameters.campaignReportsConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to set the schedule for a certification campaign template. If a schedule already exists, the API overwrites it with the new one. 
     * @summary Set Campaign Template Schedule
     * @param {CertificationCampaignsApiSetCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public setCampaignTemplateSchedule(requestParameters: CertificationCampaignsApiSetCampaignTemplateScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).setCampaignTemplateSchedule(requestParameters.id, requestParameters.schedule, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to submit a job to activate the certified campaign with the specified ID. The campaign must be staged. Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
     * @summary Activate a Campaign
     * @param {CertificationCampaignsApiStartCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public startCampaign(requestParameters: CertificationCampaignsApiStartCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).startCampaign(requestParameters.id, requestParameters.activateCampaignOptions, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to run a remediation scan task for a certification campaign. Calling this endpoint requires roles of CERT_ADMIN and ORG_ADMIN.
     * @summary Run Campaign Remediation Scan
     * @param {CertificationCampaignsApiStartCampaignRemediationScanRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public startCampaignRemediationScan(requestParameters: CertificationCampaignsApiStartCampaignRemediationScanRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).startCampaignRemediationScan(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to run a report for a certification campaign. Calling this endpoint requires the following roles: CERT_ADMIN, DASHBOARD, ORG_ADMIN and REPORT_ADMIN.
     * @summary Run Campaign Report
     * @param {CertificationCampaignsApiStartCampaignReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public startCampaignReport(requestParameters: CertificationCampaignsApiStartCampaignReportRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).startCampaignReport(requestParameters.id, requestParameters.type, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to generate a new certification campaign from a campaign template. The campaign object contained in the template has special formatting applied to its name and description fields that determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation. Placeholders consist of a percent sign followed by a letter indicating what should be inserted. For example, \"%Y\" inserts the current year, and a campaign template named \"Campaign for %y\" generates a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020). Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html). Calling this endpoint requires the ORG_ADMIN role.
     * @summary Generate a Campaign from Template
     * @param {CertificationCampaignsApiStartGenerateCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public startGenerateCampaignTemplate(requestParameters: CertificationCampaignsApiStartGenerateCampaignTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).startGenerateCampaignTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to update individual fields on a certification campaign, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @summary Update a Campaign
     * @param {CertificationCampaignsApiUpdateCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public updateCampaign(requestParameters: CertificationCampaignsApiUpdateCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).updateCampaign(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificationSummariesApi - axios parameter creator
 * @export
 */
export const CertificationSummariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityAccessSummaries: async (id: string, type: 'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityAccessSummaries', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getIdentityAccessSummaries', 'type', type)
            const localVarPath = `/certifications/{id}/access-summaries/{type}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityDecisionSummary: async (id: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityDecisionSummary', 'id', id)
            const localVarPath = `/certifications/{id}/decision-summary`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummaries: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentitySummaries', 'id', id)
            const localVarPath = `/certifications/{id}/identity-summaries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummary: async (id: string, identitySummaryId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentitySummary', 'id', id)
            // verify required parameter 'identitySummaryId' is not null or undefined
            assertParamExists('getIdentitySummary', 'identitySummaryId', identitySummaryId)
            const localVarPath = `/certifications/{id}/identity-summaries/{identitySummaryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"identitySummaryId"}}`, encodeURIComponent(String(identitySummaryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationSummariesApi - functional programming interface
 * @export
 */
export const CertificationSummariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationSummariesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityAccessSummaries(id: string, type: 'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityAccessSummaries(id, type, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityDecisionSummary(id: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertDecisionSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityDecisionSummary(id, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentitySummaries(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CertificationIdentitySummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentitySummaries(id, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentitySummary(id: string, identitySummaryId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationIdentitySummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentitySummary(id, identitySummaryId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificationSummariesApi - factory interface
 * @export
 */
export const CertificationSummariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationSummariesApiFp(configuration)
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityAccessSummaries(id: string, type: 'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<AccessSummary>> {
            return localVarFp.getIdentityAccessSummaries(id, type, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityDecisionSummary(id: string, filters?: string, axiosOptions?: any): AxiosPromise<IdentityCertDecisionSummary> {
            return localVarFp.getIdentityDecisionSummary(id, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummaries(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<CertificationIdentitySummary>> {
            return localVarFp.getIdentitySummaries(id, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummary(id: string, identitySummaryId: string, axiosOptions?: any): AxiosPromise<CertificationIdentitySummary> {
            return localVarFp.getIdentitySummary(id, identitySummaryId, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getIdentityAccessSummaries operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentityAccessSummariesRequest
 */
export interface CertificationSummariesApiGetIdentityAccessSummariesRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly id: string

    /**
     * The type of access review item to retrieve summaries for
     * @type {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly type: 'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly sorters?: string
}

/**
 * Request parameters for getIdentityDecisionSummary operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentityDecisionSummaryRequest
 */
export interface CertificationSummariesApiGetIdentityDecisionSummaryRequest {
    /**
     * The certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityDecisionSummary
     */
    readonly id: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityDecisionSummary
     */
    readonly filters?: string
}

/**
 * Request parameters for getIdentitySummaries operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentitySummariesRequest
 */
export interface CertificationSummariesApiGetIdentitySummariesRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly sorters?: string
}

/**
 * Request parameters for getIdentitySummary operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentitySummaryRequest
 */
export interface CertificationSummariesApiGetIdentitySummaryRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummary
     */
    readonly id: string

    /**
     * The identity summary ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummary
     */
    readonly identitySummaryId: string
}

/**
 * CertificationSummariesApi - object-oriented interface
 * @export
 * @class CertificationSummariesApi
 * @extends {BaseAPI}
 */
export class CertificationSummariesApi extends BaseAPI {
    /**
     * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Access Summaries
     * @param {CertificationSummariesApiGetIdentityAccessSummariesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentityAccessSummaries(requestParameters: CertificationSummariesApiGetIdentityAccessSummariesRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentityAccessSummaries(requestParameters.id, requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Summary of Certification Decisions
     * @param {CertificationSummariesApiGetIdentityDecisionSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentityDecisionSummary(requestParameters: CertificationSummariesApiGetIdentityDecisionSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentityDecisionSummary(requestParameters.id, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Identity Summaries for Campaign Certification
     * @param {CertificationSummariesApiGetIdentitySummariesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentitySummaries(requestParameters: CertificationSummariesApiGetIdentitySummariesRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentitySummaries(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Summary for Identity
     * @param {CertificationSummariesApiGetIdentitySummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentitySummary(requestParameters: CertificationSummariesApiGetIdentitySummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentitySummary(requestParameters.id, requestParameters.identitySummaryId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificationsApi - axios parameter creator
 * @export
 */
export const CertificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the certification task for the specified ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for the specified certification can also call this API.
         * @summary Certification Task by ID
         * @param {string} id The task ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCertificationTask: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCertificationTask', 'id', id)
            const localVarPath = `/certification-tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertification: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityCertification', 'id', id)
            const localVarPath = `/certifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {string} certificationId The certification ID
         * @param {string} itemId The certification item ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators: *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field.  For example, the following is valid: &#x60;?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22&#x60;  The following is invalid: 1?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)1
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationItemPermissions: async (certificationId: string, itemId: string, filters?: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificationId' is not null or undefined
            assertParamExists('getIdentityCertificationItemPermissions', 'certificationId', certificationId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getIdentityCertificationItemPermissions', 'itemId', itemId)
            const localVarPath = `/certifications/{certificationId}/access-review-items/{itemId}/permissions`
                .replace(`{${"certificationId"}}`, encodeURIComponent(String(certificationId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
         * @summary List of Pending Certification Tasks
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **targetId**: *eq, in*  **type**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPendingCertificationTasks: async (reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/certification-tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (reviewerIdentity !== undefined) {
                localVarQueryParameter['reviewer-identity'] = reviewerIdentity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for certification
         * @param {string} id The certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCertificationReviewers: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listCertificationReviewers', 'id', id)
            const localVarPath = `/certifications/{id}/reviewers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type**: *eq*  **access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessReviewItems: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, entitlements?: string, accessProfiles?: string, roles?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listIdentityAccessReviewItems', 'id', id)
            const localVarPath = `/certifications/{id}/access-review-items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (entitlements !== undefined) {
                localVarQueryParameter['entitlements'] = entitlements;
            }

            if (accessProfiles !== undefined) {
                localVarQueryParameter['access-profiles'] = accessProfiles;
            }

            if (roles !== undefined) {
                localVarQueryParameter['roles'] = roles;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get a list of identity campaign certifications for the specified query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to governance groups.
         * @summary List Identity Campaign Certifications
         * @param {string} [reviewerIdentity] Reviewer\&#39;s identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **campaign.id**: *eq, in*  **phase**: *eq*  **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityCertifications: async (reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/certifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (reviewerIdentity !== undefined) {
                localVarQueryParameter['reviewer-identity'] = reviewerIdentity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        makeIdentityDecision: async (id: string, reviewDecision: Array<ReviewDecision>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('makeIdentityDecision', 'id', id)
            // verify required parameter 'reviewDecision' is not null or undefined
            assertParamExists('makeIdentityDecision', 'reviewDecision', reviewDecision)
            const localVarPath = `/certifications/{id}/decide`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertifications: async (id: string, reviewReassign: ReviewReassign, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reassignIdentityCertifications', 'id', id)
            // verify required parameter 'reviewReassign' is not null or undefined
            assertParamExists('reassignIdentityCertifications', 'reviewReassign', reviewReassign)
            const localVarPath = `/certifications/{id}/reassign`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewReassign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        signOffIdentityCertification: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signOffIdentityCertification', 'id', id)
            const localVarPath = `/certifications/{id}/sign-off`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Reassign Certifications Asynchronously
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReassignCertsAsync: async (id: string, reviewReassign: ReviewReassign, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitReassignCertsAsync', 'id', id)
            // verify required parameter 'reviewReassign' is not null or undefined
            assertParamExists('submitReassignCertsAsync', 'reviewReassign', reviewReassign)
            const localVarPath = `/certifications/{id}/reassign-async`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewReassign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationsApi - functional programming interface
 * @export
 */
export const CertificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the certification task for the specified ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for the specified certification can also call this API.
         * @summary Certification Task by ID
         * @param {string} id The task ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCertificationTask(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCertificationTask(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityCertification(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityCertification(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {string} certificationId The certification ID
         * @param {string} itemId The certification item ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators: *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field.  For example, the following is valid: &#x60;?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22&#x60;  The following is invalid: 1?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)1
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityCertificationItemPermissions(certificationId: string, itemId: string, filters?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityCertificationItemPermissions(certificationId, itemId, filters, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
         * @summary List of Pending Certification Tasks
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **targetId**: *eq, in*  **type**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingCertificationTasks(reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CertificationTask>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingCertificationTasks(reviewerIdentity, limit, offset, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for certification
         * @param {string} id The certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCertificationReviewers(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityReferenceWithNameAndEmail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCertificationReviewers(id, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type**: *eq*  **access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityAccessReviewItems(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, entitlements?: string, accessProfiles?: string, roles?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessReviewItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityAccessReviewItems(id, limit, offset, count, filters, sorters, entitlements, accessProfiles, roles, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to get a list of identity campaign certifications for the specified query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to governance groups.
         * @summary List Identity Campaign Certifications
         * @param {string} [reviewerIdentity] Reviewer\&#39;s identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **campaign.id**: *eq, in*  **phase**: *eq*  **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityCertifications(reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityCertificationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityCertifications(reviewerIdentity, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async makeIdentityDecision(id: string, reviewDecision: Array<ReviewDecision>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.makeIdentityDecision(id, reviewDecision, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async reassignIdentityCertifications(id: string, reviewReassign: ReviewReassign, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reassignIdentityCertifications(id, reviewReassign, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async signOffIdentityCertification(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signOffIdentityCertification(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Reassign Certifications Asynchronously
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async submitReassignCertsAsync(id: string, reviewReassign: ReviewReassign, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitReassignCertsAsync(id, reviewReassign, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificationsApi - factory interface
 * @export
 */
export const CertificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationsApiFp(configuration)
    return {
        /**
         * This API returns the certification task for the specified ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for the specified certification can also call this API.
         * @summary Certification Task by ID
         * @param {string} id The task ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCertificationTask(id: string, axiosOptions?: any): AxiosPromise<CertificationTask> {
            return localVarFp.getCertificationTask(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertification(id: string, axiosOptions?: any): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.getIdentityCertification(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {string} certificationId The certification ID
         * @param {string} itemId The certification item ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators: *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field.  For example, the following is valid: &#x60;?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22&#x60;  The following is invalid: 1?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)1
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationItemPermissions(certificationId: string, itemId: string, filters?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<PermissionDto>> {
            return localVarFp.getIdentityCertificationItemPermissions(certificationId, itemId, filters, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
         * @summary List of Pending Certification Tasks
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **targetId**: *eq, in*  **type**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPendingCertificationTasks(reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<CertificationTask>> {
            return localVarFp.getPendingCertificationTasks(reviewerIdentity, limit, offset, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for certification
         * @param {string} id The certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCertificationReviewers(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<IdentityReferenceWithNameAndEmail>> {
            return localVarFp.listCertificationReviewers(id, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type**: *eq*  **access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessReviewItems(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, entitlements?: string, accessProfiles?: string, roles?: string, axiosOptions?: any): AxiosPromise<Array<AccessReviewItem>> {
            return localVarFp.listIdentityAccessReviewItems(id, limit, offset, count, filters, sorters, entitlements, accessProfiles, roles, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get a list of identity campaign certifications for the specified query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to governance groups.
         * @summary List Identity Campaign Certifications
         * @param {string} [reviewerIdentity] Reviewer\&#39;s identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **campaign.id**: *eq, in*  **phase**: *eq*  **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityCertifications(reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<IdentityCertificationDto>> {
            return localVarFp.listIdentityCertifications(reviewerIdentity, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        makeIdentityDecision(id: string, reviewDecision: Array<ReviewDecision>, axiosOptions?: any): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.makeIdentityDecision(id, reviewDecision, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertifications(id: string, reviewReassign: ReviewReassign, axiosOptions?: any): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.reassignIdentityCertifications(id, reviewReassign, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        signOffIdentityCertification(id: string, axiosOptions?: any): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.signOffIdentityCertification(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Reassign Certifications Asynchronously
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReassignCertsAsync(id: string, reviewReassign: ReviewReassign, axiosOptions?: any): AxiosPromise<CertificationTask> {
            return localVarFp.submitReassignCertsAsync(id, reviewReassign, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCertificationTask operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetCertificationTaskRequest
 */
export interface CertificationsApiGetCertificationTaskRequest {
    /**
     * The task ID
     * @type {string}
     * @memberof CertificationsApiGetCertificationTask
     */
    readonly id: string
}

/**
 * Request parameters for getIdentityCertification operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetIdentityCertificationRequest
 */
export interface CertificationsApiGetIdentityCertificationRequest {
    /**
     * The certification id
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertification
     */
    readonly id: string
}

/**
 * Request parameters for getIdentityCertificationItemPermissions operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetIdentityCertificationItemPermissionsRequest
 */
export interface CertificationsApiGetIdentityCertificationItemPermissionsRequest {
    /**
     * The certification ID
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly certificationId: string

    /**
     * The certification item ID
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly itemId: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators: *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field.  For example, the following is valid: &#x60;?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22&#x60;  The following is invalid: 1?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)1
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly filters?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiGetIdentityCertificationItemPermissions
     */
    readonly count?: boolean
}

/**
 * Request parameters for getPendingCertificationTasks operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetPendingCertificationTasksRequest
 */
export interface CertificationsApiGetPendingCertificationTasksRequest {
    /**
     * The ID of reviewer identity. *me* indicates the current user.
     * @type {string}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly reviewerIdentity?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **targetId**: *eq, in*  **type**: *eq, in*
     * @type {string}
     * @memberof CertificationsApiGetPendingCertificationTasks
     */
    readonly filters?: string
}

/**
 * Request parameters for listCertificationReviewers operation in CertificationsApi.
 * @export
 * @interface CertificationsApiListCertificationReviewersRequest
 */
export interface CertificationsApiListCertificationReviewersRequest {
    /**
     * The certification ID
     * @type {string}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
     * @type {string}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
     * @type {string}
     * @memberof CertificationsApiListCertificationReviewers
     */
    readonly sorters?: string
}

/**
 * Request parameters for listIdentityAccessReviewItems operation in CertificationsApi.
 * @export
 * @interface CertificationsApiListIdentityAccessReviewItemsRequest
 */
export interface CertificationsApiListIdentityAccessReviewItemsRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type**: *eq*  **access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly sorters?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly entitlements?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly accessProfiles?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly roles?: string
}

/**
 * Request parameters for listIdentityCertifications operation in CertificationsApi.
 * @export
 * @interface CertificationsApiListIdentityCertificationsRequest
 */
export interface CertificationsApiListIdentityCertificationsRequest {
    /**
     * Reviewer\&#39;s identity. *me* indicates the current user.
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly reviewerIdentity?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **campaign.id**: *eq, in*  **phase**: *eq*  **completed**: *eq, ne*
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, due, signed**
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly sorters?: string
}

/**
 * Request parameters for makeIdentityDecision operation in CertificationsApi.
 * @export
 * @interface CertificationsApiMakeIdentityDecisionRequest
 */
export interface CertificationsApiMakeIdentityDecisionRequest {
    /**
     * The ID of the identity campaign certification on which to make decisions
     * @type {string}
     * @memberof CertificationsApiMakeIdentityDecision
     */
    readonly id: string

    /**
     * A non-empty array of decisions to be made.
     * @type {Array<ReviewDecision>}
     * @memberof CertificationsApiMakeIdentityDecision
     */
    readonly reviewDecision: Array<ReviewDecision>
}

/**
 * Request parameters for reassignIdentityCertifications operation in CertificationsApi.
 * @export
 * @interface CertificationsApiReassignIdentityCertificationsRequest
 */
export interface CertificationsApiReassignIdentityCertificationsRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiReassignIdentityCertifications
     */
    readonly id: string

    /**
     * 
     * @type {ReviewReassign}
     * @memberof CertificationsApiReassignIdentityCertifications
     */
    readonly reviewReassign: ReviewReassign
}

/**
 * Request parameters for signOffIdentityCertification operation in CertificationsApi.
 * @export
 * @interface CertificationsApiSignOffIdentityCertificationRequest
 */
export interface CertificationsApiSignOffIdentityCertificationRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiSignOffIdentityCertification
     */
    readonly id: string
}

/**
 * Request parameters for submitReassignCertsAsync operation in CertificationsApi.
 * @export
 * @interface CertificationsApiSubmitReassignCertsAsyncRequest
 */
export interface CertificationsApiSubmitReassignCertsAsyncRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiSubmitReassignCertsAsync
     */
    readonly id: string

    /**
     * 
     * @type {ReviewReassign}
     * @memberof CertificationsApiSubmitReassignCertsAsync
     */
    readonly reviewReassign: ReviewReassign
}

/**
 * CertificationsApi - object-oriented interface
 * @export
 * @class CertificationsApi
 * @extends {BaseAPI}
 */
export class CertificationsApi extends BaseAPI {
    /**
     * This API returns the certification task for the specified ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for the specified certification can also call this API.
     * @summary Certification Task by ID
     * @param {CertificationsApiGetCertificationTaskRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getCertificationTask(requestParameters: CertificationsApiGetCertificationTaskRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getCertificationTask(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Identity Certification by ID
     * @param {CertificationsApiGetIdentityCertificationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getIdentityCertification(requestParameters: CertificationsApiGetIdentityCertificationRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getIdentityCertification(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Permissions for Entitlement Certification Item
     * @param {CertificationsApiGetIdentityCertificationItemPermissionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getIdentityCertificationItemPermissions(requestParameters: CertificationsApiGetIdentityCertificationItemPermissionsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getIdentityCertificationItemPermissions(requestParameters.certificationId, requestParameters.itemId, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
     * @summary List of Pending Certification Tasks
     * @param {CertificationsApiGetPendingCertificationTasksRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getPendingCertificationTasks(requestParameters: CertificationsApiGetPendingCertificationTasksRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getPendingCertificationTasks(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary List of Reviewers for certification
     * @param {CertificationsApiListCertificationReviewersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public listCertificationReviewers(requestParameters: CertificationsApiListCertificationReviewersRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).listCertificationReviewers(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary List of Access Review Items
     * @param {CertificationsApiListIdentityAccessReviewItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public listIdentityAccessReviewItems(requestParameters: CertificationsApiListIdentityAccessReviewItemsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).listIdentityAccessReviewItems(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.entitlements, requestParameters.accessProfiles, requestParameters.roles, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get a list of identity campaign certifications for the specified query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to governance groups.
     * @summary List Identity Campaign Certifications
     * @param {CertificationsApiListIdentityCertificationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public listIdentityCertifications(requestParameters: CertificationsApiListIdentityCertificationsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).listIdentityCertifications(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Decide on a Certification Item
     * @param {CertificationsApiMakeIdentityDecisionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public makeIdentityDecision(requestParameters: CertificationsApiMakeIdentityDecisionRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).makeIdentityDecision(requestParameters.id, requestParameters.reviewDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Reassign Identities or Items
     * @param {CertificationsApiReassignIdentityCertificationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public reassignIdentityCertifications(requestParameters: CertificationsApiReassignIdentityCertificationsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).reassignIdentityCertifications(requestParameters.id, requestParameters.reviewReassign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Finalize Identity Certification Decisions
     * @param {CertificationsApiSignOffIdentityCertificationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public signOffIdentityCertification(requestParameters: CertificationsApiSignOffIdentityCertificationRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).signOffIdentityCertification(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Reassign Certifications Asynchronously
     * @param {CertificationsApiSubmitReassignCertsAsyncRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public submitReassignCertsAsync(requestParameters: CertificationsApiSubmitReassignCertsAsyncRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).submitReassignCertsAsync(requestParameters.id, requestParameters.reviewReassign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigurationHubApi - axios parameter creator
 * @export
 */
export const ConfigurationHubApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates an object mapping between current org and source org. Source org should be \"default\" when creating an object mapping that is not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Creates an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingRequest} objectMappingRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMapping: async (sourceOrg: string, objectMappingRequest: ObjectMappingRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceOrg' is not null or undefined
            assertParamExists('createObjectMapping', 'sourceOrg', sourceOrg)
            // verify required parameter 'objectMappingRequest' is not null or undefined
            assertParamExists('createObjectMapping', 'objectMappingRequest', objectMappingRequest)
            const localVarPath = `/configuration-hub/object-mappings/{sourceOrg}`
                .replace(`{${"sourceOrg"}}`, encodeURIComponent(String(sourceOrg)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(objectMappingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This creates a set of object mappings (Max 25) between current org and source org. Source org should be \"default\" when creating object mappings that are not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk creates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkCreateRequest} objectMappingBulkCreateRequest The bulk create object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMappings: async (sourceOrg: string, objectMappingBulkCreateRequest: ObjectMappingBulkCreateRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceOrg' is not null or undefined
            assertParamExists('createObjectMappings', 'sourceOrg', sourceOrg)
            // verify required parameter 'objectMappingBulkCreateRequest' is not null or undefined
            assertParamExists('createObjectMappings', 'objectMappingBulkCreateRequest', objectMappingBulkCreateRequest)
            const localVarPath = `/configuration-hub/object-mappings/{sourceOrg}/bulk-create`
                .replace(`{${"sourceOrg"}}`, encodeURIComponent(String(sourceOrg)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(objectMappingBulkCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes an existing object mapping. Source org should be \"default\" when deleting an object mapping that is not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Deletes an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {string} objectMappingId The id of the object mapping to be deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectMapping: async (sourceOrg: string, objectMappingId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceOrg' is not null or undefined
            assertParamExists('deleteObjectMapping', 'sourceOrg', sourceOrg)
            // verify required parameter 'objectMappingId' is not null or undefined
            assertParamExists('deleteObjectMapping', 'objectMappingId', objectMappingId)
            const localVarPath = `/configuration-hub/object-mappings/{sourceOrg}/{objectMappingId}`
                .replace(`{${"sourceOrg"}}`, encodeURIComponent(String(sourceOrg)))
                .replace(`{${"objectMappingId"}}`, encodeURIComponent(String(objectMappingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes an Uploaded backup based on job ID. On success, this endpoint will return an empty response. The job id can be obtained from the response after a successful upload, or the list uploads endpoint. The following scopes are required to access this endpoint: sp:config:manage
         * @summary Deletes an uploaded backup file
         * @param {string} id The id of the uploaded backup.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadedBackup: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUploadedBackup', 'id', id)
            const localVarPath = `/configuration-hub/backups/uploads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of existing object mappings between current org and source org. Source org should be \"default\" when getting object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:read
         * @summary Gets list of object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getObjectMappings: async (sourceOrg: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceOrg' is not null or undefined
            assertParamExists('getObjectMappings', 'sourceOrg', sourceOrg)
            const localVarPath = `/configuration-hub/object-mappings/{sourceOrg}`
                .replace(`{${"sourceOrg"}}`, encodeURIComponent(String(sourceOrg)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns all the information and status of an upload job. - sp:config-backups:read
         * @summary Get an uploaded backup\'s information
         * @param {string} id The id of the uploaded backup.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedBackup: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUploadedBackup', 'id', id)
            const localVarPath = `/configuration-hub/backups/uploads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the current uploaded backups associated with the current tenant. A filter \"status\" can be added to only return the Completed, Failed, or Successful uploads
         * @summary Gets list of Uploaded backups
         * @param {string} [status] Filter listed uploaded backups by status of operation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedBackups: async (status?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/configuration-hub/backups/uploads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This post will upload a JSON backup file into a tenant. Configuration files can be managed and deployed via Configuration Hub by uploading a json file which contains configuration data. The JSON file should be the same as the one used by our import endpoints. The object types that currently support by upload file functionality are the same as the ones supported by our regular backup functionality. here: [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects).  The request will need the following security scope: - sp:config:manage
         * @summary Uploads a backup file
         * @param {any} data JSON file containing the objects to be imported.
         * @param {string} name Name that will be assigned to the uploaded file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importUploadedBackup: async (data: any, name: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('importUploadedBackup', 'data', data)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('importUploadedBackup', 'name', name)
            const localVarPath = `/configuration-hub/backups/uploads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates a set of object mappings, only enabled and targetValue fields can be updated. Source org should be \"default\" when updating object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk updates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkPatchRequest} objectMappingBulkPatchRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectMappings: async (sourceOrg: string, objectMappingBulkPatchRequest: ObjectMappingBulkPatchRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceOrg' is not null or undefined
            assertParamExists('updateObjectMappings', 'sourceOrg', sourceOrg)
            // verify required parameter 'objectMappingBulkPatchRequest' is not null or undefined
            assertParamExists('updateObjectMappings', 'objectMappingBulkPatchRequest', objectMappingBulkPatchRequest)
            const localVarPath = `/configuration-hub/object-mappings/{sourceOrg}/bulk-patch`
                .replace(`{${"sourceOrg"}}`, encodeURIComponent(String(sourceOrg)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(objectMappingBulkPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationHubApi - functional programming interface
 * @export
 */
export const ConfigurationHubApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigurationHubApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates an object mapping between current org and source org. Source org should be \"default\" when creating an object mapping that is not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Creates an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingRequest} objectMappingRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createObjectMapping(sourceOrg: string, objectMappingRequest: ObjectMappingRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectMappingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createObjectMapping(sourceOrg, objectMappingRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This creates a set of object mappings (Max 25) between current org and source org. Source org should be \"default\" when creating object mappings that are not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk creates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkCreateRequest} objectMappingBulkCreateRequest The bulk create object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createObjectMappings(sourceOrg: string, objectMappingBulkCreateRequest: ObjectMappingBulkCreateRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectMappingBulkCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createObjectMappings(sourceOrg, objectMappingBulkCreateRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes an existing object mapping. Source org should be \"default\" when deleting an object mapping that is not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Deletes an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {string} objectMappingId The id of the object mapping to be deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteObjectMapping(sourceOrg: string, objectMappingId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteObjectMapping(sourceOrg, objectMappingId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes an Uploaded backup based on job ID. On success, this endpoint will return an empty response. The job id can be obtained from the response after a successful upload, or the list uploads endpoint. The following scopes are required to access this endpoint: sp:config:manage
         * @summary Deletes an uploaded backup file
         * @param {string} id The id of the uploaded backup.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUploadedBackup(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUploadedBackup(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of existing object mappings between current org and source org. Source org should be \"default\" when getting object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:read
         * @summary Gets list of object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getObjectMappings(sourceOrg: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ObjectMappingResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObjectMappings(sourceOrg, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all the information and status of an upload job. - sp:config-backups:read
         * @summary Get an uploaded backup\'s information
         * @param {string} id The id of the uploaded backup.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getUploadedBackup(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUploadedBackup(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of the current uploaded backups associated with the current tenant. A filter \"status\" can be added to only return the Completed, Failed, or Successful uploads
         * @summary Gets list of Uploaded backups
         * @param {string} [status] Filter listed uploaded backups by status of operation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getUploadedBackups(status?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UploadsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUploadedBackups(status, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This post will upload a JSON backup file into a tenant. Configuration files can be managed and deployed via Configuration Hub by uploading a json file which contains configuration data. The JSON file should be the same as the one used by our import endpoints. The object types that currently support by upload file functionality are the same as the ones supported by our regular backup functionality. here: [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects).  The request will need the following security scope: - sp:config:manage
         * @summary Uploads a backup file
         * @param {any} data JSON file containing the objects to be imported.
         * @param {string} name Name that will be assigned to the uploaded file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importUploadedBackup(data: any, name: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadsRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUploadedBackup(data, name, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates a set of object mappings, only enabled and targetValue fields can be updated. Source org should be \"default\" when updating object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk updates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkPatchRequest} objectMappingBulkPatchRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateObjectMappings(sourceOrg: string, objectMappingBulkPatchRequest: ObjectMappingBulkPatchRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectMappingBulkPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateObjectMappings(sourceOrg, objectMappingBulkPatchRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigurationHubApi - factory interface
 * @export
 */
export const ConfigurationHubApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigurationHubApiFp(configuration)
    return {
        /**
         * This creates an object mapping between current org and source org. Source org should be \"default\" when creating an object mapping that is not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Creates an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingRequest} objectMappingRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMapping(sourceOrg: string, objectMappingRequest: ObjectMappingRequest, axiosOptions?: any): AxiosPromise<ObjectMappingResponse> {
            return localVarFp.createObjectMapping(sourceOrg, objectMappingRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This creates a set of object mappings (Max 25) between current org and source org. Source org should be \"default\" when creating object mappings that are not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk creates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkCreateRequest} objectMappingBulkCreateRequest The bulk create object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMappings(sourceOrg: string, objectMappingBulkCreateRequest: ObjectMappingBulkCreateRequest, axiosOptions?: any): AxiosPromise<ObjectMappingBulkCreateResponse> {
            return localVarFp.createObjectMappings(sourceOrg, objectMappingBulkCreateRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes an existing object mapping. Source org should be \"default\" when deleting an object mapping that is not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Deletes an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {string} objectMappingId The id of the object mapping to be deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectMapping(sourceOrg: string, objectMappingId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteObjectMapping(sourceOrg, objectMappingId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes an Uploaded backup based on job ID. On success, this endpoint will return an empty response. The job id can be obtained from the response after a successful upload, or the list uploads endpoint. The following scopes are required to access this endpoint: sp:config:manage
         * @summary Deletes an uploaded backup file
         * @param {string} id The id of the uploaded backup.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadedBackup(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteUploadedBackup(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of existing object mappings between current org and source org. Source org should be \"default\" when getting object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:read
         * @summary Gets list of object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getObjectMappings(sourceOrg: string, axiosOptions?: any): AxiosPromise<Array<ObjectMappingResponse>> {
            return localVarFp.getObjectMappings(sourceOrg, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the information and status of an upload job. - sp:config-backups:read
         * @summary Get an uploaded backup\'s information
         * @param {string} id The id of the uploaded backup.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedBackup(id: string, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.getUploadedBackup(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the current uploaded backups associated with the current tenant. A filter \"status\" can be added to only return the Completed, Failed, or Successful uploads
         * @summary Gets list of Uploaded backups
         * @param {string} [status] Filter listed uploaded backups by status of operation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedBackups(status?: string, axiosOptions?: any): AxiosPromise<Array<UploadsResponse>> {
            return localVarFp.getUploadedBackups(status, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This post will upload a JSON backup file into a tenant. Configuration files can be managed and deployed via Configuration Hub by uploading a json file which contains configuration data. The JSON file should be the same as the one used by our import endpoints. The object types that currently support by upload file functionality are the same as the ones supported by our regular backup functionality. here: [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects).  The request will need the following security scope: - sp:config:manage
         * @summary Uploads a backup file
         * @param {any} data JSON file containing the objects to be imported.
         * @param {string} name Name that will be assigned to the uploaded file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importUploadedBackup(data: any, name: string, axiosOptions?: any): AxiosPromise<UploadsRequest> {
            return localVarFp.importUploadedBackup(data, name, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates a set of object mappings, only enabled and targetValue fields can be updated. Source org should be \"default\" when updating object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk updates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkPatchRequest} objectMappingBulkPatchRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectMappings(sourceOrg: string, objectMappingBulkPatchRequest: ObjectMappingBulkPatchRequest, axiosOptions?: any): AxiosPromise<ObjectMappingBulkPatchResponse> {
            return localVarFp.updateObjectMappings(sourceOrg, objectMappingBulkPatchRequest, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createObjectMapping operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiCreateObjectMappingRequest
 */
export interface ConfigurationHubApiCreateObjectMappingRequest {
    /**
     * The name of the source org.
     * @type {string}
     * @memberof ConfigurationHubApiCreateObjectMapping
     */
    readonly sourceOrg: string

    /**
     * The object mapping request body.
     * @type {ObjectMappingRequest}
     * @memberof ConfigurationHubApiCreateObjectMapping
     */
    readonly objectMappingRequest: ObjectMappingRequest
}

/**
 * Request parameters for createObjectMappings operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiCreateObjectMappingsRequest
 */
export interface ConfigurationHubApiCreateObjectMappingsRequest {
    /**
     * The name of the source org.
     * @type {string}
     * @memberof ConfigurationHubApiCreateObjectMappings
     */
    readonly sourceOrg: string

    /**
     * The bulk create object mapping request body.
     * @type {ObjectMappingBulkCreateRequest}
     * @memberof ConfigurationHubApiCreateObjectMappings
     */
    readonly objectMappingBulkCreateRequest: ObjectMappingBulkCreateRequest
}

/**
 * Request parameters for deleteObjectMapping operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiDeleteObjectMappingRequest
 */
export interface ConfigurationHubApiDeleteObjectMappingRequest {
    /**
     * The name of the source org.
     * @type {string}
     * @memberof ConfigurationHubApiDeleteObjectMapping
     */
    readonly sourceOrg: string

    /**
     * The id of the object mapping to be deleted.
     * @type {string}
     * @memberof ConfigurationHubApiDeleteObjectMapping
     */
    readonly objectMappingId: string
}

/**
 * Request parameters for deleteUploadedBackup operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiDeleteUploadedBackupRequest
 */
export interface ConfigurationHubApiDeleteUploadedBackupRequest {
    /**
     * The id of the uploaded backup.
     * @type {string}
     * @memberof ConfigurationHubApiDeleteUploadedBackup
     */
    readonly id: string
}

/**
 * Request parameters for getObjectMappings operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiGetObjectMappingsRequest
 */
export interface ConfigurationHubApiGetObjectMappingsRequest {
    /**
     * The name of the source org.
     * @type {string}
     * @memberof ConfigurationHubApiGetObjectMappings
     */
    readonly sourceOrg: string
}

/**
 * Request parameters for getUploadedBackup operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiGetUploadedBackupRequest
 */
export interface ConfigurationHubApiGetUploadedBackupRequest {
    /**
     * The id of the uploaded backup.
     * @type {string}
     * @memberof ConfigurationHubApiGetUploadedBackup
     */
    readonly id: string
}

/**
 * Request parameters for getUploadedBackups operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiGetUploadedBackupsRequest
 */
export interface ConfigurationHubApiGetUploadedBackupsRequest {
    /**
     * Filter listed uploaded backups by status of operation
     * @type {string}
     * @memberof ConfigurationHubApiGetUploadedBackups
     */
    readonly status?: string
}

/**
 * Request parameters for importUploadedBackup operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiImportUploadedBackupRequest
 */
export interface ConfigurationHubApiImportUploadedBackupRequest {
    /**
     * JSON file containing the objects to be imported.
     * @type {any}
     * @memberof ConfigurationHubApiImportUploadedBackup
     */
    readonly data: any

    /**
     * Name that will be assigned to the uploaded file.
     * @type {string}
     * @memberof ConfigurationHubApiImportUploadedBackup
     */
    readonly name: string
}

/**
 * Request parameters for updateObjectMappings operation in ConfigurationHubApi.
 * @export
 * @interface ConfigurationHubApiUpdateObjectMappingsRequest
 */
export interface ConfigurationHubApiUpdateObjectMappingsRequest {
    /**
     * The name of the source org.
     * @type {string}
     * @memberof ConfigurationHubApiUpdateObjectMappings
     */
    readonly sourceOrg: string

    /**
     * The object mapping request body.
     * @type {ObjectMappingBulkPatchRequest}
     * @memberof ConfigurationHubApiUpdateObjectMappings
     */
    readonly objectMappingBulkPatchRequest: ObjectMappingBulkPatchRequest
}

/**
 * ConfigurationHubApi - object-oriented interface
 * @export
 * @class ConfigurationHubApi
 * @extends {BaseAPI}
 */
export class ConfigurationHubApi extends BaseAPI {
    /**
     * This creates an object mapping between current org and source org. Source org should be \"default\" when creating an object mapping that is not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
     * @summary Creates an object mapping
     * @param {ConfigurationHubApiCreateObjectMappingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public createObjectMapping(requestParameters: ConfigurationHubApiCreateObjectMappingRequest, axiosOptions?: AxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).createObjectMapping(requestParameters.sourceOrg, requestParameters.objectMappingRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This creates a set of object mappings (Max 25) between current org and source org. Source org should be \"default\" when creating object mappings that are not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
     * @summary Bulk creates object mappings
     * @param {ConfigurationHubApiCreateObjectMappingsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public createObjectMappings(requestParameters: ConfigurationHubApiCreateObjectMappingsRequest, axiosOptions?: AxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).createObjectMappings(requestParameters.sourceOrg, requestParameters.objectMappingBulkCreateRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes an existing object mapping. Source org should be \"default\" when deleting an object mapping that is not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
     * @summary Deletes an object mapping
     * @param {ConfigurationHubApiDeleteObjectMappingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public deleteObjectMapping(requestParameters: ConfigurationHubApiDeleteObjectMappingRequest, axiosOptions?: AxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).deleteObjectMapping(requestParameters.sourceOrg, requestParameters.objectMappingId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes an Uploaded backup based on job ID. On success, this endpoint will return an empty response. The job id can be obtained from the response after a successful upload, or the list uploads endpoint. The following scopes are required to access this endpoint: sp:config:manage
     * @summary Deletes an uploaded backup file
     * @param {ConfigurationHubApiDeleteUploadedBackupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public deleteUploadedBackup(requestParameters: ConfigurationHubApiDeleteUploadedBackupRequest, axiosOptions?: AxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).deleteUploadedBackup(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of existing object mappings between current org and source org. Source org should be \"default\" when getting object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:read
     * @summary Gets list of object mappings
     * @param {ConfigurationHubApiGetObjectMappingsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public getObjectMappings(requestParameters: ConfigurationHubApiGetObjectMappingsRequest, axiosOptions?: AxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).getObjectMappings(requestParameters.sourceOrg, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the information and status of an upload job. - sp:config-backups:read
     * @summary Get an uploaded backup\'s information
     * @param {ConfigurationHubApiGetUploadedBackupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public getUploadedBackup(requestParameters: ConfigurationHubApiGetUploadedBackupRequest, axiosOptions?: AxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).getUploadedBackup(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the current uploaded backups associated with the current tenant. A filter \"status\" can be added to only return the Completed, Failed, or Successful uploads
     * @summary Gets list of Uploaded backups
     * @param {ConfigurationHubApiGetUploadedBackupsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public getUploadedBackups(requestParameters: ConfigurationHubApiGetUploadedBackupsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).getUploadedBackups(requestParameters.status, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This post will upload a JSON backup file into a tenant. Configuration files can be managed and deployed via Configuration Hub by uploading a json file which contains configuration data. The JSON file should be the same as the one used by our import endpoints. The object types that currently support by upload file functionality are the same as the ones supported by our regular backup functionality. here: [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects).  The request will need the following security scope: - sp:config:manage
     * @summary Uploads a backup file
     * @param {ConfigurationHubApiImportUploadedBackupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public importUploadedBackup(requestParameters: ConfigurationHubApiImportUploadedBackupRequest, axiosOptions?: AxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).importUploadedBackup(requestParameters.data, requestParameters.name, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates a set of object mappings, only enabled and targetValue fields can be updated. Source org should be \"default\" when updating object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
     * @summary Bulk updates object mappings
     * @param {ConfigurationHubApiUpdateObjectMappingsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    public updateObjectMappings(requestParameters: ConfigurationHubApiUpdateObjectMappingsRequest, axiosOptions?: AxiosRequestConfig) {
        return ConfigurationHubApiFp(this.configuration).updateObjectMappings(requestParameters.sourceOrg, requestParameters.objectMappingBulkPatchRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConnectorsApi - axios parameter creator
 * @export
 */
export const ConnectorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create custom connector. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create custom connector
         * @param {V3CreateConnectorDto} v3CreateConnectorDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCustomConnector: async (v3CreateConnectorDto: V3CreateConnectorDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v3CreateConnectorDto' is not null or undefined
            assertParamExists('createCustomConnector', 'v3CreateConnectorDto', v3CreateConnectorDto)
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v3CreateConnectorDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @summary Deletes connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomConnector: async (scriptName: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('deleteCustomConnector', 'scriptName', scriptName)
            const localVarPath = `/connectors/{scriptName}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnector: async (scriptName: string, locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getConnector', 'scriptName', scriptName)
            const localVarPath = `/connectors/{scriptName}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorCorrelationConfig: async (scriptName: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getConnectorCorrelationConfig', 'scriptName', scriptName)
            const localVarPath = `/connectors/{scriptName}/correlation-config`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector list
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *sw, co*  **type**: *sw, co, eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*  **labels**: *ca*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorList: async (filters?: string, limit?: number, offset?: number, count?: boolean, locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceConfig: async (scriptName: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getConnectorSourceConfig', 'scriptName', scriptName)
            const localVarPath = `/connectors/{scriptName}/source-config`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceTemplate: async (scriptName: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getConnectorSourceTemplate', 'scriptName', scriptName)
            const localVarPath = `/connectors/{scriptName}/source-template`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorTranslations: async (scriptName: string, locale: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getConnectorTranslations', 'scriptName', scriptName)
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('getConnectorTranslations', 'locale', locale)
            const localVarPath = `/connectors/{scriptName}/translations/{locale}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)))
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector correlation config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putCorrelationConfig: async (scriptName: string, file: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('putCorrelationConfig', 'scriptName', scriptName)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('putCorrelationConfig', 'file', file)
            const localVarPath = `/connectors/{scriptName}/correlation-config`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector source config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceConfig: async (scriptName: string, file: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('putSourceConfig', 'scriptName', scriptName)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('putSourceConfig', 'file', file)
            const localVarPath = `/connectors/{scriptName}/source-config`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector source template xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceTemplate: async (scriptName: string, file: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('putSourceTemplate', 'scriptName', scriptName)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('putSourceTemplate', 'file', file)
            const localVarPath = `/connectors/{scriptName}/source-template`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTranslations: async (scriptName: string, locale: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('putTranslations', 'scriptName', scriptName)
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('putTranslations', 'locale', locale)
            const localVarPath = `/connectors/{scriptName}/translations/{locale}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)))
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Patch a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API. The following fields are patchable: * connectorMetadata * applicationXml * correlationConfigXml * sourceConfigXml
         * @summary Update connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of connector detail update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector: async (scriptName: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('updateConnector', 'scriptName', scriptName)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateConnector', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/connectors/{scriptName}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorsApi - functional programming interface
 * @export
 */
export const ConnectorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create custom connector. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create custom connector
         * @param {V3CreateConnectorDto} v3CreateConnectorDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomConnector(v3CreateConnectorDto: V3CreateConnectorDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V3ConnectorDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomConnector(v3CreateConnectorDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @summary Deletes connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomConnector(scriptName: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomConnector(scriptName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnector(scriptName: string, locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnector(scriptName, locale, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorCorrelationConfig(scriptName: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorCorrelationConfig(scriptName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector list
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *sw, co*  **type**: *sw, co, eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*  **labels**: *ca*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorList(filters?: string, limit?: number, offset?: number, count?: boolean, locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V3ConnectorDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorList(filters, limit, offset, count, locale, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorSourceConfig(scriptName: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorSourceConfig(scriptName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorSourceTemplate(scriptName: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorSourceTemplate(scriptName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorTranslations(scriptName: string, locale: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorTranslations(scriptName, locale, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector correlation config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putCorrelationConfig(scriptName: string, file: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCorrelationConfig(scriptName, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector source config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSourceConfig(scriptName: string, file: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSourceConfig(scriptName, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector source template xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSourceTemplate(scriptName: string, file: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSourceTemplate(scriptName, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putTranslations(scriptName: string, locale: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTranslations(scriptName, locale, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Patch a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API. The following fields are patchable: * connectorMetadata * applicationXml * correlationConfigXml * sourceConfigXml
         * @summary Update connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of connector detail update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateConnector(scriptName: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConnector(scriptName, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectorsApi - factory interface
 * @export
 */
export const ConnectorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorsApiFp(configuration)
    return {
        /**
         * Create custom connector. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create custom connector
         * @param {V3CreateConnectorDto} v3CreateConnectorDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCustomConnector(v3CreateConnectorDto: V3CreateConnectorDto, axiosOptions?: any): AxiosPromise<V3ConnectorDto> {
            return localVarFp.createCustomConnector(v3CreateConnectorDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @summary Deletes connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomConnector(scriptName: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomConnector(scriptName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnector(scriptName: string, locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions?: any): AxiosPromise<ConnectorDetail> {
            return localVarFp.getConnector(scriptName, locale, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorCorrelationConfig(scriptName: string, axiosOptions?: any): AxiosPromise<string> {
            return localVarFp.getConnectorCorrelationConfig(scriptName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector list
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *sw, co*  **type**: *sw, co, eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*  **labels**: *ca*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorList(filters?: string, limit?: number, offset?: number, count?: boolean, locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions?: any): AxiosPromise<Array<V3ConnectorDto>> {
            return localVarFp.getConnectorList(filters, limit, offset, count, locale, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceConfig(scriptName: string, axiosOptions?: any): AxiosPromise<string> {
            return localVarFp.getConnectorSourceConfig(scriptName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceTemplate(scriptName: string, axiosOptions?: any): AxiosPromise<string> {
            return localVarFp.getConnectorSourceTemplate(scriptName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorTranslations(scriptName: string, locale: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions?: any): AxiosPromise<string> {
            return localVarFp.getConnectorTranslations(scriptName, locale, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector correlation config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putCorrelationConfig(scriptName: string, file: any, axiosOptions?: any): AxiosPromise<UpdateDetail> {
            return localVarFp.putCorrelationConfig(scriptName, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector source config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceConfig(scriptName: string, file: any, axiosOptions?: any): AxiosPromise<UpdateDetail> {
            return localVarFp.putSourceConfig(scriptName, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector source template xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceTemplate(scriptName: string, file: any, axiosOptions?: any): AxiosPromise<UpdateDetail> {
            return localVarFp.putSourceTemplate(scriptName, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTranslations(scriptName: string, locale: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl', axiosOptions?: any): AxiosPromise<UpdateDetail> {
            return localVarFp.putTranslations(scriptName, locale, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Patch a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API. The following fields are patchable: * connectorMetadata * applicationXml * correlationConfigXml * sourceConfigXml
         * @summary Update connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of connector detail update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector(scriptName: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<ConnectorDetail> {
            return localVarFp.updateConnector(scriptName, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCustomConnector operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiCreateCustomConnectorRequest
 */
export interface ConnectorsApiCreateCustomConnectorRequest {
    /**
     * 
     * @type {V3CreateConnectorDto}
     * @memberof ConnectorsApiCreateCustomConnector
     */
    readonly v3CreateConnectorDto: V3CreateConnectorDto
}

/**
 * Request parameters for deleteCustomConnector operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiDeleteCustomConnectorRequest
 */
export interface ConnectorsApiDeleteCustomConnectorRequest {
    /**
     * The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiDeleteCustomConnector
     */
    readonly scriptName: string
}

/**
 * Request parameters for getConnector operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiGetConnectorRequest
 */
export interface ConnectorsApiGetConnectorRequest {
    /**
     * The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiGetConnector
     */
    readonly scriptName: string

    /**
     * The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
     * @type {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'}
     * @memberof ConnectorsApiGetConnector
     */
    readonly locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'
}

/**
 * Request parameters for getConnectorCorrelationConfig operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiGetConnectorCorrelationConfigRequest
 */
export interface ConnectorsApiGetConnectorCorrelationConfigRequest {
    /**
     * The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiGetConnectorCorrelationConfig
     */
    readonly scriptName: string
}

/**
 * Request parameters for getConnectorList operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiGetConnectorListRequest
 */
export interface ConnectorsApiGetConnectorListRequest {
    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *sw, co*  **type**: *sw, co, eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*  **labels**: *ca*
     * @type {string}
     * @memberof ConnectorsApiGetConnectorList
     */
    readonly filters?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ConnectorsApiGetConnectorList
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ConnectorsApiGetConnectorList
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ConnectorsApiGetConnectorList
     */
    readonly count?: boolean

    /**
     * The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
     * @type {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'}
     * @memberof ConnectorsApiGetConnectorList
     */
    readonly locale?: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'
}

/**
 * Request parameters for getConnectorSourceConfig operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiGetConnectorSourceConfigRequest
 */
export interface ConnectorsApiGetConnectorSourceConfigRequest {
    /**
     * The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiGetConnectorSourceConfig
     */
    readonly scriptName: string
}

/**
 * Request parameters for getConnectorSourceTemplate operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiGetConnectorSourceTemplateRequest
 */
export interface ConnectorsApiGetConnectorSourceTemplateRequest {
    /**
     * The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiGetConnectorSourceTemplate
     */
    readonly scriptName: string
}

/**
 * Request parameters for getConnectorTranslations operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiGetConnectorTranslationsRequest
 */
export interface ConnectorsApiGetConnectorTranslationsRequest {
    /**
     * The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiGetConnectorTranslations
     */
    readonly scriptName: string

    /**
     * The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
     * @type {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'}
     * @memberof ConnectorsApiGetConnectorTranslations
     */
    readonly locale: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'
}

/**
 * Request parameters for putCorrelationConfig operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiPutCorrelationConfigRequest
 */
export interface ConnectorsApiPutCorrelationConfigRequest {
    /**
     * The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiPutCorrelationConfig
     */
    readonly scriptName: string

    /**
     * connector correlation config xml file
     * @type {any}
     * @memberof ConnectorsApiPutCorrelationConfig
     */
    readonly file: any
}

/**
 * Request parameters for putSourceConfig operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiPutSourceConfigRequest
 */
export interface ConnectorsApiPutSourceConfigRequest {
    /**
     * The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiPutSourceConfig
     */
    readonly scriptName: string

    /**
     * connector source config xml file
     * @type {any}
     * @memberof ConnectorsApiPutSourceConfig
     */
    readonly file: any
}

/**
 * Request parameters for putSourceTemplate operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiPutSourceTemplateRequest
 */
export interface ConnectorsApiPutSourceTemplateRequest {
    /**
     * The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiPutSourceTemplate
     */
    readonly scriptName: string

    /**
     * connector source template xml file
     * @type {any}
     * @memberof ConnectorsApiPutSourceTemplate
     */
    readonly file: any
}

/**
 * Request parameters for putTranslations operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiPutTranslationsRequest
 */
export interface ConnectorsApiPutTranslationsRequest {
    /**
     * The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiPutTranslations
     */
    readonly scriptName: string

    /**
     * The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
     * @type {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'}
     * @memberof ConnectorsApiPutTranslations
     */
    readonly locale: 'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'
}

/**
 * Request parameters for updateConnector operation in ConnectorsApi.
 * @export
 * @interface ConnectorsApiUpdateConnectorRequest
 */
export interface ConnectorsApiUpdateConnectorRequest {
    /**
     * The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
     * @type {string}
     * @memberof ConnectorsApiUpdateConnector
     */
    readonly scriptName: string

    /**
     * A list of connector detail update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperation>}
     * @memberof ConnectorsApiUpdateConnector
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * ConnectorsApi - object-oriented interface
 * @export
 * @class ConnectorsApi
 * @extends {BaseAPI}
 */
export class ConnectorsApi extends BaseAPI {
    /**
     * Create custom connector. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create custom connector
     * @param {ConnectorsApiCreateCustomConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public createCustomConnector(requestParameters: ConnectorsApiCreateCustomConnectorRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).createCustomConnector(requestParameters.v3CreateConnectorDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @summary Deletes connector by script name
     * @param {ConnectorsApiDeleteCustomConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public deleteCustomConnector(requestParameters: ConnectorsApiDeleteCustomConnectorRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).deleteCustomConnector(requestParameters.scriptName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @summary Gets connector by script name
     * @param {ConnectorsApiGetConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnector(requestParameters: ConnectorsApiGetConnectorRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnector(requestParameters.scriptName, requestParameters.locale, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiGetConnectorCorrelationConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnectorCorrelationConfig(requestParameters: ConnectorsApiGetConnectorCorrelationConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectorCorrelationConfig(requestParameters.scriptName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination. A token with ORG_ADMIN authority is required to call this API.
     * @summary Gets connector list
     * @param {ConnectorsApiGetConnectorListRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnectorList(requestParameters: ConnectorsApiGetConnectorListRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectorList(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.locale, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiGetConnectorSourceConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnectorSourceConfig(requestParameters: ConnectorsApiGetConnectorSourceConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectorSourceConfig(requestParameters.scriptName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiGetConnectorSourceTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnectorSourceTemplate(requestParameters: ConnectorsApiGetConnectorSourceTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectorSourceTemplate(requestParameters.scriptName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiGetConnectorTranslationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnectorTranslations(requestParameters: ConnectorsApiGetConnectorTranslationsRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectorTranslations(requestParameters.scriptName, requestParameters.locale, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiPutCorrelationConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public putCorrelationConfig(requestParameters: ConnectorsApiPutCorrelationConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).putCorrelationConfig(requestParameters.scriptName, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiPutSourceConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public putSourceConfig(requestParameters: ConnectorsApiPutSourceConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).putSourceConfig(requestParameters.scriptName, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiPutSourceTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public putSourceTemplate(requestParameters: ConnectorsApiPutSourceTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).putSourceTemplate(requestParameters.scriptName, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiPutTranslationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public putTranslations(requestParameters: ConnectorsApiPutTranslationsRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).putTranslations(requestParameters.scriptName, requestParameters.locale, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API. The following fields are patchable: * connectorMetadata * applicationXml * correlationConfigXml * sourceConfigXml
     * @summary Update connector by script name
     * @param {ConnectorsApiUpdateConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public updateConnector(requestParameters: ConnectorsApiUpdateConnectorRequest, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).updateConnector(requestParameters.scriptName, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GlobalTenantSecuritySettingsApi - axios parameter creator
 * @export
 */
export const GlobalTenantSecuritySettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:create\'
         * @summary Create security network configuration.
         * @param {NetworkConfiguration} networkConfiguration Network configuration creation request body.   The following constraints ensure the request body conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAuthOrgNetworkConfig: async (networkConfiguration: NetworkConfiguration, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkConfiguration' is not null or undefined
            assertParamExists('createAuthOrgNetworkConfig', 'networkConfiguration', networkConfiguration)
            const localVarPath = `/auth-org/network-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:read\'
         * @summary Get security network configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgNetworkConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth-org/network-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
         * @summary Update security network configuration.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org network configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Network Config conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgNetworkConfig: async (jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchAuthOrgNetworkConfig', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/auth-org/network-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlobalTenantSecuritySettingsApi - functional programming interface
 * @export
 */
export const GlobalTenantSecuritySettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GlobalTenantSecuritySettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:create\'
         * @summary Create security network configuration.
         * @param {NetworkConfiguration} networkConfiguration Network configuration creation request body.   The following constraints ensure the request body conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthOrgNetworkConfig(networkConfiguration: NetworkConfiguration, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthOrgNetworkConfig(networkConfiguration, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:read\'
         * @summary Get security network configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthOrgNetworkConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthOrgNetworkConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
         * @summary Update security network configuration.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org network configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Network Config conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAuthOrgNetworkConfig(jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAuthOrgNetworkConfig(jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GlobalTenantSecuritySettingsApi - factory interface
 * @export
 */
export const GlobalTenantSecuritySettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GlobalTenantSecuritySettingsApiFp(configuration)
    return {
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:create\'
         * @summary Create security network configuration.
         * @param {NetworkConfiguration} networkConfiguration Network configuration creation request body.   The following constraints ensure the request body conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAuthOrgNetworkConfig(networkConfiguration: NetworkConfiguration, axiosOptions?: any): AxiosPromise<NetworkConfiguration> {
            return localVarFp.createAuthOrgNetworkConfig(networkConfiguration, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:read\'
         * @summary Get security network configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgNetworkConfig(axiosOptions?: any): AxiosPromise<NetworkConfiguration> {
            return localVarFp.getAuthOrgNetworkConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
         * @summary Update security network configuration.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org network configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Network Config conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgNetworkConfig(jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<NetworkConfiguration> {
            return localVarFp.patchAuthOrgNetworkConfig(jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAuthOrgNetworkConfig operation in GlobalTenantSecuritySettingsApi.
 * @export
 * @interface GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest
 */
export interface GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest {
    /**
     * Network configuration creation request body.   The following constraints ensure the request body conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
     * @type {NetworkConfiguration}
     * @memberof GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfig
     */
    readonly networkConfiguration: NetworkConfiguration
}

/**
 * Request parameters for patchAuthOrgNetworkConfig operation in GlobalTenantSecuritySettingsApi.
 * @export
 * @interface GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest
 */
export interface GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest {
    /**
     * A list of auth org network configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Network Config conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
     * @type {Array<JsonPatchOperation>}
     * @memberof GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfig
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * GlobalTenantSecuritySettingsApi - object-oriented interface
 * @export
 * @class GlobalTenantSecuritySettingsApi
 * @extends {BaseAPI}
 */
export class GlobalTenantSecuritySettingsApi extends BaseAPI {
    /**
     * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:create\'
     * @summary Create security network configuration.
     * @param {GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public createAuthOrgNetworkConfig(requestParameters: GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).createAuthOrgNetworkConfig(requestParameters.networkConfiguration, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:read\'
     * @summary Get security network configuration.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public getAuthOrgNetworkConfig(axiosOptions?: AxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).getAuthOrgNetworkConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
     * @summary Update security network configuration.
     * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    public patchAuthOrgNetworkConfig(requestParameters: GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return GlobalTenantSecuritySettingsApiFp(this.configuration).patchAuthOrgNetworkConfig(requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdentityProfilesApi - axios parameter creator
 * @export
 */
export const IdentityProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This deletes an Identity Profile based on ID.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete an Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfile: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('deleteIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete Identity Profiles
         * @param {Array<string>} requestBody Identity Profile bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfiles: async (requestBody: Array<string>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('deleteIdentityProfiles', 'requestBody', requestBody)
            const localVarPath = `/identity-profiles/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-profiles/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getDefaultIdentityAttributeConfig', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/default-identity-attribute-config`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles: async (identityProfileExportedObject: Array<IdentityProfileExportedObject>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileExportedObject' is not null or undefined
            assertParamExists('importIdentityProfiles', 'identityProfileExportedObject', identityProfileExportedObject)
            const localVarPath = `/identity-profiles/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProfileExportedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne, ge, gt, in, le, lt, isnull, sw*  **name**: *eq, ne, in, le, lt, isnull, sw*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority, created, modified, owner.id, owner.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Process identities under the profile This operation should not be used to schedule your own identity processing or to perform system wide identity refreshes. The system will use a combination of [event-based processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#event-based-processing) and [scheduled processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#scheduled-processing) that runs every day at 8:00 AM and 8:00 PM in the tenant\'s timezone to keep your identities synchronized.  This should only be run on identity profiles that have the `identityRefreshRequired` attribute set to `true`. If `identityRefreshRequired` is false, then there is no benefit to running this operation. Typically, this operation is performed when a change is made to the identity profile or its related lifecycle states that requires a refresh. This operation will perform the following activities on all identities under the identity profile. 1. Updates identity attribute according to the identity profile mappings. 2. Determines the identity\'s correct manager through manager correlation. 3. Updates the identity\'s access according to their assigned lifecycle state. 4. Updates the identity\'s access based on role assignment criteria. A token with ORG_ADMIN authority is required to call this API.
         * @summary Process identities under profile
         * @param {string} identityProfileId The Identity Profile ID to be processed
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        syncIdentityProfile: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('syncIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/process-identities`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityProfilesApi - functional programming interface
 * @export
 */
export const IdentityProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * This deletes an Identity Profile based on ID.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete an Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityProfile(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResultSimplified>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityProfile(identityProfileId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete Identity Profiles
         * @param {Array<string>} requestBody Identity Profile bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityProfiles(requestBody: Array<string>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResultSimplified>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityProfiles(requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProfileExportedObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultIdentityAttributeConfig(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityAttributeConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultIdentityAttributeConfig(identityProfileId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityProfile(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityProfile(identityProfileId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importIdentityProfiles(identityProfileExportedObject: Array<IdentityProfileExportedObject>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectImportResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importIdentityProfiles(identityProfileExportedObject, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne, ge, gt, in, le, lt, isnull, sw*  **name**: *eq, ne, in, le, lt, isnull, sw*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority, created, modified, owner.id, owner.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process identities under the profile This operation should not be used to schedule your own identity processing or to perform system wide identity refreshes. The system will use a combination of [event-based processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#event-based-processing) and [scheduled processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#scheduled-processing) that runs every day at 8:00 AM and 8:00 PM in the tenant\'s timezone to keep your identities synchronized.  This should only be run on identity profiles that have the `identityRefreshRequired` attribute set to `true`. If `identityRefreshRequired` is false, then there is no benefit to running this operation. Typically, this operation is performed when a change is made to the identity profile or its related lifecycle states that requires a refresh. This operation will perform the following activities on all identities under the identity profile. 1. Updates identity attribute according to the identity profile mappings. 2. Determines the identity\'s correct manager through manager correlation. 3. Updates the identity\'s access according to their assigned lifecycle state. 4. Updates the identity\'s access based on role assignment criteria. A token with ORG_ADMIN authority is required to call this API.
         * @summary Process identities under profile
         * @param {string} identityProfileId The Identity Profile ID to be processed
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async syncIdentityProfile(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncIdentityProfile(identityProfileId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdentityProfilesApi - factory interface
 * @export
 */
export const IdentityProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityProfilesApiFp(configuration)
    return {
        /**
         * This deletes an Identity Profile based on ID.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete an Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfile(identityProfileId: string, axiosOptions?: any): AxiosPromise<TaskResultSimplified> {
            return localVarFp.deleteIdentityProfile(identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete Identity Profiles
         * @param {Array<string>} requestBody Identity Profile bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfiles(requestBody: Array<string>, axiosOptions?: any): AxiosPromise<TaskResultSimplified> {
            return localVarFp.deleteIdentityProfiles(requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<IdentityProfileExportedObject>> {
            return localVarFp.exportIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig(identityProfileId: string, axiosOptions?: any): AxiosPromise<IdentityAttributeConfig> {
            return localVarFp.getDefaultIdentityAttributeConfig(identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile(identityProfileId: string, axiosOptions?: any): AxiosPromise<IdentityProfile> {
            return localVarFp.getIdentityProfile(identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles(identityProfileExportedObject: Array<IdentityProfileExportedObject>, axiosOptions?: any): AxiosPromise<ObjectImportResult> {
            return localVarFp.importIdentityProfiles(identityProfileExportedObject, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne, ge, gt, in, le, lt, isnull, sw*  **name**: *eq, ne, in, le, lt, isnull, sw*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority, created, modified, owner.id, owner.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<IdentityProfile>> {
            return localVarFp.listIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Process identities under the profile This operation should not be used to schedule your own identity processing or to perform system wide identity refreshes. The system will use a combination of [event-based processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#event-based-processing) and [scheduled processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#scheduled-processing) that runs every day at 8:00 AM and 8:00 PM in the tenant\'s timezone to keep your identities synchronized.  This should only be run on identity profiles that have the `identityRefreshRequired` attribute set to `true`. If `identityRefreshRequired` is false, then there is no benefit to running this operation. Typically, this operation is performed when a change is made to the identity profile or its related lifecycle states that requires a refresh. This operation will perform the following activities on all identities under the identity profile. 1. Updates identity attribute according to the identity profile mappings. 2. Determines the identity\'s correct manager through manager correlation. 3. Updates the identity\'s access according to their assigned lifecycle state. 4. Updates the identity\'s access based on role assignment criteria. A token with ORG_ADMIN authority is required to call this API.
         * @summary Process identities under profile
         * @param {string} identityProfileId The Identity Profile ID to be processed
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        syncIdentityProfile(identityProfileId: string, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.syncIdentityProfile(identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteIdentityProfile operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiDeleteIdentityProfileRequest
 */
export interface IdentityProfilesApiDeleteIdentityProfileRequest {
    /**
     * The Identity Profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiDeleteIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for deleteIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiDeleteIdentityProfilesRequest
 */
export interface IdentityProfilesApiDeleteIdentityProfilesRequest {
    /**
     * Identity Profile bulk delete request body.
     * @type {Array<string>}
     * @memberof IdentityProfilesApiDeleteIdentityProfiles
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for exportIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiExportIdentityProfilesRequest
 */
export interface IdentityProfilesApiExportIdentityProfilesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
     * @type {string}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority**
     * @type {string}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly sorters?: string
}

/**
 * Request parameters for getDefaultIdentityAttributeConfig operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest
 */
export interface IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest {
    /**
     * The Identity Profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiGetDefaultIdentityAttributeConfig
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for getIdentityProfile operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiGetIdentityProfileRequest
 */
export interface IdentityProfilesApiGetIdentityProfileRequest {
    /**
     * The Identity Profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiGetIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for importIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiImportIdentityProfilesRequest
 */
export interface IdentityProfilesApiImportIdentityProfilesRequest {
    /**
     * Previously exported Identity Profiles.
     * @type {Array<IdentityProfileExportedObject>}
     * @memberof IdentityProfilesApiImportIdentityProfiles
     */
    readonly identityProfileExportedObject: Array<IdentityProfileExportedObject>
}

/**
 * Request parameters for listIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiListIdentityProfilesRequest
 */
export interface IdentityProfilesApiListIdentityProfilesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne, ge, gt, in, le, lt, isnull, sw*  **name**: *eq, ne, in, le, lt, isnull, sw*  **priority**: *eq, ne*
     * @type {string}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority, created, modified, owner.id, owner.name**
     * @type {string}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly sorters?: string
}

/**
 * Request parameters for syncIdentityProfile operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiSyncIdentityProfileRequest
 */
export interface IdentityProfilesApiSyncIdentityProfileRequest {
    /**
     * The Identity Profile ID to be processed
     * @type {string}
     * @memberof IdentityProfilesApiSyncIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * IdentityProfilesApi - object-oriented interface
 * @export
 * @class IdentityProfilesApi
 * @extends {BaseAPI}
 */
export class IdentityProfilesApi extends BaseAPI {
    /**
     * This deletes an Identity Profile based on ID.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
     * @summary Delete an Identity Profile
     * @param {IdentityProfilesApiDeleteIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public deleteIdentityProfile(requestParameters: IdentityProfilesApiDeleteIdentityProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).deleteIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
     * @summary Delete Identity Profiles
     * @param {IdentityProfilesApiDeleteIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public deleteIdentityProfiles(requestParameters: IdentityProfilesApiDeleteIdentityProfilesRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).deleteIdentityProfiles(requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This exports existing identity profiles in the format specified by the sp-config service.
     * @summary Export Identity Profiles
     * @param {IdentityProfilesApiExportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public exportIdentityProfiles(requestParameters: IdentityProfilesApiExportIdentityProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).exportIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
     * @summary Get default Identity Attribute Config
     * @param {IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public getDefaultIdentityAttributeConfig(requestParameters: IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).getDefaultIdentityAttributeConfig(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Get single Identity Profile
     * @param {IdentityProfilesApiGetIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public getIdentityProfile(requestParameters: IdentityProfilesApiGetIdentityProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).getIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This imports previously exported identity profiles.
     * @summary Import Identity Profiles
     * @param {IdentityProfilesApiImportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public importIdentityProfiles(requestParameters: IdentityProfilesApiImportIdentityProfilesRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).importIdentityProfiles(requestParameters.identityProfileExportedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
     * @summary Identity Profiles List
     * @param {IdentityProfilesApiListIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public listIdentityProfiles(requestParameters: IdentityProfilesApiListIdentityProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).listIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process identities under the profile This operation should not be used to schedule your own identity processing or to perform system wide identity refreshes. The system will use a combination of [event-based processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#event-based-processing) and [scheduled processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#scheduled-processing) that runs every day at 8:00 AM and 8:00 PM in the tenant\'s timezone to keep your identities synchronized.  This should only be run on identity profiles that have the `identityRefreshRequired` attribute set to `true`. If `identityRefreshRequired` is false, then there is no benefit to running this operation. Typically, this operation is performed when a change is made to the identity profile or its related lifecycle states that requires a refresh. This operation will perform the following activities on all identities under the identity profile. 1. Updates identity attribute according to the identity profile mappings. 2. Determines the identity\'s correct manager through manager correlation. 3. Updates the identity\'s access according to their assigned lifecycle state. 4. Updates the identity\'s access based on role assignment criteria. A token with ORG_ADMIN authority is required to call this API.
     * @summary Process identities under profile
     * @param {IdentityProfilesApiSyncIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public syncIdentityProfile(requestParameters: IdentityProfilesApiSyncIdentityProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).syncIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LifecycleStatesApi - axios parameter creator
 * @export
 */
export const LifecycleStatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create a lifecycle state. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {LifecycleState} lifecycleState Lifecycle state to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createLifecycleState: async (identityProfileId: string, lifecycleState: LifecycleState, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('createLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleState' is not null or undefined
            assertParamExists('createLifecycleState', 'lifecycleState', lifecycleState)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lifecycleState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete the lifecycle state by its ID.  A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteLifecycleState: async (identityProfileId: string, lifecycleStateId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('deleteLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('deleteLifecycleState', 'lifecycleStateId', lifecycleStateId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to get a lifecycle state by its ID and its associated identity profile ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleState: async (identityProfileId: string, lifecycleStateId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('getLifecycleState', 'lifecycleStateId', lifecycleStateId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all lifecycle states by their associated identity profiles.  A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId Identity profile ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleStates: async (identityProfileId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getLifecycleStates', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to set/update an identity\'s lifecycle state to the one provided and update the corresponding identity profile. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId The ID of the identity to update.
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setLifecycleState: async (identityId: string, setLifecycleStateRequest: SetLifecycleStateRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('setLifecycleState', 'identityId', identityId)
            // verify required parameter 'setLifecycleStateRequest' is not null or undefined
            assertParamExists('setLifecycleState', 'setLifecycleStateRequest', setLifecycleStateRequest)
            const localVarPath = `/identities/{identity-id}/set-lifecycle-state`
                .replace(`{${"identity-id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setLifecycleStateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update individual lifecycle state fields, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates: async (identityProfileId: string, lifecycleStateId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('updateLifecycleStates', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('updateLifecycleStates', 'lifecycleStateId', lifecycleStateId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateLifecycleStates', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * LifecycleStatesApi - functional programming interface
 * @export
 */
export const LifecycleStatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LifecycleStatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create a lifecycle state. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {LifecycleState} lifecycleState Lifecycle state to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createLifecycleState(identityProfileId: string, lifecycleState: LifecycleState, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLifecycleState(identityProfileId, lifecycleState, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete the lifecycle state by its ID.  A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecyclestateDeleted>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLifecycleState(identityProfileId, lifecycleStateId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to get a lifecycle state by its ID and its associated identity profile ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLifecycleState(identityProfileId, lifecycleStateId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all lifecycle states by their associated identity profiles.  A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId Identity profile ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLifecycleStates(identityProfileId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifecycleState>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLifecycleStates(identityProfileId, limit, offset, count, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to set/update an identity\'s lifecycle state to the one provided and update the corresponding identity profile. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId The ID of the identity to update.
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setLifecycleState(identityId: string, setLifecycleStateRequest: SetLifecycleStateRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetLifecycleState200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setLifecycleState(identityId, setLifecycleStateRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update individual lifecycle state fields, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateLifecycleStates(identityProfileId: string, lifecycleStateId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLifecycleStates(identityProfileId, lifecycleStateId, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LifecycleStatesApi - factory interface
 * @export
 */
export const LifecycleStatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LifecycleStatesApiFp(configuration)
    return {
        /**
         * Use this endpoint to create a lifecycle state. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {LifecycleState} lifecycleState Lifecycle state to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createLifecycleState(identityProfileId: string, lifecycleState: LifecycleState, axiosOptions?: any): AxiosPromise<LifecycleState> {
            return localVarFp.createLifecycleState(identityProfileId, lifecycleState, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete the lifecycle state by its ID.  A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: any): AxiosPromise<LifecyclestateDeleted> {
            return localVarFp.deleteLifecycleState(identityProfileId, lifecycleStateId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to get a lifecycle state by its ID and its associated identity profile ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: any): AxiosPromise<LifecycleState> {
            return localVarFp.getLifecycleState(identityProfileId, lifecycleStateId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all lifecycle states by their associated identity profiles.  A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId Identity profile ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleStates(identityProfileId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: any): AxiosPromise<Array<LifecycleState>> {
            return localVarFp.getLifecycleStates(identityProfileId, limit, offset, count, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to set/update an identity\'s lifecycle state to the one provided and update the corresponding identity profile. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId The ID of the identity to update.
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setLifecycleState(identityId: string, setLifecycleStateRequest: SetLifecycleStateRequest, axiosOptions?: any): AxiosPromise<SetLifecycleState200Response> {
            return localVarFp.setLifecycleState(identityId, setLifecycleStateRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update individual lifecycle state fields, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates(identityProfileId: string, lifecycleStateId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<LifecycleState> {
            return localVarFp.updateLifecycleStates(identityProfileId, lifecycleStateId, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiCreateLifecycleStateRequest
 */
export interface LifecycleStatesApiCreateLifecycleStateRequest {
    /**
     * Identity profile ID.
     * @type {string}
     * @memberof LifecycleStatesApiCreateLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle state to be created.
     * @type {LifecycleState}
     * @memberof LifecycleStatesApiCreateLifecycleState
     */
    readonly lifecycleState: LifecycleState
}

/**
 * Request parameters for deleteLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiDeleteLifecycleStateRequest
 */
export interface LifecycleStatesApiDeleteLifecycleStateRequest {
    /**
     * Identity profile ID.
     * @type {string}
     * @memberof LifecycleStatesApiDeleteLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle state ID.
     * @type {string}
     * @memberof LifecycleStatesApiDeleteLifecycleState
     */
    readonly lifecycleStateId: string
}

/**
 * Request parameters for getLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiGetLifecycleStateRequest
 */
export interface LifecycleStatesApiGetLifecycleStateRequest {
    /**
     * Identity profile ID.
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle state ID.
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleState
     */
    readonly lifecycleStateId: string
}

/**
 * Request parameters for getLifecycleStates operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiGetLifecycleStatesRequest
 */
export interface LifecycleStatesApiGetLifecycleStatesRequest {
    /**
     * Identity profile ID.
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleStates
     */
    readonly identityProfileId: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof LifecycleStatesApiGetLifecycleStates
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof LifecycleStatesApiGetLifecycleStates
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof LifecycleStatesApiGetLifecycleStates
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleStates
     */
    readonly sorters?: string
}

/**
 * Request parameters for setLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiSetLifecycleStateRequest
 */
export interface LifecycleStatesApiSetLifecycleStateRequest {
    /**
     * The ID of the identity to update.
     * @type {string}
     * @memberof LifecycleStatesApiSetLifecycleState
     */
    readonly identityId: string

    /**
     * 
     * @type {SetLifecycleStateRequest}
     * @memberof LifecycleStatesApiSetLifecycleState
     */
    readonly setLifecycleStateRequest: SetLifecycleStateRequest
}

/**
 * Request parameters for updateLifecycleStates operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiUpdateLifecycleStatesRequest
 */
export interface LifecycleStatesApiUpdateLifecycleStatesRequest {
    /**
     * Identity profile ID.
     * @type {string}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly identityProfileId: string

    /**
     * Lifecycle state ID.
     * @type {string}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly lifecycleStateId: string

    /**
     * A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
     * @type {Array<JsonPatchOperation>}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * LifecycleStatesApi - object-oriented interface
 * @export
 * @class LifecycleStatesApi
 * @extends {BaseAPI}
 */
export class LifecycleStatesApi extends BaseAPI {
    /**
     * Use this endpoint to create a lifecycle state. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Create Lifecycle State
     * @param {LifecycleStatesApiCreateLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public createLifecycleState(requestParameters: LifecycleStatesApiCreateLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).createLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleState, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete the lifecycle state by its ID.  A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Delete Lifecycle State
     * @param {LifecycleStatesApiDeleteLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public deleteLifecycleState(requestParameters: LifecycleStatesApiDeleteLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).deleteLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to get a lifecycle state by its ID and its associated identity profile ID.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Get Lifecycle State
     * @param {LifecycleStatesApiGetLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public getLifecycleState(requestParameters: LifecycleStatesApiGetLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).getLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all lifecycle states by their associated identity profiles.  A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Lists LifecycleStates
     * @param {LifecycleStatesApiGetLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public getLifecycleStates(requestParameters: LifecycleStatesApiGetLifecycleStatesRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).getLifecycleStates(requestParameters.identityProfileId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to set/update an identity\'s lifecycle state to the one provided and update the corresponding identity profile. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Set Lifecycle State
     * @param {LifecycleStatesApiSetLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public setLifecycleState(requestParameters: LifecycleStatesApiSetLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).setLifecycleState(requestParameters.identityId, requestParameters.setLifecycleStateRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update individual lifecycle state fields, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Update Lifecycle State
     * @param {LifecycleStatesApiUpdateLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public updateLifecycleStates(requestParameters: LifecycleStatesApiUpdateLifecycleStatesRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).updateLifecycleStates(requestParameters.identityProfileId, requestParameters.lifecycleStateId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MFAConfigurationApi - axios parameter creator
 * @export
 */
export const MFAConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API removes the configuration for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete MFA method configuration
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteMFAConfig: async (method: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'method' is not null or undefined
            assertParamExists('deleteMFAConfig', 'method', method)
            const localVarPath = `/mfa/{method}/delete`
                .replace(`{${"method"}}`, encodeURIComponent(String(method)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of Duo MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFADuoConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mfa/duo-web/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the KBA configuration for MFA. A token with USER or ORG_ADMIN authority is required to call this API.
         * @summary Configuration of KBA MFA method
         * @param {boolean} [allLanguages] Indicator whether the question text should be returned in all configured languages    * If true, the question text is returned in all languages that it is configured in.    * If false, the question text is returned in the user locale if available, else for the default locale.     * If not passed, it behaves the same way as passing this parameter as false
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAKbaConfig: async (allLanguages?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mfa/kba/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (allLanguages !== undefined) {
                localVarQueryParameter['allLanguages'] = allLanguages;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of Okta MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAOktaConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mfa/okta-verify/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API sets the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set Duo MFA configuration
         * @param {MfaDuoConfig} mfaDuoConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFADuoConfig: async (mfaDuoConfig: MfaDuoConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mfaDuoConfig' is not null or undefined
            assertParamExists('setMFADuoConfig', 'mfaDuoConfig', mfaDuoConfig)
            const localVarPath = `/mfa/duo-web/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaDuoConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API sets answers to challenge questions.  Any configured questions omitted from the request are removed from user KBA configuration. A token with USER authority is required to call this API.
         * @summary Set MFA KBA configuration
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAKBAConfig: async (kbaAnswerRequestItem: Array<KbaAnswerRequestItem>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'kbaAnswerRequestItem' is not null or undefined
            assertParamExists('setMFAKBAConfig', 'kbaAnswerRequestItem', kbaAnswerRequestItem)
            const localVarPath = `/mfa/kba/config/answers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kbaAnswerRequestItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API sets the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set Okta MFA configuration
         * @param {MfaOktaConfig} mfaOktaConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAOktaConfig: async (mfaOktaConfig: MfaOktaConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mfaOktaConfig' is not null or undefined
            assertParamExists('setMFAOktaConfig', 'mfaOktaConfig', mfaOktaConfig)
            const localVarPath = `/mfa/okta-verify/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaOktaConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter. A token with ORG_ADMIN authority is required to call this API.
         * @summary MFA method\'s test configuration
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testMFAConfig: async (method: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'method' is not null or undefined
            assertParamExists('testMFAConfig', 'method', method)
            const localVarPath = `/mfa/{method}/test`
                .replace(`{${"method"}}`, encodeURIComponent(String(method)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * MFAConfigurationApi - functional programming interface
 * @export
 */
export const MFAConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MFAConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * This API removes the configuration for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete MFA method configuration
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMFAConfig(method: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaOktaConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMFAConfig(method, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of Duo MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getMFADuoConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaDuoConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMFADuoConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the KBA configuration for MFA. A token with USER or ORG_ADMIN authority is required to call this API.
         * @summary Configuration of KBA MFA method
         * @param {boolean} [allLanguages] Indicator whether the question text should be returned in all configured languages    * If true, the question text is returned in all languages that it is configured in.    * If false, the question text is returned in the user locale if available, else for the default locale.     * If not passed, it behaves the same way as passing this parameter as false
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getMFAKbaConfig(allLanguages?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KbaQuestion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMFAKbaConfig(allLanguages, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of Okta MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getMFAOktaConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaOktaConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMFAOktaConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API sets the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set Duo MFA configuration
         * @param {MfaDuoConfig} mfaDuoConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setMFADuoConfig(mfaDuoConfig: MfaDuoConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaDuoConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMFADuoConfig(mfaDuoConfig, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API sets answers to challenge questions.  Any configured questions omitted from the request are removed from user KBA configuration. A token with USER authority is required to call this API.
         * @summary Set MFA KBA configuration
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setMFAKBAConfig(kbaAnswerRequestItem: Array<KbaAnswerRequestItem>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KbaAnswerResponseItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMFAKBAConfig(kbaAnswerRequestItem, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API sets the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set Okta MFA configuration
         * @param {MfaOktaConfig} mfaOktaConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setMFAOktaConfig(mfaOktaConfig: MfaOktaConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaOktaConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMFAOktaConfig(mfaOktaConfig, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter. A token with ORG_ADMIN authority is required to call this API.
         * @summary MFA method\'s test configuration
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async testMFAConfig(method: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaConfigTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testMFAConfig(method, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MFAConfigurationApi - factory interface
 * @export
 */
export const MFAConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MFAConfigurationApiFp(configuration)
    return {
        /**
         * This API removes the configuration for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete MFA method configuration
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteMFAConfig(method: string, axiosOptions?: any): AxiosPromise<MfaOktaConfig> {
            return localVarFp.deleteMFAConfig(method, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of Duo MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFADuoConfig(axiosOptions?: any): AxiosPromise<MfaDuoConfig> {
            return localVarFp.getMFADuoConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the KBA configuration for MFA. A token with USER or ORG_ADMIN authority is required to call this API.
         * @summary Configuration of KBA MFA method
         * @param {boolean} [allLanguages] Indicator whether the question text should be returned in all configured languages    * If true, the question text is returned in all languages that it is configured in.    * If false, the question text is returned in the user locale if available, else for the default locale.     * If not passed, it behaves the same way as passing this parameter as false
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAKbaConfig(allLanguages?: boolean, axiosOptions?: any): AxiosPromise<Array<KbaQuestion>> {
            return localVarFp.getMFAKbaConfig(allLanguages, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of Okta MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAOktaConfig(axiosOptions?: any): AxiosPromise<MfaOktaConfig> {
            return localVarFp.getMFAOktaConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API sets the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set Duo MFA configuration
         * @param {MfaDuoConfig} mfaDuoConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFADuoConfig(mfaDuoConfig: MfaDuoConfig, axiosOptions?: any): AxiosPromise<MfaDuoConfig> {
            return localVarFp.setMFADuoConfig(mfaDuoConfig, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API sets answers to challenge questions.  Any configured questions omitted from the request are removed from user KBA configuration. A token with USER authority is required to call this API.
         * @summary Set MFA KBA configuration
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAKBAConfig(kbaAnswerRequestItem: Array<KbaAnswerRequestItem>, axiosOptions?: any): AxiosPromise<Array<KbaAnswerResponseItem>> {
            return localVarFp.setMFAKBAConfig(kbaAnswerRequestItem, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API sets the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set Okta MFA configuration
         * @param {MfaOktaConfig} mfaOktaConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAOktaConfig(mfaOktaConfig: MfaOktaConfig, axiosOptions?: any): AxiosPromise<MfaOktaConfig> {
            return localVarFp.setMFAOktaConfig(mfaOktaConfig, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter. A token with ORG_ADMIN authority is required to call this API.
         * @summary MFA method\'s test configuration
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testMFAConfig(method: string, axiosOptions?: any): AxiosPromise<MfaConfigTestResponse> {
            return localVarFp.testMFAConfig(method, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteMFAConfig operation in MFAConfigurationApi.
 * @export
 * @interface MFAConfigurationApiDeleteMFAConfigRequest
 */
export interface MFAConfigurationApiDeleteMFAConfigRequest {
    /**
     * The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
     * @type {string}
     * @memberof MFAConfigurationApiDeleteMFAConfig
     */
    readonly method: string
}

/**
 * Request parameters for getMFAKbaConfig operation in MFAConfigurationApi.
 * @export
 * @interface MFAConfigurationApiGetMFAKbaConfigRequest
 */
export interface MFAConfigurationApiGetMFAKbaConfigRequest {
    /**
     * Indicator whether the question text should be returned in all configured languages    * If true, the question text is returned in all languages that it is configured in.    * If false, the question text is returned in the user locale if available, else for the default locale.     * If not passed, it behaves the same way as passing this parameter as false
     * @type {boolean}
     * @memberof MFAConfigurationApiGetMFAKbaConfig
     */
    readonly allLanguages?: boolean
}

/**
 * Request parameters for setMFADuoConfig operation in MFAConfigurationApi.
 * @export
 * @interface MFAConfigurationApiSetMFADuoConfigRequest
 */
export interface MFAConfigurationApiSetMFADuoConfigRequest {
    /**
     * 
     * @type {MfaDuoConfig}
     * @memberof MFAConfigurationApiSetMFADuoConfig
     */
    readonly mfaDuoConfig: MfaDuoConfig
}

/**
 * Request parameters for setMFAKBAConfig operation in MFAConfigurationApi.
 * @export
 * @interface MFAConfigurationApiSetMFAKBAConfigRequest
 */
export interface MFAConfigurationApiSetMFAKBAConfigRequest {
    /**
     * 
     * @type {Array<KbaAnswerRequestItem>}
     * @memberof MFAConfigurationApiSetMFAKBAConfig
     */
    readonly kbaAnswerRequestItem: Array<KbaAnswerRequestItem>
}

/**
 * Request parameters for setMFAOktaConfig operation in MFAConfigurationApi.
 * @export
 * @interface MFAConfigurationApiSetMFAOktaConfigRequest
 */
export interface MFAConfigurationApiSetMFAOktaConfigRequest {
    /**
     * 
     * @type {MfaOktaConfig}
     * @memberof MFAConfigurationApiSetMFAOktaConfig
     */
    readonly mfaOktaConfig: MfaOktaConfig
}

/**
 * Request parameters for testMFAConfig operation in MFAConfigurationApi.
 * @export
 * @interface MFAConfigurationApiTestMFAConfigRequest
 */
export interface MFAConfigurationApiTestMFAConfigRequest {
    /**
     * The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
     * @type {string}
     * @memberof MFAConfigurationApiTestMFAConfig
     */
    readonly method: string
}

/**
 * MFAConfigurationApi - object-oriented interface
 * @export
 * @class MFAConfigurationApi
 * @extends {BaseAPI}
 */
export class MFAConfigurationApi extends BaseAPI {
    /**
     * This API removes the configuration for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete MFA method configuration
     * @param {MFAConfigurationApiDeleteMFAConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public deleteMFAConfig(requestParameters: MFAConfigurationApiDeleteMFAConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).deleteMFAConfig(requestParameters.method, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Configuration of Duo MFA method
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public getMFADuoConfig(axiosOptions?: AxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).getMFADuoConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the KBA configuration for MFA. A token with USER or ORG_ADMIN authority is required to call this API.
     * @summary Configuration of KBA MFA method
     * @param {MFAConfigurationApiGetMFAKbaConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public getMFAKbaConfig(requestParameters: MFAConfigurationApiGetMFAKbaConfigRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).getMFAKbaConfig(requestParameters.allLanguages, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Configuration of Okta MFA method
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public getMFAOktaConfig(axiosOptions?: AxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).getMFAOktaConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API sets the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Set Duo MFA configuration
     * @param {MFAConfigurationApiSetMFADuoConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public setMFADuoConfig(requestParameters: MFAConfigurationApiSetMFADuoConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).setMFADuoConfig(requestParameters.mfaDuoConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API sets answers to challenge questions.  Any configured questions omitted from the request are removed from user KBA configuration. A token with USER authority is required to call this API.
     * @summary Set MFA KBA configuration
     * @param {MFAConfigurationApiSetMFAKBAConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public setMFAKBAConfig(requestParameters: MFAConfigurationApiSetMFAKBAConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).setMFAKBAConfig(requestParameters.kbaAnswerRequestItem, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API sets the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Set Okta MFA configuration
     * @param {MFAConfigurationApiSetMFAOktaConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public setMFAOktaConfig(requestParameters: MFAConfigurationApiSetMFAOktaConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).setMFAOktaConfig(requestParameters.mfaOktaConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter. A token with ORG_ADMIN authority is required to call this API.
     * @summary MFA method\'s test configuration
     * @param {MFAConfigurationApiTestMFAConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    public testMFAConfig(requestParameters: MFAConfigurationApiTestMFAConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAConfigurationApiFp(this.configuration).testMFAConfig(requestParameters.method, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MFAControllerApi - axios parameter creator
 * @export
 */
export const MFAControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API send token request.
         * @summary Create and send user token
         * @param {SendTokenRequest} sendTokenRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSendToken: async (sendTokenRequest: SendTokenRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendTokenRequest' is not null or undefined
            assertParamExists('createSendToken', 'sendTokenRequest', sendTokenRequest)
            const localVarPath = `/mfa/token/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API poll the VerificationPollRequest for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Polling MFA method by VerificationPollRequest
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39;, \&#39;duo-web\&#39;, \&#39;kba\&#39;,\&#39;token\&#39;, \&#39;rsa\&#39;
         * @param {VerificationPollRequest} verificationPollRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        pingVerificationStatus: async (method: string, verificationPollRequest: VerificationPollRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'method' is not null or undefined
            assertParamExists('pingVerificationStatus', 'method', method)
            // verify required parameter 'verificationPollRequest' is not null or undefined
            assertParamExists('pingVerificationStatus', 'verificationPollRequest', verificationPollRequest)
            const localVarPath = `/mfa/{method}/poll`
                .replace(`{${"method"}}`, encodeURIComponent(String(method)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verificationPollRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API Authenticates the user via Duo-Web MFA method.
         * @summary Verifying authentication via Duo method
         * @param {DuoVerificationRequest} duoVerificationRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendDuoVerifyRequest: async (duoVerificationRequest: DuoVerificationRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'duoVerificationRequest' is not null or undefined
            assertParamExists('sendDuoVerifyRequest', 'duoVerificationRequest', duoVerificationRequest)
            const localVarPath = `/mfa/duo-web/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(duoVerificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API Authenticate user in KBA MFA method.
         * @summary Authenticate KBA provided MFA method
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendKbaAnswers: async (kbaAnswerRequestItem: Array<KbaAnswerRequestItem>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'kbaAnswerRequestItem' is not null or undefined
            assertParamExists('sendKbaAnswers', 'kbaAnswerRequestItem', kbaAnswerRequestItem)
            const localVarPath = `/mfa/kba/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kbaAnswerRequestItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API Authenticates the user via Okta-Verify MFA method. Request requires a header called \'slpt-forwarding\', and it must contain a remote IP Address of caller.
         * @summary Verifying authentication via Okta method
         * @param {OktaVerificationRequest} oktaVerificationRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendOktaVerifyRequest: async (oktaVerificationRequest: OktaVerificationRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oktaVerificationRequest' is not null or undefined
            assertParamExists('sendOktaVerifyRequest', 'oktaVerificationRequest', oktaVerificationRequest)
            const localVarPath = `/mfa/okta-verify/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oktaVerificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API Authenticate user in Token MFA method.
         * @summary Authenticate Token provided MFA method
         * @param {TokenAuthRequest} tokenAuthRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendTokenAuthRequest: async (tokenAuthRequest: TokenAuthRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenAuthRequest' is not null or undefined
            assertParamExists('sendTokenAuthRequest', 'tokenAuthRequest', tokenAuthRequest)
            const localVarPath = `/mfa/token/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * MFAControllerApi - functional programming interface
 * @export
 */
export const MFAControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MFAControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * This API send token request.
         * @summary Create and send user token
         * @param {SendTokenRequest} sendTokenRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSendToken(sendTokenRequest: SendTokenRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSendToken(sendTokenRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API poll the VerificationPollRequest for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Polling MFA method by VerificationPollRequest
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39;, \&#39;duo-web\&#39;, \&#39;kba\&#39;,\&#39;token\&#39;, \&#39;rsa\&#39;
         * @param {VerificationPollRequest} verificationPollRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async pingVerificationStatus(method: string, verificationPollRequest: VerificationPollRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingVerificationStatus(method, verificationPollRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API Authenticates the user via Duo-Web MFA method.
         * @summary Verifying authentication via Duo method
         * @param {DuoVerificationRequest} duoVerificationRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async sendDuoVerifyRequest(duoVerificationRequest: DuoVerificationRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendDuoVerifyRequest(duoVerificationRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API Authenticate user in KBA MFA method.
         * @summary Authenticate KBA provided MFA method
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async sendKbaAnswers(kbaAnswerRequestItem: Array<KbaAnswerRequestItem>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KbaAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendKbaAnswers(kbaAnswerRequestItem, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API Authenticates the user via Okta-Verify MFA method. Request requires a header called \'slpt-forwarding\', and it must contain a remote IP Address of caller.
         * @summary Verifying authentication via Okta method
         * @param {OktaVerificationRequest} oktaVerificationRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async sendOktaVerifyRequest(oktaVerificationRequest: OktaVerificationRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendOktaVerifyRequest(oktaVerificationRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API Authenticate user in Token MFA method.
         * @summary Authenticate Token provided MFA method
         * @param {TokenAuthRequest} tokenAuthRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async sendTokenAuthRequest(tokenAuthRequest: TokenAuthRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTokenAuthRequest(tokenAuthRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MFAControllerApi - factory interface
 * @export
 */
export const MFAControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MFAControllerApiFp(configuration)
    return {
        /**
         * This API send token request.
         * @summary Create and send user token
         * @param {SendTokenRequest} sendTokenRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSendToken(sendTokenRequest: SendTokenRequest, axiosOptions?: any): AxiosPromise<SendTokenResponse> {
            return localVarFp.createSendToken(sendTokenRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API poll the VerificationPollRequest for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Polling MFA method by VerificationPollRequest
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39;, \&#39;duo-web\&#39;, \&#39;kba\&#39;,\&#39;token\&#39;, \&#39;rsa\&#39;
         * @param {VerificationPollRequest} verificationPollRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        pingVerificationStatus(method: string, verificationPollRequest: VerificationPollRequest, axiosOptions?: any): AxiosPromise<VerificationResponse> {
            return localVarFp.pingVerificationStatus(method, verificationPollRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API Authenticates the user via Duo-Web MFA method.
         * @summary Verifying authentication via Duo method
         * @param {DuoVerificationRequest} duoVerificationRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendDuoVerifyRequest(duoVerificationRequest: DuoVerificationRequest, axiosOptions?: any): AxiosPromise<VerificationResponse> {
            return localVarFp.sendDuoVerifyRequest(duoVerificationRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API Authenticate user in KBA MFA method.
         * @summary Authenticate KBA provided MFA method
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendKbaAnswers(kbaAnswerRequestItem: Array<KbaAnswerRequestItem>, axiosOptions?: any): AxiosPromise<KbaAuthResponse> {
            return localVarFp.sendKbaAnswers(kbaAnswerRequestItem, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API Authenticates the user via Okta-Verify MFA method. Request requires a header called \'slpt-forwarding\', and it must contain a remote IP Address of caller.
         * @summary Verifying authentication via Okta method
         * @param {OktaVerificationRequest} oktaVerificationRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendOktaVerifyRequest(oktaVerificationRequest: OktaVerificationRequest, axiosOptions?: any): AxiosPromise<VerificationResponse> {
            return localVarFp.sendOktaVerifyRequest(oktaVerificationRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API Authenticate user in Token MFA method.
         * @summary Authenticate Token provided MFA method
         * @param {TokenAuthRequest} tokenAuthRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendTokenAuthRequest(tokenAuthRequest: TokenAuthRequest, axiosOptions?: any): AxiosPromise<TokenAuthResponse> {
            return localVarFp.sendTokenAuthRequest(tokenAuthRequest, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSendToken operation in MFAControllerApi.
 * @export
 * @interface MFAControllerApiCreateSendTokenRequest
 */
export interface MFAControllerApiCreateSendTokenRequest {
    /**
     * 
     * @type {SendTokenRequest}
     * @memberof MFAControllerApiCreateSendToken
     */
    readonly sendTokenRequest: SendTokenRequest
}

/**
 * Request parameters for pingVerificationStatus operation in MFAControllerApi.
 * @export
 * @interface MFAControllerApiPingVerificationStatusRequest
 */
export interface MFAControllerApiPingVerificationStatusRequest {
    /**
     * The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39;, \&#39;duo-web\&#39;, \&#39;kba\&#39;,\&#39;token\&#39;, \&#39;rsa\&#39;
     * @type {string}
     * @memberof MFAControllerApiPingVerificationStatus
     */
    readonly method: string

    /**
     * 
     * @type {VerificationPollRequest}
     * @memberof MFAControllerApiPingVerificationStatus
     */
    readonly verificationPollRequest: VerificationPollRequest
}

/**
 * Request parameters for sendDuoVerifyRequest operation in MFAControllerApi.
 * @export
 * @interface MFAControllerApiSendDuoVerifyRequestRequest
 */
export interface MFAControllerApiSendDuoVerifyRequestRequest {
    /**
     * 
     * @type {DuoVerificationRequest}
     * @memberof MFAControllerApiSendDuoVerifyRequest
     */
    readonly duoVerificationRequest: DuoVerificationRequest
}

/**
 * Request parameters for sendKbaAnswers operation in MFAControllerApi.
 * @export
 * @interface MFAControllerApiSendKbaAnswersRequest
 */
export interface MFAControllerApiSendKbaAnswersRequest {
    /**
     * 
     * @type {Array<KbaAnswerRequestItem>}
     * @memberof MFAControllerApiSendKbaAnswers
     */
    readonly kbaAnswerRequestItem: Array<KbaAnswerRequestItem>
}

/**
 * Request parameters for sendOktaVerifyRequest operation in MFAControllerApi.
 * @export
 * @interface MFAControllerApiSendOktaVerifyRequestRequest
 */
export interface MFAControllerApiSendOktaVerifyRequestRequest {
    /**
     * 
     * @type {OktaVerificationRequest}
     * @memberof MFAControllerApiSendOktaVerifyRequest
     */
    readonly oktaVerificationRequest: OktaVerificationRequest
}

/**
 * Request parameters for sendTokenAuthRequest operation in MFAControllerApi.
 * @export
 * @interface MFAControllerApiSendTokenAuthRequestRequest
 */
export interface MFAControllerApiSendTokenAuthRequestRequest {
    /**
     * 
     * @type {TokenAuthRequest}
     * @memberof MFAControllerApiSendTokenAuthRequest
     */
    readonly tokenAuthRequest: TokenAuthRequest
}

/**
 * MFAControllerApi - object-oriented interface
 * @export
 * @class MFAControllerApi
 * @extends {BaseAPI}
 */
export class MFAControllerApi extends BaseAPI {
    /**
     * This API send token request.
     * @summary Create and send user token
     * @param {MFAControllerApiCreateSendTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    public createSendToken(requestParameters: MFAControllerApiCreateSendTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAControllerApiFp(this.configuration).createSendToken(requestParameters.sendTokenRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API poll the VerificationPollRequest for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Polling MFA method by VerificationPollRequest
     * @param {MFAControllerApiPingVerificationStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    public pingVerificationStatus(requestParameters: MFAControllerApiPingVerificationStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAControllerApiFp(this.configuration).pingVerificationStatus(requestParameters.method, requestParameters.verificationPollRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API Authenticates the user via Duo-Web MFA method.
     * @summary Verifying authentication via Duo method
     * @param {MFAControllerApiSendDuoVerifyRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    public sendDuoVerifyRequest(requestParameters: MFAControllerApiSendDuoVerifyRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAControllerApiFp(this.configuration).sendDuoVerifyRequest(requestParameters.duoVerificationRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API Authenticate user in KBA MFA method.
     * @summary Authenticate KBA provided MFA method
     * @param {MFAControllerApiSendKbaAnswersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    public sendKbaAnswers(requestParameters: MFAControllerApiSendKbaAnswersRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAControllerApiFp(this.configuration).sendKbaAnswers(requestParameters.kbaAnswerRequestItem, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API Authenticates the user via Okta-Verify MFA method. Request requires a header called \'slpt-forwarding\', and it must contain a remote IP Address of caller.
     * @summary Verifying authentication via Okta method
     * @param {MFAControllerApiSendOktaVerifyRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    public sendOktaVerifyRequest(requestParameters: MFAControllerApiSendOktaVerifyRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAControllerApiFp(this.configuration).sendOktaVerifyRequest(requestParameters.oktaVerificationRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API Authenticate user in Token MFA method.
     * @summary Authenticate Token provided MFA method
     * @param {MFAControllerApiSendTokenAuthRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    public sendTokenAuthRequest(requestParameters: MFAControllerApiSendTokenAuthRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return MFAControllerApiFp(this.configuration).sendTokenAuthRequest(requestParameters.tokenAuthRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManagedClientsApi - axios parameter creator
 * @export
 */
export const ManagedClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Managed Client. The API returns a result that includes the Managed Client ID.
         * @summary Create a new Managed Client
         * @param {ManagedClientRequest} managedClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedClient: async (managedClientRequest: ManagedClientRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'managedClientRequest' is not null or undefined
            assertParamExists('createManagedClient', 'managedClientRequest', managedClientRequest)
            const localVarPath = `/managed-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(managedClientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Managed Client.
         * @summary Delete a Managed Client
         * @param {string} id Managed Client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedClient: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteManagedClient', 'id', id)
            const localVarPath = `/managed-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a Managed Client.
         * @summary Get a Managed Client
         * @param {string} id Managed Client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClient: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getManagedClient', 'id', id)
            const localVarPath = `/managed-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the Status of a Managed Client by ID.
         * @summary Get Managed Client Status.
         * @param {string} id ID of the Managed Client to get Status of
         * @param {ManagedClientType} type Type of the Managed Client to get Status of
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClientStatus: async (id: string, type: ManagedClientType, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getManagedClientStatus', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getManagedClientStatus', 'type', type)
            const localVarPath = `/managed-clients/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Managed Clients.
         * @summary Get Managed Clients
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **clientId**: *eq*  **clusterId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClients: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/managed-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Managed Client.
         * @summary Update a Managed Client
         * @param {string} id Managed Client ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedClient: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateManagedClient', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateManagedClient', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/managed-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagedClientsApi - functional programming interface
 * @export
 */
export const ManagedClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagedClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Managed Client. The API returns a result that includes the Managed Client ID.
         * @summary Create a new Managed Client
         * @param {ManagedClientRequest} managedClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createManagedClient(managedClientRequest: ManagedClientRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManagedClient(managedClientRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Managed Client.
         * @summary Delete a Managed Client
         * @param {string} id Managed Client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteManagedClient(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManagedClient(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a Managed Client.
         * @summary Get a Managed Client
         * @param {string} id Managed Client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManagedClient(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagedClient(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the Status of a Managed Client by ID.
         * @summary Get Managed Client Status.
         * @param {string} id ID of the Managed Client to get Status of
         * @param {ManagedClientType} type Type of the Managed Client to get Status of
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManagedClientStatus(id: string, type: ManagedClientType, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedClientStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagedClientStatus(id, type, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of Managed Clients.
         * @summary Get Managed Clients
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **clientId**: *eq*  **clusterId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManagedClients(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ManagedClient>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagedClients(offset, limit, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Managed Client.
         * @summary Update a Managed Client
         * @param {string} id Managed Client ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateManagedClient(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateManagedClient(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManagedClientsApi - factory interface
 * @export
 */
export const ManagedClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManagedClientsApiFp(configuration)
    return {
        /**
         * Create a new Managed Client. The API returns a result that includes the Managed Client ID.
         * @summary Create a new Managed Client
         * @param {ManagedClientRequest} managedClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedClient(managedClientRequest: ManagedClientRequest, axiosOptions?: any): AxiosPromise<ManagedClient> {
            return localVarFp.createManagedClient(managedClientRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Managed Client.
         * @summary Delete a Managed Client
         * @param {string} id Managed Client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedClient(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteManagedClient(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a Managed Client.
         * @summary Get a Managed Client
         * @param {string} id Managed Client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClient(id: string, axiosOptions?: any): AxiosPromise<ManagedClient> {
            return localVarFp.getManagedClient(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the Status of a Managed Client by ID.
         * @summary Get Managed Client Status.
         * @param {string} id ID of the Managed Client to get Status of
         * @param {ManagedClientType} type Type of the Managed Client to get Status of
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClientStatus(id: string, type: ManagedClientType, axiosOptions?: any): AxiosPromise<ManagedClientStatus> {
            return localVarFp.getManagedClientStatus(id, type, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of Managed Clients.
         * @summary Get Managed Clients
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **clientId**: *eq*  **clusterId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClients(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<ManagedClient>> {
            return localVarFp.getManagedClients(offset, limit, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Managed Client.
         * @summary Update a Managed Client
         * @param {string} id Managed Client ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedClient(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<ManagedClient> {
            return localVarFp.updateManagedClient(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createManagedClient operation in ManagedClientsApi.
 * @export
 * @interface ManagedClientsApiCreateManagedClientRequest
 */
export interface ManagedClientsApiCreateManagedClientRequest {
    /**
     * 
     * @type {ManagedClientRequest}
     * @memberof ManagedClientsApiCreateManagedClient
     */
    readonly managedClientRequest: ManagedClientRequest
}

/**
 * Request parameters for deleteManagedClient operation in ManagedClientsApi.
 * @export
 * @interface ManagedClientsApiDeleteManagedClientRequest
 */
export interface ManagedClientsApiDeleteManagedClientRequest {
    /**
     * Managed Client ID.
     * @type {string}
     * @memberof ManagedClientsApiDeleteManagedClient
     */
    readonly id: string
}

/**
 * Request parameters for getManagedClient operation in ManagedClientsApi.
 * @export
 * @interface ManagedClientsApiGetManagedClientRequest
 */
export interface ManagedClientsApiGetManagedClientRequest {
    /**
     * Managed Client ID.
     * @type {string}
     * @memberof ManagedClientsApiGetManagedClient
     */
    readonly id: string
}

/**
 * Request parameters for getManagedClientStatus operation in ManagedClientsApi.
 * @export
 * @interface ManagedClientsApiGetManagedClientStatusRequest
 */
export interface ManagedClientsApiGetManagedClientStatusRequest {
    /**
     * ID of the Managed Client to get Status of
     * @type {string}
     * @memberof ManagedClientsApiGetManagedClientStatus
     */
    readonly id: string

    /**
     * Type of the Managed Client to get Status of
     * @type {ManagedClientType}
     * @memberof ManagedClientsApiGetManagedClientStatus
     */
    readonly type: ManagedClientType
}

/**
 * Request parameters for getManagedClients operation in ManagedClientsApi.
 * @export
 * @interface ManagedClientsApiGetManagedClientsRequest
 */
export interface ManagedClientsApiGetManagedClientsRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ManagedClientsApiGetManagedClients
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ManagedClientsApiGetManagedClients
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ManagedClientsApiGetManagedClients
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **clientId**: *eq*  **clusterId**: *eq*
     * @type {string}
     * @memberof ManagedClientsApiGetManagedClients
     */
    readonly filters?: string
}

/**
 * Request parameters for updateManagedClient operation in ManagedClientsApi.
 * @export
 * @interface ManagedClientsApiUpdateManagedClientRequest
 */
export interface ManagedClientsApiUpdateManagedClientRequest {
    /**
     * Managed Client ID.
     * @type {string}
     * @memberof ManagedClientsApiUpdateManagedClient
     */
    readonly id: string

    /**
     * The JSONPatch payload used to update the object.
     * @type {Array<JsonPatchOperation>}
     * @memberof ManagedClientsApiUpdateManagedClient
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * ManagedClientsApi - object-oriented interface
 * @export
 * @class ManagedClientsApi
 * @extends {BaseAPI}
 */
export class ManagedClientsApi extends BaseAPI {
    /**
     * Create a new Managed Client. The API returns a result that includes the Managed Client ID.
     * @summary Create a new Managed Client
     * @param {ManagedClientsApiCreateManagedClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    public createManagedClient(requestParameters: ManagedClientsApiCreateManagedClientRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClientsApiFp(this.configuration).createManagedClient(requestParameters.managedClientRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Managed Client.
     * @summary Delete a Managed Client
     * @param {ManagedClientsApiDeleteManagedClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    public deleteManagedClient(requestParameters: ManagedClientsApiDeleteManagedClientRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClientsApiFp(this.configuration).deleteManagedClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Managed Client.
     * @summary Get a Managed Client
     * @param {ManagedClientsApiGetManagedClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    public getManagedClient(requestParameters: ManagedClientsApiGetManagedClientRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClientsApiFp(this.configuration).getManagedClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the Status of a Managed Client by ID.
     * @summary Get Managed Client Status.
     * @param {ManagedClientsApiGetManagedClientStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    public getManagedClientStatus(requestParameters: ManagedClientsApiGetManagedClientStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClientsApiFp(this.configuration).getManagedClientStatus(requestParameters.id, requestParameters.type, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of Managed Clients.
     * @summary Get Managed Clients
     * @param {ManagedClientsApiGetManagedClientsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    public getManagedClients(requestParameters: ManagedClientsApiGetManagedClientsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ManagedClientsApiFp(this.configuration).getManagedClients(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Managed Client.
     * @summary Update a Managed Client
     * @param {ManagedClientsApiUpdateManagedClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    public updateManagedClient(requestParameters: ManagedClientsApiUpdateManagedClientRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClientsApiFp(this.configuration).updateManagedClient(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManagedClustersApi - axios parameter creator
 * @export
 */
export const ManagedClustersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Managed Cluster. The API returns a result that includes the Managed Cluster ID.
         * @summary Create a new Managed Cluster
         * @param {ManagedClusterRequest} managedClusterRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedCluster: async (managedClusterRequest: ManagedClusterRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'managedClusterRequest' is not null or undefined
            assertParamExists('createManagedCluster', 'managedClusterRequest', managedClusterRequest)
            const localVarPath = `/managed-clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(managedClusterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Managed Cluster.
         * @summary Delete a Managed Cluster
         * @param {string} id Managed Cluster ID.
         * @param {boolean} [removeClients] Flag to determine the need to delete a cluster with clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedCluster: async (id: string, removeClients?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteManagedCluster', 'id', id)
            const localVarPath = `/managed-clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (removeClients !== undefined) {
                localVarQueryParameter['removeClients'] = removeClients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a ManagedCluster by ID.
         * @summary Get a specified Managed Cluster.
         * @param {string} id ManagedCluster ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedCluster: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getManagedCluster', 'id', id)
            const localVarPath = `/managed-clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all Managed Clusters for the current Org, based on request context.
         * @summary Retrieve all Managed Clusters.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **operational**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClusters: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/managed-clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Managed Cluster.
         * @summary Update a Managed Cluster
         * @param {string} id Managed Cluster ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedCluster: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateManagedCluster', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateManagedCluster', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/managed-clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagedClustersApi - functional programming interface
 * @export
 */
export const ManagedClustersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagedClustersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Managed Cluster. The API returns a result that includes the Managed Cluster ID.
         * @summary Create a new Managed Cluster
         * @param {ManagedClusterRequest} managedClusterRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createManagedCluster(managedClusterRequest: ManagedClusterRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedCluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManagedCluster(managedClusterRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Managed Cluster.
         * @summary Delete a Managed Cluster
         * @param {string} id Managed Cluster ID.
         * @param {boolean} [removeClients] Flag to determine the need to delete a cluster with clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteManagedCluster(id: string, removeClients?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManagedCluster(id, removeClients, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a ManagedCluster by ID.
         * @summary Get a specified Managed Cluster.
         * @param {string} id ManagedCluster ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManagedCluster(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedCluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagedCluster(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all Managed Clusters for the current Org, based on request context.
         * @summary Retrieve all Managed Clusters.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **operational**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getManagedClusters(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ManagedCluster>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagedClusters(offset, limit, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Managed Cluster.
         * @summary Update a Managed Cluster
         * @param {string} id Managed Cluster ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateManagedCluster(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedCluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateManagedCluster(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManagedClustersApi - factory interface
 * @export
 */
export const ManagedClustersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManagedClustersApiFp(configuration)
    return {
        /**
         * Create a new Managed Cluster. The API returns a result that includes the Managed Cluster ID.
         * @summary Create a new Managed Cluster
         * @param {ManagedClusterRequest} managedClusterRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedCluster(managedClusterRequest: ManagedClusterRequest, axiosOptions?: any): AxiosPromise<ManagedCluster> {
            return localVarFp.createManagedCluster(managedClusterRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Managed Cluster.
         * @summary Delete a Managed Cluster
         * @param {string} id Managed Cluster ID.
         * @param {boolean} [removeClients] Flag to determine the need to delete a cluster with clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedCluster(id: string, removeClients?: boolean, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteManagedCluster(id, removeClients, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a ManagedCluster by ID.
         * @summary Get a specified Managed Cluster.
         * @param {string} id ManagedCluster ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedCluster(id: string, axiosOptions?: any): AxiosPromise<ManagedCluster> {
            return localVarFp.getManagedCluster(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all Managed Clusters for the current Org, based on request context.
         * @summary Retrieve all Managed Clusters.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **operational**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClusters(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<ManagedCluster>> {
            return localVarFp.getManagedClusters(offset, limit, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Managed Cluster.
         * @summary Update a Managed Cluster
         * @param {string} id Managed Cluster ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedCluster(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<ManagedCluster> {
            return localVarFp.updateManagedCluster(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createManagedCluster operation in ManagedClustersApi.
 * @export
 * @interface ManagedClustersApiCreateManagedClusterRequest
 */
export interface ManagedClustersApiCreateManagedClusterRequest {
    /**
     * 
     * @type {ManagedClusterRequest}
     * @memberof ManagedClustersApiCreateManagedCluster
     */
    readonly managedClusterRequest: ManagedClusterRequest
}

/**
 * Request parameters for deleteManagedCluster operation in ManagedClustersApi.
 * @export
 * @interface ManagedClustersApiDeleteManagedClusterRequest
 */
export interface ManagedClustersApiDeleteManagedClusterRequest {
    /**
     * Managed Cluster ID.
     * @type {string}
     * @memberof ManagedClustersApiDeleteManagedCluster
     */
    readonly id: string

    /**
     * Flag to determine the need to delete a cluster with clients
     * @type {boolean}
     * @memberof ManagedClustersApiDeleteManagedCluster
     */
    readonly removeClients?: boolean
}

/**
 * Request parameters for getManagedCluster operation in ManagedClustersApi.
 * @export
 * @interface ManagedClustersApiGetManagedClusterRequest
 */
export interface ManagedClustersApiGetManagedClusterRequest {
    /**
     * ManagedCluster ID.
     * @type {string}
     * @memberof ManagedClustersApiGetManagedCluster
     */
    readonly id: string
}

/**
 * Request parameters for getManagedClusters operation in ManagedClustersApi.
 * @export
 * @interface ManagedClustersApiGetManagedClustersRequest
 */
export interface ManagedClustersApiGetManagedClustersRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ManagedClustersApiGetManagedClusters
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ManagedClustersApiGetManagedClusters
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ManagedClustersApiGetManagedClusters
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **operational**: *eq*
     * @type {string}
     * @memberof ManagedClustersApiGetManagedClusters
     */
    readonly filters?: string
}

/**
 * Request parameters for updateManagedCluster operation in ManagedClustersApi.
 * @export
 * @interface ManagedClustersApiUpdateManagedClusterRequest
 */
export interface ManagedClustersApiUpdateManagedClusterRequest {
    /**
     * Managed Cluster ID.
     * @type {string}
     * @memberof ManagedClustersApiUpdateManagedCluster
     */
    readonly id: string

    /**
     * The JSONPatch payload used to update the object.
     * @type {Array<JsonPatchOperation>}
     * @memberof ManagedClustersApiUpdateManagedCluster
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * ManagedClustersApi - object-oriented interface
 * @export
 * @class ManagedClustersApi
 * @extends {BaseAPI}
 */
export class ManagedClustersApi extends BaseAPI {
    /**
     * Create a new Managed Cluster. The API returns a result that includes the Managed Cluster ID.
     * @summary Create a new Managed Cluster
     * @param {ManagedClustersApiCreateManagedClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    public createManagedCluster(requestParameters: ManagedClustersApiCreateManagedClusterRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClustersApiFp(this.configuration).createManagedCluster(requestParameters.managedClusterRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Managed Cluster.
     * @summary Delete a Managed Cluster
     * @param {ManagedClustersApiDeleteManagedClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    public deleteManagedCluster(requestParameters: ManagedClustersApiDeleteManagedClusterRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClustersApiFp(this.configuration).deleteManagedCluster(requestParameters.id, requestParameters.removeClients, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a ManagedCluster by ID.
     * @summary Get a specified Managed Cluster.
     * @param {ManagedClustersApiGetManagedClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    public getManagedCluster(requestParameters: ManagedClustersApiGetManagedClusterRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClustersApiFp(this.configuration).getManagedCluster(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all Managed Clusters for the current Org, based on request context.
     * @summary Retrieve all Managed Clusters.
     * @param {ManagedClustersApiGetManagedClustersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    public getManagedClusters(requestParameters: ManagedClustersApiGetManagedClustersRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ManagedClustersApiFp(this.configuration).getManagedClusters(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Managed Cluster.
     * @summary Update a Managed Cluster
     * @param {ManagedClustersApiUpdateManagedClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    public updateManagedCluster(requestParameters: ManagedClustersApiUpdateManagedClusterRequest, axiosOptions?: AxiosRequestConfig) {
        return ManagedClustersApiFp(this.configuration).updateManagedCluster(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NonEmployeeLifecycleManagementApi - axios parameter creator
 * @export
 */
export const NonEmployeeLifecycleManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveNonEmployeeRequest: async (id: string, nonEmployeeApprovalDecision: NonEmployeeApprovalDecision, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveNonEmployeeRequest', 'id', id)
            // verify required parameter 'nonEmployeeApprovalDecision' is not null or undefined
            assertParamExists('approveNonEmployeeRequest', 'nonEmployeeApprovalDecision', nonEmployeeApprovalDecision)
            const localVarPath = `/non-employee-approvals/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeApprovalDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRecord: async (nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('createNonEmployeeRecord', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRequest: async (nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('createNonEmployeeRequest', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSource: async (nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeSourceRequestBody' is not null or undefined
            assertParamExists('createNonEmployeeSource', 'nonEmployeeSourceRequestBody', nonEmployeeSourceRequestBody)
            const localVarPath = `/non-employee-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeSourceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSourceSchemaAttributes: async (sourceId: string, nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            // verify required parameter 'nonEmployeeSchemaAttributeBody' is not null or undefined
            assertParamExists('createNonEmployeeSourceSchemaAttributes', 'nonEmployeeSchemaAttributeBody', nonEmployeeSchemaAttributeBody)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeSchemaAttributeBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecord: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNonEmployeeRecord', 'id', id)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordsInBulkRequest} deleteNonEmployeeRecordsInBulkRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecordsInBulk: async (deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteNonEmployeeRecordsInBulkRequest' is not null or undefined
            assertParamExists('deleteNonEmployeeRecordsInBulk', 'deleteNonEmployeeRecordsInBulkRequest', deleteNonEmployeeRecordsInBulkRequest)
            const localVarPath = `/non-employee-records/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteNonEmployeeRecordsInBulkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRequest: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNonEmployeeRequest', 'id', id)
            const localVarPath = `/non-employee-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('deleteNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSource: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSource', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSourceSchemaAttributes: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeRecords: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportNonEmployeeRecords', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/non-employees/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeSourceSchemaTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportNonEmployeeSourceSchemaTemplate', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/schema-attributes-template/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApproval: async (id: string, includeDetail?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeApproval', 'id', id)
            const localVarPath = `/non-employee-approvals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (includeDetail !== undefined) {
                localVarQueryParameter['include-detail'] = includeDetail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApprovalSummary: async (requestedFor: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('getNonEmployeeApprovalSummary', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-approvals/summary/{requested-for}`
                .replace(`{${"requested-for"}}`, encodeURIComponent(String(requestedFor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeBulkUploadStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeBulkUploadStatus', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/non-employee-bulk-upload/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRecord: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeRecord', 'id', id)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequest: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeRequest', 'id', id)
            const localVarPath = `/non-employee-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequestSummary: async (requestedFor: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('getNonEmployeeRequestSummary', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-requests/summary/{requested-for}`
                .replace(`{${"requested-for"}}`, encodeURIComponent(String(requestedFor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('getNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSource: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSource', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSourceSchemaAttributes: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {any} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importNonEmployeeRecordsInBulk: async (id: string, data: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importNonEmployeeRecordsInBulk', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('importNonEmployeeRecordsInBulk', 'data', data)
            const localVarPath = `/non-employee-sources/{id}/non-employee-bulk-upload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **approvalStatus**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeApprovals: async (requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/non-employee-approvals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRecords: async (limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/non-employee-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq* 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRequests: async (requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('listNonEmployeeRequests', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, sourceId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeSources: async (requestedFor: string, limit?: number, offset?: number, count?: boolean, nonEmployeeCount?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('listNonEmployeeSources', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (nonEmployeeCount !== undefined) {
                localVarQueryParameter['non-employee-count'] = nonEmployeeCount;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeRecord: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchNonEmployeeRecord', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchNonEmployeeRecord', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSource: async (sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('patchNonEmployeeSource', 'sourceId', sourceId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchNonEmployeeSource', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectNonEmployeeRequest: async (id: string, nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectNonEmployeeRequest', 'id', id)
            // verify required parameter 'nonEmployeeRejectApprovalDecision' is not null or undefined
            assertParamExists('rejectNonEmployeeRequest', 'nonEmployeeRejectApprovalDecision', nonEmployeeRejectApprovalDecision)
            const localVarPath = `/non-employee-approvals/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRejectApprovalDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateNonEmployeeRecord: async (id: string, nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateNonEmployeeRecord', 'id', id)
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('updateNonEmployeeRecord', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * NonEmployeeLifecycleManagementApi - functional programming interface
 * @export
 */
export const NonEmployeeLifecycleManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NonEmployeeLifecycleManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveNonEmployeeRequest(id: string, nonEmployeeApprovalDecision: NonEmployeeApprovalDecision, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveNonEmployeeRequest(id, nonEmployeeApprovalDecision, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeRecord(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeRecord(nonEmployeeRequestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeRequest(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeRequest(nonEmployeeRequestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeSource(nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSourceWithCloudExternalId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeSource(nonEmployeeSourceRequestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeSourceSchemaAttributes(sourceId: string, nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeSourceSchemaAttributes(sourceId, nonEmployeeSchemaAttributeBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRecord(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRecord(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordsInBulkRequest} deleteNonEmployeeRecordsInBulkRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRequest(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRequest(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSource(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSource(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportNonEmployeeRecords(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNonEmployeeRecords(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportNonEmployeeSourceSchemaTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNonEmployeeSourceSchemaTemplate(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeApproval(id: string, includeDetail?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeApproval(id, includeDetail, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeApprovalSummary(requestedFor: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeApprovalSummary(requestedFor, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeBulkUploadStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeBulkUploadStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeBulkUploadStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRecord(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRecord(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRequest(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRequest(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRequestSummary(requestedFor: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequestSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRequestSummary(requestedFor, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSource(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSource(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeSchemaAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {any} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importNonEmployeeRecordsInBulk(id: string, data: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeBulkUploadJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importNonEmployeeRecordsInBulk(id, data, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **approvalStatus**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeApprovals(requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeApprovalItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeApprovals(requestedFor, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeRecords(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeRecords(limit, offset, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq* 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeRequests(requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeRequest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeRequests(requestedFor, limit, offset, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, sourceId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeSources(requestedFor: string, limit?: number, offset?: number, count?: boolean, nonEmployeeCount?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeSourceWithNECount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeSources(requestedFor, limit, offset, count, nonEmployeeCount, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeRecord(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeRecord(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeSchemaAttribute(attributeId, sourceId, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeSource(sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeSource(sourceId, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectNonEmployeeRequest(id: string, nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectNonEmployeeRequest(id, nonEmployeeRejectApprovalDecision, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateNonEmployeeRecord(id: string, nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNonEmployeeRecord(id, nonEmployeeRequestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NonEmployeeLifecycleManagementApi - factory interface
 * @export
 */
export const NonEmployeeLifecycleManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NonEmployeeLifecycleManagementApiFp(configuration)
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveNonEmployeeRequest(id: string, nonEmployeeApprovalDecision: NonEmployeeApprovalDecision, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalItem> {
            return localVarFp.approveNonEmployeeRequest(id, nonEmployeeApprovalDecision, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRecord(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: any): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.createNonEmployeeRecord(nonEmployeeRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRequest(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: any): AxiosPromise<NonEmployeeRequest> {
            return localVarFp.createNonEmployeeRequest(nonEmployeeRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSource(nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody, axiosOptions?: any): AxiosPromise<NonEmployeeSourceWithCloudExternalId> {
            return localVarFp.createNonEmployeeSource(nonEmployeeSourceRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSourceSchemaAttributes(sourceId: string, nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody, axiosOptions?: any): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.createNonEmployeeSourceSchemaAttributes(sourceId, nonEmployeeSchemaAttributeBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecord(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRecord(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordsInBulkRequest} deleteNonEmployeeRecordsInBulkRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRequest(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRequest(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSource(sourceId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSource(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeRecords(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.exportNonEmployeeRecords(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeSourceSchemaTemplate(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.exportNonEmployeeSourceSchemaTemplate(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApproval(id: string, includeDetail?: boolean, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalItemDetail> {
            return localVarFp.getNonEmployeeApproval(id, includeDetail, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApprovalSummary(requestedFor: string, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalSummary> {
            return localVarFp.getNonEmployeeApprovalSummary(requestedFor, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeBulkUploadStatus(id: string, axiosOptions?: any): AxiosPromise<NonEmployeeBulkUploadStatus> {
            return localVarFp.getNonEmployeeBulkUploadStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRecord(id: string, axiosOptions?: any): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.getNonEmployeeRecord(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequest(id: string, axiosOptions?: any): AxiosPromise<NonEmployeeRequest> {
            return localVarFp.getNonEmployeeRequest(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequestSummary(requestedFor: string, axiosOptions?: any): AxiosPromise<NonEmployeeRequestSummary> {
            return localVarFp.getNonEmployeeRequestSummary(requestedFor, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: any): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.getNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSource(sourceId: string, axiosOptions?: any): AxiosPromise<NonEmployeeSource> {
            return localVarFp.getNonEmployeeSource(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeSchemaAttribute>> {
            return localVarFp.getNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {any} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importNonEmployeeRecordsInBulk(id: string, data: any, axiosOptions?: any): AxiosPromise<NonEmployeeBulkUploadJob> {
            return localVarFp.importNonEmployeeRecordsInBulk(id, data, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **approvalStatus**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeApprovals(requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeApprovalItem>> {
            return localVarFp.listNonEmployeeApprovals(requestedFor, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRecords(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeRecord>> {
            return localVarFp.listNonEmployeeRecords(limit, offset, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq* 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRequests(requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeRequest>> {
            return localVarFp.listNonEmployeeRequests(requestedFor, limit, offset, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, sourceId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeSources(requestedFor: string, limit?: number, offset?: number, count?: boolean, nonEmployeeCount?: boolean, sorters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeSourceWithNECount>> {
            return localVarFp.listNonEmployeeSources(requestedFor, limit, offset, count, nonEmployeeCount, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeRecord(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.patchNonEmployeeRecord(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.patchNonEmployeeSchemaAttribute(attributeId, sourceId, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSource(sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<NonEmployeeSource> {
            return localVarFp.patchNonEmployeeSource(sourceId, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectNonEmployeeRequest(id: string, nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalItem> {
            return localVarFp.rejectNonEmployeeRequest(id, nonEmployeeRejectApprovalDecision, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateNonEmployeeRecord(id: string, nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: any): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.updateNonEmployeeRecord(id, nonEmployeeRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiApproveNonEmployeeRequest
     */
    readonly id: string

    /**
     * 
     * @type {NonEmployeeApprovalDecision}
     * @memberof NonEmployeeLifecycleManagementApiApproveNonEmployeeRequest
     */
    readonly nonEmployeeApprovalDecision: NonEmployeeApprovalDecision
}

/**
 * Request parameters for createNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest {
    /**
     * Non-Employee record creation request body.
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeRecord
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * Request parameters for createNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest {
    /**
     * Non-Employee creation request body
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeRequest
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * Request parameters for createNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest {
    /**
     * Non-Employee source creation request body.
     * @type {NonEmployeeSourceRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeSource
     */
    readonly nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody
}

/**
 * Request parameters for createNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string

    /**
     * 
     * @type {NonEmployeeSchemaAttributeBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributes
     */
    readonly nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody
}

/**
 * Request parameters for deleteNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest {
    /**
     * Non-Employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecord
     */
    readonly id: string
}

/**
 * Request parameters for deleteNonEmployeeRecordsInBulk operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest {
    /**
     * Non-Employee bulk delete request body.
     * @type {DeleteNonEmployeeRecordsInBulkRequest}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulk
     */
    readonly deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest
}

/**
 * Request parameters for deleteNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest {
    /**
     * Non-Employee request id in the UUID format
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequest
     */
    readonly id: string
}

/**
 * Request parameters for deleteNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttribute
     */
    readonly sourceId: string
}

/**
 * Request parameters for deleteNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSource
     */
    readonly sourceId: string
}

/**
 * Request parameters for deleteNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string
}

/**
 * Request parameters for exportNonEmployeeRecords operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest
 */
export interface NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiExportNonEmployeeRecords
     */
    readonly id: string
}

/**
 * Request parameters for exportNonEmployeeSourceSchemaTemplate operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest
 */
export interface NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplate
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeApproval operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeApproval
     */
    readonly id: string

    /**
     * The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeApproval
     */
    readonly includeDetail?: boolean
}

/**
 * Request parameters for getNonEmployeeApprovalSummary operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest {
    /**
     * The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummary
     */
    readonly requestedFor: string
}

/**
 * Request parameters for getNonEmployeeBulkUploadStatus operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest {
    /**
     * Source ID (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatus
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest {
    /**
     * Non-Employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeRecord
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest {
    /**
     * Non-Employee request id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeRequest
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRequestSummary operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest {
    /**
     * The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummary
     */
    readonly requestedFor: string
}

/**
 * Request parameters for getNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttribute
     */
    readonly sourceId: string
}

/**
 * Request parameters for getNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSource
     */
    readonly sourceId: string
}

/**
 * Request parameters for getNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string
}

/**
 * Request parameters for importNonEmployeeRecordsInBulk operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest
 */
export interface NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulk
     */
    readonly id: string

    /**
     * 
     * @type {any}
     * @memberof NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulk
     */
    readonly data: any
}

/**
 * Request parameters for listNonEmployeeApprovals operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly requestedFor?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **approvalStatus**: *eq*
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for listNonEmployeeRecords operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly filters?: string
}

/**
 * Request parameters for listNonEmployeeRequests operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly requestedFor: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq* 
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly filters?: string
}

/**
 * Request parameters for listNonEmployeeSources operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly requestedFor: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly count?: boolean

    /**
     * The flag to determine whether return a non-employee count associate with source.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly nonEmployeeCount?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, sourceId**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly sorters?: string
}

/**
 * Request parameters for patchNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest {
    /**
     * Non-employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeRecord
     */
    readonly id: string

    /**
     * A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeRecord
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for patchNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttribute
     */
    readonly sourceId: string

    /**
     * A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttribute
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for patchNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSource
     */
    readonly sourceId: string

    /**
     * A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSource
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for rejectNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiRejectNonEmployeeRequest
     */
    readonly id: string

    /**
     * 
     * @type {NonEmployeeRejectApprovalDecision}
     * @memberof NonEmployeeLifecycleManagementApiRejectNonEmployeeRequest
     */
    readonly nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision
}

/**
 * Request parameters for updateNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest {
    /**
     * Non-employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecord
     */
    readonly id: string

    /**
     * Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecord
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * NonEmployeeLifecycleManagementApi - object-oriented interface
 * @export
 * @class NonEmployeeLifecycleManagementApi
 * @extends {BaseAPI}
 */
export class NonEmployeeLifecycleManagementApi extends BaseAPI {
    /**
     * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
     * @summary Approve a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public approveNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).approveNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeApprovalDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee record. Requires role context of `idn:nesr:create`
     * @summary Create Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeRecord(requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
     * @summary Create Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeRequest(requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee source. Requires role context of `idn:nesr:create`
     * @summary Create Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeSource(requestParameters.nonEmployeeSourceRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
     * @summary Create a new Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, requestParameters.nonEmployeeSchemaAttributeBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
     * @summary Delete Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeRecord(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
     * @summary Delete Multiple Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeRecordsInBulk(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeRecordsInBulk(requestParameters.deleteNonEmployeeRecordsInBulkRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
     * @summary Delete Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeRequest(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
     * @summary Delete a Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
     * @summary Delete Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeSource(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
     * @summary Delete all custom schema attributes for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
     * @summary Exports Non-Employee Records to CSV
     * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public exportNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).exportNonEmployeeRecords(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
     * @summary Exports Source Schema Template
     * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public exportNonEmployeeSourceSchemaTemplate(requestParameters: NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).exportNonEmployeeSourceSchemaTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
     * @summary Get a non-employee approval item detail
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeApproval(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeApproval(requestParameters.id, requestParameters.includeDetail, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
     * @summary Get Summary of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeApprovalSummary(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeApprovalSummary(requestParameters.requestedFor, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
     * @summary Obtain the status of bulk upload on the source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeBulkUploadStatus(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeBulkUploadStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee record. Requires role context of `idn:nesr:read`
     * @summary Get a Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeRecord(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
     * @summary Get a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeRequest(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
     * @summary Get Summary of Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeRequestSummary(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeRequestSummary(requestParameters.requestedFor, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
     * @summary Get Schema Attribute Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
     * @summary Get a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeSource(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
     * @summary List Schema Attributes Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
     * @summary Imports, or Updates, Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public importNonEmployeeRecordsInBulk(requestParameters: NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).importNonEmployeeRecordsInBulk(requestParameters.id, requestParameters.data, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
     * @summary Get List of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeApprovals(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeApprovals(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
     * @summary List Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeRecords(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
     * @summary List Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeRequests(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeRequests(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
     * @summary List Non-Employee Sources
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeSources(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeSources(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.nonEmployeeCount, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
     * @summary Patch Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public patchNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).patchNonEmployeeRecord(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
     * @summary Patch a Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public patchNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).patchNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
     * @summary Patch a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public patchNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).patchNonEmployeeSource(requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
     * @summary Reject a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public rejectNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).rejectNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeRejectApprovalDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
     * @summary Update Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public updateNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).updateNonEmployeeRecord(requestParameters.id, requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuthClientsApi - axios parameter creator
 * @export
 */
export const OAuthClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient: async (createOAuthClientRequest: CreateOAuthClientRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOAuthClientRequest' is not null or undefined
            assertParamExists('createOauthClient', 'createOAuthClientRequest', createOAuthClientRequest)
            const localVarPath = `/oauth-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOAuthClientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOauthClient', 'id', id)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOauthClient', 'id', id)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients: async (filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchOauthClient', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchOauthClient', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthClientsApi - functional programming interface
 * @export
 */
export const OAuthClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createOauthClient(createOAuthClientRequest: CreateOAuthClientRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOauthClient(createOAuthClientRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOauthClient(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOauthClient(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getOauthClient(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOauthClient(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listOauthClients(filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOAuthClientResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOauthClients(filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchOauthClient(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOauthClient(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuthClientsApi - factory interface
 * @export
 */
export const OAuthClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthClientsApiFp(configuration)
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient(createOAuthClientRequest: CreateOAuthClientRequest, axiosOptions?: any): AxiosPromise<CreateOAuthClientResponse> {
            return localVarFp.createOauthClient(createOAuthClientRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteOauthClient(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient(id: string, axiosOptions?: any): AxiosPromise<GetOAuthClientResponse> {
            return localVarFp.getOauthClient(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients(filters?: string, axiosOptions?: any): AxiosPromise<Array<GetOAuthClientResponse>> {
            return localVarFp.listOauthClients(filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<GetOAuthClientResponse> {
            return localVarFp.patchOauthClient(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiCreateOauthClientRequest
 */
export interface OAuthClientsApiCreateOauthClientRequest {
    /**
     * 
     * @type {CreateOAuthClientRequest}
     * @memberof OAuthClientsApiCreateOauthClient
     */
    readonly createOAuthClientRequest: CreateOAuthClientRequest
}

/**
 * Request parameters for deleteOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiDeleteOauthClientRequest
 */
export interface OAuthClientsApiDeleteOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiDeleteOauthClient
     */
    readonly id: string
}

/**
 * Request parameters for getOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiGetOauthClientRequest
 */
export interface OAuthClientsApiGetOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiGetOauthClient
     */
    readonly id: string
}

/**
 * Request parameters for listOauthClients operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiListOauthClientsRequest
 */
export interface OAuthClientsApiListOauthClientsRequest {
    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
     * @type {string}
     * @memberof OAuthClientsApiListOauthClients
     */
    readonly filters?: string
}

/**
 * Request parameters for patchOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiPatchOauthClientRequest
 */
export interface OAuthClientsApiPatchOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiPatchOauthClient
     */
    readonly id: string

    /**
     * A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
     * @type {Array<JsonPatchOperation>}
     * @memberof OAuthClientsApiPatchOauthClient
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * OAuthClientsApi - object-oriented interface
 * @export
 * @class OAuthClientsApi
 * @extends {BaseAPI}
 */
export class OAuthClientsApi extends BaseAPI {
    /**
     * This creates an OAuth client.
     * @summary Create OAuth Client
     * @param {OAuthClientsApiCreateOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public createOauthClient(requestParameters: OAuthClientsApiCreateOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).createOauthClient(requestParameters.createOAuthClientRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes an OAuth client.
     * @summary Delete OAuth Client
     * @param {OAuthClientsApiDeleteOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public deleteOauthClient(requestParameters: OAuthClientsApiDeleteOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).deleteOauthClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets details of an OAuth client.
     * @summary Get OAuth Client
     * @param {OAuthClientsApiGetOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public getOauthClient(requestParameters: OAuthClientsApiGetOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).getOauthClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of OAuth clients.
     * @summary List OAuth Clients
     * @param {OAuthClientsApiListOauthClientsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public listOauthClients(requestParameters: OAuthClientsApiListOauthClientsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).listOauthClients(requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This performs a targeted update to the field(s) of an OAuth client.
     * @summary Patch OAuth Client
     * @param {OAuthClientsApiPatchOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public patchOauthClient(requestParameters: OAuthClientsApiPatchOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).patchOauthClient(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordConfigurationApi - axios parameter creator
 * @export
 */
export const PasswordConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordOrgConfig: async (passwordOrgConfig: PasswordOrgConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordOrgConfig' is not null or undefined
            assertParamExists('createPasswordOrgConfig', 'passwordOrgConfig', passwordOrgConfig)
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordOrgConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordOrgConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordOrgConfig: async (passwordOrgConfig: PasswordOrgConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordOrgConfig' is not null or undefined
            assertParamExists('putPasswordOrgConfig', 'passwordOrgConfig', passwordOrgConfig)
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordOrgConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordConfigurationApi - functional programming interface
 * @export
 */
export const PasswordConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPasswordOrgConfig(passwordOrgConfig: PasswordOrgConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPasswordOrgConfig(passwordOrgConfig, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordOrgConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordOrgConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putPasswordOrgConfig(passwordOrgConfig: PasswordOrgConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPasswordOrgConfig(passwordOrgConfig, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordConfigurationApi - factory interface
 * @export
 */
export const PasswordConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordConfigurationApiFp(configuration)
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordOrgConfig(passwordOrgConfig: PasswordOrgConfig, axiosOptions?: any): AxiosPromise<PasswordOrgConfig> {
            return localVarFp.createPasswordOrgConfig(passwordOrgConfig, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordOrgConfig(axiosOptions?: any): AxiosPromise<PasswordOrgConfig> {
            return localVarFp.getPasswordOrgConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordOrgConfig(passwordOrgConfig: PasswordOrgConfig, axiosOptions?: any): AxiosPromise<PasswordOrgConfig> {
            return localVarFp.putPasswordOrgConfig(passwordOrgConfig, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPasswordOrgConfig operation in PasswordConfigurationApi.
 * @export
 * @interface PasswordConfigurationApiCreatePasswordOrgConfigRequest
 */
export interface PasswordConfigurationApiCreatePasswordOrgConfigRequest {
    /**
     * 
     * @type {PasswordOrgConfig}
     * @memberof PasswordConfigurationApiCreatePasswordOrgConfig
     */
    readonly passwordOrgConfig: PasswordOrgConfig
}

/**
 * Request parameters for putPasswordOrgConfig operation in PasswordConfigurationApi.
 * @export
 * @interface PasswordConfigurationApiPutPasswordOrgConfigRequest
 */
export interface PasswordConfigurationApiPutPasswordOrgConfigRequest {
    /**
     * 
     * @type {PasswordOrgConfig}
     * @memberof PasswordConfigurationApiPutPasswordOrgConfig
     */
    readonly passwordOrgConfig: PasswordOrgConfig
}

/**
 * PasswordConfigurationApi - object-oriented interface
 * @export
 * @class PasswordConfigurationApi
 * @extends {BaseAPI}
 */
export class PasswordConfigurationApi extends BaseAPI {
    /**
     * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
     * @summary Create Password Org Config
     * @param {PasswordConfigurationApiCreatePasswordOrgConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    public createPasswordOrgConfig(requestParameters: PasswordConfigurationApiCreatePasswordOrgConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordConfigurationApiFp(this.configuration).createPasswordOrgConfig(requestParameters.passwordOrgConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
     * @summary Get Password Org Config
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    public getPasswordOrgConfig(axiosOptions?: AxiosRequestConfig) {
        return PasswordConfigurationApiFp(this.configuration).getPasswordOrgConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
     * @summary Update Password Org Config
     * @param {PasswordConfigurationApiPutPasswordOrgConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    public putPasswordOrgConfig(requestParameters: PasswordConfigurationApiPutPasswordOrgConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordConfigurationApiFp(this.configuration).putPasswordOrgConfig(requestParameters.passwordOrgConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordDictionaryApi - axios parameter creator
 * @export
 */
export const PasswordDictionaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordDictionary: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-dictionary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Update Password Dictionary
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordDictionary: async (file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-dictionary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordDictionaryApi - functional programming interface
 * @export
 */
export const PasswordDictionaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordDictionaryApiAxiosParamCreator(configuration)
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordDictionary(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordDictionary(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Update Password Dictionary
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putPasswordDictionary(file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPasswordDictionary(file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordDictionaryApi - factory interface
 * @export
 */
export const PasswordDictionaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordDictionaryApiFp(configuration)
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordDictionary(axiosOptions?: any): AxiosPromise<string> {
            return localVarFp.getPasswordDictionary(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Update Password Dictionary
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordDictionary(file?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.putPasswordDictionary(file, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for putPasswordDictionary operation in PasswordDictionaryApi.
 * @export
 * @interface PasswordDictionaryApiPutPasswordDictionaryRequest
 */
export interface PasswordDictionaryApiPutPasswordDictionaryRequest {
    /**
     * 
     * @type {any}
     * @memberof PasswordDictionaryApiPutPasswordDictionary
     */
    readonly file?: any
}

/**
 * PasswordDictionaryApi - object-oriented interface
 * @export
 * @class PasswordDictionaryApi
 * @extends {BaseAPI}
 */
export class PasswordDictionaryApi extends BaseAPI {
    /**
     * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
     * @summary Get Password Dictionary
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordDictionaryApi
     */
    public getPasswordDictionary(axiosOptions?: AxiosRequestConfig) {
        return PasswordDictionaryApiFp(this.configuration).getPasswordDictionary(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
     * @summary Update Password Dictionary
     * @param {PasswordDictionaryApiPutPasswordDictionaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordDictionaryApi
     */
    public putPasswordDictionary(requestParameters: PasswordDictionaryApiPutPasswordDictionaryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PasswordDictionaryApiFp(this.configuration).putPasswordDictionary(requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordManagementApi - axios parameter creator
 * @export
 */
export const PasswordManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordChangeStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPasswordChangeStatus', 'id', id)
            const localVarPath = `/password-change-status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo: async (passwordInfoQueryDTO: PasswordInfoQueryDTO, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordInfoQueryDTO' is not null or undefined
            assertParamExists('queryPasswordInfo', 'passwordInfoQueryDTO', passwordInfoQueryDTO)
            const localVarPath = `/query-password-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordInfoQueryDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their ISC user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  >**Note: If you want to set an identity\'s source account password, you must enable `PASSWORD` as one of the source\'s features. You can use the [PATCH Source endpoint](https://developer.sailpoint.com/docs/api/v3/update-source) to add the `PASSWORD` feature.**  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPassword: async (passwordChangeRequest: PasswordChangeRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChangeRequest' is not null or undefined
            assertParamExists('setPassword', 'passwordChangeRequest', passwordChangeRequest)
            const localVarPath = `/set-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordManagementApi - functional programming interface
 * @export
 */
export const PasswordManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordChangeStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordChangeStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async queryPasswordInfo(passwordInfoQueryDTO: PasswordInfoQueryDTO, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryPasswordInfo(passwordInfoQueryDTO, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their ISC user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  >**Note: If you want to set an identity\'s source account password, you must enable `PASSWORD` as one of the source\'s features. You can use the [PATCH Source endpoint](https://developer.sailpoint.com/docs/api/v3/update-source) to add the `PASSWORD` feature.**  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setPassword(passwordChangeRequest: PasswordChangeRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordChangeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPassword(passwordChangeRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordManagementApi - factory interface
 * @export
 */
export const PasswordManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordManagementApiFp(configuration)
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordChangeStatus(id: string, axiosOptions?: any): AxiosPromise<PasswordStatus> {
            return localVarFp.getPasswordChangeStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo(passwordInfoQueryDTO: PasswordInfoQueryDTO, axiosOptions?: any): AxiosPromise<PasswordInfo> {
            return localVarFp.queryPasswordInfo(passwordInfoQueryDTO, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their ISC user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  >**Note: If you want to set an identity\'s source account password, you must enable `PASSWORD` as one of the source\'s features. You can use the [PATCH Source endpoint](https://developer.sailpoint.com/docs/api/v3/update-source) to add the `PASSWORD` feature.**  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPassword(passwordChangeRequest: PasswordChangeRequest, axiosOptions?: any): AxiosPromise<PasswordChangeResponse> {
            return localVarFp.setPassword(passwordChangeRequest, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPasswordChangeStatus operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiGetPasswordChangeStatusRequest
 */
export interface PasswordManagementApiGetPasswordChangeStatusRequest {
    /**
     * Password change request ID
     * @type {string}
     * @memberof PasswordManagementApiGetPasswordChangeStatus
     */
    readonly id: string
}

/**
 * Request parameters for queryPasswordInfo operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiQueryPasswordInfoRequest
 */
export interface PasswordManagementApiQueryPasswordInfoRequest {
    /**
     * 
     * @type {PasswordInfoQueryDTO}
     * @memberof PasswordManagementApiQueryPasswordInfo
     */
    readonly passwordInfoQueryDTO: PasswordInfoQueryDTO
}

/**
 * Request parameters for setPassword operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiSetPasswordRequest
 */
export interface PasswordManagementApiSetPasswordRequest {
    /**
     * 
     * @type {PasswordChangeRequest}
     * @memberof PasswordManagementApiSetPassword
     */
    readonly passwordChangeRequest: PasswordChangeRequest
}

/**
 * PasswordManagementApi - object-oriented interface
 * @export
 * @class PasswordManagementApi
 * @extends {BaseAPI}
 */
export class PasswordManagementApi extends BaseAPI {
    /**
     * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
     * @summary Get Password Change Request Status
     * @param {PasswordManagementApiGetPasswordChangeStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public getPasswordChangeStatus(requestParameters: PasswordManagementApiGetPasswordChangeStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).getPasswordChangeStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
     * @summary Query Password Info
     * @param {PasswordManagementApiQueryPasswordInfoRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public queryPasswordInfo(requestParameters: PasswordManagementApiQueryPasswordInfoRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).queryPasswordInfo(requestParameters.passwordInfoQueryDTO, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their ISC user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  >**Note: If you want to set an identity\'s source account password, you must enable `PASSWORD` as one of the source\'s features. You can use the [PATCH Source endpoint](https://developer.sailpoint.com/docs/api/v3/update-source) to add the `PASSWORD` feature.**  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
     * @summary Set Identity\'s Password
     * @param {PasswordManagementApiSetPasswordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public setPassword(requestParameters: PasswordManagementApiSetPasswordRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).setPassword(requestParameters.passwordChangeRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordPoliciesApi - axios parameter creator
 * @export
 */
export const PasswordPoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Policy
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordPolicy: async (passwordPolicyV3Dto: PasswordPolicyV3Dto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordPolicyV3Dto' is not null or undefined
            assertParamExists('createPasswordPolicy', 'passwordPolicyV3Dto', passwordPolicyV3Dto)
            const localVarPath = `/password-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordPolicyV3Dto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Policy by ID
         * @param {string} id The ID of password policy to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordPolicy: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePasswordPolicy', 'id', id)
            const localVarPath = `/password-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the password policy for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Policy by ID
         * @param {string} id The ID of password policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordPolicyById: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPasswordPolicyById', 'id', id)
            const localVarPath = `/password-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets list of all Password Policies. Requires role of ORG_ADMIN
         * @summary List Password Policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPasswordPolicies: async (limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Policy by ID
         * @param {string} id The ID of password policy to update.
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPasswordPolicy: async (id: string, passwordPolicyV3Dto: PasswordPolicyV3Dto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setPasswordPolicy', 'id', id)
            // verify required parameter 'passwordPolicyV3Dto' is not null or undefined
            assertParamExists('setPasswordPolicy', 'passwordPolicyV3Dto', passwordPolicyV3Dto)
            const localVarPath = `/password-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordPolicyV3Dto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordPoliciesApi - functional programming interface
 * @export
 */
export const PasswordPoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordPoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Policy
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPasswordPolicy(passwordPolicyV3Dto: PasswordPolicyV3Dto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordPolicyV3Dto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPasswordPolicy(passwordPolicyV3Dto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API deletes the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Policy by ID
         * @param {string} id The ID of password policy to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePasswordPolicy(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePasswordPolicy(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the password policy for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Policy by ID
         * @param {string} id The ID of password policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordPolicyById(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordPolicyV3Dto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordPolicyById(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets list of all Password Policies. Requires role of ORG_ADMIN
         * @summary List Password Policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPasswordPolicies(limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PasswordPolicyV3Dto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPasswordPolicies(limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Policy by ID
         * @param {string} id The ID of password policy to update.
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setPasswordPolicy(id: string, passwordPolicyV3Dto: PasswordPolicyV3Dto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordPolicyV3Dto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPasswordPolicy(id, passwordPolicyV3Dto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordPoliciesApi - factory interface
 * @export
 */
export const PasswordPoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordPoliciesApiFp(configuration)
    return {
        /**
         * This API creates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Policy
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordPolicy(passwordPolicyV3Dto: PasswordPolicyV3Dto, axiosOptions?: any): AxiosPromise<PasswordPolicyV3Dto> {
            return localVarFp.createPasswordPolicy(passwordPolicyV3Dto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Policy by ID
         * @param {string} id The ID of password policy to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordPolicy(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deletePasswordPolicy(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the password policy for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Policy by ID
         * @param {string} id The ID of password policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordPolicyById(id: string, axiosOptions?: any): AxiosPromise<PasswordPolicyV3Dto> {
            return localVarFp.getPasswordPolicyById(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets list of all Password Policies. Requires role of ORG_ADMIN
         * @summary List Password Policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPasswordPolicies(limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<PasswordPolicyV3Dto>> {
            return localVarFp.listPasswordPolicies(limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Policy by ID
         * @param {string} id The ID of password policy to update.
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPasswordPolicy(id: string, passwordPolicyV3Dto: PasswordPolicyV3Dto, axiosOptions?: any): AxiosPromise<PasswordPolicyV3Dto> {
            return localVarFp.setPasswordPolicy(id, passwordPolicyV3Dto, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPasswordPolicy operation in PasswordPoliciesApi.
 * @export
 * @interface PasswordPoliciesApiCreatePasswordPolicyRequest
 */
export interface PasswordPoliciesApiCreatePasswordPolicyRequest {
    /**
     * 
     * @type {PasswordPolicyV3Dto}
     * @memberof PasswordPoliciesApiCreatePasswordPolicy
     */
    readonly passwordPolicyV3Dto: PasswordPolicyV3Dto
}

/**
 * Request parameters for deletePasswordPolicy operation in PasswordPoliciesApi.
 * @export
 * @interface PasswordPoliciesApiDeletePasswordPolicyRequest
 */
export interface PasswordPoliciesApiDeletePasswordPolicyRequest {
    /**
     * The ID of password policy to delete.
     * @type {string}
     * @memberof PasswordPoliciesApiDeletePasswordPolicy
     */
    readonly id: string
}

/**
 * Request parameters for getPasswordPolicyById operation in PasswordPoliciesApi.
 * @export
 * @interface PasswordPoliciesApiGetPasswordPolicyByIdRequest
 */
export interface PasswordPoliciesApiGetPasswordPolicyByIdRequest {
    /**
     * The ID of password policy to retrieve.
     * @type {string}
     * @memberof PasswordPoliciesApiGetPasswordPolicyById
     */
    readonly id: string
}

/**
 * Request parameters for listPasswordPolicies operation in PasswordPoliciesApi.
 * @export
 * @interface PasswordPoliciesApiListPasswordPoliciesRequest
 */
export interface PasswordPoliciesApiListPasswordPoliciesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordPoliciesApiListPasswordPolicies
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordPoliciesApiListPasswordPolicies
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof PasswordPoliciesApiListPasswordPolicies
     */
    readonly count?: boolean
}

/**
 * Request parameters for setPasswordPolicy operation in PasswordPoliciesApi.
 * @export
 * @interface PasswordPoliciesApiSetPasswordPolicyRequest
 */
export interface PasswordPoliciesApiSetPasswordPolicyRequest {
    /**
     * The ID of password policy to update.
     * @type {string}
     * @memberof PasswordPoliciesApiSetPasswordPolicy
     */
    readonly id: string

    /**
     * 
     * @type {PasswordPolicyV3Dto}
     * @memberof PasswordPoliciesApiSetPasswordPolicy
     */
    readonly passwordPolicyV3Dto: PasswordPolicyV3Dto
}

/**
 * PasswordPoliciesApi - object-oriented interface
 * @export
 * @class PasswordPoliciesApi
 * @extends {BaseAPI}
 */
export class PasswordPoliciesApi extends BaseAPI {
    /**
     * This API creates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Password Policy
     * @param {PasswordPoliciesApiCreatePasswordPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    public createPasswordPolicy(requestParameters: PasswordPoliciesApiCreatePasswordPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordPoliciesApiFp(this.configuration).createPasswordPolicy(requestParameters.passwordPolicyV3Dto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes the specified password policy. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete Password Policy by ID
     * @param {PasswordPoliciesApiDeletePasswordPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    public deletePasswordPolicy(requestParameters: PasswordPoliciesApiDeletePasswordPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordPoliciesApiFp(this.configuration).deletePasswordPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the password policy for the specified ID. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Policy by ID
     * @param {PasswordPoliciesApiGetPasswordPolicyByIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    public getPasswordPolicyById(requestParameters: PasswordPoliciesApiGetPasswordPolicyByIdRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordPoliciesApiFp(this.configuration).getPasswordPolicyById(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets list of all Password Policies. Requires role of ORG_ADMIN
     * @summary List Password Policies
     * @param {PasswordPoliciesApiListPasswordPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    public listPasswordPolicies(requestParameters: PasswordPoliciesApiListPasswordPoliciesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PasswordPoliciesApiFp(this.configuration).listPasswordPolicies(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Password Policy by ID
     * @param {PasswordPoliciesApiSetPasswordPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    public setPasswordPolicy(requestParameters: PasswordPoliciesApiSetPasswordPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordPoliciesApiFp(this.configuration).setPasswordPolicy(requestParameters.id, requestParameters.passwordPolicyV3Dto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordSyncGroupsApi - axios parameter creator
 * @export
 */
export const PasswordSyncGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordSyncGroup: async (passwordSyncGroup: PasswordSyncGroup, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordSyncGroup' is not null or undefined
            assertParamExists('createPasswordSyncGroup', 'passwordSyncGroup', passwordSyncGroup)
            const localVarPath = `/password-sync-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordSyncGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordSyncGroup: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePasswordSyncGroup', 'id', id)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroup: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPasswordSyncGroup', 'id', id)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroups: async (limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-sync-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSyncGroup: async (id: string, passwordSyncGroup: PasswordSyncGroup, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePasswordSyncGroup', 'id', id)
            // verify required parameter 'passwordSyncGroup' is not null or undefined
            assertParamExists('updatePasswordSyncGroup', 'passwordSyncGroup', passwordSyncGroup)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordSyncGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordSyncGroupsApi - functional programming interface
 * @export
 */
export const PasswordSyncGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordSyncGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPasswordSyncGroup(passwordSyncGroup: PasswordSyncGroup, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPasswordSyncGroup(passwordSyncGroup, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePasswordSyncGroup(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePasswordSyncGroup(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordSyncGroup(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordSyncGroup(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordSyncGroups(limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PasswordSyncGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordSyncGroups(limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasswordSyncGroup(id: string, passwordSyncGroup: PasswordSyncGroup, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasswordSyncGroup(id, passwordSyncGroup, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordSyncGroupsApi - factory interface
 * @export
 */
export const PasswordSyncGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordSyncGroupsApiFp(configuration)
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordSyncGroup(passwordSyncGroup: PasswordSyncGroup, axiosOptions?: any): AxiosPromise<PasswordSyncGroup> {
            return localVarFp.createPasswordSyncGroup(passwordSyncGroup, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordSyncGroup(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deletePasswordSyncGroup(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroup(id: string, axiosOptions?: any): AxiosPromise<PasswordSyncGroup> {
            return localVarFp.getPasswordSyncGroup(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroups(limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<PasswordSyncGroup>> {
            return localVarFp.getPasswordSyncGroups(limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSyncGroup(id: string, passwordSyncGroup: PasswordSyncGroup, axiosOptions?: any): AxiosPromise<PasswordSyncGroup> {
            return localVarFp.updatePasswordSyncGroup(id, passwordSyncGroup, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiCreatePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiCreatePasswordSyncGroupRequest {
    /**
     * 
     * @type {PasswordSyncGroup}
     * @memberof PasswordSyncGroupsApiCreatePasswordSyncGroup
     */
    readonly passwordSyncGroup: PasswordSyncGroup
}

/**
 * Request parameters for deletePasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiDeletePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiDeletePasswordSyncGroupRequest {
    /**
     * The ID of password sync group to delete.
     * @type {string}
     * @memberof PasswordSyncGroupsApiDeletePasswordSyncGroup
     */
    readonly id: string
}

/**
 * Request parameters for getPasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiGetPasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiGetPasswordSyncGroupRequest {
    /**
     * The ID of password sync group to retrieve.
     * @type {string}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroup
     */
    readonly id: string
}

/**
 * Request parameters for getPasswordSyncGroups operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiGetPasswordSyncGroupsRequest
 */
export interface PasswordSyncGroupsApiGetPasswordSyncGroupsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroups
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroups
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroups
     */
    readonly count?: boolean
}

/**
 * Request parameters for updatePasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest {
    /**
     * The ID of password sync group to update.
     * @type {string}
     * @memberof PasswordSyncGroupsApiUpdatePasswordSyncGroup
     */
    readonly id: string

    /**
     * 
     * @type {PasswordSyncGroup}
     * @memberof PasswordSyncGroupsApiUpdatePasswordSyncGroup
     */
    readonly passwordSyncGroup: PasswordSyncGroup
}

/**
 * PasswordSyncGroupsApi - object-oriented interface
 * @export
 * @class PasswordSyncGroupsApi
 * @extends {BaseAPI}
 */
export class PasswordSyncGroupsApi extends BaseAPI {
    /**
     * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Password Sync Group
     * @param {PasswordSyncGroupsApiCreatePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public createPasswordSyncGroup(requestParameters: PasswordSyncGroupsApiCreatePasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).createPasswordSyncGroup(requestParameters.passwordSyncGroup, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete Password Sync Group by ID
     * @param {PasswordSyncGroupsApiDeletePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public deletePasswordSyncGroup(requestParameters: PasswordSyncGroupsApiDeletePasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).deletePasswordSyncGroup(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Sync Group by ID
     * @param {PasswordSyncGroupsApiGetPasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public getPasswordSyncGroup(requestParameters: PasswordSyncGroupsApiGetPasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).getPasswordSyncGroup(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Sync Group List
     * @param {PasswordSyncGroupsApiGetPasswordSyncGroupsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public getPasswordSyncGroups(requestParameters: PasswordSyncGroupsApiGetPasswordSyncGroupsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).getPasswordSyncGroups(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Password Sync Group by ID
     * @param {PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public updatePasswordSyncGroup(requestParameters: PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).updatePasswordSyncGroup(requestParameters.id, requestParameters.passwordSyncGroup, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonalAccessTokensApi - axios parameter creator
 * @export
 */
export const PersonalAccessTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken: async (createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonalAccessTokenRequest' is not null or undefined
            assertParamExists('createPersonalAccessToken', 'createPersonalAccessTokenRequest', createPersonalAccessTokenRequest)
            const localVarPath = `/personal-access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonalAccessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePersonalAccessToken', 'id', id)
            const localVarPath = `/personal-access-tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens: async (ownerId?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personal-access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchPersonalAccessToken', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchPersonalAccessToken', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/personal-access-tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonalAccessTokensApi - functional programming interface
 * @export
 */
export const PersonalAccessTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonalAccessTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPersonalAccessToken(createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersonalAccessToken(createPersonalAccessTokenRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePersonalAccessToken(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonalAccessToken(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonalAccessTokens(ownerId?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPersonalAccessTokenResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonalAccessTokens(ownerId, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchPersonalAccessToken(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchPersonalAccessToken(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonalAccessTokensApi - factory interface
 * @export
 */
export const PersonalAccessTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonalAccessTokensApiFp(configuration)
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken(createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest, axiosOptions?: any): AxiosPromise<CreatePersonalAccessTokenResponse> {
            return localVarFp.createPersonalAccessToken(createPersonalAccessTokenRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deletePersonalAccessToken(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens(ownerId?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<GetPersonalAccessTokenResponse>> {
            return localVarFp.listPersonalAccessTokens(ownerId, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<GetPersonalAccessTokenResponse> {
            return localVarFp.patchPersonalAccessToken(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiCreatePersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiCreatePersonalAccessTokenRequest {
    /**
     * Name and scope of personal access token.
     * @type {CreatePersonalAccessTokenRequest}
     * @memberof PersonalAccessTokensApiCreatePersonalAccessToken
     */
    readonly createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest
}

/**
 * Request parameters for deletePersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiDeletePersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiDeletePersonalAccessTokenRequest {
    /**
     * The personal access token id
     * @type {string}
     * @memberof PersonalAccessTokensApiDeletePersonalAccessToken
     */
    readonly id: string
}

/**
 * Request parameters for listPersonalAccessTokens operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiListPersonalAccessTokensRequest
 */
export interface PersonalAccessTokensApiListPersonalAccessTokensRequest {
    /**
     * The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
     * @type {string}
     * @memberof PersonalAccessTokensApiListPersonalAccessTokens
     */
    readonly ownerId?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
     * @type {string}
     * @memberof PersonalAccessTokensApiListPersonalAccessTokens
     */
    readonly filters?: string
}

/**
 * Request parameters for patchPersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiPatchPersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiPatchPersonalAccessTokenRequest {
    /**
     * The Personal Access Token id
     * @type {string}
     * @memberof PersonalAccessTokensApiPatchPersonalAccessToken
     */
    readonly id: string

    /**
     * A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
     * @type {Array<JsonPatchOperation>}
     * @memberof PersonalAccessTokensApiPatchPersonalAccessToken
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * PersonalAccessTokensApi - object-oriented interface
 * @export
 * @class PersonalAccessTokensApi
 * @extends {BaseAPI}
 */
export class PersonalAccessTokensApi extends BaseAPI {
    /**
     * This creates a personal access token.
     * @summary Create Personal Access Token
     * @param {PersonalAccessTokensApiCreatePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public createPersonalAccessToken(requestParameters: PersonalAccessTokensApiCreatePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).createPersonalAccessToken(requestParameters.createPersonalAccessTokenRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a personal access token.
     * @summary Delete Personal Access Token
     * @param {PersonalAccessTokensApiDeletePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public deletePersonalAccessToken(requestParameters: PersonalAccessTokensApiDeletePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).deletePersonalAccessToken(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
     * @summary List Personal Access Tokens
     * @param {PersonalAccessTokensApiListPersonalAccessTokensRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public listPersonalAccessTokens(requestParameters: PersonalAccessTokensApiListPersonalAccessTokensRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).listPersonalAccessTokens(requestParameters.ownerId, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This performs a targeted update to the field(s) of a Personal Access Token.
     * @summary Patch Personal Access Token
     * @param {PersonalAccessTokensApiPatchPersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public patchPersonalAccessToken(requestParameters: PersonalAccessTokensApiPatchPersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).patchPersonalAccessToken(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicIdentitiesApi - axios parameter creator
 * @export
 */
export const PublicIdentitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentities: async (limit?: number, offset?: number, count?: boolean, filters?: string, addCoreFilters?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public-identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (addCoreFilters !== undefined) {
                localVarQueryParameter['add-core-filters'] = addCoreFilters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicIdentitiesApi - functional programming interface
 * @export
 */
export const PublicIdentitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicIdentitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicIdentities(limit?: number, offset?: number, count?: boolean, filters?: string, addCoreFilters?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicIdentity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicIdentities(limit, offset, count, filters, addCoreFilters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicIdentitiesApi - factory interface
 * @export
 */
export const PublicIdentitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicIdentitiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentities(limit?: number, offset?: number, count?: boolean, filters?: string, addCoreFilters?: boolean, sorters?: string, axiosOptions?: any): AxiosPromise<Array<PublicIdentity>> {
            return localVarFp.getPublicIdentities(limit, offset, count, filters, addCoreFilters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPublicIdentities operation in PublicIdentitiesApi.
 * @export
 * @interface PublicIdentitiesApiGetPublicIdentitiesRequest
 */
export interface PublicIdentitiesApiGetPublicIdentitiesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
     * @type {string}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly filters?: string

    /**
     * If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
     * @type {boolean}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly addCoreFilters?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly sorters?: string
}

/**
 * PublicIdentitiesApi - object-oriented interface
 * @export
 * @class PublicIdentitiesApi
 * @extends {BaseAPI}
 */
export class PublicIdentitiesApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of public identities
     * @param {PublicIdentitiesApiGetPublicIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesApi
     */
    public getPublicIdentities(requestParameters: PublicIdentitiesApiGetPublicIdentitiesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesApiFp(this.configuration).getPublicIdentities(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.addCoreFilters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicIdentitiesConfigApi - axios parameter creator
 * @export
 */
export const PublicIdentitiesConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public-identities-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig: async (publicIdentityConfig: PublicIdentityConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicIdentityConfig' is not null or undefined
            assertParamExists('updatePublicIdentityConfig', 'publicIdentityConfig', publicIdentityConfig)
            const localVarPath = `/public-identities-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicIdentityConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicIdentitiesConfigApi - functional programming interface
 * @export
 */
export const PublicIdentitiesConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicIdentitiesConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicIdentityConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIdentityConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicIdentityConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicIdentityConfig(publicIdentityConfig: PublicIdentityConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIdentityConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicIdentityConfig(publicIdentityConfig, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicIdentitiesConfigApi - factory interface
 * @export
 */
export const PublicIdentitiesConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicIdentitiesConfigApiFp(configuration)
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig(axiosOptions?: any): AxiosPromise<PublicIdentityConfig> {
            return localVarFp.getPublicIdentityConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig(publicIdentityConfig: PublicIdentityConfig, axiosOptions?: any): AxiosPromise<PublicIdentityConfig> {
            return localVarFp.updatePublicIdentityConfig(publicIdentityConfig, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updatePublicIdentityConfig operation in PublicIdentitiesConfigApi.
 * @export
 * @interface PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest
 */
export interface PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest {
    /**
     * 
     * @type {PublicIdentityConfig}
     * @memberof PublicIdentitiesConfigApiUpdatePublicIdentityConfig
     */
    readonly publicIdentityConfig: PublicIdentityConfig
}

/**
 * PublicIdentitiesConfigApi - object-oriented interface
 * @export
 * @class PublicIdentitiesConfigApi
 * @extends {BaseAPI}
 */
export class PublicIdentitiesConfigApi extends BaseAPI {
    /**
     * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
     * @summary Get the Public Identities Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigApi
     */
    public getPublicIdentityConfig(axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesConfigApiFp(this.configuration).getPublicIdentityConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
     * @summary Update the Public Identities Configuration
     * @param {PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigApi
     */
    public updatePublicIdentityConfig(requestParameters: PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesConfigApiFp(this.configuration).updatePublicIdentityConfig(requestParameters.publicIdentityConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportsDataExtractionApi - axios parameter creator
 * @export
 */
export const ReportsDataExtractionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels a running report.
         * @summary Cancel Report
         * @param {string} id ID of the running Report to cancel
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelReport', 'id', id)
            const localVarPath = `/reports/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a report in file format.
         * @summary Get Report File
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {'csv' | 'pdf'} fileFormat Output format of the requested report file
         * @param {string} [name] preferred Report file name, by default will be used report name from task result.
         * @param {boolean} [auditable] Enables auditing for current report download. Will create an audit event and sent it to the REPORT cloud-audit kafka topic.  Event will be created if there is any result present by requested taskResultId.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (taskResultId: string, fileFormat: 'csv' | 'pdf', name?: string, auditable?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskResultId' is not null or undefined
            assertParamExists('getReport', 'taskResultId', taskResultId)
            // verify required parameter 'fileFormat' is not null or undefined
            assertParamExists('getReport', 'fileFormat', fileFormat)
            const localVarPath = `/reports/{taskResultId}`
                .replace(`{${"taskResultId"}}`, encodeURIComponent(String(taskResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (fileFormat !== undefined) {
                localVarQueryParameter['fileFormat'] = fileFormat;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (auditable !== undefined) {
                localVarQueryParameter['auditable'] = auditable;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
         * @summary Get Report Result
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {boolean} [completed] state of task result to apply ordering when results are fetching from the DB
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReportResult: async (taskResultId: string, completed?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskResultId' is not null or undefined
            assertParamExists('getReportResult', 'taskResultId', taskResultId)
            const localVarPath = `/reports/{taskResultId}/result`
                .replace(`{${"taskResultId"}}`, encodeURIComponent(String(taskResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (completed !== undefined) {
                localVarQueryParameter['completed'] = completed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Runs a report according to input report details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
         * @summary Run Report
         * @param {ReportDetails} reportDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startReport: async (reportDetails: ReportDetails, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportDetails' is not null or undefined
            assertParamExists('startReport', 'reportDetails', reportDetails)
            const localVarPath = `/reports/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsDataExtractionApi - functional programming interface
 * @export
 */
export const ReportsDataExtractionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsDataExtractionApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels a running report.
         * @summary Cancel Report
         * @param {string} id ID of the running Report to cancel
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelReport(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelReport(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a report in file format.
         * @summary Get Report File
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {'csv' | 'pdf'} fileFormat Output format of the requested report file
         * @param {string} [name] preferred Report file name, by default will be used report name from task result.
         * @param {boolean} [auditable] Enables auditing for current report download. Will create an audit event and sent it to the REPORT cloud-audit kafka topic.  Event will be created if there is any result present by requested taskResultId.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(taskResultId: string, fileFormat: 'csv' | 'pdf', name?: string, auditable?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(taskResultId, fileFormat, name, auditable, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
         * @summary Get Report Result
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {boolean} [completed] state of task result to apply ordering when results are fetching from the DB
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getReportResult(taskResultId: string, completed?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReportResult(taskResultId, completed, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Runs a report according to input report details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
         * @summary Run Report
         * @param {ReportDetails} reportDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startReport(reportDetails: ReportDetails, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResultDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startReport(reportDetails, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportsDataExtractionApi - factory interface
 * @export
 */
export const ReportsDataExtractionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsDataExtractionApiFp(configuration)
    return {
        /**
         * Cancels a running report.
         * @summary Cancel Report
         * @param {string} id ID of the running Report to cancel
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.cancelReport(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a report in file format.
         * @summary Get Report File
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {'csv' | 'pdf'} fileFormat Output format of the requested report file
         * @param {string} [name] preferred Report file name, by default will be used report name from task result.
         * @param {boolean} [auditable] Enables auditing for current report download. Will create an audit event and sent it to the REPORT cloud-audit kafka topic.  Event will be created if there is any result present by requested taskResultId.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReport(taskResultId: string, fileFormat: 'csv' | 'pdf', name?: string, auditable?: boolean, axiosOptions?: any): AxiosPromise<any> {
            return localVarFp.getReport(taskResultId, fileFormat, name, auditable, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
         * @summary Get Report Result
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {boolean} [completed] state of task result to apply ordering when results are fetching from the DB
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReportResult(taskResultId: string, completed?: boolean, axiosOptions?: any): AxiosPromise<ReportResults> {
            return localVarFp.getReportResult(taskResultId, completed, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Runs a report according to input report details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
         * @summary Run Report
         * @param {ReportDetails} reportDetails 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startReport(reportDetails: ReportDetails, axiosOptions?: any): AxiosPromise<TaskResultDetails> {
            return localVarFp.startReport(reportDetails, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelReport operation in ReportsDataExtractionApi.
 * @export
 * @interface ReportsDataExtractionApiCancelReportRequest
 */
export interface ReportsDataExtractionApiCancelReportRequest {
    /**
     * ID of the running Report to cancel
     * @type {string}
     * @memberof ReportsDataExtractionApiCancelReport
     */
    readonly id: string
}

/**
 * Request parameters for getReport operation in ReportsDataExtractionApi.
 * @export
 * @interface ReportsDataExtractionApiGetReportRequest
 */
export interface ReportsDataExtractionApiGetReportRequest {
    /**
     * Unique identifier of the task result which handled report
     * @type {string}
     * @memberof ReportsDataExtractionApiGetReport
     */
    readonly taskResultId: string

    /**
     * Output format of the requested report file
     * @type {'csv' | 'pdf'}
     * @memberof ReportsDataExtractionApiGetReport
     */
    readonly fileFormat: 'csv' | 'pdf'

    /**
     * preferred Report file name, by default will be used report name from task result.
     * @type {string}
     * @memberof ReportsDataExtractionApiGetReport
     */
    readonly name?: string

    /**
     * Enables auditing for current report download. Will create an audit event and sent it to the REPORT cloud-audit kafka topic.  Event will be created if there is any result present by requested taskResultId.
     * @type {boolean}
     * @memberof ReportsDataExtractionApiGetReport
     */
    readonly auditable?: boolean
}

/**
 * Request parameters for getReportResult operation in ReportsDataExtractionApi.
 * @export
 * @interface ReportsDataExtractionApiGetReportResultRequest
 */
export interface ReportsDataExtractionApiGetReportResultRequest {
    /**
     * Unique identifier of the task result which handled report
     * @type {string}
     * @memberof ReportsDataExtractionApiGetReportResult
     */
    readonly taskResultId: string

    /**
     * state of task result to apply ordering when results are fetching from the DB
     * @type {boolean}
     * @memberof ReportsDataExtractionApiGetReportResult
     */
    readonly completed?: boolean
}

/**
 * Request parameters for startReport operation in ReportsDataExtractionApi.
 * @export
 * @interface ReportsDataExtractionApiStartReportRequest
 */
export interface ReportsDataExtractionApiStartReportRequest {
    /**
     * 
     * @type {ReportDetails}
     * @memberof ReportsDataExtractionApiStartReport
     */
    readonly reportDetails: ReportDetails
}

/**
 * ReportsDataExtractionApi - object-oriented interface
 * @export
 * @class ReportsDataExtractionApi
 * @extends {BaseAPI}
 */
export class ReportsDataExtractionApi extends BaseAPI {
    /**
     * Cancels a running report.
     * @summary Cancel Report
     * @param {ReportsDataExtractionApiCancelReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    public cancelReport(requestParameters: ReportsDataExtractionApiCancelReportRequest, axiosOptions?: AxiosRequestConfig) {
        return ReportsDataExtractionApiFp(this.configuration).cancelReport(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a report in file format.
     * @summary Get Report File
     * @param {ReportsDataExtractionApiGetReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    public getReport(requestParameters: ReportsDataExtractionApiGetReportRequest, axiosOptions?: AxiosRequestConfig) {
        return ReportsDataExtractionApiFp(this.configuration).getReport(requestParameters.taskResultId, requestParameters.fileFormat, requestParameters.name, requestParameters.auditable, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
     * @summary Get Report Result
     * @param {ReportsDataExtractionApiGetReportResultRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    public getReportResult(requestParameters: ReportsDataExtractionApiGetReportResultRequest, axiosOptions?: AxiosRequestConfig) {
        return ReportsDataExtractionApiFp(this.configuration).getReportResult(requestParameters.taskResultId, requestParameters.completed, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Runs a report according to input report details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
     * @summary Run Report
     * @param {ReportsDataExtractionApiStartReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    public startReport(requestParameters: ReportsDataExtractionApiStartReportRequest, axiosOptions?: AxiosRequestConfig) {
        return ReportsDataExtractionApiFp(this.configuration).startReport(requestParameters.reportDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RequestableObjectsApi - axios parameter creator
 * @export
 */
export const RequestableObjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects: async (identityId?: string, types?: Array<RequestableObjectType>, term?: string, statuses?: Array<RequestableObjectRequestStatus>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/requestable-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (identityId !== undefined) {
                localVarQueryParameter['identity-id'] = identityId;
            }

            if (types) {
                localVarQueryParameter['types'] = types.join(COLLECTION_FORMATS.csv);
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequestableObjectsApi - functional programming interface
 * @export
 */
export const RequestableObjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RequestableObjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listRequestableObjects(identityId?: string, types?: Array<RequestableObjectType>, term?: string, statuses?: Array<RequestableObjectRequestStatus>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RequestableObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRequestableObjects(identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RequestableObjectsApi - factory interface
 * @export
 */
export const RequestableObjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RequestableObjectsApiFp(configuration)
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects(identityId?: string, types?: Array<RequestableObjectType>, term?: string, statuses?: Array<RequestableObjectRequestStatus>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<RequestableObject>> {
            return localVarFp.listRequestableObjects(identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listRequestableObjects operation in RequestableObjectsApi.
 * @export
 * @interface RequestableObjectsApiListRequestableObjectsRequest
 */
export interface RequestableObjectsApiListRequestableObjectsRequest {
    /**
     * If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly identityId?: string

    /**
     * Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
     * @type {Array<RequestableObjectType>}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly types?: Array<RequestableObjectType>

    /**
     * It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly term?: string

    /**
     * Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
     * @type {Array<RequestableObjectRequestStatus>}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly statuses?: Array<RequestableObjectRequestStatus>

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly sorters?: string
}

/**
 * RequestableObjectsApi - object-oriented interface
 * @export
 * @class RequestableObjectsApi
 * @extends {BaseAPI}
 */
export class RequestableObjectsApi extends BaseAPI {
    /**
     * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
     * @summary Requestable Objects List
     * @param {RequestableObjectsApiListRequestableObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestableObjectsApi
     */
    public listRequestableObjects(requestParameters: RequestableObjectsApiListRequestableObjectsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return RequestableObjectsApiFp(this.configuration).listRequestableObjects(requestParameters.identityId, requestParameters.types, requestParameters.term, requestParameters.statuses, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a role.  You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.   In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.   The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {Role} role 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (role: Role, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('createRole', 'role', role)
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint initiates a bulk deletion of one or more roles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 roles per request.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this endpoint. In addition, a token with ROLE_SUBADMIN authority can only call this endpoint if all roles included in the request are associated with sources with management workgroups the ROLE_SUBADMIN is a member of.
         * @summary Delete Role(s)
         * @param {RoleBulkDeleteRequest} roleBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBulkRoles: async (roleBulkDeleteRequest: RoleBulkDeleteRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleBulkDeleteRequest' is not null or undefined
            assertParamExists('deleteBulkRoles', 'roleBulkDeleteRequest', roleBulkDeleteRequest)
            const localVarPath = `/roles/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleBulkDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, aliasName, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignedIdentities: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoleAssignedIdentities', 'id', id)
            const localVarPath = `/roles/{id}/assigned-identities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSegmentIds !== undefined) {
                localVarQueryParameter['for-segment-ids'] = forSegmentIds;
            }

            if (includeUnsegmented !== undefined) {
                localVarQueryParameter['include-unsegmented'] = includeUnsegmented;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable:  * name * description * enabled * owner * accessProfiles * membership * requestable * accessRequestConfig * revokeRequestConfig * segments  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all access profiles included in the role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.  When you use this API to modify a role\'s membership identities, you can only modify up to a limit of 500 membership identities at a time. 
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRole: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchRole', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchRole', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a role.  You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.   In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.   The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {Role} role 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(role: Role, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(role, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint initiates a bulk deletion of one or more roles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 roles per request.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this endpoint. In addition, a token with ROLE_SUBADMIN authority can only call this endpoint if all roles included in the request are associated with sources with management workgroups the ROLE_SUBADMIN is a member of.
         * @summary Delete Role(s)
         * @param {RoleBulkDeleteRequest} roleBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBulkRoles(roleBulkDeleteRequest: RoleBulkDeleteRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBulkRoles(roleBulkDeleteRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API deletes a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, aliasName, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleAssignedIdentities(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleIdentity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleAssignedIdentities(id, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates an existing role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable:  * name * description * enabled * owner * accessProfiles * membership * requestable * accessRequestConfig * revokeRequestConfig * segments  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all access profiles included in the role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.  When you use this API to modify a role\'s membership identities, you can only modify up to a limit of 500 membership identities at a time. 
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchRole(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRole(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * This API creates a role.  You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.   In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.   The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {Role} role 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRole(role: Role, axiosOptions?: any): AxiosPromise<Role> {
            return localVarFp.createRole(role, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint initiates a bulk deletion of one or more roles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 roles per request.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this endpoint. In addition, a token with ROLE_SUBADMIN authority can only call this endpoint if all roles included in the request are associated with sources with management workgroups the ROLE_SUBADMIN is a member of.
         * @summary Delete Role(s)
         * @param {RoleBulkDeleteRequest} roleBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBulkRoles(roleBulkDeleteRequest: RoleBulkDeleteRequest, axiosOptions?: any): AxiosPromise<TaskResultDto> {
            return localVarFp.deleteBulkRoles(roleBulkDeleteRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteRole(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRole(id: string, axiosOptions?: any): AxiosPromise<Role> {
            return localVarFp.getRole(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, aliasName, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignedIdentities(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<RoleIdentity>> {
            return localVarFp.getRoleAssignedIdentities(id, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: any): AxiosPromise<Array<Role>> {
            return localVarFp.listRoles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable:  * name * description * enabled * owner * accessProfiles * membership * requestable * accessRequestConfig * revokeRequestConfig * segments  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all access profiles included in the role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.  When you use this API to modify a role\'s membership identities, you can only modify up to a limit of 500 membership identities at a time. 
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRole(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<Role> {
            return localVarFp.patchRole(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createRole operation in RolesApi.
 * @export
 * @interface RolesApiCreateRoleRequest
 */
export interface RolesApiCreateRoleRequest {
    /**
     * 
     * @type {Role}
     * @memberof RolesApiCreateRole
     */
    readonly role: Role
}

/**
 * Request parameters for deleteBulkRoles operation in RolesApi.
 * @export
 * @interface RolesApiDeleteBulkRolesRequest
 */
export interface RolesApiDeleteBulkRolesRequest {
    /**
     * 
     * @type {RoleBulkDeleteRequest}
     * @memberof RolesApiDeleteBulkRoles
     */
    readonly roleBulkDeleteRequest: RoleBulkDeleteRequest
}

/**
 * Request parameters for deleteRole operation in RolesApi.
 * @export
 * @interface RolesApiDeleteRoleRequest
 */
export interface RolesApiDeleteRoleRequest {
    /**
     * ID of the Role
     * @type {string}
     * @memberof RolesApiDeleteRole
     */
    readonly id: string
}

/**
 * Request parameters for getRole operation in RolesApi.
 * @export
 * @interface RolesApiGetRoleRequest
 */
export interface RolesApiGetRoleRequest {
    /**
     * ID of the Role
     * @type {string}
     * @memberof RolesApiGetRole
     */
    readonly id: string
}

/**
 * Request parameters for getRoleAssignedIdentities operation in RolesApi.
 * @export
 * @interface RolesApiGetRoleAssignedIdentitiesRequest
 */
export interface RolesApiGetRoleAssignedIdentitiesRequest {
    /**
     * ID of the Role for which the assigned Identities are to be listed
     * @type {string}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
     * @type {string}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, aliasName, email**
     * @type {string}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly sorters?: string
}

/**
 * Request parameters for listRoles operation in RolesApi.
 * @export
 * @interface RolesApiListRolesRequest
 */
export interface RolesApiListRolesRequest {
    /**
     * If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly forSubadmin?: string

    /**
     * Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiListRoles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiListRoles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RolesApiListRoles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly sorters?: string

    /**
     * If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly forSegmentIds?: string

    /**
     * Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
     * @type {boolean}
     * @memberof RolesApiListRoles
     */
    readonly includeUnsegmented?: boolean
}

/**
 * Request parameters for patchRole operation in RolesApi.
 * @export
 * @interface RolesApiPatchRoleRequest
 */
export interface RolesApiPatchRoleRequest {
    /**
     * ID of the Role to patch
     * @type {string}
     * @memberof RolesApiPatchRole
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperation>}
     * @memberof RolesApiPatchRole
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * This API creates a role.  You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.   In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.   The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
     * @summary Create a Role
     * @param {RolesApiCreateRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public createRole(requestParameters: RolesApiCreateRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).createRole(requestParameters.role, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint initiates a bulk deletion of one or more roles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 roles per request.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this endpoint. In addition, a token with ROLE_SUBADMIN authority can only call this endpoint if all roles included in the request are associated with sources with management workgroups the ROLE_SUBADMIN is a member of.
     * @summary Delete Role(s)
     * @param {RolesApiDeleteBulkRolesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteBulkRoles(requestParameters: RolesApiDeleteBulkRolesRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteBulkRoles(requestParameters.roleBulkDeleteRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
     * @summary Delete a Role
     * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRole(requestParameters: RolesApiDeleteRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteRole(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
     * @summary Get a Role
     * @param {RolesApiGetRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRole(requestParameters: RolesApiGetRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRole(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Identities assigned a Role
     * @param {RolesApiGetRoleAssignedIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleAssignedIdentities(requestParameters: RolesApiGetRoleAssignedIdentitiesRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRoleAssignedIdentities(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
     * @summary List Roles
     * @param {RolesApiListRolesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public listRoles(requestParameters: RolesApiListRolesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).listRoles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable:  * name * description * enabled * owner * accessProfiles * membership * requestable * accessRequestConfig * revokeRequestConfig * segments  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all access profiles included in the role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.  When you use this API to modify a role\'s membership identities, you can only modify up to a limit of 500 membership identities at a time. 
     * @summary Patch a specified Role
     * @param {RolesApiPatchRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public patchRole(requestParameters: RolesApiPatchRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).patchRole(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SODPoliciesApi - axios parameter creator
 * @export
 */
export const SODPoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSodPolicy: async (sodPolicy: SodPolicy, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sodPolicy' is not null or undefined
            assertParamExists('createSodPolicy', 'sodPolicy', sodPolicy)
            const localVarPath = `/sod-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicy: async (id: string, logical?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (logical !== undefined) {
                localVarQueryParameter['logical'] = logical;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicySchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSodPolicySchedule', 'id', id)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCustomViolationReport: async (reportResultId: string, fileName: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('getCustomViolationReport', 'reportResultId', reportResultId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getCustomViolationReport', 'fileName', fileName)
            const localVarPath = `/sod-violation-report/{reportResultId}/download/{fileName}`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultViolationReport: async (reportResultId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('getDefaultViolationReport', 'reportResultId', reportResultId)
            const localVarPath = `/sod-violation-report/{reportResultId}/download`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodAllReportRunStatus: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-violation-report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the SOD Policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicy: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the SOD policy schedule to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicySchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodPolicySchedule', 'id', id)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportRunStatus: async (reportResultId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('getSodViolationReportRunStatus', 'reportResultId', reportResultId)
            const localVarPath = `/sod-policies/sod-violation-report-status/{reportResultId}`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the violation report to retrieve status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodViolationReportStatus', 'id', id)
            const localVarPath = `/sod-policies/{id}/violation-report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in*  **state**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, description**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSodPolicies: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch SOD policy by ID
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSodPolicy: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchSodPolicy', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchSodPolicy', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicySchedule} sodPolicySchedule 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPolicySchedule: async (id: string, sodPolicySchedule: SodPolicySchedule, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putPolicySchedule', 'id', id)
            // verify required parameter 'sodPolicySchedule' is not null or undefined
            assertParamExists('putPolicySchedule', 'sodPolicySchedule', sodPolicySchedule)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicySchedule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSodPolicy: async (id: string, sodPolicy: SodPolicy, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putSodPolicy', 'id', id)
            // verify required parameter 'sodPolicy' is not null or undefined
            assertParamExists('putSodPolicy', 'sodPolicy', sodPolicy)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startEvaluateSodPolicy: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startEvaluateSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}/evaluate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequest} [multiPolicyRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodAllPoliciesForOrg: async (multiPolicyRequest?: MultiPolicyRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-violation-report/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(multiPolicyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodPolicy: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}/violation-report/run`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SODPoliciesApi - functional programming interface
 * @export
 */
export const SODPoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SODPoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSodPolicy(sodPolicy: SodPolicy, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSodPolicy(sodPolicy, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSodPolicy(id: string, logical?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSodPolicy(id, logical, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSodPolicySchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSodPolicySchedule(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomViolationReport(reportResultId: string, fileName: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomViolationReport(reportResultId, fileName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultViolationReport(reportResultId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultViolationReport(reportResultId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodAllReportRunStatus(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodAllReportRunStatus(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the SOD Policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodPolicy(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodPolicy(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the SOD policy schedule to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodPolicySchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicySchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodPolicySchedule(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodViolationReportRunStatus(reportResultId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodViolationReportRunStatus(reportResultId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the violation report to retrieve status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodViolationReportStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodViolationReportStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in*  **state**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, description**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSodPolicies(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SodPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSodPolicies(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch SOD policy by ID
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSodPolicy(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSodPolicy(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicySchedule} sodPolicySchedule 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putPolicySchedule(id: string, sodPolicySchedule: SodPolicySchedule, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicySchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPolicySchedule(id, sodPolicySchedule, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSodPolicy(id: string, sodPolicy: SodPolicy, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSodPolicy(id, sodPolicy, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startEvaluateSodPolicy(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startEvaluateSodPolicy(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequest} [multiPolicyRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startSodAllPoliciesForOrg(multiPolicyRequest?: MultiPolicyRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startSodAllPoliciesForOrg(multiPolicyRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startSodPolicy(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startSodPolicy(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SODPoliciesApi - factory interface
 * @export
 */
export const SODPoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SODPoliciesApiFp(configuration)
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSodPolicy(sodPolicy: SodPolicy, axiosOptions?: any): AxiosPromise<SodPolicy> {
            return localVarFp.createSodPolicy(sodPolicy, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicy(id: string, logical?: boolean, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSodPolicy(id, logical, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicySchedule(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSodPolicySchedule(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCustomViolationReport(reportResultId: string, fileName: string, axiosOptions?: any): AxiosPromise<any> {
            return localVarFp.getCustomViolationReport(reportResultId, fileName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultViolationReport(reportResultId: string, axiosOptions?: any): AxiosPromise<any> {
            return localVarFp.getDefaultViolationReport(reportResultId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodAllReportRunStatus(axiosOptions?: any): AxiosPromise<ReportResultReference> {
            return localVarFp.getSodAllReportRunStatus(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the SOD Policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicy(id: string, axiosOptions?: any): AxiosPromise<SodPolicy> {
            return localVarFp.getSodPolicy(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the SOD policy schedule to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicySchedule(id: string, axiosOptions?: any): AxiosPromise<SodPolicySchedule> {
            return localVarFp.getSodPolicySchedule(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportRunStatus(reportResultId: string, axiosOptions?: any): AxiosPromise<ReportResultReference> {
            return localVarFp.getSodViolationReportRunStatus(reportResultId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the violation report to retrieve status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportStatus(id: string, axiosOptions?: any): AxiosPromise<ReportResultReference> {
            return localVarFp.getSodViolationReportStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in*  **state**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, description**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSodPolicies(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<SodPolicy>> {
            return localVarFp.listSodPolicies(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch SOD policy by ID
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSodPolicy(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<SodPolicy> {
            return localVarFp.patchSodPolicy(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicySchedule} sodPolicySchedule 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPolicySchedule(id: string, sodPolicySchedule: SodPolicySchedule, axiosOptions?: any): AxiosPromise<SodPolicySchedule> {
            return localVarFp.putPolicySchedule(id, sodPolicySchedule, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSodPolicy(id: string, sodPolicy: SodPolicy, axiosOptions?: any): AxiosPromise<SodPolicy> {
            return localVarFp.putSodPolicy(id, sodPolicy, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startEvaluateSodPolicy(id: string, axiosOptions?: any): AxiosPromise<ReportResultReference> {
            return localVarFp.startEvaluateSodPolicy(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequest} [multiPolicyRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodAllPoliciesForOrg(multiPolicyRequest?: MultiPolicyRequest, axiosOptions?: any): AxiosPromise<ReportResultReference> {
            return localVarFp.startSodAllPoliciesForOrg(multiPolicyRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodPolicy(id: string, axiosOptions?: any): AxiosPromise<ReportResultReference> {
            return localVarFp.startSodPolicy(id, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiCreateSodPolicyRequest
 */
export interface SODPoliciesApiCreateSodPolicyRequest {
    /**
     * 
     * @type {SodPolicy}
     * @memberof SODPoliciesApiCreateSodPolicy
     */
    readonly sodPolicy: SodPolicy
}

/**
 * Request parameters for deleteSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiDeleteSodPolicyRequest
 */
export interface SODPoliciesApiDeleteSodPolicyRequest {
    /**
     * The ID of the SOD Policy to delete.
     * @type {string}
     * @memberof SODPoliciesApiDeleteSodPolicy
     */
    readonly id: string

    /**
     * Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
     * @type {boolean}
     * @memberof SODPoliciesApiDeleteSodPolicy
     */
    readonly logical?: boolean
}

/**
 * Request parameters for deleteSodPolicySchedule operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiDeleteSodPolicyScheduleRequest
 */
export interface SODPoliciesApiDeleteSodPolicyScheduleRequest {
    /**
     * The ID of the SOD policy the schedule must be deleted for.
     * @type {string}
     * @memberof SODPoliciesApiDeleteSodPolicySchedule
     */
    readonly id: string
}

/**
 * Request parameters for getCustomViolationReport operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiGetCustomViolationReportRequest
 */
export interface SODPoliciesApiGetCustomViolationReportRequest {
    /**
     * The ID of the report reference to download.
     * @type {string}
     * @memberof SODPoliciesApiGetCustomViolationReport
     */
    readonly reportResultId: string

    /**
     * Custom Name for the  file.
     * @type {string}
     * @memberof SODPoliciesApiGetCustomViolationReport
     */
    readonly fileName: string
}

/**
 * Request parameters for getDefaultViolationReport operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiGetDefaultViolationReportRequest
 */
export interface SODPoliciesApiGetDefaultViolationReportRequest {
    /**
     * The ID of the report reference to download.
     * @type {string}
     * @memberof SODPoliciesApiGetDefaultViolationReport
     */
    readonly reportResultId: string
}

/**
 * Request parameters for getSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiGetSodPolicyRequest
 */
export interface SODPoliciesApiGetSodPolicyRequest {
    /**
     * The ID of the SOD Policy to retrieve.
     * @type {string}
     * @memberof SODPoliciesApiGetSodPolicy
     */
    readonly id: string
}

/**
 * Request parameters for getSodPolicySchedule operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiGetSodPolicyScheduleRequest
 */
export interface SODPoliciesApiGetSodPolicyScheduleRequest {
    /**
     * The ID of the SOD policy schedule to retrieve.
     * @type {string}
     * @memberof SODPoliciesApiGetSodPolicySchedule
     */
    readonly id: string
}

/**
 * Request parameters for getSodViolationReportRunStatus operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiGetSodViolationReportRunStatusRequest
 */
export interface SODPoliciesApiGetSodViolationReportRunStatusRequest {
    /**
     * The ID of the report reference to retrieve.
     * @type {string}
     * @memberof SODPoliciesApiGetSodViolationReportRunStatus
     */
    readonly reportResultId: string
}

/**
 * Request parameters for getSodViolationReportStatus operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiGetSodViolationReportStatusRequest
 */
export interface SODPoliciesApiGetSodViolationReportStatusRequest {
    /**
     * The ID of the violation report to retrieve status for.
     * @type {string}
     * @memberof SODPoliciesApiGetSodViolationReportStatus
     */
    readonly id: string
}

/**
 * Request parameters for listSodPolicies operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiListSodPoliciesRequest
 */
export interface SODPoliciesApiListSodPoliciesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SODPoliciesApiListSodPolicies
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SODPoliciesApiListSodPolicies
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SODPoliciesApiListSodPolicies
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in*  **state**: *eq, in*
     * @type {string}
     * @memberof SODPoliciesApiListSodPolicies
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, description**
     * @type {string}
     * @memberof SODPoliciesApiListSodPolicies
     */
    readonly sorters?: string
}

/**
 * Request parameters for patchSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiPatchSodPolicyRequest
 */
export interface SODPoliciesApiPatchSodPolicyRequest {
    /**
     * The ID of the SOD policy being modified.
     * @type {string}
     * @memberof SODPoliciesApiPatchSodPolicy
     */
    readonly id: string

    /**
     * A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
     * @type {Array<JsonPatchOperation>}
     * @memberof SODPoliciesApiPatchSodPolicy
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for putPolicySchedule operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiPutPolicyScheduleRequest
 */
export interface SODPoliciesApiPutPolicyScheduleRequest {
    /**
     * The ID of the SOD policy to update its schedule.
     * @type {string}
     * @memberof SODPoliciesApiPutPolicySchedule
     */
    readonly id: string

    /**
     * 
     * @type {SodPolicySchedule}
     * @memberof SODPoliciesApiPutPolicySchedule
     */
    readonly sodPolicySchedule: SodPolicySchedule
}

/**
 * Request parameters for putSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiPutSodPolicyRequest
 */
export interface SODPoliciesApiPutSodPolicyRequest {
    /**
     * The ID of the SOD policy to update.
     * @type {string}
     * @memberof SODPoliciesApiPutSodPolicy
     */
    readonly id: string

    /**
     * 
     * @type {SodPolicy}
     * @memberof SODPoliciesApiPutSodPolicy
     */
    readonly sodPolicy: SodPolicy
}

/**
 * Request parameters for startEvaluateSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiStartEvaluateSodPolicyRequest
 */
export interface SODPoliciesApiStartEvaluateSodPolicyRequest {
    /**
     * The SOD policy ID to run.
     * @type {string}
     * @memberof SODPoliciesApiStartEvaluateSodPolicy
     */
    readonly id: string
}

/**
 * Request parameters for startSodAllPoliciesForOrg operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiStartSodAllPoliciesForOrgRequest
 */
export interface SODPoliciesApiStartSodAllPoliciesForOrgRequest {
    /**
     * 
     * @type {MultiPolicyRequest}
     * @memberof SODPoliciesApiStartSodAllPoliciesForOrg
     */
    readonly multiPolicyRequest?: MultiPolicyRequest
}

/**
 * Request parameters for startSodPolicy operation in SODPoliciesApi.
 * @export
 * @interface SODPoliciesApiStartSodPolicyRequest
 */
export interface SODPoliciesApiStartSodPolicyRequest {
    /**
     * The SOD policy ID to run.
     * @type {string}
     * @memberof SODPoliciesApiStartSodPolicy
     */
    readonly id: string
}

/**
 * SODPoliciesApi - object-oriented interface
 * @export
 * @class SODPoliciesApi
 * @extends {BaseAPI}
 */
export class SODPoliciesApi extends BaseAPI {
    /**
     * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
     * @summary Create SOD policy
     * @param {SODPoliciesApiCreateSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public createSodPolicy(requestParameters: SODPoliciesApiCreateSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).createSodPolicy(requestParameters.sodPolicy, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Delete SOD policy by ID
     * @param {SODPoliciesApiDeleteSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public deleteSodPolicy(requestParameters: SODPoliciesApiDeleteSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).deleteSodPolicy(requestParameters.id, requestParameters.logical, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes schedule for a specified SOD policy by ID.
     * @summary Delete SOD policy schedule
     * @param {SODPoliciesApiDeleteSodPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public deleteSodPolicySchedule(requestParameters: SODPoliciesApiDeleteSodPolicyScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).deleteSodPolicySchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This allows to download a specified named violation report for a given report reference.
     * @summary Download custom violation report
     * @param {SODPoliciesApiGetCustomViolationReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getCustomViolationReport(requestParameters: SODPoliciesApiGetCustomViolationReportRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getCustomViolationReport(requestParameters.reportResultId, requestParameters.fileName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This allows to download a violation report for a given report reference.
     * @summary Download violation report
     * @param {SODPoliciesApiGetDefaultViolationReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getDefaultViolationReport(requestParameters: SODPoliciesApiGetDefaultViolationReportRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getDefaultViolationReport(requestParameters.reportResultId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets the status for a violation report for all policy run.
     * @summary Get multi-report run task status
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getSodAllReportRunStatus(axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getSodAllReportRunStatus(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Get SOD policy by ID
     * @param {SODPoliciesApiGetSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getSodPolicy(requestParameters: SODPoliciesApiGetSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets a specified SOD policy\'s schedule.
     * @summary Get SOD policy schedule
     * @param {SODPoliciesApiGetSodPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getSodPolicySchedule(requestParameters: SODPoliciesApiGetSodPolicyScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getSodPolicySchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the status for a violation report run task that has already been invoked.
     * @summary Get violation report run status
     * @param {SODPoliciesApiGetSodViolationReportRunStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getSodViolationReportRunStatus(requestParameters: SODPoliciesApiGetSodViolationReportRunStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getSodViolationReportRunStatus(requestParameters.reportResultId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the status for a violation report run task that has already been invoked.
     * @summary Get SOD violation report status
     * @param {SODPoliciesApiGetSodViolationReportStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public getSodViolationReportStatus(requestParameters: SODPoliciesApiGetSodViolationReportStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).getSodViolationReportStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets list of all SOD policies. Requires role of ORG_ADMIN
     * @summary List SOD policies
     * @param {SODPoliciesApiListSodPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public listSodPolicies(requestParameters: SODPoliciesApiListSodPoliciesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).listSodPolicies(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
     * @summary Patch SOD policy by ID
     * @param {SODPoliciesApiPatchSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public patchSodPolicy(requestParameters: SODPoliciesApiPatchSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).patchSodPolicy(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates schedule for a specified SOD policy.
     * @summary Update SOD Policy schedule
     * @param {SODPoliciesApiPutPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public putPolicySchedule(requestParameters: SODPoliciesApiPutPolicyScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).putPolicySchedule(requestParameters.id, requestParameters.sodPolicySchedule, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Update SOD policy by ID
     * @param {SODPoliciesApiPutSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public putSodPolicy(requestParameters: SODPoliciesApiPutSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).putSodPolicy(requestParameters.id, requestParameters.sodPolicy, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
     * @summary Evaluate one policy by ID
     * @param {SODPoliciesApiStartEvaluateSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public startEvaluateSodPolicy(requestParameters: SODPoliciesApiStartEvaluateSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).startEvaluateSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
     * @summary Runs all policies for org
     * @param {SODPoliciesApiStartSodAllPoliciesForOrgRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public startSodAllPoliciesForOrg(requestParameters: SODPoliciesApiStartSodAllPoliciesForOrgRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).startSodAllPoliciesForOrg(requestParameters.multiPolicyRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
     * @summary Runs SOD policy violation report
     * @param {SODPoliciesApiStartSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    public startSodPolicy(requestParameters: SODPoliciesApiStartSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPoliciesApiFp(this.configuration).startSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SODViolationsApi - axios parameter creator
 * @export
 */
export const SODViolationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for identity.
         * @param {IdentityWithNewAccess} identityWithNewAccess 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startPredictSodViolations: async (identityWithNewAccess: IdentityWithNewAccess, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityWithNewAccess' is not null or undefined
            assertParamExists('startPredictSodViolations', 'identityWithNewAccess', identityWithNewAccess)
            const localVarPath = `/sod-violations/predict`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityWithNewAccess, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Check SOD violations
         * @param {IdentityWithNewAccess1} identityWithNewAccess1 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startViolationCheck: async (identityWithNewAccess1: IdentityWithNewAccess1, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityWithNewAccess1' is not null or undefined
            assertParamExists('startViolationCheck', 'identityWithNewAccess1', identityWithNewAccess1)
            const localVarPath = `/sod-violations/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityWithNewAccess1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SODViolationsApi - functional programming interface
 * @export
 */
export const SODViolationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SODViolationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for identity.
         * @param {IdentityWithNewAccess} identityWithNewAccess 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startPredictSodViolations(identityWithNewAccess: IdentityWithNewAccess, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViolationPrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startPredictSodViolations(identityWithNewAccess, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Check SOD violations
         * @param {IdentityWithNewAccess1} identityWithNewAccess1 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startViolationCheck(identityWithNewAccess1: IdentityWithNewAccess1, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodViolationCheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startViolationCheck(identityWithNewAccess1, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SODViolationsApi - factory interface
 * @export
 */
export const SODViolationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SODViolationsApiFp(configuration)
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for identity.
         * @param {IdentityWithNewAccess} identityWithNewAccess 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startPredictSodViolations(identityWithNewAccess: IdentityWithNewAccess, axiosOptions?: any): AxiosPromise<ViolationPrediction> {
            return localVarFp.startPredictSodViolations(identityWithNewAccess, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Check SOD violations
         * @param {IdentityWithNewAccess1} identityWithNewAccess1 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startViolationCheck(identityWithNewAccess1: IdentityWithNewAccess1, axiosOptions?: any): AxiosPromise<SodViolationCheck> {
            return localVarFp.startViolationCheck(identityWithNewAccess1, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for startPredictSodViolations operation in SODViolationsApi.
 * @export
 * @interface SODViolationsApiStartPredictSodViolationsRequest
 */
export interface SODViolationsApiStartPredictSodViolationsRequest {
    /**
     * 
     * @type {IdentityWithNewAccess}
     * @memberof SODViolationsApiStartPredictSodViolations
     */
    readonly identityWithNewAccess: IdentityWithNewAccess
}

/**
 * Request parameters for startViolationCheck operation in SODViolationsApi.
 * @export
 * @interface SODViolationsApiStartViolationCheckRequest
 */
export interface SODViolationsApiStartViolationCheckRequest {
    /**
     * 
     * @type {IdentityWithNewAccess1}
     * @memberof SODViolationsApiStartViolationCheck
     */
    readonly identityWithNewAccess1: IdentityWithNewAccess1
}

/**
 * SODViolationsApi - object-oriented interface
 * @export
 * @class SODViolationsApi
 * @extends {BaseAPI}
 */
export class SODViolationsApi extends BaseAPI {
    /**
     * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Predict SOD violations for identity.
     * @param {SODViolationsApiStartPredictSodViolationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODViolationsApi
     */
    public startPredictSodViolations(requestParameters: SODViolationsApiStartPredictSodViolationsRequest, axiosOptions?: AxiosRequestConfig) {
        return SODViolationsApiFp(this.configuration).startPredictSodViolations(requestParameters.identityWithNewAccess, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
     * @summary Check SOD violations
     * @param {SODViolationsApiStartViolationCheckRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODViolationsApi
     */
    public startViolationCheck(requestParameters: SODViolationsApiStartViolationCheckRequest, axiosOptions?: AxiosRequestConfig) {
        return SODViolationsApiFp(this.configuration).startViolationCheck(requestParameters.identityWithNewAccess1, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SavedSearchApi - axios parameter creator
 * @export
 */
export const SavedSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {CreateSavedSearchRequest} createSavedSearchRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch: async (createSavedSearchRequest: CreateSavedSearchRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSavedSearchRequest' is not null or undefined
            assertParamExists('createSavedSearch', 'createSavedSearchRequest', createSavedSearchRequest)
            const localVarPath = `/saved-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSavedSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearch: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSavedSearch', 'id', id)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        executeSavedSearch: async (id: string, searchArguments: SearchArguments, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('executeSavedSearch', 'id', id)
            // verify required parameter 'searchArguments' is not null or undefined
            assertParamExists('executeSavedSearch', 'searchArguments', searchArguments)
            const localVarPath = `/saved-searches/{id}/execute`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchArguments, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified saved search. 
         * @summary Return saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearch: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSavedSearch', 'id', id)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of saved searches. 
         * @summary A list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSavedSearches: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saved-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
         * @summary Updates an existing saved search 
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSavedSearch: async (id: string, savedSearch: SavedSearch, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putSavedSearch', 'id', id)
            // verify required parameter 'savedSearch' is not null or undefined
            assertParamExists('putSavedSearch', 'savedSearch', savedSearch)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(savedSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SavedSearchApi - functional programming interface
 * @export
 */
export const SavedSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SavedSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {CreateSavedSearchRequest} createSavedSearchRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSavedSearch(createSavedSearchRequest: CreateSavedSearchRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSavedSearch(createSavedSearchRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSavedSearch(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSavedSearch(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async executeSavedSearch(id: string, searchArguments: SearchArguments, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSavedSearch(id, searchArguments, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the specified saved search. 
         * @summary Return saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedSearch(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedSearch(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of saved searches. 
         * @summary A list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSavedSearches(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SavedSearch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSavedSearches(offset, limit, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
         * @summary Updates an existing saved search 
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSavedSearch(id: string, savedSearch: SavedSearch, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSavedSearch(id, savedSearch, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SavedSearchApi - factory interface
 * @export
 */
export const SavedSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SavedSearchApiFp(configuration)
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {CreateSavedSearchRequest} createSavedSearchRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch(createSavedSearchRequest: CreateSavedSearchRequest, axiosOptions?: any): AxiosPromise<SavedSearch> {
            return localVarFp.createSavedSearch(createSavedSearchRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearch(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSavedSearch(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        executeSavedSearch(id: string, searchArguments: SearchArguments, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.executeSavedSearch(id, searchArguments, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified saved search. 
         * @summary Return saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearch(id: string, axiosOptions?: any): AxiosPromise<SavedSearch> {
            return localVarFp.getSavedSearch(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of saved searches. 
         * @summary A list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSavedSearches(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<SavedSearch>> {
            return localVarFp.listSavedSearches(offset, limit, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
         * @summary Updates an existing saved search 
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSavedSearch(id: string, savedSearch: SavedSearch, axiosOptions?: any): AxiosPromise<SavedSearch> {
            return localVarFp.putSavedSearch(id, savedSearch, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiCreateSavedSearchRequest
 */
export interface SavedSearchApiCreateSavedSearchRequest {
    /**
     * The saved search to persist.
     * @type {CreateSavedSearchRequest}
     * @memberof SavedSearchApiCreateSavedSearch
     */
    readonly createSavedSearchRequest: CreateSavedSearchRequest
}

/**
 * Request parameters for deleteSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiDeleteSavedSearchRequest
 */
export interface SavedSearchApiDeleteSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiDeleteSavedSearch
     */
    readonly id: string
}

/**
 * Request parameters for executeSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiExecuteSavedSearchRequest
 */
export interface SavedSearchApiExecuteSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiExecuteSavedSearch
     */
    readonly id: string

    /**
     * When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
     * @type {SearchArguments}
     * @memberof SavedSearchApiExecuteSavedSearch
     */
    readonly searchArguments: SearchArguments
}

/**
 * Request parameters for getSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiGetSavedSearchRequest
 */
export interface SavedSearchApiGetSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiGetSavedSearch
     */
    readonly id: string
}

/**
 * Request parameters for listSavedSearches operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiListSavedSearchesRequest
 */
export interface SavedSearchApiListSavedSearchesRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*
     * @type {string}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly filters?: string
}

/**
 * Request parameters for putSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiPutSavedSearchRequest
 */
export interface SavedSearchApiPutSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiPutSavedSearch
     */
    readonly id: string

    /**
     * The saved search to persist.
     * @type {SavedSearch}
     * @memberof SavedSearchApiPutSavedSearch
     */
    readonly savedSearch: SavedSearch
}

/**
 * SavedSearchApi - object-oriented interface
 * @export
 * @class SavedSearchApi
 * @extends {BaseAPI}
 */
export class SavedSearchApi extends BaseAPI {
    /**
     * Creates a new saved search. 
     * @summary Create a saved search
     * @param {SavedSearchApiCreateSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public createSavedSearch(requestParameters: SavedSearchApiCreateSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).createSavedSearch(requestParameters.createSavedSearchRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified saved search. 
     * @summary Delete document by ID
     * @param {SavedSearchApiDeleteSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public deleteSavedSearch(requestParameters: SavedSearchApiDeleteSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).deleteSavedSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Executes the specified saved search. 
     * @summary Execute a saved search by ID
     * @param {SavedSearchApiExecuteSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public executeSavedSearch(requestParameters: SavedSearchApiExecuteSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).executeSavedSearch(requestParameters.id, requestParameters.searchArguments, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified saved search. 
     * @summary Return saved search by ID
     * @param {SavedSearchApiGetSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public getSavedSearch(requestParameters: SavedSearchApiGetSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).getSavedSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of saved searches. 
     * @summary A list of Saved Searches
     * @param {SavedSearchApiListSavedSearchesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public listSavedSearches(requestParameters: SavedSearchApiListSavedSearchesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).listSavedSearches(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
     * @summary Updates an existing saved search 
     * @param {SavedSearchApiPutSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public putSavedSearch(requestParameters: SavedSearchApiPutSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).putSavedSearch(requestParameters.id, requestParameters.savedSearch, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduledSearchApi - axios parameter creator
 * @export
 */
export const ScheduledSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {CreateScheduledSearchRequest} createScheduledSearchRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledSearch: async (createScheduledSearchRequest: CreateScheduledSearchRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createScheduledSearchRequest' is not null or undefined
            assertParamExists('createScheduledSearch', 'createScheduledSearchRequest', createScheduledSearchRequest)
            const localVarPath = `/scheduled-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScheduledSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledSearch: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteScheduledSearch', 'id', id)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledSearch: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getScheduledSearch', 'id', id)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **savedSearchId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledSearch: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scheduled-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeScheduledSearch: async (id: string, typedReference: TypedReference, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unsubscribeScheduledSearch', 'id', id)
            // verify required parameter 'typedReference' is not null or undefined
            assertParamExists('unsubscribeScheduledSearch', 'typedReference', typedReference)
            const localVarPath = `/scheduled-searches/{id}/unsubscribe`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typedReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledSearch: async (id: string, scheduledSearch: ScheduledSearch, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateScheduledSearch', 'id', id)
            // verify required parameter 'scheduledSearch' is not null or undefined
            assertParamExists('updateScheduledSearch', 'scheduledSearch', scheduledSearch)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduledSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledSearchApi - functional programming interface
 * @export
 */
export const ScheduledSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduledSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {CreateScheduledSearchRequest} createScheduledSearchRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createScheduledSearch(createScheduledSearchRequest: CreateScheduledSearchRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScheduledSearch(createScheduledSearchRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScheduledSearch(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScheduledSearch(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduledSearch(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduledSearch(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **savedSearchId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listScheduledSearch(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduledSearch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScheduledSearch(offset, limit, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribeScheduledSearch(id: string, typedReference: TypedReference, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribeScheduledSearch(id, typedReference, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateScheduledSearch(id: string, scheduledSearch: ScheduledSearch, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScheduledSearch(id, scheduledSearch, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScheduledSearchApi - factory interface
 * @export
 */
export const ScheduledSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduledSearchApiFp(configuration)
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {CreateScheduledSearchRequest} createScheduledSearchRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledSearch(createScheduledSearchRequest: CreateScheduledSearchRequest, axiosOptions?: any): AxiosPromise<ScheduledSearch> {
            return localVarFp.createScheduledSearch(createScheduledSearchRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledSearch(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteScheduledSearch(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledSearch(id: string, axiosOptions?: any): AxiosPromise<ScheduledSearch> {
            return localVarFp.getScheduledSearch(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **savedSearchId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledSearch(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<ScheduledSearch>> {
            return localVarFp.listScheduledSearch(offset, limit, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeScheduledSearch(id: string, typedReference: TypedReference, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.unsubscribeScheduledSearch(id, typedReference, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledSearch(id: string, scheduledSearch: ScheduledSearch, axiosOptions?: any): AxiosPromise<ScheduledSearch> {
            return localVarFp.updateScheduledSearch(id, scheduledSearch, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiCreateScheduledSearchRequest
 */
export interface ScheduledSearchApiCreateScheduledSearchRequest {
    /**
     * The scheduled search to persist.
     * @type {CreateScheduledSearchRequest}
     * @memberof ScheduledSearchApiCreateScheduledSearch
     */
    readonly createScheduledSearchRequest: CreateScheduledSearchRequest
}

/**
 * Request parameters for deleteScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiDeleteScheduledSearchRequest
 */
export interface ScheduledSearchApiDeleteScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiDeleteScheduledSearch
     */
    readonly id: string
}

/**
 * Request parameters for getScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiGetScheduledSearchRequest
 */
export interface ScheduledSearchApiGetScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiGetScheduledSearch
     */
    readonly id: string
}

/**
 * Request parameters for listScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiListScheduledSearchRequest
 */
export interface ScheduledSearchApiListScheduledSearchRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **savedSearchId**: *eq*
     * @type {string}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly filters?: string
}

/**
 * Request parameters for unsubscribeScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiUnsubscribeScheduledSearchRequest
 */
export interface ScheduledSearchApiUnsubscribeScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiUnsubscribeScheduledSearch
     */
    readonly id: string

    /**
     * The recipient to be removed from the scheduled search. 
     * @type {TypedReference}
     * @memberof ScheduledSearchApiUnsubscribeScheduledSearch
     */
    readonly typedReference: TypedReference
}

/**
 * Request parameters for updateScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiUpdateScheduledSearchRequest
 */
export interface ScheduledSearchApiUpdateScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiUpdateScheduledSearch
     */
    readonly id: string

    /**
     * The scheduled search to persist.
     * @type {ScheduledSearch}
     * @memberof ScheduledSearchApiUpdateScheduledSearch
     */
    readonly scheduledSearch: ScheduledSearch
}

/**
 * ScheduledSearchApi - object-oriented interface
 * @export
 * @class ScheduledSearchApi
 * @extends {BaseAPI}
 */
export class ScheduledSearchApi extends BaseAPI {
    /**
     * Creates a new scheduled search. 
     * @summary Create a new scheduled search
     * @param {ScheduledSearchApiCreateScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public createScheduledSearch(requestParameters: ScheduledSearchApiCreateScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).createScheduledSearch(requestParameters.createScheduledSearchRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified scheduled search. 
     * @summary Delete a Scheduled Search
     * @param {ScheduledSearchApiDeleteScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public deleteScheduledSearch(requestParameters: ScheduledSearchApiDeleteScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).deleteScheduledSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified scheduled search.
     * @summary Get a Scheduled Search
     * @param {ScheduledSearchApiGetScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public getScheduledSearch(requestParameters: ScheduledSearchApiGetScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).getScheduledSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of scheduled searches. 
     * @summary List scheduled searches
     * @param {ScheduledSearchApiListScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public listScheduledSearch(requestParameters: ScheduledSearchApiListScheduledSearchRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).listScheduledSearch(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unsubscribes a recipient from the specified scheduled search. 
     * @summary Unsubscribe a recipient from Scheduled Search
     * @param {ScheduledSearchApiUnsubscribeScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public unsubscribeScheduledSearch(requestParameters: ScheduledSearchApiUnsubscribeScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).unsubscribeScheduledSearch(requestParameters.id, requestParameters.typedReference, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing scheduled search. 
     * @summary Update an existing Scheduled Search
     * @param {ScheduledSearchApiUpdateScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public updateScheduledSearch(requestParameters: ScheduledSearchApiUpdateScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).updateScheduledSearch(requestParameters.id, requestParameters.scheduledSearch, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchAggregate: async (search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchAggregate', 'search', search)
            const localVarPath = `/search/aggregate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchCount: async (search: Search, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchCount', 'search', search)
            const localVarPath = `/search/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *entitlements*, *events*, *identities*, and *roles*. 
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchGet: async (index: string, id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('searchGet', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('searchGet', 'id', id)
            const localVarPath = `/search/{index}/{id}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform Search
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPost: async (search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchPost', 'search', search)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchAggregate(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AggregationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAggregate(search, offset, limit, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchCount(search: Search, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCount(search, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *entitlements*, *events*, *identities*, and *roles*. 
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchGet(index: string, id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGet(index, id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform Search
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchPost(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchDocument>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPost(search, offset, limit, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchAggregate(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: any): AxiosPromise<AggregationResult> {
            return localVarFp.searchAggregate(search, offset, limit, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchCount(search: Search, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.searchCount(search, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *entitlements*, *events*, *identities*, and *roles*. 
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchGet(index: string, id: string, axiosOptions?: any): AxiosPromise<SearchDocument> {
            return localVarFp.searchGet(index, id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform Search
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPost(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<SearchDocument>> {
            return localVarFp.searchPost(search, offset, limit, count, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for searchAggregate operation in SearchApi.
 * @export
 * @interface SearchApiSearchAggregateRequest
 */
export interface SearchApiSearchAggregateRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchAggregate
     */
    readonly search: Search

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchAggregate
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchAggregate
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SearchApiSearchAggregate
     */
    readonly count?: boolean
}

/**
 * Request parameters for searchCount operation in SearchApi.
 * @export
 * @interface SearchApiSearchCountRequest
 */
export interface SearchApiSearchCountRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchCount
     */
    readonly search: Search
}

/**
 * Request parameters for searchGet operation in SearchApi.
 * @export
 * @interface SearchApiSearchGetRequest
 */
export interface SearchApiSearchGetRequest {
    /**
     * The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *entitlements*, *events*, *identities*, and *roles*. 
     * @type {string}
     * @memberof SearchApiSearchGet
     */
    readonly index: string

    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SearchApiSearchGet
     */
    readonly id: string
}

/**
 * Request parameters for searchPost operation in SearchApi.
 * @export
 * @interface SearchApiSearchPostRequest
 */
export interface SearchApiSearchPostRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchPost
     */
    readonly search: Search

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchPost
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchPost
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SearchApiSearchPost
     */
    readonly count?: boolean
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
     * @summary Perform a Search Query Aggregation
     * @param {SearchApiSearchAggregateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchAggregate(requestParameters: SearchApiSearchAggregateRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchAggregate(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
     * @summary Count Documents Satisfying a Query
     * @param {SearchApiSearchCountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchCount(requestParameters: SearchApiSearchCountRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchCount(requestParameters.search, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a single document from the specified index, using the specified document ID.
     * @summary Get a Document by ID
     * @param {SearchApiSearchGetRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchGet(requestParameters: SearchApiSearchGetRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchGet(requestParameters.index, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
     * @summary Perform Search
     * @param {SearchApiSearchPostRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchPost(requestParameters: SearchApiSearchPostRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchPost(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SegmentsApi - axios parameter creator
 * @export
 */
export const SegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {Segment} segment 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSegment: async (segment: Segment, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segment' is not null or undefined
            assertParamExists('createSegment', 'segment', segment)
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The segment ID to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSegment', 'id', id)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the segment specified by the given ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Segment by ID
         * @param {string} id The segment ID to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSegment', 'id', id)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all segments.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSegments: async (limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Segment
         * @param {string} id The segment ID to modify.
         * @param {Array<object>} requestBody A list of segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * owner * visibilityCriteria * active 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment: async (id: string, requestBody: Array<object>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchSegment', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('patchSegment', 'requestBody', requestBody)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {Segment} segment 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSegment(segment: Segment, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSegment(segment, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The segment ID to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSegment(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSegment(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the segment specified by the given ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Segment by ID
         * @param {string} id The segment ID to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSegment(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegment(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of all segments.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSegments(limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Segment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSegments(limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Segment
         * @param {string} id The segment ID to modify.
         * @param {Array<object>} requestBody A list of segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * owner * visibilityCriteria * active 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSegment(id: string, requestBody: Array<object>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSegment(id, requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsApiFp(configuration)
    return {
        /**
         * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {Segment} segment 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSegment(segment: Segment, axiosOptions?: any): AxiosPromise<Segment> {
            return localVarFp.createSegment(segment, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The segment ID to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSegment(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the segment specified by the given ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Segment by ID
         * @param {string} id The segment ID to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSegment(id: string, axiosOptions?: any): AxiosPromise<Segment> {
            return localVarFp.getSegment(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all segments.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSegments(limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<Segment>> {
            return localVarFp.listSegments(limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Segment
         * @param {string} id The segment ID to modify.
         * @param {Array<object>} requestBody A list of segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * owner * visibilityCriteria * active 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment(id: string, requestBody: Array<object>, axiosOptions?: any): AxiosPromise<Segment> {
            return localVarFp.patchSegment(id, requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiCreateSegmentRequest
 */
export interface SegmentsApiCreateSegmentRequest {
    /**
     * 
     * @type {Segment}
     * @memberof SegmentsApiCreateSegment
     */
    readonly segment: Segment
}

/**
 * Request parameters for deleteSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiDeleteSegmentRequest
 */
export interface SegmentsApiDeleteSegmentRequest {
    /**
     * The segment ID to delete.
     * @type {string}
     * @memberof SegmentsApiDeleteSegment
     */
    readonly id: string
}

/**
 * Request parameters for getSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiGetSegmentRequest
 */
export interface SegmentsApiGetSegmentRequest {
    /**
     * The segment ID to retrieve.
     * @type {string}
     * @memberof SegmentsApiGetSegment
     */
    readonly id: string
}

/**
 * Request parameters for listSegments operation in SegmentsApi.
 * @export
 * @interface SegmentsApiListSegmentsRequest
 */
export interface SegmentsApiListSegmentsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SegmentsApiListSegments
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SegmentsApiListSegments
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SegmentsApiListSegments
     */
    readonly count?: boolean
}

/**
 * Request parameters for patchSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiPatchSegmentRequest
 */
export interface SegmentsApiPatchSegmentRequest {
    /**
     * The segment ID to modify.
     * @type {string}
     * @memberof SegmentsApiPatchSegment
     */
    readonly id: string

    /**
     * A list of segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * owner * visibilityCriteria * active 
     * @type {Array<object>}
     * @memberof SegmentsApiPatchSegment
     */
    readonly requestBody: Array<object>
}

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
    /**
     * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Create Segment
     * @param {SegmentsApiCreateSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public createSegment(requestParameters: SegmentsApiCreateSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).createSegment(requestParameters.segment, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Delete Segment by ID
     * @param {SegmentsApiDeleteSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public deleteSegment(requestParameters: SegmentsApiDeleteSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).deleteSegment(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the segment specified by the given ID. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Get Segment by ID
     * @param {SegmentsApiGetSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegment(requestParameters: SegmentsApiGetSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegment(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all segments.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary List Segments
     * @param {SegmentsApiListSegmentsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public listSegments(requestParameters: SegmentsApiListSegmentsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).listSegments(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Update Segment
     * @param {SegmentsApiPatchSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public patchSegment(requestParameters: SegmentsApiPatchSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).patchSegment(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceDeskIntegrationApi - axios parameter creator
 * @export
 */
export const ServiceDeskIntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration: async (serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceDeskIntegrationDto' is not null or undefined
            assertParamExists('createServiceDeskIntegration', 'serviceDeskIntegrationDto', serviceDeskIntegrationDto)
            const localVarPath = `/service-desk-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceDeskIntegrationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteServiceDeskIntegration', 'id', id)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getServiceDeskIntegration', 'id', id)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate: async (scriptName: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getServiceDeskIntegrationTemplate', 'scriptName', scriptName)
            const localVarPath = `/service-desk-integrations/templates/{scriptName}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrations: async (offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations/status-check-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {PatchServiceDeskIntegrationRequest} patchServiceDeskIntegrationRequest A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Only &#x60;replace&#x60; operations are accepted by this endpoint.  A 403 Forbidden Error indicates that you attempted to PATCH a operation that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration: async (id: string, patchServiceDeskIntegrationRequest: PatchServiceDeskIntegrationRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchServiceDeskIntegration', 'id', id)
            // verify required parameter 'patchServiceDeskIntegrationRequest' is not null or undefined
            assertParamExists('patchServiceDeskIntegration', 'patchServiceDeskIntegrationRequest', patchServiceDeskIntegrationRequest)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchServiceDeskIntegrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putServiceDeskIntegration: async (id: string, serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putServiceDeskIntegration', 'id', id)
            // verify required parameter 'serviceDeskIntegrationDto' is not null or undefined
            assertParamExists('putServiceDeskIntegration', 'serviceDeskIntegrationDto', serviceDeskIntegrationDto)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceDeskIntegrationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails: async (queuedCheckConfigDetails: QueuedCheckConfigDetails, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queuedCheckConfigDetails' is not null or undefined
            assertParamExists('updateStatusCheckDetails', 'queuedCheckConfigDetails', queuedCheckConfigDetails)
            const localVarPath = `/service-desk-integrations/status-check-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queuedCheckConfigDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceDeskIntegrationApi - functional programming interface
 * @export
 */
export const ServiceDeskIntegrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceDeskIntegrationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceDeskIntegration(serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceDeskIntegration(serviceDeskIntegrationDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceDeskIntegration(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceDeskIntegration(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegration(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegration(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationTemplate(scriptName: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationTemplate(scriptName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationTypes(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDeskIntegrationTemplateType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationTypes(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrations(offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDeskIntegrationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrations(offset, limit, sorters, filters, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusCheckDetails(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedCheckConfigDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusCheckDetails(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {PatchServiceDeskIntegrationRequest} patchServiceDeskIntegrationRequest A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Only &#x60;replace&#x60; operations are accepted by this endpoint.  A 403 Forbidden Error indicates that you attempted to PATCH a operation that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchServiceDeskIntegration(id: string, patchServiceDeskIntegrationRequest: PatchServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchServiceDeskIntegration(id, patchServiceDeskIntegrationRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putServiceDeskIntegration(id: string, serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putServiceDeskIntegration(id, serviceDeskIntegrationDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatusCheckDetails(queuedCheckConfigDetails: QueuedCheckConfigDetails, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedCheckConfigDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatusCheckDetails(queuedCheckConfigDetails, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceDeskIntegrationApi - factory interface
 * @export
 */
export const ServiceDeskIntegrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceDeskIntegrationApiFp(configuration)
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration(serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.createServiceDeskIntegration(serviceDeskIntegrationDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteServiceDeskIntegration(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration(id: string, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.getServiceDeskIntegration(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate(scriptName: string, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationTemplateDto> {
            return localVarFp.getServiceDeskIntegrationTemplate(scriptName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes(axiosOptions?: any): AxiosPromise<Array<ServiceDeskIntegrationTemplateType>> {
            return localVarFp.getServiceDeskIntegrationTypes(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrations(offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions?: any): AxiosPromise<Array<ServiceDeskIntegrationDto>> {
            return localVarFp.getServiceDeskIntegrations(offset, limit, sorters, filters, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails(axiosOptions?: any): AxiosPromise<QueuedCheckConfigDetails> {
            return localVarFp.getStatusCheckDetails(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {PatchServiceDeskIntegrationRequest} patchServiceDeskIntegrationRequest A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Only &#x60;replace&#x60; operations are accepted by this endpoint.  A 403 Forbidden Error indicates that you attempted to PATCH a operation that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration(id: string, patchServiceDeskIntegrationRequest: PatchServiceDeskIntegrationRequest, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.patchServiceDeskIntegration(id, patchServiceDeskIntegrationRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putServiceDeskIntegration(id: string, serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.putServiceDeskIntegration(id, serviceDeskIntegrationDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails(queuedCheckConfigDetails: QueuedCheckConfigDetails, axiosOptions?: any): AxiosPromise<QueuedCheckConfigDetails> {
            return localVarFp.updateStatusCheckDetails(queuedCheckConfigDetails, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest {
    /**
     * The specifics of a new integration to create
     * @type {ServiceDeskIntegrationDto}
     * @memberof ServiceDeskIntegrationApiCreateServiceDeskIntegration
     */
    readonly serviceDeskIntegrationDto: ServiceDeskIntegrationDto
}

/**
 * Request parameters for deleteServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest {
    /**
     * ID of Service Desk integration to delete
     * @type {string}
     * @memberof ServiceDeskIntegrationApiDeleteServiceDeskIntegration
     */
    readonly id: string
}

/**
 * Request parameters for getServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to get
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegration
     */
    readonly id: string
}

/**
 * Request parameters for getServiceDeskIntegrationTemplate operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest {
    /**
     * The scriptName value of the Service Desk integration template to get
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplate
     */
    readonly scriptName: string
}

/**
 * Request parameters for getServiceDeskIntegrations operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly limit?: number

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly filters?: string

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly count?: boolean
}

/**
 * Request parameters for patchServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to update
     * @type {string}
     * @memberof ServiceDeskIntegrationApiPatchServiceDeskIntegration
     */
    readonly id: string

    /**
     * A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Only &#x60;replace&#x60; operations are accepted by this endpoint.  A 403 Forbidden Error indicates that you attempted to PATCH a operation that is not allowed. 
     * @type {PatchServiceDeskIntegrationRequest}
     * @memberof ServiceDeskIntegrationApiPatchServiceDeskIntegration
     */
    readonly patchServiceDeskIntegrationRequest: PatchServiceDeskIntegrationRequest
}

/**
 * Request parameters for putServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to update
     * @type {string}
     * @memberof ServiceDeskIntegrationApiPutServiceDeskIntegration
     */
    readonly id: string

    /**
     * The specifics of the integration to update
     * @type {ServiceDeskIntegrationDto}
     * @memberof ServiceDeskIntegrationApiPutServiceDeskIntegration
     */
    readonly serviceDeskIntegrationDto: ServiceDeskIntegrationDto
}

/**
 * Request parameters for updateStatusCheckDetails operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest
 */
export interface ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest {
    /**
     * the modified time check configuration
     * @type {QueuedCheckConfigDetails}
     * @memberof ServiceDeskIntegrationApiUpdateStatusCheckDetails
     */
    readonly queuedCheckConfigDetails: QueuedCheckConfigDetails
}

/**
 * ServiceDeskIntegrationApi - object-oriented interface
 * @export
 * @class ServiceDeskIntegrationApi
 * @extends {BaseAPI}
 */
export class ServiceDeskIntegrationApi extends BaseAPI {
    /**
     * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Create new Service Desk integration
     * @param {ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public createServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).createServiceDeskIntegration(requestParameters.serviceDeskIntegrationDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Delete a Service Desk integration
     * @param {ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public deleteServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).deleteServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Get a Service Desk integration
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Service Desk integration template by scriptName.
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrationTemplate(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrationTemplate(requestParameters.scriptName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Service Desk Integration Types List.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrationTypes(axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrationTypes(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary List existing Service Desk Integrations
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrations(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrations(requestParameters.offset, requestParameters.limit, requestParameters.sorters, requestParameters.filters, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Get the time check configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getStatusCheckDetails(axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getStatusCheckDetails(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing ServiceDeskIntegration by ID with a PATCH request.
     * @summary Service Desk Integration Update PATCH
     * @param {ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public patchServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).patchServiceDeskIntegration(requestParameters.id, requestParameters.patchServiceDeskIntegrationRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Update a Service Desk integration
     * @param {ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public putServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).putServiceDeskIntegration(requestParameters.id, requestParameters.serviceDeskIntegrationDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Update the time check configuration
     * @param {ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public updateStatusCheckDetails(requestParameters: ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).updateStatusCheckDetails(requestParameters.queuedCheckConfigDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SourceUsagesApi - axios parameter creator
 * @export
 */
export const SourceUsagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the status of the source usage insights setup by IDN source ID.
         * @summary Finds status of source usage
         * @param {string} sourceId ID of IDN source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusBySourceId: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getStatusBySourceId', 'sourceId', sourceId)
            const localVarPath = `/source-usages/{sourceId}/status`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a summary of source usage insights for past 12 months.
         * @summary Returns source usage insights
         * @param {string} sourceId ID of IDN source
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesBySourceId: async (sourceId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getUsagesBySourceId', 'sourceId', sourceId)
            const localVarPath = `/source-usages/{sourceId}/summaries`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourceUsagesApi - functional programming interface
 * @export
 */
export const SourceUsagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourceUsagesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the status of the source usage insights setup by IDN source ID.
         * @summary Finds status of source usage
         * @param {string} sourceId ID of IDN source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusBySourceId(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceUsageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusBySourceId(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a summary of source usage insights for past 12 months.
         * @summary Returns source usage insights
         * @param {string} sourceId ID of IDN source
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getUsagesBySourceId(sourceId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SourceUsage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsagesBySourceId(sourceId, limit, offset, count, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SourceUsagesApi - factory interface
 * @export
 */
export const SourceUsagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourceUsagesApiFp(configuration)
    return {
        /**
         * This API returns the status of the source usage insights setup by IDN source ID.
         * @summary Finds status of source usage
         * @param {string} sourceId ID of IDN source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusBySourceId(sourceId: string, axiosOptions?: any): AxiosPromise<SourceUsageStatus> {
            return localVarFp.getStatusBySourceId(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a summary of source usage insights for past 12 months.
         * @summary Returns source usage insights
         * @param {string} sourceId ID of IDN source
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesBySourceId(sourceId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: any): AxiosPromise<Array<SourceUsage>> {
            return localVarFp.getUsagesBySourceId(sourceId, limit, offset, count, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getStatusBySourceId operation in SourceUsagesApi.
 * @export
 * @interface SourceUsagesApiGetStatusBySourceIdRequest
 */
export interface SourceUsagesApiGetStatusBySourceIdRequest {
    /**
     * ID of IDN source
     * @type {string}
     * @memberof SourceUsagesApiGetStatusBySourceId
     */
    readonly sourceId: string
}

/**
 * Request parameters for getUsagesBySourceId operation in SourceUsagesApi.
 * @export
 * @interface SourceUsagesApiGetUsagesBySourceIdRequest
 */
export interface SourceUsagesApiGetUsagesBySourceIdRequest {
    /**
     * ID of IDN source
     * @type {string}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly sourceId: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
     * @type {string}
     * @memberof SourceUsagesApiGetUsagesBySourceId
     */
    readonly sorters?: string
}

/**
 * SourceUsagesApi - object-oriented interface
 * @export
 * @class SourceUsagesApi
 * @extends {BaseAPI}
 */
export class SourceUsagesApi extends BaseAPI {
    /**
     * This API returns the status of the source usage insights setup by IDN source ID.
     * @summary Finds status of source usage
     * @param {SourceUsagesApiGetStatusBySourceIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceUsagesApi
     */
    public getStatusBySourceId(requestParameters: SourceUsagesApiGetStatusBySourceIdRequest, axiosOptions?: AxiosRequestConfig) {
        return SourceUsagesApiFp(this.configuration).getStatusBySourceId(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a summary of source usage insights for past 12 months.
     * @summary Returns source usage insights
     * @param {SourceUsagesApiGetUsagesBySourceIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceUsagesApi
     */
    public getUsagesBySourceId(requestParameters: SourceUsagesApiGetUsagesBySourceIdRequest, axiosOptions?: AxiosRequestConfig) {
        return SourceUsagesApiFp(this.configuration).getUsagesBySourceId(requestParameters.sourceId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SourcesApi - axios parameter creator
 * @export
 */
export const SourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy: async (sourceId: string, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('createProvisioningPolicy', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source 
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource: async (source: Source, provisionAsCsv?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('createSource', 'source', source)
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (provisionAsCsv !== undefined) {
                localVarQueryParameter['provisionAsCsv'] = provisionAsCsv;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(source, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to create a new schema on the specified source in Identity Security Cloud (ISC). 
         * @summary Create Schema on Source
         * @param {string} sourceId Source ID.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSourceSchema: async (sourceId: string, schema: Schema, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schema' is not null or undefined
            assertParamExists('createSourceSchema', 'schema', schema)
            const localVarPath = `/sources/{sourceId}/schemas`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy: async (sourceId: string, usageType: UsageType, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('deleteProvisioningPolicy', 'usageType', usageType)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to delete a specific source in Identity Security Cloud (ISC). The API removes all the accounts on the source first, and then it deletes the source. You can retrieve the actual task execution status with this method: GET `/task-status/{id}` A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Delete Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSource', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceSchema: async (sourceId: string, schemaId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('deleteSourceSchema', 'schemaId', schemaId)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsSchema: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementsSchema: async (id: string, schemaName?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEntitlementsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (schemaName !== undefined) {
                localVarQueryParameter['schemaName'] = schemaName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy: async (sourceId: string, usageType: UsageType, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('getProvisioningPolicy', 'usageType', usageType)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get a source by a specified ID in Identity Security Cloud (ISC). A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSource', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceHealth: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceHealth', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/source-health`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchema: async (sourceId: string, schemaId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('getSourceSchema', 'schemaId', schemaId)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to list the schemas that exist on the specified source in Identity Security Cloud (ISC). 
         * @summary List Schemas on Source
         * @param {string} sourceId Source ID.
         * @param {'group' | 'user'} [includeTypes] If this is set to &#x60;group&#x60;, the API filters the account schema and only returns only group schemas. If this is set to &#x60;user&#x60;, the API returns the account schema for the source. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchemas: async (sourceId: string, includeTypes?: 'group' | 'user', axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceSchemas', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/schemas`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (includeTypes !== undefined) {
                localVarQueryParameter['include-types'] = includeTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importAccountsSchema: async (id: string, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importAccountsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importConnectorFile: async (sourceId: string, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('importConnectorFile', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/upload-connector-file`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importEntitlementsSchema: async (id: string, schemaName?: string, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importEntitlementsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (schemaName !== undefined) {
                localVarQueryParameter['schemaName'] = schemaName;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('listProvisioningPolicies', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/provisioning-policies`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **name**: *co, eq, in, sw, ge, gt, ne, isnull*  **type**: *eq, in, ge, gt, ne, isnull, sw*  **owner.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **features**: *ca, co*  **created**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **modified**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **managementWorkgroup.id**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **description**: *eq, sw*  **authoritative**: *eq, ne, isnull*  **healthy**: *isnull*  **status**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **connectionType**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **connectorName**: *eq, ge, gt, in, ne, isnull, sw*  **category**: *co, eq, ge, gt, in, le, lt, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status, id, description, owner.id, accountCorrelationConfig.id, accountCorrelationConfig.name, managerCorrelationRule.type, managerCorrelationRule.id, managerCorrelationRule.name, authoritative, managementWorkgroup.id, connectorName, connectionType**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putProvisioningPolicy: async (sourceId: string, usageType: UsageType, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'usageType', usageType)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to update a source in Identity Security Cloud (ISC), using a full object representation. This means that when you use this API, it completely replaces the existing source configuration.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id Source ID.
         * @param {Source} source 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSource: async (id: string, source: Source, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putSource', 'id', id)
            // verify required parameter 'source' is not null or undefined
            assertParamExists('putSource', 'source', source)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(source, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceSchema: async (sourceId: string, schemaId: string, schema: Schema, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('putSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('putSourceSchema', 'schemaId', schemaId)
            // verify required parameter 'schema' is not null or undefined
            assertParamExists('putSourceSchema', 'schema', schema)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPoliciesInBulk: async (sourceId: string, provisioningPolicyDto: Array<ProvisioningPolicyDto>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateProvisioningPoliciesInBulk', 'sourceId', sourceId)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('updateProvisioningPoliciesInBulk', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/bulk-update`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy: async (sourceId: string, usageType: UsageType, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'usageType', usageType)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to partially update a source in Identity Security Cloud (ISC), using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id Source ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in Identity Security Cloud (ISC).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSource', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateSource', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceSchema: async (sourceId: string, schemaId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('updateSourceSchema', 'schemaId', schemaId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateSourceSchema', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesApi - functional programming interface
 * @export
 */
export const SourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createProvisioningPolicy(sourceId: string, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProvisioningPolicy(sourceId, provisioningPolicyDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source 
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSource(source: Source, provisionAsCsv?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSource(source, provisionAsCsv, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to create a new schema on the specified source in Identity Security Cloud (ISC). 
         * @summary Create Schema on Source
         * @param {string} sourceId Source ID.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSourceSchema(sourceId: string, schema: Schema, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSourceSchema(sourceId, schema, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProvisioningPolicy(sourceId, usageType, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to delete a specific source in Identity Security Cloud (ISC). The API removes all the accounts on the source first, and then it deletes the source. You can retrieve the actual task execution status with this method: GET `/task-status/{id}` A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Delete Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteSource202Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSourceSchema(sourceId: string, schemaId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSourceSchema(sourceId, schemaId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsSchema(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsSchema(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitlementsSchema(id: string, schemaName?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitlementsSchema(id, schemaName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProvisioningPolicy(sourceId, usageType, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to get a source by a specified ID in Identity Security Cloud (ISC). A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSource(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSource(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceHealth(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceHealthDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceHealth(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceSchema(sourceId: string, schemaId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceSchema(sourceId, schemaId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to list the schemas that exist on the specified source in Identity Security Cloud (ISC). 
         * @summary List Schemas on Source
         * @param {string} sourceId Source ID.
         * @param {'group' | 'user'} [includeTypes] If this is set to &#x60;group&#x60;, the API filters the account schema and only returns only group schemas. If this is set to &#x60;user&#x60;, the API returns the account schema for the source. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceSchemas(sourceId: string, includeTypes?: 'group' | 'user', axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceSchemas(sourceId, includeTypes, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importAccountsSchema(id: string, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importAccountsSchema(id, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importConnectorFile(sourceId: string, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importConnectorFile(sourceId, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importEntitlementsSchema(id: string, schemaName?: string, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importEntitlementsSchema(id, schemaName, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listProvisioningPolicies(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProvisioningPolicyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProvisioningPolicies(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **name**: *co, eq, in, sw, ge, gt, ne, isnull*  **type**: *eq, in, ge, gt, ne, isnull, sw*  **owner.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **features**: *ca, co*  **created**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **modified**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **managementWorkgroup.id**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **description**: *eq, sw*  **authoritative**: *eq, ne, isnull*  **healthy**: *isnull*  **status**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **connectionType**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **connectorName**: *eq, ge, gt, in, ne, isnull, sw*  **category**: *co, eq, ge, gt, in, le, lt, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status, id, description, owner.id, accountCorrelationConfig.id, accountCorrelationConfig.name, managerCorrelationRule.type, managerCorrelationRule.id, managerCorrelationRule.name, authoritative, managementWorkgroup.id, connectorName, connectionType**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSources(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Source>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSources(limit, offset, count, filters, sorters, forSubadmin, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putProvisioningPolicy(sourceId: string, usageType: UsageType, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProvisioningPolicy(sourceId, usageType, provisioningPolicyDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to update a source in Identity Security Cloud (ISC), using a full object representation. This means that when you use this API, it completely replaces the existing source configuration.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id Source ID.
         * @param {Source} source 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSource(id: string, source: Source, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSource(id, source, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSourceSchema(sourceId: string, schemaId: string, schema: Schema, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSourceSchema(sourceId, schemaId, schema, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateProvisioningPoliciesInBulk(sourceId: string, provisioningPolicyDto: Array<ProvisioningPolicyDto>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProvisioningPolicyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProvisioningPoliciesInBulk(sourceId, provisioningPolicyDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateProvisioningPolicy(sourceId: string, usageType: UsageType, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProvisioningPolicy(sourceId, usageType, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to partially update a source in Identity Security Cloud (ISC), using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id Source ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in Identity Security Cloud (ISC).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSource(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSource(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSourceSchema(sourceId: string, schemaId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSourceSchema(sourceId, schemaId, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SourcesApi - factory interface
 * @export
 */
export const SourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourcesApiFp(configuration)
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy(sourceId: string, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.createProvisioningPolicy(sourceId, provisioningPolicyDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source 
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource(source: Source, provisionAsCsv?: boolean, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.createSource(source, provisionAsCsv, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to create a new schema on the specified source in Identity Security Cloud (ISC). 
         * @summary Create Schema on Source
         * @param {string} sourceId Source ID.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSourceSchema(sourceId: string, schema: Schema, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.createSourceSchema(sourceId, schema, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteProvisioningPolicy(sourceId, usageType, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to delete a specific source in Identity Security Cloud (ISC). The API removes all the accounts on the source first, and then it deletes the source. You can retrieve the actual task execution status with this method: GET `/task-status/{id}` A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Delete Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(id: string, axiosOptions?: any): AxiosPromise<DeleteSource202Response> {
            return localVarFp.deleteSource(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceSchema(sourceId: string, schemaId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSourceSchema(sourceId, schemaId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsSchema(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getAccountsSchema(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementsSchema(id: string, schemaName?: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getEntitlementsSchema(id, schemaName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.getProvisioningPolicy(sourceId, usageType, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get a source by a specified ID in Identity Security Cloud (ISC). A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource(id: string, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.getSource(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceHealth(sourceId: string, axiosOptions?: any): AxiosPromise<SourceHealthDto> {
            return localVarFp.getSourceHealth(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchema(sourceId: string, schemaId: string, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.getSourceSchema(sourceId, schemaId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to list the schemas that exist on the specified source in Identity Security Cloud (ISC). 
         * @summary List Schemas on Source
         * @param {string} sourceId Source ID.
         * @param {'group' | 'user'} [includeTypes] If this is set to &#x60;group&#x60;, the API filters the account schema and only returns only group schemas. If this is set to &#x60;user&#x60;, the API returns the account schema for the source. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchemas(sourceId: string, includeTypes?: 'group' | 'user', axiosOptions?: any): AxiosPromise<Array<Schema>> {
            return localVarFp.getSourceSchemas(sourceId, includeTypes, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importAccountsSchema(id: string, file?: any, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.importAccountsSchema(id, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importConnectorFile(sourceId: string, file?: any, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.importConnectorFile(sourceId, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importEntitlementsSchema(id: string, schemaName?: string, file?: any, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.importEntitlementsSchema(id, schemaName, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies(sourceId: string, axiosOptions?: any): AxiosPromise<Array<ProvisioningPolicyDto>> {
            return localVarFp.listProvisioningPolicies(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **name**: *co, eq, in, sw, ge, gt, ne, isnull*  **type**: *eq, in, ge, gt, ne, isnull, sw*  **owner.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **features**: *ca, co*  **created**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **modified**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **managementWorkgroup.id**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **description**: *eq, sw*  **authoritative**: *eq, ne, isnull*  **healthy**: *isnull*  **status**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **connectionType**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **connectorName**: *eq, ge, gt, in, ne, isnull, sw*  **category**: *co, eq, ge, gt, in, le, lt, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status, id, description, owner.id, accountCorrelationConfig.id, accountCorrelationConfig.name, managerCorrelationRule.type, managerCorrelationRule.id, managerCorrelationRule.name, authoritative, managementWorkgroup.id, connectorName, connectionType**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions?: any): AxiosPromise<Array<Source>> {
            return localVarFp.listSources(limit, offset, count, filters, sorters, forSubadmin, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putProvisioningPolicy(sourceId: string, usageType: UsageType, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.putProvisioningPolicy(sourceId, usageType, provisioningPolicyDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to update a source in Identity Security Cloud (ISC), using a full object representation. This means that when you use this API, it completely replaces the existing source configuration.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id Source ID.
         * @param {Source} source 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSource(id: string, source: Source, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.putSource(id, source, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceSchema(sourceId: string, schemaId: string, schema: Schema, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.putSourceSchema(sourceId, schemaId, schema, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPoliciesInBulk(sourceId: string, provisioningPolicyDto: Array<ProvisioningPolicyDto>, axiosOptions?: any): AxiosPromise<Array<ProvisioningPolicyDto>> {
            return localVarFp.updateProvisioningPoliciesInBulk(sourceId, provisioningPolicyDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy(sourceId: string, usageType: UsageType, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.updateProvisioningPolicy(sourceId, usageType, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to partially update a source in Identity Security Cloud (ISC), using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id Source ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in Identity Security Cloud (ISC).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.updateSource(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceSchema(sourceId: string, schemaId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.updateSourceSchema(sourceId, schemaId, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateProvisioningPolicyRequest
 */
export interface SourcesApiCreateProvisioningPolicyRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiCreateProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * 
     * @type {ProvisioningPolicyDto}
     * @memberof SourcesApiCreateProvisioningPolicy
     */
    readonly provisioningPolicyDto: ProvisioningPolicyDto
}

/**
 * Request parameters for createSource operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateSourceRequest
 */
export interface SourcesApiCreateSourceRequest {
    /**
     * 
     * @type {Source}
     * @memberof SourcesApiCreateSource
     */
    readonly source: Source

    /**
     * If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
     * @type {boolean}
     * @memberof SourcesApiCreateSource
     */
    readonly provisionAsCsv?: boolean
}

/**
 * Request parameters for createSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateSourceSchemaRequest
 */
export interface SourcesApiCreateSourceSchemaRequest {
    /**
     * Source ID.
     * @type {string}
     * @memberof SourcesApiCreateSourceSchema
     */
    readonly sourceId: string

    /**
     * 
     * @type {Schema}
     * @memberof SourcesApiCreateSourceSchema
     */
    readonly schema: Schema
}

/**
 * Request parameters for deleteProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteProvisioningPolicyRequest
 */
export interface SourcesApiDeleteProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiDeleteProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
     * @type {UsageType}
     * @memberof SourcesApiDeleteProvisioningPolicy
     */
    readonly usageType: UsageType
}

/**
 * Request parameters for deleteSource operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteSourceRequest
 */
export interface SourcesApiDeleteSourceRequest {
    /**
     * Source ID.
     * @type {string}
     * @memberof SourcesApiDeleteSource
     */
    readonly id: string
}

/**
 * Request parameters for deleteSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteSourceSchemaRequest
 */
export interface SourcesApiDeleteSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiDeleteSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiDeleteSourceSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for getAccountsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiGetAccountsSchemaRequest
 */
export interface SourcesApiGetAccountsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiGetAccountsSchema
     */
    readonly id: string
}

/**
 * Request parameters for getEntitlementsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiGetEntitlementsSchemaRequest
 */
export interface SourcesApiGetEntitlementsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiGetEntitlementsSchema
     */
    readonly id: string

    /**
     * Name of entitlement schema
     * @type {string}
     * @memberof SourcesApiGetEntitlementsSchema
     */
    readonly schemaName?: string
}

/**
 * Request parameters for getProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiGetProvisioningPolicyRequest
 */
export interface SourcesApiGetProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiGetProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
     * @type {UsageType}
     * @memberof SourcesApiGetProvisioningPolicy
     */
    readonly usageType: UsageType
}

/**
 * Request parameters for getSource operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceRequest
 */
export interface SourcesApiGetSourceRequest {
    /**
     * Source ID.
     * @type {string}
     * @memberof SourcesApiGetSource
     */
    readonly id: string
}

/**
 * Request parameters for getSourceHealth operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceHealthRequest
 */
export interface SourcesApiGetSourceHealthRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiGetSourceHealth
     */
    readonly sourceId: string
}

/**
 * Request parameters for getSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceSchemaRequest
 */
export interface SourcesApiGetSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiGetSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiGetSourceSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for getSourceSchemas operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceSchemasRequest
 */
export interface SourcesApiGetSourceSchemasRequest {
    /**
     * Source ID.
     * @type {string}
     * @memberof SourcesApiGetSourceSchemas
     */
    readonly sourceId: string

    /**
     * If this is set to &#x60;group&#x60;, the API filters the account schema and only returns only group schemas. If this is set to &#x60;user&#x60;, the API returns the account schema for the source. 
     * @type {'group' | 'user'}
     * @memberof SourcesApiGetSourceSchemas
     */
    readonly includeTypes?: 'group' | 'user'
}

/**
 * Request parameters for importAccountsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiImportAccountsSchemaRequest
 */
export interface SourcesApiImportAccountsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiImportAccountsSchema
     */
    readonly id: string

    /**
     * 
     * @type {any}
     * @memberof SourcesApiImportAccountsSchema
     */
    readonly file?: any
}

/**
 * Request parameters for importConnectorFile operation in SourcesApi.
 * @export
 * @interface SourcesApiImportConnectorFileRequest
 */
export interface SourcesApiImportConnectorFileRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiImportConnectorFile
     */
    readonly sourceId: string

    /**
     * 
     * @type {any}
     * @memberof SourcesApiImportConnectorFile
     */
    readonly file?: any
}

/**
 * Request parameters for importEntitlementsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiImportEntitlementsSchemaRequest
 */
export interface SourcesApiImportEntitlementsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiImportEntitlementsSchema
     */
    readonly id: string

    /**
     * Name of entitlement schema
     * @type {string}
     * @memberof SourcesApiImportEntitlementsSchema
     */
    readonly schemaName?: string

    /**
     * 
     * @type {any}
     * @memberof SourcesApiImportEntitlementsSchema
     */
    readonly file?: any
}

/**
 * Request parameters for listProvisioningPolicies operation in SourcesApi.
 * @export
 * @interface SourcesApiListProvisioningPoliciesRequest
 */
export interface SourcesApiListProvisioningPoliciesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiListProvisioningPolicies
     */
    readonly sourceId: string
}

/**
 * Request parameters for listSources operation in SourcesApi.
 * @export
 * @interface SourcesApiListSourcesRequest
 */
export interface SourcesApiListSourcesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourcesApiListSources
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourcesApiListSources
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SourcesApiListSources
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **name**: *co, eq, in, sw, ge, gt, ne, isnull*  **type**: *eq, in, ge, gt, ne, isnull, sw*  **owner.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **features**: *ca, co*  **created**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **modified**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **managementWorkgroup.id**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **description**: *eq, sw*  **authoritative**: *eq, ne, isnull*  **healthy**: *isnull*  **status**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **connectionType**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **connectorName**: *eq, ge, gt, in, ne, isnull, sw*  **category**: *co, eq, ge, gt, in, le, lt, ne, sw*
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status, id, description, owner.id, accountCorrelationConfig.id, accountCorrelationConfig.name, managerCorrelationRule.type, managerCorrelationRule.id, managerCorrelationRule.name, authoritative, managementWorkgroup.id, connectorName, connectionType**
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly sorters?: string

    /**
     * Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly forSubadmin?: string
}

/**
 * Request parameters for putProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiPutProvisioningPolicyRequest
 */
export interface SourcesApiPutProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiPutProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
     * @type {UsageType}
     * @memberof SourcesApiPutProvisioningPolicy
     */
    readonly usageType: UsageType

    /**
     * 
     * @type {ProvisioningPolicyDto}
     * @memberof SourcesApiPutProvisioningPolicy
     */
    readonly provisioningPolicyDto: ProvisioningPolicyDto
}

/**
 * Request parameters for putSource operation in SourcesApi.
 * @export
 * @interface SourcesApiPutSourceRequest
 */
export interface SourcesApiPutSourceRequest {
    /**
     * Source ID.
     * @type {string}
     * @memberof SourcesApiPutSource
     */
    readonly id: string

    /**
     * 
     * @type {Source}
     * @memberof SourcesApiPutSource
     */
    readonly source: Source
}

/**
 * Request parameters for putSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiPutSourceSchemaRequest
 */
export interface SourcesApiPutSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiPutSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiPutSourceSchema
     */
    readonly schemaId: string

    /**
     * 
     * @type {Schema}
     * @memberof SourcesApiPutSourceSchema
     */
    readonly schema: Schema
}

/**
 * Request parameters for updateProvisioningPoliciesInBulk operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateProvisioningPoliciesInBulkRequest
 */
export interface SourcesApiUpdateProvisioningPoliciesInBulkRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateProvisioningPoliciesInBulk
     */
    readonly sourceId: string

    /**
     * 
     * @type {Array<ProvisioningPolicyDto>}
     * @memberof SourcesApiUpdateProvisioningPoliciesInBulk
     */
    readonly provisioningPolicyDto: Array<ProvisioningPolicyDto>
}

/**
 * Request parameters for updateProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateProvisioningPolicyRequest
 */
export interface SourcesApiUpdateProvisioningPolicyRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs. 
     * @type {UsageType}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly usageType: UsageType

    /**
     * The JSONPatch payload used to update the schema.
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for updateSource operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateSourceRequest
 */
export interface SourcesApiUpdateSourceRequest {
    /**
     * Source ID.
     * @type {string}
     * @memberof SourcesApiUpdateSource
     */
    readonly id: string

    /**
     * A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in Identity Security Cloud (ISC).
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateSource
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for updateSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateSourceSchemaRequest
 */
export interface SourcesApiUpdateSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiUpdateSourceSchema
     */
    readonly schemaId: string

    /**
     * The JSONPatch payload used to update the schema.
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateSourceSchema
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * SourcesApi - object-oriented interface
 * @export
 * @class SourcesApi
 * @extends {BaseAPI}
 */
export class SourcesApi extends BaseAPI {
    /**
     * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Provisioning Policy
     * @param {SourcesApiCreateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createProvisioningPolicy(requestParameters: SourcesApiCreateProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createProvisioningPolicy(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Creates a source in IdentityNow.
     * @param {SourcesApiCreateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createSource(requestParameters: SourcesApiCreateSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createSource(requestParameters.source, requestParameters.provisionAsCsv, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to create a new schema on the specified source in Identity Security Cloud (ISC). 
     * @summary Create Schema on Source
     * @param {SourcesApiCreateSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createSourceSchema(requestParameters: SourcesApiCreateSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createSourceSchema(requestParameters.sourceId, requestParameters.schema, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Delete Provisioning Policy by UsageType
     * @param {SourcesApiDeleteProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteProvisioningPolicy(requestParameters: SourcesApiDeleteProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to delete a specific source in Identity Security Cloud (ISC). The API removes all the accounts on the source first, and then it deletes the source. You can retrieve the actual task execution status with this method: GET `/task-status/{id}` A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Delete Source by ID
     * @param {SourcesApiDeleteSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteSource(requestParameters: SourcesApiDeleteSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteSource(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Source Schema by ID
     * @param {SourcesApiDeleteSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteSourceSchema(requestParameters: SourcesApiDeleteSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Downloads source accounts schema template
     * @param {SourcesApiGetAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getAccountsSchema(requestParameters: SourcesApiGetAccountsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getAccountsSchema(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Downloads source entitlements schema template
     * @param {SourcesApiGetEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getEntitlementsSchema(requestParameters: SourcesApiGetEntitlementsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getEntitlementsSchema(requestParameters.id, requestParameters.schemaName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get Provisioning Policy by UsageType
     * @param {SourcesApiGetProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getProvisioningPolicy(requestParameters: SourcesApiGetProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get a source by a specified ID in Identity Security Cloud (ISC). A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get Source by ID
     * @param {SourcesApiGetSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSource(requestParameters: SourcesApiGetSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSource(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint fetches source health by source\'s id
     * @summary Fetches source health by id
     * @param {SourcesApiGetSourceHealthRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourceHealth(requestParameters: SourcesApiGetSourceHealthRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSourceHealth(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Source Schema by ID in IdentityNow. 
     * @summary Get Source Schema by ID
     * @param {SourcesApiGetSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourceSchema(requestParameters: SourcesApiGetSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to list the schemas that exist on the specified source in Identity Security Cloud (ISC). 
     * @summary List Schemas on Source
     * @param {SourcesApiGetSourceSchemasRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourceSchemas(requestParameters: SourcesApiGetSourceSchemasRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSourceSchemas(requestParameters.sourceId, requestParameters.includeTypes, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Uploads source accounts schema template
     * @param {SourcesApiImportAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public importAccountsSchema(requestParameters: SourcesApiImportAccountsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).importAccountsSchema(requestParameters.id, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
     * @summary Upload connector file to source
     * @param {SourcesApiImportConnectorFileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public importConnectorFile(requestParameters: SourcesApiImportConnectorFileRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).importConnectorFile(requestParameters.sourceId, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Uploads source entitlements schema template
     * @param {SourcesApiImportEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public importEntitlementsSchema(requestParameters: SourcesApiImportEntitlementsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).importEntitlementsSchema(requestParameters.id, requestParameters.schemaName, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Lists ProvisioningPolicies
     * @param {SourcesApiListProvisioningPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listProvisioningPolicies(requestParameters: SourcesApiListProvisioningPoliciesRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).listProvisioningPolicies(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
     * @summary Lists all sources in IdentityNow.
     * @param {SourcesApiListSourcesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listSources(requestParameters: SourcesApiListSourcesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).listSources(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSubadmin, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Update Provisioning Policy by UsageType
     * @param {SourcesApiPutProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public putProvisioningPolicy(requestParameters: SourcesApiPutProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).putProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to update a source in Identity Security Cloud (ISC), using a full object representation. This means that when you use this API, it completely replaces the existing source configuration.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
     * @summary Update Source (Full)
     * @param {SourcesApiPutSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public putSource(requestParameters: SourcesApiPutSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).putSource(requestParameters.id, requestParameters.source, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
     * @summary Update Source Schema (Full)
     * @param {SourcesApiPutSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public putSourceSchema(requestParameters: SourcesApiPutSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).putSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.schema, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Bulk Update Provisioning Policies
     * @param {SourcesApiUpdateProvisioningPoliciesInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateProvisioningPoliciesInBulk(requestParameters: SourcesApiUpdateProvisioningPoliciesInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateProvisioningPoliciesInBulk(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Partial update of Provisioning Policy
     * @param {SourcesApiUpdateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateProvisioningPolicy(requestParameters: SourcesApiUpdateProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to partially update a source in Identity Security Cloud (ISC), using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
     * @summary Update Source (Partial)
     * @param {SourcesApiUpdateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateSource(requestParameters: SourcesApiUpdateSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateSource(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
     * @summary Update Source Schema (Partial)
     * @param {SourcesApiUpdateSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateSourceSchema(requestParameters: SourcesApiUpdateSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaggedObjectsApi - axios parameter creator
 * @export
 */
export const TaggedObjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaggedObject: async (type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTaggedObject', 'id', id)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsToManyObject: async (bulkTaggedObject: BulkTaggedObject, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkTaggedObject' is not null or undefined
            assertParamExists('deleteTagsToManyObject', 'bulkTaggedObject', bulkTaggedObject)
            const localVarPath = `/tagged-objects/bulk-remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkTaggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTaggedObject: async (type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaggedObject', 'id', id)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjects: async (limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tagged-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects by Type
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjectsByType: async (type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('listTaggedObjectsByType', 'type', type)
            const localVarPath = `/tagged-objects/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTaggedObject: async (type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', id: string, taggedObject: TaggedObject, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('putTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putTaggedObject', 'id', id)
            // verify required parameter 'taggedObject' is not null or undefined
            assertParamExists('putTaggedObject', 'taggedObject', taggedObject)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagToObject: async (taggedObject: TaggedObject, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taggedObject' is not null or undefined
            assertParamExists('setTagToObject', 'taggedObject', taggedObject)
            const localVarPath = `/tagged-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagsToManyObjects: async (bulkTaggedObject: BulkTaggedObject, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkTaggedObject' is not null or undefined
            assertParamExists('setTagsToManyObjects', 'bulkTaggedObject', bulkTaggedObject)
            const localVarPath = `/tagged-objects/bulk-add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkTaggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaggedObjectsApi - functional programming interface
 * @export
 */
export const TaggedObjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaggedObjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaggedObject(type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaggedObject(type, id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTagsToManyObject(bulkTaggedObject: BulkTaggedObject, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTagsToManyObject(bulkTaggedObject, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTaggedObject(type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggedObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaggedObject(type, id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTaggedObjects(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaggedObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTaggedObjects(limit, offset, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects by Type
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTaggedObjectsByType(type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaggedObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTaggedObjectsByType(type, limit, offset, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putTaggedObject(type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', id: string, taggedObject: TaggedObject, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggedObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTaggedObject(type, id, taggedObject, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setTagToObject(taggedObject: TaggedObject, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTagToObject(taggedObject, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setTagsToManyObjects(bulkTaggedObject: BulkTaggedObject, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkTaggedObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTagsToManyObjects(bulkTaggedObject, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaggedObjectsApi - factory interface
 * @export
 */
export const TaggedObjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaggedObjectsApiFp(configuration)
    return {
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaggedObject(type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteTaggedObject(type, id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsToManyObject(bulkTaggedObject: BulkTaggedObject, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteTagsToManyObject(bulkTaggedObject, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTaggedObject(type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', id: string, axiosOptions?: any): AxiosPromise<TaggedObject> {
            return localVarFp.getTaggedObject(type, id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjects(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<TaggedObject>> {
            return localVarFp.listTaggedObjects(limit, offset, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects by Type
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjectsByType(type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<TaggedObject>> {
            return localVarFp.listTaggedObjectsByType(type, limit, offset, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTaggedObject(type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE', id: string, taggedObject: TaggedObject, axiosOptions?: any): AxiosPromise<TaggedObject> {
            return localVarFp.putTaggedObject(type, id, taggedObject, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagToObject(taggedObject: TaggedObject, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.setTagToObject(taggedObject, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagsToManyObjects(bulkTaggedObject: BulkTaggedObject, axiosOptions?: any): AxiosPromise<BulkTaggedObject> {
            return localVarFp.setTagsToManyObjects(bulkTaggedObject, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteTaggedObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiDeleteTaggedObjectRequest
 */
export interface TaggedObjectsApiDeleteTaggedObjectRequest {
    /**
     * The type of tagged object to delete.
     * @type {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'}
     * @memberof TaggedObjectsApiDeleteTaggedObject
     */
    readonly type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'

    /**
     * The ID of the object reference to delete.
     * @type {string}
     * @memberof TaggedObjectsApiDeleteTaggedObject
     */
    readonly id: string
}

/**
 * Request parameters for deleteTagsToManyObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiDeleteTagsToManyObjectRequest
 */
export interface TaggedObjectsApiDeleteTagsToManyObjectRequest {
    /**
     * Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
     * @type {BulkTaggedObject}
     * @memberof TaggedObjectsApiDeleteTagsToManyObject
     */
    readonly bulkTaggedObject: BulkTaggedObject
}

/**
 * Request parameters for getTaggedObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiGetTaggedObjectRequest
 */
export interface TaggedObjectsApiGetTaggedObjectRequest {
    /**
     * The type of tagged object to retrieve.
     * @type {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'}
     * @memberof TaggedObjectsApiGetTaggedObject
     */
    readonly type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'

    /**
     * The ID of the object reference to retrieve.
     * @type {string}
     * @memberof TaggedObjectsApiGetTaggedObject
     */
    readonly id: string
}

/**
 * Request parameters for listTaggedObjects operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiListTaggedObjectsRequest
 */
export interface TaggedObjectsApiListTaggedObjectsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
     * @type {string}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly filters?: string
}

/**
 * Request parameters for listTaggedObjectsByType operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiListTaggedObjectsByTypeRequest
 */
export interface TaggedObjectsApiListTaggedObjectsByTypeRequest {
    /**
     * The type of tagged object to retrieve.
     * @type {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
     * @type {string}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly filters?: string
}

/**
 * Request parameters for putTaggedObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiPutTaggedObjectRequest
 */
export interface TaggedObjectsApiPutTaggedObjectRequest {
    /**
     * The type of tagged object to update.
     * @type {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'}
     * @memberof TaggedObjectsApiPutTaggedObject
     */
    readonly type: 'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'

    /**
     * The ID of the object reference to update.
     * @type {string}
     * @memberof TaggedObjectsApiPutTaggedObject
     */
    readonly id: string

    /**
     * 
     * @type {TaggedObject}
     * @memberof TaggedObjectsApiPutTaggedObject
     */
    readonly taggedObject: TaggedObject
}

/**
 * Request parameters for setTagToObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiSetTagToObjectRequest
 */
export interface TaggedObjectsApiSetTagToObjectRequest {
    /**
     * 
     * @type {TaggedObject}
     * @memberof TaggedObjectsApiSetTagToObject
     */
    readonly taggedObject: TaggedObject
}

/**
 * Request parameters for setTagsToManyObjects operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiSetTagsToManyObjectsRequest
 */
export interface TaggedObjectsApiSetTagsToManyObjectsRequest {
    /**
     * Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
     * @type {BulkTaggedObject}
     * @memberof TaggedObjectsApiSetTagsToManyObjects
     */
    readonly bulkTaggedObject: BulkTaggedObject
}

/**
 * TaggedObjectsApi - object-oriented interface
 * @export
 * @class TaggedObjectsApi
 * @extends {BaseAPI}
 */
export class TaggedObjectsApi extends BaseAPI {
    /**
     * This deletes a tagged object for the specified type.
     * @summary Delete Tagged Object
     * @param {TaggedObjectsApiDeleteTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public deleteTaggedObject(requestParameters: TaggedObjectsApiDeleteTaggedObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).deleteTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Remove Tags from Multiple Objects
     * @param {TaggedObjectsApiDeleteTagsToManyObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public deleteTagsToManyObject(requestParameters: TaggedObjectsApiDeleteTagsToManyObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).deleteTagsToManyObject(requestParameters.bulkTaggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a tagged object for the specified type.
     * @summary Get Tagged Object
     * @param {TaggedObjectsApiGetTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public getTaggedObject(requestParameters: TaggedObjectsApiGetTaggedObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).getTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
     * @summary List Tagged Objects
     * @param {TaggedObjectsApiListTaggedObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public listTaggedObjects(requestParameters: TaggedObjectsApiListTaggedObjectsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).listTaggedObjects(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
     * @summary List Tagged Objects by Type
     * @param {TaggedObjectsApiListTaggedObjectsByTypeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public listTaggedObjectsByType(requestParameters: TaggedObjectsApiListTaggedObjectsByTypeRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).listTaggedObjectsByType(requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates a tagged object for the specified type.
     * @summary Update Tagged Object
     * @param {TaggedObjectsApiPutTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public putTaggedObject(requestParameters: TaggedObjectsApiPutTaggedObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).putTaggedObject(requestParameters.type, requestParameters.id, requestParameters.taggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This adds a tag to an object.  Any authenticated token may be used to call this API.
     * @summary Add Tag to Object
     * @param {TaggedObjectsApiSetTagToObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public setTagToObject(requestParameters: TaggedObjectsApiSetTagToObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).setTagToObject(requestParameters.taggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Tag Multiple Objects
     * @param {TaggedObjectsApiSetTagsToManyObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public setTagsToManyObjects(requestParameters: TaggedObjectsApiSetTagsToManyObjectsRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).setTagsToManyObjects(requestParameters.bulkTaggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransformsApi - axios parameter creator
 * @export
 */
export const TransformsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform: async (transform: Transform, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transform' is not null or undefined
            assertParamExists('createTransform', 'transform', transform)
            const localVarPath = `/transforms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transform, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **internal**: *eq*  **name**: *eq, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTransforms: async (offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transforms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object. Must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields, but \&quot;name\&quot; and \&quot;type\&quot; must not be modified.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform: async (id: string, transform?: Transform, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transform, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransformsApi - functional programming interface
 * @export
 */
export const TransformsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransformsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createTransform(transform: Transform, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransformRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransform(transform, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransform(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransform(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTransform(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransformRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransform(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **internal**: *eq*  **name**: *eq, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTransforms(offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransformRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransforms(offset, limit, count, name, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object. Must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields, but \&quot;name\&quot; and \&quot;type\&quot; must not be modified.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransform(id: string, transform?: Transform, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransformRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransform(id, transform, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransformsApi - factory interface
 * @export
 */
export const TransformsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransformsApiFp(configuration)
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform(transform: Transform, axiosOptions?: any): AxiosPromise<TransformRead> {
            return localVarFp.createTransform(transform, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteTransform(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform(id: string, axiosOptions?: any): AxiosPromise<TransformRead> {
            return localVarFp.getTransform(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **internal**: *eq*  **name**: *eq, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTransforms(offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<TransformRead>> {
            return localVarFp.listTransforms(offset, limit, count, name, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object. Must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields, but \&quot;name\&quot; and \&quot;type\&quot; must not be modified.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform(id: string, transform?: Transform, axiosOptions?: any): AxiosPromise<TransformRead> {
            return localVarFp.updateTransform(id, transform, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiCreateTransformRequest
 */
export interface TransformsApiCreateTransformRequest {
    /**
     * The transform to be created.
     * @type {Transform}
     * @memberof TransformsApiCreateTransform
     */
    readonly transform: Transform
}

/**
 * Request parameters for deleteTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiDeleteTransformRequest
 */
export interface TransformsApiDeleteTransformRequest {
    /**
     * ID of the transform to delete
     * @type {string}
     * @memberof TransformsApiDeleteTransform
     */
    readonly id: string
}

/**
 * Request parameters for getTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiGetTransformRequest
 */
export interface TransformsApiGetTransformRequest {
    /**
     * ID of the transform to retrieve
     * @type {string}
     * @memberof TransformsApiGetTransform
     */
    readonly id: string
}

/**
 * Request parameters for listTransforms operation in TransformsApi.
 * @export
 * @interface TransformsApiListTransformsRequest
 */
export interface TransformsApiListTransformsRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TransformsApiListTransforms
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TransformsApiListTransforms
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TransformsApiListTransforms
     */
    readonly count?: boolean

    /**
     * Name of the transform to retrieve from the list.
     * @type {string}
     * @memberof TransformsApiListTransforms
     */
    readonly name?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **internal**: *eq*  **name**: *eq, sw*
     * @type {string}
     * @memberof TransformsApiListTransforms
     */
    readonly filters?: string
}

/**
 * Request parameters for updateTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiUpdateTransformRequest
 */
export interface TransformsApiUpdateTransformRequest {
    /**
     * ID of the transform to update
     * @type {string}
     * @memberof TransformsApiUpdateTransform
     */
    readonly id: string

    /**
     * The updated transform object. Must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields, but \&quot;name\&quot; and \&quot;type\&quot; must not be modified.
     * @type {Transform}
     * @memberof TransformsApiUpdateTransform
     */
    readonly transform?: Transform
}

/**
 * TransformsApi - object-oriented interface
 * @export
 * @class TransformsApi
 * @extends {BaseAPI}
 */
export class TransformsApi extends BaseAPI {
    /**
     * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
     * @summary Create transform
     * @param {TransformsApiCreateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public createTransform(requestParameters: TransformsApiCreateTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).createTransform(requestParameters.transform, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
     * @summary Delete a transform
     * @param {TransformsApiDeleteTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public deleteTransform(requestParameters: TransformsApiDeleteTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).deleteTransform(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
     * @summary Transform by ID
     * @param {TransformsApiGetTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public getTransform(requestParameters: TransformsApiGetTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).getTransform(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
     * @summary List transforms
     * @param {TransformsApiListTransformsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public listTransforms(requestParameters: TransformsApiListTransformsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).listTransforms(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.name, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
     * @summary Update a transform
     * @param {TransformsApiUpdateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public updateTransform(requestParameters: TransformsApiUpdateTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).updateTransform(requestParameters.id, requestParameters.transform, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkItemsApi - axios parameter creator
 * @export
 */
export const WorkItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem: async (id: string, approvalItemId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveApprovalItem', 'id', id)
            // verify required parameter 'approvalItemId' is not null or undefined
            assertParamExists('approveApprovalItem', 'approvalItemId', approvalItemId)
            const localVarPath = `/work-items/{id}/approve/{approvalItemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"approvalItemId"}}`, encodeURIComponent(String(approvalItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItemsInBulk: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveApprovalItemsInBulk', 'id', id)
            const localVarPath = `/work-items/bulk-approve/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeWorkItem', 'id', id)
            const localVarPath = `/work-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCompletedWorkItems: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountCompletedWorkItems: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/completed/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountWorkItems: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItem: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkItem', 'id', id)
            const localVarPath = `/work-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsSummary: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems: async (limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem: async (id: string, approvalItemId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectApprovalItem', 'id', id)
            // verify required parameter 'approvalItemId' is not null or undefined
            assertParamExists('rejectApprovalItem', 'approvalItemId', approvalItemId)
            const localVarPath = `/work-items/{id}/reject/{approvalItemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"approvalItemId"}}`, encodeURIComponent(String(approvalItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItemsInBulk: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectApprovalItemsInBulk', 'id', id)
            const localVarPath = `/work-items/bulk-reject/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection: async (id: string, requestBody: { [key: string]: any; }, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitAccountSelection', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('submitAccountSelection', 'requestBody', requestBody)
            const localVarPath = `/work-items/{id}/submit-account-selection`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkItemsApi - functional programming interface
 * @export
 */
export const WorkItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveApprovalItem(id: string, approvalItemId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveApprovalItem(id, approvalItemId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveApprovalItemsInBulk(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveApprovalItemsInBulk(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async completeWorkItem(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeWorkItem(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCompletedWorkItems(ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItems>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompletedWorkItems(ownerId, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCountCompletedWorkItems(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountCompletedWorkItems(ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCountWorkItems(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountWorkItems(ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItem(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItem(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItemsSummary(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItemsSummary(ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkItems(limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItems>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkItems(limit, offset, count, ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectApprovalItem(id: string, approvalItemId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectApprovalItem(id, approvalItemId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectApprovalItemsInBulk(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectApprovalItemsInBulk(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async submitAccountSelection(id: string, requestBody: { [key: string]: any; }, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitAccountSelection(id, requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkItemsApi - factory interface
 * @export
 */
export const WorkItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkItemsApiFp(configuration)
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem(id: string, approvalItemId: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.approveApprovalItem(id, approvalItemId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItemsInBulk(id: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.approveApprovalItemsInBulk(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem(id: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.completeWorkItem(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCompletedWorkItems(ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<WorkItems>> {
            return localVarFp.getCompletedWorkItems(ownerId, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountCompletedWorkItems(ownerId?: string, axiosOptions?: any): AxiosPromise<WorkItemsCount> {
            return localVarFp.getCountCompletedWorkItems(ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountWorkItems(ownerId?: string, axiosOptions?: any): AxiosPromise<WorkItemsCount> {
            return localVarFp.getCountWorkItems(ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItem(id: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.getWorkItem(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsSummary(ownerId?: string, axiosOptions?: any): AxiosPromise<WorkItemsSummary> {
            return localVarFp.getWorkItemsSummary(ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems(limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions?: any): AxiosPromise<Array<WorkItems>> {
            return localVarFp.listWorkItems(limit, offset, count, ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem(id: string, approvalItemId: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.rejectApprovalItem(id, approvalItemId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItemsInBulk(id: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.rejectApprovalItemsInBulk(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection(id: string, requestBody: { [key: string]: any; }, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.submitAccountSelection(id, requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveApprovalItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiApproveApprovalItemRequest
 */
export interface WorkItemsApiApproveApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItem
     */
    readonly id: string

    /**
     * The ID of the approval item.
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItem
     */
    readonly approvalItemId: string
}

/**
 * Request parameters for approveApprovalItemsInBulk operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiApproveApprovalItemsInBulkRequest
 */
export interface WorkItemsApiApproveApprovalItemsInBulkRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItemsInBulk
     */
    readonly id: string
}

/**
 * Request parameters for completeWorkItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiCompleteWorkItemRequest
 */
export interface WorkItemsApiCompleteWorkItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiCompleteWorkItem
     */
    readonly id: string
}

/**
 * Request parameters for getCompletedWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetCompletedWorkItemsRequest
 */
export interface WorkItemsApiGetCompletedWorkItemsRequest {
    /**
     * The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
     * @type {string}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly count?: boolean
}

/**
 * Request parameters for getCountCompletedWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetCountCompletedWorkItemsRequest
 */
export interface WorkItemsApiGetCountCompletedWorkItemsRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiGetCountCompletedWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for getCountWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetCountWorkItemsRequest
 */
export interface WorkItemsApiGetCountWorkItemsRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiGetCountWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for getWorkItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetWorkItemRequest
 */
export interface WorkItemsApiGetWorkItemRequest {
    /**
     * ID of the work item.
     * @type {string}
     * @memberof WorkItemsApiGetWorkItem
     */
    readonly id: string
}

/**
 * Request parameters for getWorkItemsSummary operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetWorkItemsSummaryRequest
 */
export interface WorkItemsApiGetWorkItemsSummaryRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiGetWorkItemsSummary
     */
    readonly ownerId?: string
}

/**
 * Request parameters for listWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiListWorkItemsRequest
 */
export interface WorkItemsApiListWorkItemsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly count?: boolean

    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for rejectApprovalItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiRejectApprovalItemRequest
 */
export interface WorkItemsApiRejectApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItem
     */
    readonly id: string

    /**
     * The ID of the approval item.
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItem
     */
    readonly approvalItemId: string
}

/**
 * Request parameters for rejectApprovalItemsInBulk operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiRejectApprovalItemsInBulkRequest
 */
export interface WorkItemsApiRejectApprovalItemsInBulkRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItemsInBulk
     */
    readonly id: string
}

/**
 * Request parameters for submitAccountSelection operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiSubmitAccountSelectionRequest
 */
export interface WorkItemsApiSubmitAccountSelectionRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiSubmitAccountSelection
     */
    readonly id: string

    /**
     * Account Selection Data map, keyed on fieldName
     * @type {{ [key: string]: any; }}
     * @memberof WorkItemsApiSubmitAccountSelection
     */
    readonly requestBody: { [key: string]: any; }
}

/**
 * WorkItemsApi - object-oriented interface
 * @export
 * @class WorkItemsApi
 * @extends {BaseAPI}
 */
export class WorkItemsApi extends BaseAPI {
    /**
     * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Approve an Approval Item
     * @param {WorkItemsApiApproveApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public approveApprovalItem(requestParameters: WorkItemsApiApproveApprovalItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).approveApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk approve Approval Items
     * @param {WorkItemsApiApproveApprovalItemsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public approveApprovalItemsInBulk(requestParameters: WorkItemsApiApproveApprovalItemsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).approveApprovalItemsInBulk(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API completes a work item. Either an admin, or the owning/current user must make this request.
     * @summary Complete a Work Item
     * @param {WorkItemsApiCompleteWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public completeWorkItem(requestParameters: WorkItemsApiCompleteWorkItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).completeWorkItem(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Completed Work Items
     * @param {WorkItemsApiGetCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getCompletedWorkItems(requestParameters: WorkItemsApiGetCompletedWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getCompletedWorkItems(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Completed Work Items
     * @param {WorkItemsApiGetCountCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getCountCompletedWorkItems(requestParameters: WorkItemsApiGetCountCompletedWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getCountCompletedWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a count of work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Work Items
     * @param {WorkItemsApiGetCountWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getCountWorkItems(requestParameters: WorkItemsApiGetCountWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getCountWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
     * @summary Get a Work Item
     * @param {WorkItemsApiGetWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getWorkItem(requestParameters: WorkItemsApiGetWorkItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getWorkItem(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
     * @summary Work Items Summary
     * @param {WorkItemsApiGetWorkItemsSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getWorkItemsSummary(requestParameters: WorkItemsApiGetWorkItemsSummaryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getWorkItemsSummary(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
     * @summary List Work Items
     * @param {WorkItemsApiListWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public listWorkItems(requestParameters: WorkItemsApiListWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).listWorkItems(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Reject an Approval Item
     * @param {WorkItemsApiRejectApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public rejectApprovalItem(requestParameters: WorkItemsApiRejectApprovalItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).rejectApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk reject Approval Items
     * @param {WorkItemsApiRejectApprovalItemsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public rejectApprovalItemsInBulk(requestParameters: WorkItemsApiRejectApprovalItemsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).rejectApprovalItemsInBulk(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits account selections. Either an admin, or the owning/current user must make this request.
     * @summary Submit Account Selections
     * @param {WorkItemsApiSubmitAccountSelectionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public submitAccountSelection(requestParameters: WorkItemsApiSubmitAccountSelectionRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).submitAccountSelection(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to cancel a running workflow execution.
         * @summary Cancel Workflow Execution by ID
         * @param {string} id The workflow execution ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelWorkflowExecution: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelWorkflowExecution', 'id', id)
            const localVarPath = `/workflow-executions/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
         * @summary Execute Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {CreateExternalExecuteWorkflowRequest} [createExternalExecuteWorkflowRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createExternalExecuteWorkflow: async (id: string, createExternalExecuteWorkflowRequest?: CreateExternalExecuteWorkflowRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createExternalExecuteWorkflow', 'id', id)
            const localVarPath = `/workflows/execute/external/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createExternalExecuteWorkflowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Create a new workflow with the desired trigger and steps specified in the request body.
         * @summary Create Workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow: async (createWorkflowRequest: CreateWorkflowRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkflowRequest' is not null or undefined
            assertParamExists('createWorkflow', 'createWorkflowRequest', createWorkflowRequest)
            const localVarPath = `/workflows/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkflowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
         * @summary Generate External Trigger OAuth Client
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowExternalTrigger: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createWorkflowExternalTrigger', 'id', id)
            const localVarPath = `/workflows/{id}/external/oauth-clients`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
         * @summary Delete Workflow By Id
         * @param {string} id Id of the Workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWorkflow', 'id', id)
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a single workflow by id.
         * @summary Get Workflow By Id
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkflow', 'id', id)
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to get a single workflow execution. Workflow executions are available for up to 90 days before being archived. If you attempt to access a workflow execution that has been archived, you will receive a \"404 Not Found\" response.
         * @summary Get Workflow Execution
         * @param {string} id Workflow execution ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecution: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkflowExecution', 'id', id)
            const localVarPath = `/workflow-executions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get Workflow Execution History
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutionHistory: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkflowExecutionHistory', 'id', id)
            const localVarPath = `/workflow-executions/{id}/history`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to list a specified workflow\'s executions. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions. To get executions past the first 250 records, you can do the following: 1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows. 2. Get your workflow ID from the response. 3. You can then do either of the following:    - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - Paginate through results with the `offset` parameter.   For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.   Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination.
         * @summary List Workflow Executions
         * @param {string} id Workflow ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **startTime**: *eq, lt, le, gt, ge*  **status**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutions: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkflowExecutions', 'id', id)
            const localVarPath = `/workflows/{id}/executions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists all triggers, actions, and operators in the library
         * @summary List Complete Workflow Library
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompleteWorkflowLibrary: async (limit?: number, offset?: number, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow-library`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists the workflow actions available to you.
         * @summary List Workflow Library Actions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryActions: async (limit?: number, offset?: number, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow-library/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists the workflow operators available to you
         * @summary List Workflow Library Operators
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryOperators: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow-library/operators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This lists the workflow triggers available to you
         * @summary List Workflow Library Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryTriggers: async (limit?: number, offset?: number, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow-library/triggers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * List all workflows in the tenant.
         * @summary List Workflows
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
         * @summary Patch Workflow
         * @param {string} id Id of the Workflow
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkflow: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchWorkflow', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchWorkflow', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Perform a full update of a workflow.  The updated workflow object is returned in the response.
         * @summary Update Workflow
         * @param {string} id Id of the Workflow
         * @param {WorkflowBody} workflowBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putWorkflow: async (id: string, workflowBody: WorkflowBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putWorkflow', 'id', id)
            // verify required parameter 'workflowBody' is not null or undefined
            assertParamExists('putWorkflow', 'workflowBody', workflowBody)
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
         * @summary Test Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {TestExternalExecuteWorkflowRequest} [testExternalExecuteWorkflowRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testExternalExecuteWorkflow: async (id: string, testExternalExecuteWorkflowRequest?: TestExternalExecuteWorkflowRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('testExternalExecuteWorkflow', 'id', id)
            const localVarPath = `/workflows/execute/external/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testExternalExecuteWorkflowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
         * @summary Test Workflow By Id
         * @param {string} id Id of the workflow
         * @param {TestWorkflowRequest} testWorkflowRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testWorkflow: async (id: string, testWorkflowRequest: TestWorkflowRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('testWorkflow', 'id', id)
            // verify required parameter 'testWorkflowRequest' is not null or undefined
            assertParamExists('testWorkflow', 'testWorkflowRequest', testWorkflowRequest)
            const localVarPath = `/workflows/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)

            // authentication UserContextAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "UserContextAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testWorkflowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to cancel a running workflow execution.
         * @summary Cancel Workflow Execution by ID
         * @param {string} id The workflow execution ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelWorkflowExecution(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelWorkflowExecution(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
         * @summary Execute Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {CreateExternalExecuteWorkflowRequest} [createExternalExecuteWorkflowRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createExternalExecuteWorkflow(id: string, createExternalExecuteWorkflowRequest?: CreateExternalExecuteWorkflowRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateExternalExecuteWorkflow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExternalExecuteWorkflow(id, createExternalExecuteWorkflowRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new workflow with the desired trigger and steps specified in the request body.
         * @summary Create Workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflow(createWorkflowRequest: CreateWorkflowRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflow(createWorkflowRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
         * @summary Generate External Trigger OAuth Client
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowExternalTrigger(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOAuthClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowExternalTrigger(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
         * @summary Delete Workflow By Id
         * @param {string} id Id of the Workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflow(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflow(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single workflow by id.
         * @summary Get Workflow By Id
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflow(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflow(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to get a single workflow execution. Workflow executions are available for up to 90 days before being archived. If you attempt to access a workflow execution that has been archived, you will receive a \"404 Not Found\" response.
         * @summary Get Workflow Execution
         * @param {string} id Workflow execution ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowExecution(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowExecution(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get Workflow Execution History
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowExecutionHistory(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowExecutionEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowExecutionHistory(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to list a specified workflow\'s executions. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions. To get executions past the first 250 records, you can do the following: 1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows. 2. Get your workflow ID from the response. 3. You can then do either of the following:    - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - Paginate through results with the `offset` parameter.   For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.   Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination.
         * @summary List Workflow Executions
         * @param {string} id Workflow ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **startTime**: *eq, lt, le, gt, ge*  **status**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowExecutions(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowExecution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowExecutions(id, limit, offset, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This lists all triggers, actions, and operators in the library
         * @summary List Complete Workflow Library
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCompleteWorkflowLibrary(limit?: number, offset?: number, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListCompleteWorkflowLibrary200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCompleteWorkflowLibrary(limit, offset, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This lists the workflow actions available to you.
         * @summary List Workflow Library Actions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowLibraryActions(limit?: number, offset?: number, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowLibraryAction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowLibraryActions(limit, offset, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This lists the workflow operators available to you
         * @summary List Workflow Library Operators
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowLibraryOperators(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowLibraryOperator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowLibraryOperators(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This lists the workflow triggers available to you
         * @summary List Workflow Library Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowLibraryTriggers(limit?: number, offset?: number, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowLibraryTrigger>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowLibraryTriggers(limit, offset, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all workflows in the tenant.
         * @summary List Workflows
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflows(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workflow>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflows(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
         * @summary Patch Workflow
         * @param {string} id Id of the Workflow
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchWorkflow(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchWorkflow(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform a full update of a workflow.  The updated workflow object is returned in the response.
         * @summary Update Workflow
         * @param {string} id Id of the Workflow
         * @param {WorkflowBody} workflowBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putWorkflow(id: string, workflowBody: WorkflowBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putWorkflow(id, workflowBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
         * @summary Test Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {TestExternalExecuteWorkflowRequest} [testExternalExecuteWorkflowRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async testExternalExecuteWorkflow(id: string, testExternalExecuteWorkflowRequest?: TestExternalExecuteWorkflowRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestExternalExecuteWorkflow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testExternalExecuteWorkflow(id, testExternalExecuteWorkflowRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
         * @summary Test Workflow By Id
         * @param {string} id Id of the workflow
         * @param {TestWorkflowRequest} testWorkflowRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async testWorkflow(id: string, testWorkflowRequest: TestWorkflowRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestWorkflow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testWorkflow(id, testWorkflowRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsApiFp(configuration)
    return {
        /**
         * Use this API to cancel a running workflow execution.
         * @summary Cancel Workflow Execution by ID
         * @param {string} id The workflow execution ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelWorkflowExecution(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.cancelWorkflowExecution(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
         * @summary Execute Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {CreateExternalExecuteWorkflowRequest} [createExternalExecuteWorkflowRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createExternalExecuteWorkflow(id: string, createExternalExecuteWorkflowRequest?: CreateExternalExecuteWorkflowRequest, axiosOptions?: any): AxiosPromise<CreateExternalExecuteWorkflow200Response> {
            return localVarFp.createExternalExecuteWorkflow(id, createExternalExecuteWorkflowRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Create a new workflow with the desired trigger and steps specified in the request body.
         * @summary Create Workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(createWorkflowRequest: CreateWorkflowRequest, axiosOptions?: any): AxiosPromise<Workflow> {
            return localVarFp.createWorkflow(createWorkflowRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
         * @summary Generate External Trigger OAuth Client
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowExternalTrigger(id: string, axiosOptions?: any): AxiosPromise<WorkflowOAuthClient> {
            return localVarFp.createWorkflowExternalTrigger(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
         * @summary Delete Workflow By Id
         * @param {string} id Id of the Workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkflow(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a single workflow by id.
         * @summary Get Workflow By Id
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(id: string, axiosOptions?: any): AxiosPromise<Workflow> {
            return localVarFp.getWorkflow(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to get a single workflow execution. Workflow executions are available for up to 90 days before being archived. If you attempt to access a workflow execution that has been archived, you will receive a \"404 Not Found\" response.
         * @summary Get Workflow Execution
         * @param {string} id Workflow execution ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecution(id: string, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.getWorkflowExecution(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get Workflow Execution History
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutionHistory(id: string, axiosOptions?: any): AxiosPromise<Array<WorkflowExecutionEvent>> {
            return localVarFp.getWorkflowExecutionHistory(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to list a specified workflow\'s executions. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions. To get executions past the first 250 records, you can do the following: 1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows. 2. Get your workflow ID from the response. 3. You can then do either of the following:    - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - Paginate through results with the `offset` parameter.   For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.   Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination.
         * @summary List Workflow Executions
         * @param {string} id Workflow ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **startTime**: *eq, lt, le, gt, ge*  **status**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutions(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<WorkflowExecution>> {
            return localVarFp.getWorkflowExecutions(id, limit, offset, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists all triggers, actions, and operators in the library
         * @summary List Complete Workflow Library
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompleteWorkflowLibrary(limit?: number, offset?: number, axiosOptions?: any): AxiosPromise<Array<ListCompleteWorkflowLibrary200ResponseInner>> {
            return localVarFp.listCompleteWorkflowLibrary(limit, offset, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists the workflow actions available to you.
         * @summary List Workflow Library Actions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryActions(limit?: number, offset?: number, filters?: string, axiosOptions?: any): AxiosPromise<Array<WorkflowLibraryAction>> {
            return localVarFp.listWorkflowLibraryActions(limit, offset, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists the workflow operators available to you
         * @summary List Workflow Library Operators
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryOperators(axiosOptions?: any): AxiosPromise<Array<WorkflowLibraryOperator>> {
            return localVarFp.listWorkflowLibraryOperators(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This lists the workflow triggers available to you
         * @summary List Workflow Library Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryTriggers(limit?: number, offset?: number, filters?: string, axiosOptions?: any): AxiosPromise<Array<WorkflowLibraryTrigger>> {
            return localVarFp.listWorkflowLibraryTriggers(limit, offset, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * List all workflows in the tenant.
         * @summary List Workflows
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(axiosOptions?: any): AxiosPromise<Array<Workflow>> {
            return localVarFp.listWorkflows(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
         * @summary Patch Workflow
         * @param {string} id Id of the Workflow
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkflow(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<Workflow> {
            return localVarFp.patchWorkflow(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Perform a full update of a workflow.  The updated workflow object is returned in the response.
         * @summary Update Workflow
         * @param {string} id Id of the Workflow
         * @param {WorkflowBody} workflowBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putWorkflow(id: string, workflowBody: WorkflowBody, axiosOptions?: any): AxiosPromise<Workflow> {
            return localVarFp.putWorkflow(id, workflowBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
         * @summary Test Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {TestExternalExecuteWorkflowRequest} [testExternalExecuteWorkflowRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testExternalExecuteWorkflow(id: string, testExternalExecuteWorkflowRequest?: TestExternalExecuteWorkflowRequest, axiosOptions?: any): AxiosPromise<TestExternalExecuteWorkflow200Response> {
            return localVarFp.testExternalExecuteWorkflow(id, testExternalExecuteWorkflowRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
         * @summary Test Workflow By Id
         * @param {string} id Id of the workflow
         * @param {TestWorkflowRequest} testWorkflowRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testWorkflow(id: string, testWorkflowRequest: TestWorkflowRequest, axiosOptions?: any): AxiosPromise<TestWorkflow200Response> {
            return localVarFp.testWorkflow(id, testWorkflowRequest, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelWorkflowExecution operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiCancelWorkflowExecutionRequest
 */
export interface WorkflowsApiCancelWorkflowExecutionRequest {
    /**
     * The workflow execution ID
     * @type {string}
     * @memberof WorkflowsApiCancelWorkflowExecution
     */
    readonly id: string
}

/**
 * Request parameters for createExternalExecuteWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiCreateExternalExecuteWorkflowRequest
 */
export interface WorkflowsApiCreateExternalExecuteWorkflowRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsApiCreateExternalExecuteWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {CreateExternalExecuteWorkflowRequest}
     * @memberof WorkflowsApiCreateExternalExecuteWorkflow
     */
    readonly createExternalExecuteWorkflowRequest?: CreateExternalExecuteWorkflowRequest
}

/**
 * Request parameters for createWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiCreateWorkflowRequest
 */
export interface WorkflowsApiCreateWorkflowRequest {
    /**
     * 
     * @type {CreateWorkflowRequest}
     * @memberof WorkflowsApiCreateWorkflow
     */
    readonly createWorkflowRequest: CreateWorkflowRequest
}

/**
 * Request parameters for createWorkflowExternalTrigger operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiCreateWorkflowExternalTriggerRequest
 */
export interface WorkflowsApiCreateWorkflowExternalTriggerRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsApiCreateWorkflowExternalTrigger
     */
    readonly id: string
}

/**
 * Request parameters for deleteWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiDeleteWorkflowRequest
 */
export interface WorkflowsApiDeleteWorkflowRequest {
    /**
     * Id of the Workflow
     * @type {string}
     * @memberof WorkflowsApiDeleteWorkflow
     */
    readonly id: string
}

/**
 * Request parameters for getWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiGetWorkflowRequest
 */
export interface WorkflowsApiGetWorkflowRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsApiGetWorkflow
     */
    readonly id: string
}

/**
 * Request parameters for getWorkflowExecution operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiGetWorkflowExecutionRequest
 */
export interface WorkflowsApiGetWorkflowExecutionRequest {
    /**
     * Workflow execution ID.
     * @type {string}
     * @memberof WorkflowsApiGetWorkflowExecution
     */
    readonly id: string
}

/**
 * Request parameters for getWorkflowExecutionHistory operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiGetWorkflowExecutionHistoryRequest
 */
export interface WorkflowsApiGetWorkflowExecutionHistoryRequest {
    /**
     * Id of the workflow execution
     * @type {string}
     * @memberof WorkflowsApiGetWorkflowExecutionHistory
     */
    readonly id: string
}

/**
 * Request parameters for getWorkflowExecutions operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiGetWorkflowExecutionsRequest
 */
export interface WorkflowsApiGetWorkflowExecutionsRequest {
    /**
     * Workflow ID.
     * @type {string}
     * @memberof WorkflowsApiGetWorkflowExecutions
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiGetWorkflowExecutions
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiGetWorkflowExecutions
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkflowsApiGetWorkflowExecutions
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **startTime**: *eq, lt, le, gt, ge*  **status**: *eq*
     * @type {string}
     * @memberof WorkflowsApiGetWorkflowExecutions
     */
    readonly filters?: string
}

/**
 * Request parameters for listCompleteWorkflowLibrary operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiListCompleteWorkflowLibraryRequest
 */
export interface WorkflowsApiListCompleteWorkflowLibraryRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiListCompleteWorkflowLibrary
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiListCompleteWorkflowLibrary
     */
    readonly offset?: number
}

/**
 * Request parameters for listWorkflowLibraryActions operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiListWorkflowLibraryActionsRequest
 */
export interface WorkflowsApiListWorkflowLibraryActionsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiListWorkflowLibraryActions
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiListWorkflowLibraryActions
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
     * @type {string}
     * @memberof WorkflowsApiListWorkflowLibraryActions
     */
    readonly filters?: string
}

/**
 * Request parameters for listWorkflowLibraryTriggers operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiListWorkflowLibraryTriggersRequest
 */
export interface WorkflowsApiListWorkflowLibraryTriggersRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiListWorkflowLibraryTriggers
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkflowsApiListWorkflowLibraryTriggers
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
     * @type {string}
     * @memberof WorkflowsApiListWorkflowLibraryTriggers
     */
    readonly filters?: string
}

/**
 * Request parameters for patchWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiPatchWorkflowRequest
 */
export interface WorkflowsApiPatchWorkflowRequest {
    /**
     * Id of the Workflow
     * @type {string}
     * @memberof WorkflowsApiPatchWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperation>}
     * @memberof WorkflowsApiPatchWorkflow
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for putWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiPutWorkflowRequest
 */
export interface WorkflowsApiPutWorkflowRequest {
    /**
     * Id of the Workflow
     * @type {string}
     * @memberof WorkflowsApiPutWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {WorkflowBody}
     * @memberof WorkflowsApiPutWorkflow
     */
    readonly workflowBody: WorkflowBody
}

/**
 * Request parameters for testExternalExecuteWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiTestExternalExecuteWorkflowRequest
 */
export interface WorkflowsApiTestExternalExecuteWorkflowRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsApiTestExternalExecuteWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {TestExternalExecuteWorkflowRequest}
     * @memberof WorkflowsApiTestExternalExecuteWorkflow
     */
    readonly testExternalExecuteWorkflowRequest?: TestExternalExecuteWorkflowRequest
}

/**
 * Request parameters for testWorkflow operation in WorkflowsApi.
 * @export
 * @interface WorkflowsApiTestWorkflowRequest
 */
export interface WorkflowsApiTestWorkflowRequest {
    /**
     * Id of the workflow
     * @type {string}
     * @memberof WorkflowsApiTestWorkflow
     */
    readonly id: string

    /**
     * 
     * @type {TestWorkflowRequest}
     * @memberof WorkflowsApiTestWorkflow
     */
    readonly testWorkflowRequest: TestWorkflowRequest
}

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * Use this API to cancel a running workflow execution.
     * @summary Cancel Workflow Execution by ID
     * @param {WorkflowsApiCancelWorkflowExecutionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public cancelWorkflowExecution(requestParameters: WorkflowsApiCancelWorkflowExecutionRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).cancelWorkflowExecution(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
     * @summary Execute Workflow via External Trigger
     * @param {WorkflowsApiCreateExternalExecuteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createExternalExecuteWorkflow(requestParameters: WorkflowsApiCreateExternalExecuteWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createExternalExecuteWorkflow(requestParameters.id, requestParameters.createExternalExecuteWorkflowRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new workflow with the desired trigger and steps specified in the request body.
     * @summary Create Workflow
     * @param {WorkflowsApiCreateWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflow(requestParameters: WorkflowsApiCreateWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createWorkflow(requestParameters.createWorkflowRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
     * @summary Generate External Trigger OAuth Client
     * @param {WorkflowsApiCreateWorkflowExternalTriggerRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflowExternalTrigger(requestParameters: WorkflowsApiCreateWorkflowExternalTriggerRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createWorkflowExternalTrigger(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
     * @summary Delete Workflow By Id
     * @param {WorkflowsApiDeleteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public deleteWorkflow(requestParameters: WorkflowsApiDeleteWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).deleteWorkflow(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single workflow by id.
     * @summary Get Workflow By Id
     * @param {WorkflowsApiGetWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflow(requestParameters: WorkflowsApiGetWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflow(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to get a single workflow execution. Workflow executions are available for up to 90 days before being archived. If you attempt to access a workflow execution that has been archived, you will receive a \"404 Not Found\" response.
     * @summary Get Workflow Execution
     * @param {WorkflowsApiGetWorkflowExecutionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflowExecution(requestParameters: WorkflowsApiGetWorkflowExecutionRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflowExecution(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
     * @summary Get Workflow Execution History
     * @param {WorkflowsApiGetWorkflowExecutionHistoryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflowExecutionHistory(requestParameters: WorkflowsApiGetWorkflowExecutionHistoryRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflowExecutionHistory(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to list a specified workflow\'s executions. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions. To get executions past the first 250 records, you can do the following: 1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows. 2. Get your workflow ID from the response. 3. You can then do either of the following:    - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - Paginate through results with the `offset` parameter.   For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.   Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination.
     * @summary List Workflow Executions
     * @param {WorkflowsApiGetWorkflowExecutionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflowExecutions(requestParameters: WorkflowsApiGetWorkflowExecutionsRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflowExecutions(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists all triggers, actions, and operators in the library
     * @summary List Complete Workflow Library
     * @param {WorkflowsApiListCompleteWorkflowLibraryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public listCompleteWorkflowLibrary(requestParameters: WorkflowsApiListCompleteWorkflowLibraryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).listCompleteWorkflowLibrary(requestParameters.limit, requestParameters.offset, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists the workflow actions available to you.
     * @summary List Workflow Library Actions
     * @param {WorkflowsApiListWorkflowLibraryActionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public listWorkflowLibraryActions(requestParameters: WorkflowsApiListWorkflowLibraryActionsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).listWorkflowLibraryActions(requestParameters.limit, requestParameters.offset, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists the workflow operators available to you
     * @summary List Workflow Library Operators
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public listWorkflowLibraryOperators(axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).listWorkflowLibraryOperators(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This lists the workflow triggers available to you
     * @summary List Workflow Library Triggers
     * @param {WorkflowsApiListWorkflowLibraryTriggersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public listWorkflowLibraryTriggers(requestParameters: WorkflowsApiListWorkflowLibraryTriggersRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).listWorkflowLibraryTriggers(requestParameters.limit, requestParameters.offset, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all workflows in the tenant.
     * @summary List Workflows
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public listWorkflows(axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).listWorkflows(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
     * @summary Patch Workflow
     * @param {WorkflowsApiPatchWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public patchWorkflow(requestParameters: WorkflowsApiPatchWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).patchWorkflow(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a full update of a workflow.  The updated workflow object is returned in the response.
     * @summary Update Workflow
     * @param {WorkflowsApiPutWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public putWorkflow(requestParameters: WorkflowsApiPutWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).putWorkflow(requestParameters.id, requestParameters.workflowBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
     * @summary Test Workflow via External Trigger
     * @param {WorkflowsApiTestExternalExecuteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public testExternalExecuteWorkflow(requestParameters: WorkflowsApiTestExternalExecuteWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).testExternalExecuteWorkflow(requestParameters.id, requestParameters.testExternalExecuteWorkflowRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
     * @summary Test Workflow By Id
     * @param {WorkflowsApiTestWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public testWorkflow(requestParameters: WorkflowsApiTestWorkflowRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).testWorkflow(requestParameters.id, requestParameters.testWorkflowRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


