/* tslint:disable */
/* eslint-disable */
/**
 * IdentityNow V3 API
 * Use these APIs to interact with the IdentityNow platform to achieve repeatable, automated processes with greater scalability. We encourage you to join the SailPoint Developer Community forum at https://developer.sailpoint.com/discuss to connect with other developers using our APIs.
 *
 * The version of the OpenAPI document: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof Access
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof Access
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof Access
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AccessAllOf
 */
export interface AccessAllOf {
    /**
     * 
     * @type {DtoType}
     * @memberof AccessAllOf
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessAllOf
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AccessConstraint
 */
export interface AccessConstraint {
    /**
     * Type of Access
     * @type {string}
     * @memberof AccessConstraint
     */
    'type': AccessConstraintTypeEnum;
    /**
     * Must be set only if operator is SELECTED.
     * @type {Array<string>}
     * @memberof AccessConstraint
     */
    'ids'?: Array<string>;
    /**
     * Used to determine whether the scope of the campaign should be reduced for selected ids or all.
     * @type {string}
     * @memberof AccessConstraint
     */
    'operator': AccessConstraintOperatorEnum;
}

export const AccessConstraintTypeEnum = {
    Entitlement: 'ENTITLEMENT',
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE'
} as const;

export type AccessConstraintTypeEnum = typeof AccessConstraintTypeEnum[keyof typeof AccessConstraintTypeEnum];
export const AccessConstraintOperatorEnum = {
    All: 'ALL',
    Selected: 'SELECTED'
} as const;

export type AccessConstraintOperatorEnum = typeof AccessConstraintOperatorEnum[keyof typeof AccessConstraintOperatorEnum];

/**
 * 
 * @export
 * @interface AccessCriteria
 */
export interface AccessCriteria {
    /**
     * Business name for the access construct list
     * @type {string}
     * @memberof AccessCriteria
     */
    'name'?: string;
    /**
     * List of criteria. There is a min of 1 and max of 50 items in the list.
     * @type {Array<AccessCriteriaCriteriaListInner>}
     * @memberof AccessCriteria
     */
    'criteriaList'?: Array<AccessCriteriaCriteriaListInner>;
}
/**
 * 
 * @export
 * @interface AccessCriteriaCriteriaListInner
 */
export interface AccessCriteriaCriteriaListInner {
    /**
     * Type of the propery to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInner
     */
    'type'?: AccessCriteriaCriteriaListInnerTypeEnum;
    /**
     * ID of the object to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies to
     * @type {string}
     * @memberof AccessCriteriaCriteriaListInner
     */
    'name'?: string;
}

export const AccessCriteriaCriteriaListInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessCriteriaCriteriaListInnerTypeEnum = typeof AccessCriteriaCriteriaListInnerTypeEnum[keyof typeof AccessCriteriaCriteriaListInnerTypeEnum];

/**
 * 
 * @export
 * @interface AccessProfile
 */
export interface AccessProfile {
    /**
     * The ID of the Access Profile
     * @type {string}
     * @memberof AccessProfile
     */
    'id'?: string;
    /**
     * Name of the Access Profile
     * @type {string}
     * @memberof AccessProfile
     */
    'name': string;
    /**
     * Information about the Access Profile
     * @type {string}
     * @memberof AccessProfile
     */
    'description'?: string | null;
    /**
     * Date the Access Profile was created
     * @type {string}
     * @memberof AccessProfile
     */
    'created'?: string;
    /**
     * Date the Access Profile was last modified.
     * @type {string}
     * @memberof AccessProfile
     */
    'modified'?: string;
    /**
     * Whether the Access Profile is enabled. If the Access Profile is enabled then you must include at least one Entitlement.
     * @type {boolean}
     * @memberof AccessProfile
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {OwnerReference}
     * @memberof AccessProfile
     */
    'owner': OwnerReference | null;
    /**
     * 
     * @type {AccessProfileSourceRef}
     * @memberof AccessProfile
     */
    'source': AccessProfileSourceRef;
    /**
     * A list of entitlements associated with the Access Profile. If enabled is false this is allowed to be empty otherwise it needs to contain at least one Entitlement.
     * @type {Array<EntitlementRef>}
     * @memberof AccessProfile
     */
    'entitlements'?: Array<EntitlementRef>;
    /**
     * Whether the Access Profile is requestable via access request. Currently, making an Access Profile non-requestable is only supported  for customers enabled with the new Request Center. Otherwise, attempting to create an Access Profile with a value  **false** in this field results in a 400 error.
     * @type {boolean}
     * @memberof AccessProfile
     */
    'requestable'?: boolean;
    /**
     * 
     * @type {Requestability}
     * @memberof AccessProfile
     */
    'accessRequestConfig'?: Requestability;
    /**
     * 
     * @type {Revocability}
     * @memberof AccessProfile
     */
    'revocationRequestConfig'?: Revocability;
    /**
     * List of IDs of segments, if any, to which this Access Profile is assigned.
     * @type {Array<string>}
     * @memberof AccessProfile
     */
    'segments'?: Array<string> | null;
    /**
     * 
     * @type {ProvisioningCriteriaLevel1}
     * @memberof AccessProfile
     */
    'provisioningCriteria'?: ProvisioningCriteriaLevel1 | null;
}
/**
 * 
 * @export
 * @interface AccessProfileApprovalScheme
 */
export interface AccessProfileApprovalScheme {
    /**
     * Describes the individual or group that is responsible for an approval step. Values are as follows. **APP_OWNER**: The owner of the Application  **OWNER**: Owner of the associated Access Profile or Role  **SOURCE_OWNER**: Owner of the Source associated with an Access Profile  **MANAGER**: Manager of the Identity making the request  **GOVERNANCE_GROUP**: A Governance Group, the ID of which is specified by the **approverId** field
     * @type {string}
     * @memberof AccessProfileApprovalScheme
     */
    'approverType'?: AccessProfileApprovalSchemeApproverTypeEnum;
    /**
     * Id of the specific approver, used only when approverType is GOVERNANCE_GROUP
     * @type {string}
     * @memberof AccessProfileApprovalScheme
     */
    'approverId'?: string | null;
}

export const AccessProfileApprovalSchemeApproverTypeEnum = {
    AppOwner: 'APP_OWNER',
    Owner: 'OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type AccessProfileApprovalSchemeApproverTypeEnum = typeof AccessProfileApprovalSchemeApproverTypeEnum[keyof typeof AccessProfileApprovalSchemeApproverTypeEnum];

/**
 * 
 * @export
 * @interface AccessProfileBulkDeleteRequest
 */
export interface AccessProfileBulkDeleteRequest {
    /**
     * List of IDs of Access Profiles to be deleted.
     * @type {Array<string>}
     * @memberof AccessProfileBulkDeleteRequest
     */
    'accessProfileIds'?: Array<string>;
    /**
     * If **true**, silently skip over any of the specified Access Profiles if they cannot be deleted because they are in use. If **false**, no deletions will be attempted if any of the Access Profiles are in use.
     * @type {boolean}
     * @memberof AccessProfileBulkDeleteRequest
     */
    'bestEffortOnly'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileBulkDeleteResponse
 */
export interface AccessProfileBulkDeleteResponse {
    /**
     * ID of the task which is executing the bulk deletion. This can be passed to the **_/task-status** API to track status.
     * @type {string}
     * @memberof AccessProfileBulkDeleteResponse
     */
    'taskId'?: string;
    /**
     * List of IDs of Access Profiles which are pending deletion.
     * @type {Array<string>}
     * @memberof AccessProfileBulkDeleteResponse
     */
    'pending'?: Array<string>;
    /**
     * List of usages of Access Profiles targeted for deletion.
     * @type {Array<AccessProfileUsage>}
     * @memberof AccessProfileBulkDeleteResponse
     */
    'inUse'?: Array<AccessProfileUsage>;
}
/**
 * This is more of a complete representation of an access profile.  
 * @export
 * @interface AccessProfileDocument
 */
export interface AccessProfileDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccessProfileDocument
     */
    '_type': DocumentType;
    /**
     * The description of the access item
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'description'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'synced'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'enabled'?: boolean;
    /**
     * Indicates if the access can be requested
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'requestable'?: boolean;
    /**
     * Indicates if comments are required when requesting access
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {Owner}
     * @memberof AccessProfileDocument
     */
    'owner'?: Owner;
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileDocument
     */
    'source'?: Reference1;
    /**
     * 
     * @type {Array<BaseEntitlement>}
     * @memberof AccessProfileDocument
     */
    'entitlements'?: Array<BaseEntitlement>;
    /**
     * 
     * @type {number}
     * @memberof AccessProfileDocument
     */
    'entitlementCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccessProfileDocument
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AccessProfileDocumentAllOf
 */
export interface AccessProfileDocumentAllOf {
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileDocumentAllOf
     */
    'source'?: Reference1;
    /**
     * 
     * @type {Array<BaseEntitlement>}
     * @memberof AccessProfileDocumentAllOf
     */
    'entitlements'?: Array<BaseEntitlement>;
    /**
     * 
     * @type {number}
     * @memberof AccessProfileDocumentAllOf
     */
    'entitlementCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccessProfileDocumentAllOf
     */
    'tags'?: Array<string>;
}
/**
 * EntitlementReference
 * @export
 * @interface AccessProfileEntitlement
 */
export interface AccessProfileEntitlement {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof AccessProfileEntitlement
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileEntitlement
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileEntitlement
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'attribute'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileEntitlement
     */
    'standalone'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileRef
 */
export interface AccessProfileRef {
    /**
     * ID of the Access Profile
     * @type {string}
     * @memberof AccessProfileRef
     */
    'id'?: string;
    /**
     * Type of requested object. This field must be either left null or set to \'ACCESS_PROFILE\' when creating an Access Profile, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof AccessProfileRef
     */
    'type'?: AccessProfileRefTypeEnum;
    /**
     * Human-readable display name of the Access Profile. This field is ignored on input.
     * @type {string}
     * @memberof AccessProfileRef
     */
    'name'?: string;
}

export const AccessProfileRefTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE'
} as const;

export type AccessProfileRefTypeEnum = typeof AccessProfileRefTypeEnum[keyof typeof AccessProfileRefTypeEnum];

/**
 * Role
 * @export
 * @interface AccessProfileRole
 */
export interface AccessProfileRole {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileRole
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileRole
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileRole
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof AccessProfileRole
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileRole
     */
    'description'?: string | null;
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccessProfileRole
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileRole
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileRole
     */
    'revocable'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileSourceRef
 */
export interface AccessProfileSourceRef {
    /**
     * The ID of the Source with with which the Access Profile is associated
     * @type {string}
     * @memberof AccessProfileSourceRef
     */
    'id'?: string;
    /**
     * The type of the Source, will always be SOURCE
     * @type {string}
     * @memberof AccessProfileSourceRef
     */
    'type'?: AccessProfileSourceRefTypeEnum;
    /**
     * The display name of the associated Source
     * @type {string}
     * @memberof AccessProfileSourceRef
     */
    'name'?: string;
}

export const AccessProfileSourceRefTypeEnum = {
    Source: 'SOURCE'
} as const;

export type AccessProfileSourceRefTypeEnum = typeof AccessProfileSourceRefTypeEnum[keyof typeof AccessProfileSourceRefTypeEnum];

/**
 * This is a summary representation of an access profile.
 * @export
 * @interface AccessProfileSummary
 */
export interface AccessProfileSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof AccessProfileSummary
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileSummary
     */
    'source'?: Reference1;
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccessProfileSummary
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileSummary
     */
    'revocable'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileSummaryAllOf
 */
export interface AccessProfileSummaryAllOf {
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileSummaryAllOf
     */
    'source'?: Reference1;
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccessProfileSummaryAllOf
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileSummaryAllOf
     */
    'revocable'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileUsage
 */
export interface AccessProfileUsage {
    /**
     * ID of the Access Profile that is in use
     * @type {string}
     * @memberof AccessProfileUsage
     */
    'accessProfileId'?: string;
    /**
     * List of references to objects which are using the indicated Access Profile
     * @type {Array<BaseReferenceDto>}
     * @memberof AccessProfileUsage
     */
    'usedBy'?: Array<BaseReferenceDto>;
}
/**
 * 
 * @export
 * @interface AccessRequest
 */
export interface AccessRequest {
    /**
     * A list of Identity IDs for whom the Access is requested. If it\'s a Revoke request, there can only be one Identity ID.
     * @type {Array<string>}
     * @memberof AccessRequest
     */
    'requestedFor': Array<string>;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof AccessRequest
     */
    'requestType'?: AccessRequestType;
    /**
     * 
     * @type {Array<AccessRequestItem>}
     * @memberof AccessRequest
     */
    'requestedItems': Array<AccessRequestItem>;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on associated APIs such as /account-activities.
     * @type {{ [key: string]: string; }}
     * @memberof AccessRequest
     */
    'clientMetadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface AccessRequestConfig
 */
export interface AccessRequestConfig {
    /**
     * If true, then approvals must be processed by external system.
     * @type {boolean}
     * @memberof AccessRequestConfig
     */
    'approvalsMustBeExternal'?: boolean;
    /**
     * If true and requester and reviewer are the same, then automatically approve the approval.
     * @type {boolean}
     * @memberof AccessRequestConfig
     */
    'autoApprovalEnabled'?: boolean;
    /**
     * 
     * @type {RequestOnBehalfOfConfig}
     * @memberof AccessRequestConfig
     */
    'requestOnBehalfOfConfig'?: RequestOnBehalfOfConfig;
    /**
     * 
     * @type {ApprovalReminderAndEscalationConfig}
     * @memberof AccessRequestConfig
     */
    'approvalReminderAndEscalationConfig'?: ApprovalReminderAndEscalationConfig;
    /**
     * 
     * @type {EntitlementRequestConfig}
     * @memberof AccessRequestConfig
     */
    'entitlementRequestConfig'?: EntitlementRequestConfig;
}
/**
 * 
 * @export
 * @interface AccessRequestItem
 */
export interface AccessRequestItem {
    /**
     * The type of the item being requested.
     * @type {string}
     * @memberof AccessRequestItem
     */
    'type': AccessRequestItemTypeEnum;
    /**
     * ID of Role, Access Profile or Entitlement being requested.
     * @type {string}
     * @memberof AccessRequestItem
     */
    'id': string;
    /**
     * Comment provided by requester. * Comment is required when the request is of type Revoke Access. 
     * @type {string}
     * @memberof AccessRequestItem
     */
    'comment'?: string;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on associated APIs such as /account-activities and /access-request-status.
     * @type {{ [key: string]: string; }}
     * @memberof AccessRequestItem
     */
    'clientMetadata'?: { [key: string]: string; };
    /**
     * The date the role or access profile is no longer assigned to the specified identity. * Specify a date in the future. * The current SLA for the deprovisioning is 24 hours. * This date can be modified to either extend or decrease the duration of access item assignments for the specified identity. * Currently it is not supported for entitlements. 
     * @type {string}
     * @memberof AccessRequestItem
     */
    'removeDate'?: string;
}

export const AccessRequestItemTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessRequestItemTypeEnum = typeof AccessRequestItemTypeEnum[keyof typeof AccessRequestItemTypeEnum];

/**
 * Provides additional details about this access request phase.
 * @export
 * @interface AccessRequestPhases
 */
export interface AccessRequestPhases {
    /**
     * The time that this phase started.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'started'?: string;
    /**
     * The time that this phase finished.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'finished'?: string;
    /**
     * The name of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'name'?: string;
    /**
     * The state of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'state'?: AccessRequestPhasesStateEnum;
    /**
     * The state of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'result'?: AccessRequestPhasesResultEnum;
    /**
     * A reference to another object on the RequestedItemStatus that contains more details about the phase. Note that for the Provisioning phase, this will be empty if there are no manual work items.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'phaseReference'?: string;
}

export const AccessRequestPhasesStateEnum = {
    Pending: 'PENDING',
    Executing: 'EXECUTING',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type AccessRequestPhasesStateEnum = typeof AccessRequestPhasesStateEnum[keyof typeof AccessRequestPhasesStateEnum];
export const AccessRequestPhasesResultEnum = {
    Successful: 'SUCCESSFUL',
    Failed: 'FAILED'
} as const;

export type AccessRequestPhasesResultEnum = typeof AccessRequestPhasesResultEnum[keyof typeof AccessRequestPhasesResultEnum];

/**
 * Access request type. Defaults to GRANT_ACCESS. REVOKE_ACCESS type can only have a single Identity ID in the requestedFor field.
 * @export
 * @enum {string}
 */

export const AccessRequestType = {
    GrantAccess: 'GRANT_ACCESS',
    RevokeAccess: 'REVOKE_ACCESS'
} as const;

export type AccessRequestType = typeof AccessRequestType[keyof typeof AccessRequestType];


/**
 * 
 * @export
 * @interface AccessReviewItem
 */
export interface AccessReviewItem {
    /**
     * 
     * @type {AccessSummary}
     * @memberof AccessReviewItem
     */
    'accessSummary'?: AccessSummary;
    /**
     * 
     * @type {CertificationIdentitySummary}
     * @memberof AccessReviewItem
     */
    'identitySummary'?: CertificationIdentitySummary;
    /**
     * The review item\'s id
     * @type {string}
     * @memberof AccessReviewItem
     */
    'id'?: string;
    /**
     * Whether the review item is complete
     * @type {boolean}
     * @memberof AccessReviewItem
     */
    'completed'?: boolean;
    /**
     * Indicates whether the review item is for new access to a source
     * @type {boolean}
     * @memberof AccessReviewItem
     */
    'newAccess'?: boolean;
    /**
     * 
     * @type {CertificationDecision}
     * @memberof AccessReviewItem
     */
    'decision'?: CertificationDecision;
    /**
     * Comments for this review item
     * @type {string}
     * @memberof AccessReviewItem
     */
    'comments'?: string | null;
}
/**
 * 
 * @export
 * @interface AccessReviewReassignment
 */
export interface AccessReviewReassignment {
    /**
     * 
     * @type {Array<ReassignReference>}
     * @memberof AccessReviewReassignment
     */
    'reassign': Array<ReassignReference>;
    /**
     * The ID of the identity to which the certification is reassigned
     * @type {string}
     * @memberof AccessReviewReassignment
     */
    'reassignTo': string;
    /**
     * The reason comment for why the reassign was made
     * @type {string}
     * @memberof AccessReviewReassignment
     */
    'reason': string;
}
/**
 * An object holding the access that is being reviewed
 * @export
 * @interface AccessSummary
 */
export interface AccessSummary {
    /**
     * 
     * @type {AccessSummaryAccess}
     * @memberof AccessSummary
     */
    'access'?: AccessSummaryAccess;
    /**
     * 
     * @type {ReviewableEntitlement}
     * @memberof AccessSummary
     */
    'entitlement'?: ReviewableEntitlement | null;
    /**
     * 
     * @type {ReviewableAccessProfile}
     * @memberof AccessSummary
     */
    'accessProfile'?: ReviewableAccessProfile;
    /**
     * 
     * @type {ReviewableRole}
     * @memberof AccessSummary
     */
    'role'?: ReviewableRole | null;
}
/**
 * 
 * @export
 * @interface AccessSummaryAccess
 */
export interface AccessSummaryAccess {
    /**
     * 
     * @type {DtoType}
     * @memberof AccessSummaryAccess
     */
    'type'?: DtoType;
    /**
     * The ID of the item being certified
     * @type {string}
     * @memberof AccessSummaryAccess
     */
    'id'?: string;
    /**
     * The name of the item being certified
     * @type {string}
     * @memberof AccessSummaryAccess
     */
    'name'?: string;
}
/**
 * Access type of API Client indicating online or offline use
 * @export
 * @enum {string}
 */

export const AccessType = {
    Online: 'ONLINE',
    Offline: 'OFFLINE'
} as const;

export type AccessType = typeof AccessType[keyof typeof AccessType];


/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof Account
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof Account
     */
    'modified'?: string;
    /**
     * The unique ID of the source this account belongs to
     * @type {string}
     * @memberof Account
     */
    'sourceId': string;
    /**
     * The display name of the source this account belongs to
     * @type {string}
     * @memberof Account
     */
    'sourceName': string;
    /**
     * The unique ID of the identity this account is correlated to
     * @type {string}
     * @memberof Account
     */
    'identityId'?: string;
    /**
     * The account attributes that are aggregated
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    'attributes': { [key: string]: any; };
    /**
     * Indicates if this account is from an authoritative source
     * @type {boolean}
     * @memberof Account
     */
    'authoritative': boolean;
    /**
     * A description of the account
     * @type {string}
     * @memberof Account
     */
    'description'?: string | null;
    /**
     * Indicates if the account is currently disabled
     * @type {boolean}
     * @memberof Account
     */
    'disabled': boolean;
    /**
     * Indicates if the account is currently locked
     * @type {boolean}
     * @memberof Account
     */
    'locked': boolean;
    /**
     * The unique ID of the account generated by the source system
     * @type {string}
     * @memberof Account
     */
    'nativeIdentity': string;
    /**
     * If true, this is a user account within IdentityNow.  If false, this is an account from a source system.
     * @type {boolean}
     * @memberof Account
     */
    'systemAccount': boolean;
    /**
     * Indicates if this account is not correlated to an identity
     * @type {boolean}
     * @memberof Account
     */
    'uncorrelated': boolean;
    /**
     * The unique ID of the account as determined by the account schema
     * @type {string}
     * @memberof Account
     */
    'uuid'?: string | null;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof Account
     */
    'manuallyCorrelated': boolean;
    /**
     * Indicates if the account has entitlements
     * @type {boolean}
     * @memberof Account
     */
    'hasEntitlements': boolean;
}
/**
 * Object for specifying Actions to be performed on a specified list of sources\' account.
 * @export
 * @interface AccountAction
 */
export interface AccountAction {
    /**
     * Describes if action will be enabled or disabled
     * @type {string}
     * @memberof AccountAction
     */
    'action'?: AccountActionActionEnum;
    /**
     * List of unique source IDs. The sources must have the ENABLE feature or flat file source. See \"/sources\" endpoint for source features.
     * @type {Set<string>}
     * @memberof AccountAction
     */
    'sourceIds'?: Set<string>;
}

export const AccountActionActionEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type AccountActionActionEnum = typeof AccountActionActionEnum[keyof typeof AccountActionActionEnum];

/**
 * 
 * @export
 * @interface AccountActivity
 */
export interface AccountActivity {
    /**
     * Id of the account activity
     * @type {string}
     * @memberof AccountActivity
     */
    'id'?: string;
    /**
     * The name of the activity
     * @type {string}
     * @memberof AccountActivity
     */
    'name'?: string;
    /**
     * When the activity was first created
     * @type {string}
     * @memberof AccountActivity
     */
    'created'?: string;
    /**
     * When the activity was last modified
     * @type {string}
     * @memberof AccountActivity
     */
    'modified'?: string | null;
    /**
     * When the activity was completed
     * @type {string}
     * @memberof AccountActivity
     */
    'completed'?: string | null;
    /**
     * 
     * @type {CompletionStatus}
     * @memberof AccountActivity
     */
    'completionStatus'?: CompletionStatus | null;
    /**
     * The type of action the activity performed.  Please see the following list of types.  This list may grow over time.  - CloudAutomated - IdentityAttributeUpdate - appRequest - LifecycleStateChange - AccountStateUpdate - AccountAttributeUpdate - CloudPasswordRequest - Attribute Synchronization Refresh - Certification - Identity Refresh - Lifecycle Change Refresh   [Learn more here](https://documentation.sailpoint.com/saas/help/search/searchable-fields.html#searching-account-activity-data). 
     * @type {string}
     * @memberof AccountActivity
     */
    'type'?: string | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivity
     */
    'requesterIdentitySummary'?: IdentitySummary | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivity
     */
    'targetIdentitySummary'?: IdentitySummary | null;
    /**
     * A list of error messages, if any, that were encountered.
     * @type {Array<string>}
     * @memberof AccountActivity
     */
    'errors'?: Array<string> | null;
    /**
     * A list of warning messages, if any, that were encountered.
     * @type {Array<string>}
     * @memberof AccountActivity
     */
    'warnings'?: Array<string> | null;
    /**
     * Individual actions performed as part of this account activity
     * @type {Array<AccountActivityItem>}
     * @memberof AccountActivity
     */
    'items'?: Array<AccountActivityItem>;
    /**
     * 
     * @type {ExecutionStatus}
     * @memberof AccountActivity
     */
    'executionStatus'?: ExecutionStatus;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request
     * @type {{ [key: string]: string; }}
     * @memberof AccountActivity
     */
    'clientMetadata'?: { [key: string]: string; } | null;
}
/**
 * AccountActivity
 * @export
 * @interface AccountActivityDocument
 */
export interface AccountActivityDocument {
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccountActivityDocument
     */
    '_type': DocumentType;
    /**
     * The type of action that this activity performed
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'action'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'modified'?: string | null;
    /**
     * The current stage of the activity
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'stage'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'origin'?: string | null;
    /**
     * the current status of the activity
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'status'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivityDocument
     */
    'requester'?: AccountSource;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivityDocument
     */
    'recipient'?: AccountSource;
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivityDocument
     */
    'errors'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivityDocument
     */
    'warnings'?: Array<string> | null;
    /**
     * 
     * @type {Array<Approval>}
     * @memberof AccountActivityDocument
     */
    'approvals'?: Array<Approval>;
    /**
     * 
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivityDocument
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * 
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivityDocument
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * 
     * @type {Array<AccountRequest>}
     * @memberof AccountActivityDocument
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'sources'?: string;
}
/**
 * 
 * @export
 * @interface AccountActivityItem
 */
export interface AccountActivityItem {
    /**
     * Item id
     * @type {string}
     * @memberof AccountActivityItem
     */
    'id'?: string;
    /**
     * Human-readable display name of item
     * @type {string}
     * @memberof AccountActivityItem
     */
    'name'?: string;
    /**
     * Date and time item was requested
     * @type {string}
     * @memberof AccountActivityItem
     */
    'requested'?: string;
    /**
     * 
     * @type {WorkItemState}
     * @memberof AccountActivityItem
     */
    'approvalStatus'?: WorkItemState;
    /**
     * 
     * @type {ProvisioningState}
     * @memberof AccountActivityItem
     */
    'provisioningStatus'?: ProvisioningState;
    /**
     * 
     * @type {Comment}
     * @memberof AccountActivityItem
     */
    'requesterComment'?: Comment | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivityItem
     */
    'reviewerIdentitySummary'?: IdentitySummary | null;
    /**
     * 
     * @type {Comment}
     * @memberof AccountActivityItem
     */
    'reviewerComment'?: Comment | null;
    /**
     * 
     * @type {AccountActivityItemOperation}
     * @memberof AccountActivityItem
     */
    'operation'?: AccountActivityItemOperation;
    /**
     * Attribute to which account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'attribute'?: string | null;
    /**
     * Value of attribute
     * @type {string}
     * @memberof AccountActivityItem
     */
    'value'?: string | null;
    /**
     * Native identity in the target system to which the account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'nativeIdentity'?: string | null;
    /**
     * Id of Source to which account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'sourceId'?: string;
    /**
     * 
     * @type {AccountRequestInfo}
     * @memberof AccountActivityItem
     */
    'accountRequestInfo'?: AccountRequestInfo | null;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request item
     * @type {{ [key: string]: string; }}
     * @memberof AccountActivityItem
     */
    'clientMetadata'?: { [key: string]: string; } | null;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof AccountActivityItem
     */
    'removeDate'?: string | null;
}
/**
 * Represents an operation in an account activity item
 * @export
 * @enum {string}
 */

export const AccountActivityItemOperation = {
    Add: 'ADD',
    Create: 'CREATE',
    Modify: 'MODIFY',
    Delete: 'DELETE',
    Disable: 'DISABLE',
    Enable: 'ENABLE',
    Unlock: 'UNLOCK',
    Lock: 'LOCK',
    Remove: 'REMOVE'
} as const;

export type AccountActivityItemOperation = typeof AccountActivityItemOperation[keyof typeof AccountActivityItemOperation];


/**
 * AccountActivity
 * @export
 * @interface AccountActivitySearchedItem
 */
export interface AccountActivitySearchedItem {
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccountActivitySearchedItem
     */
    '_type': DocumentType;
    /**
     * The type of action that this activity performed
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'action'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'modified'?: string | null;
    /**
     * The current stage of the activity
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'stage'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'origin'?: string | null;
    /**
     * the current status of the activity
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'status'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItem
     */
    'requester'?: AccountSource;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItem
     */
    'recipient'?: AccountSource;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItem
     */
    'errors'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItem
     */
    'warnings'?: Array<string> | null;
    /**
     * 
     * @type {Array<Approval>}
     * @memberof AccountActivitySearchedItem
     */
    'approvals'?: Array<Approval>;
    /**
     * 
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivitySearchedItem
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * 
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivitySearchedItem
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * 
     * @type {Array<AccountRequest>}
     * @memberof AccountActivitySearchedItem
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'sources'?: string;
}
/**
 * 
 * @export
 * @interface AccountActivitySearchedItemAllOf
 */
export interface AccountActivitySearchedItemAllOf {
    /**
     * The type of action that this activity performed
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'action'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'modified'?: string | null;
    /**
     * The current stage of the activity
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'stage'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'origin'?: string | null;
    /**
     * the current status of the activity
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'status'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'requester'?: AccountSource;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'recipient'?: AccountSource;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'errors'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'warnings'?: Array<string> | null;
    /**
     * 
     * @type {Array<Approval>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'approvals'?: Array<Approval>;
    /**
     * 
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * 
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * 
     * @type {Array<AccountRequest>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'sources'?: string;
}
/**
 * 
 * @export
 * @interface AccountAllOf
 */
export interface AccountAllOf {
    /**
     * The unique ID of the source this account belongs to
     * @type {string}
     * @memberof AccountAllOf
     */
    'sourceId': string;
    /**
     * The display name of the source this account belongs to
     * @type {string}
     * @memberof AccountAllOf
     */
    'sourceName': string;
    /**
     * The unique ID of the identity this account is correlated to
     * @type {string}
     * @memberof AccountAllOf
     */
    'identityId'?: string;
    /**
     * The account attributes that are aggregated
     * @type {{ [key: string]: any; }}
     * @memberof AccountAllOf
     */
    'attributes': { [key: string]: any; };
    /**
     * Indicates if this account is from an authoritative source
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'authoritative': boolean;
    /**
     * A description of the account
     * @type {string}
     * @memberof AccountAllOf
     */
    'description'?: string | null;
    /**
     * Indicates if the account is currently disabled
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'disabled': boolean;
    /**
     * Indicates if the account is currently locked
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'locked': boolean;
    /**
     * The unique ID of the account generated by the source system
     * @type {string}
     * @memberof AccountAllOf
     */
    'nativeIdentity': string;
    /**
     * If true, this is a user account within IdentityNow.  If false, this is an account from a source system.
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'systemAccount': boolean;
    /**
     * Indicates if this account is not correlated to an identity
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'uncorrelated': boolean;
    /**
     * The unique ID of the account as determined by the account schema
     * @type {string}
     * @memberof AccountAllOf
     */
    'uuid'?: string | null;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'manuallyCorrelated': boolean;
    /**
     * Indicates if the account has entitlements
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'hasEntitlements': boolean;
}
/**
 * 
 * @export
 * @interface AccountAttribute
 */
export interface AccountAttribute {
    /**
     * A reference to the source to search for the account
     * @type {string}
     * @memberof AccountAttribute
     */
    'sourceName': string;
    /**
     * The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema.
     * @type {string}
     * @memberof AccountAttribute
     */
    'attributeName': string;
    /**
     * The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountSortAttribute'?: string;
    /**
     * The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'accountSortDescending'?: boolean;
    /**
     * The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'accountReturnFirstLink'?: boolean;
    /**
     * This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria. Only certain searchable attributes are available:  - `nativeIdentity` - the Account ID  - `displayName` - the Account Name  - `entitlements` - a boolean value to determine if the account has entitlements
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountFilter'?: string;
    /**
     * This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.  All account attributes are available for filtering as this operation is performed in memory.
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountPropertyFilter'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof AccountAttribute
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface AccountAttributes
 */
export interface AccountAttributes {
    /**
     * The schema attribute values for the account
     * @type {{ [key: string]: any; }}
     * @memberof AccountAttributes
     */
    'attributes': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface AccountAttributesCreate
 */
export interface AccountAttributesCreate {
    /**
     * 
     * @type {AccountAttributesCreateAttributes}
     * @memberof AccountAttributesCreate
     */
    'attributes': AccountAttributesCreateAttributes;
}
/**
 * The schema attribute values for the account
 * @export
 * @interface AccountAttributesCreateAttributes
 */
export interface AccountAttributesCreateAttributes {
    [key: string]: string | any;

    /**
     * Target source to create an account
     * @type {string}
     * @memberof AccountAttributesCreateAttributes
     */
    'sourceId': string;
}
/**
 * Account
 * @export
 * @interface AccountDocument
 */
export interface AccountDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccountDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccountDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccountDocument
     */
    '_type': DocumentType;
    /**
     * The ID of the account
     * @type {string}
     * @memberof AccountDocument
     */
    'accountId'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountDocument
     */
    'source'?: AccountSource;
    /**
     * Indicates if the account is disabled
     * @type {boolean}
     * @memberof AccountDocument
     */
    'disabled'?: boolean;
    /**
     * Indicates if the account is locked
     * @type {boolean}
     * @memberof AccountDocument
     */
    'locked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountDocument
     */
    'privileged'?: boolean;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof AccountDocument
     */
    'manuallyCorrelated'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountDocument
     */
    'passwordLastSet'?: string | null;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof AccountDocument
     */
    'entitlementAttributes'?: { [key: string]: any; } | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountDocument
     */
    'modified'?: string | null;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof AccountDocument
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccountDocument
     */
    'identity'?: DisplayReference;
    /**
     * 
     * @type {Array<AccessProfileEntitlement>}
     * @memberof AccountDocument
     */
    'access'?: Array<AccessProfileEntitlement>;
    /**
     * The number of entitlements assigned to the account
     * @type {number}
     * @memberof AccountDocument
     */
    'entitlementCount'?: number;
    /**
     * Indicates if the account is not correlated to an identity
     * @type {boolean}
     * @memberof AccountDocument
     */
    'uncorrelated'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountDocument
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AccountDocumentAllOf
 */
export interface AccountDocumentAllOf {
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountDocumentAllOf
     */
    'modified'?: string | null;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof AccountDocumentAllOf
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccountDocumentAllOf
     */
    'identity'?: DisplayReference;
    /**
     * 
     * @type {Array<AccessProfileEntitlement>}
     * @memberof AccountDocumentAllOf
     */
    'access'?: Array<AccessProfileEntitlement>;
    /**
     * The number of entitlements assigned to the account
     * @type {number}
     * @memberof AccountDocumentAllOf
     */
    'entitlementCount'?: number;
    /**
     * Indicates if the account is not correlated to an identity
     * @type {boolean}
     * @memberof AccountDocumentAllOf
     */
    'uncorrelated'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountDocumentAllOf
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AccountRequest
 */
export interface AccountRequest {
    /**
     * Unique ID of the account
     * @type {string}
     * @memberof AccountRequest
     */
    'accountId'?: string;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof AccountRequest
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * The operation that was performed
     * @type {string}
     * @memberof AccountRequest
     */
    'op'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountRequest
     */
    'provisioningTarget'?: AccountSource;
    /**
     * 
     * @type {AccountRequestResult}
     * @memberof AccountRequest
     */
    'result'?: AccountRequestResult;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountRequest
     */
    'source'?: AccountSource;
}
/**
 * If an account activity item is associated with an access request, captures details of that request.
 * @export
 * @interface AccountRequestInfo
 */
export interface AccountRequestInfo {
    /**
     * Id of requested object
     * @type {string}
     * @memberof AccountRequestInfo
     */
    'requestedObjectId'?: string;
    /**
     * Human-readable name of requested object
     * @type {string}
     * @memberof AccountRequestInfo
     */
    'requestedObjectName'?: string;
    /**
     * 
     * @type {RequestableObjectType}
     * @memberof AccountRequestInfo
     */
    'requestedObjectType'?: RequestableObjectType;
}
/**
 * 
 * @export
 * @interface AccountRequestResult
 */
export interface AccountRequestResult {
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountRequestResult
     */
    'errors'?: Array<string>;
    /**
     * The status of the account request
     * @type {string}
     * @memberof AccountRequestResult
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountRequestResult
     */
    'ticketId'?: string | null;
}
/**
 * 
 * @export
 * @interface AccountSource
 */
export interface AccountSource {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccountSource
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccountSource
     */
    'name'?: string;
    /**
     * the type of source returned
     * @type {string}
     * @memberof AccountSource
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface AccountSourceAllOf
 */
export interface AccountSourceAllOf {
    /**
     * the type of source returned
     * @type {string}
     * @memberof AccountSourceAllOf
     */
    'type'?: string;
}
/**
 * Request used for account enable/disable
 * @export
 * @interface AccountToggleRequest
 */
export interface AccountToggleRequest {
    /**
     * If set, an external process validates that the user wants to proceed with this request.
     * @type {string}
     * @memberof AccountToggleRequest
     */
    'externalVerificationId'?: string;
    /**
     * If set, provisioning updates the account attribute at the source.   This option is used when the account is not synced to ensure the attribute is updated. Providing \'true\' for an unlocked account will add and process \'Unlock\' operation by the workflow.
     * @type {boolean}
     * @memberof AccountToggleRequest
     */
    'forceProvisioning'?: boolean;
}
/**
 * Request used for account unlock
 * @export
 * @interface AccountUnlockRequest
 */
export interface AccountUnlockRequest {
    /**
     * If set, an external process validates that the user wants to proceed with this request.
     * @type {string}
     * @memberof AccountUnlockRequest
     */
    'externalVerificationId'?: string;
    /**
     * If set, the IDN account is unlocked after the workflow completes.
     * @type {boolean}
     * @memberof AccountUnlockRequest
     */
    'unlockIDNAccount'?: boolean;
    /**
     * If set, provisioning updates the account attribute at the source.   This option is used when the account is not synced to ensure the attribute is updated.
     * @type {boolean}
     * @memberof AccountUnlockRequest
     */
    'forceProvisioning'?: boolean;
}
/**
 * Accounts async response containing details on started async process
 * @export
 * @interface AccountsAsyncResult
 */
export interface AccountsAsyncResult {
    /**
     * id of the task
     * @type {string}
     * @memberof AccountsAsyncResult
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ActivateCampaignOptions
 */
export interface ActivateCampaignOptions {
    /**
     * The timezone must be in a valid ISO 8601 format. Timezones in ISO 8601 are represented as UTC (represented as \'Z\') or as an offset from UTC. The offset format can be +/-hh:mm, +/-hhmm, or +/-hh.
     * @type {string}
     * @memberof ActivateCampaignOptions
     */
    'timeZone'?: string;
}
/**
 * 
 * @export
 * @interface AdminReviewReassign
 */
export interface AdminReviewReassign {
    /**
     * List of certification IDs to reassign
     * @type {Array<string>}
     * @memberof AdminReviewReassign
     */
    'certificationIds'?: Array<string>;
    /**
     * 
     * @type {AdminReviewReassignReassignTo}
     * @memberof AdminReviewReassign
     */
    'reassignTo'?: AdminReviewReassignReassignTo;
    /**
     * Comment to explain why the certification was reassigned
     * @type {string}
     * @memberof AdminReviewReassign
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface AdminReviewReassignReassignTo
 */
export interface AdminReviewReassignReassignTo {
    /**
     * The identity ID to which the review is being assigned.
     * @type {string}
     * @memberof AdminReviewReassignReassignTo
     */
    'id'?: string;
    /**
     * The type of the ID provided.
     * @type {string}
     * @memberof AdminReviewReassignReassignTo
     */
    'type'?: AdminReviewReassignReassignToTypeEnum;
}

export const AdminReviewReassignReassignToTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type AdminReviewReassignReassignToTypeEnum = typeof AdminReviewReassignReassignToTypeEnum[keyof typeof AdminReviewReassignReassignToTypeEnum];

/**
 * Aggregation
 * @export
 * @interface Aggregation
 */
export interface Aggregation {
    /**
     * 
     * @type {string}
     * @memberof Aggregation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Aggregation
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof Aggregation
     */
    '_type': DocumentType;
    /**
     * 
     * @type {string}
     * @memberof Aggregation
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof Aggregation
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof Aggregation
     */
    'avgDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof Aggregation
     */
    'changedAccounts'?: number;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Aggregation
     */
    'nextScheduled'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Aggregation
     */
    'startTime'?: string | null;
    /**
     * John Doe
     * @type {string}
     * @memberof Aggregation
     */
    'sourceOwner'?: string;
}
/**
 * 
 * @export
 * @interface AggregationAllOf
 */
export interface AggregationAllOf {
    /**
     * 
     * @type {string}
     * @memberof AggregationAllOf
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof AggregationAllOf
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof AggregationAllOf
     */
    'avgDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof AggregationAllOf
     */
    'changedAccounts'?: number;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AggregationAllOf
     */
    'nextScheduled'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AggregationAllOf
     */
    'startTime'?: string | null;
    /**
     * John Doe
     * @type {string}
     * @memberof AggregationAllOf
     */
    'sourceOwner'?: string;
}
/**
 * Aggregation
 * @export
 * @interface AggregationDocument
 */
export interface AggregationDocument {
    /**
     * 
     * @type {string}
     * @memberof AggregationDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AggregationDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AggregationDocument
     */
    '_type': DocumentType;
    /**
     * 
     * @type {string}
     * @memberof AggregationDocument
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof AggregationDocument
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof AggregationDocument
     */
    'avgDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof AggregationDocument
     */
    'changedAccounts'?: number;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AggregationDocument
     */
    'nextScheduled'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AggregationDocument
     */
    'startTime'?: string | null;
    /**
     * John Doe
     * @type {string}
     * @memberof AggregationDocument
     */
    'sourceOwner'?: string;
}
/**
 * 
 * @export
 * @interface AggregationResult
 */
export interface AggregationResult {
    /**
     * The document containing the results of the aggregation. This document is controlled by Elasticsearch and depends on the type of aggregation query that is run.  See Elasticsearch [Aggregations](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations.html) documentation for information. 
     * @type {object}
     * @memberof AggregationResult
     */
    'aggregations'?: object;
    /**
     * The results of the aggregation search query. 
     * @type {Array<SearchDocument>}
     * @memberof AggregationResult
     */
    'hits'?: Array<SearchDocument>;
}
/**
 * Enum representing the currently available query languages for aggregations, which are used to perform calculations or groupings on search results.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const AggregationType = {
    Dsl: 'DSL',
    Sailpoint: 'SAILPOINT'
} as const;

export type AggregationType = typeof AggregationType[keyof typeof AggregationType];


/**
 * 
 * @export
 * @interface Aggregations
 */
export interface Aggregations {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof Aggregations
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof Aggregations
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof Aggregations
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof Aggregations
     */
    'bucket'?: BucketAggregation;
}
/**
 * 
 * @export
 * @interface App
 */
export interface App {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof App
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof App
     */
    'name'?: string;
    /**
     * 
     * @type {Reference1}
     * @memberof App
     */
    'source'?: Reference1;
    /**
     * 
     * @type {AppAllOfAccount}
     * @memberof App
     */
    'account'?: AppAllOfAccount;
}
/**
 * 
 * @export
 * @interface AppAllOf
 */
export interface AppAllOf {
    /**
     * 
     * @type {Reference1}
     * @memberof AppAllOf
     */
    'source'?: Reference1;
    /**
     * 
     * @type {AppAllOfAccount}
     * @memberof AppAllOf
     */
    'account'?: AppAllOfAccount;
}
/**
 * 
 * @export
 * @interface AppAllOfAccount
 */
export interface AppAllOfAccount {
    /**
     * The SailPoint generated unique ID
     * @type {string}
     * @memberof AppAllOfAccount
     */
    'id'?: string;
    /**
     * The account ID generated by the source
     * @type {string}
     * @memberof AppAllOfAccount
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface Approval
 */
export interface Approval {
    /**
     * 
     * @type {Array<ApprovalComment>}
     * @memberof Approval
     */
    'comments'?: Array<ApprovalComment>;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Approval
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Approval
     */
    'modified'?: string | null;
    /**
     * 
     * @type {AccountSource}
     * @memberof Approval
     */
    'owner'?: AccountSource;
    /**
     * The result of the approval
     * @type {string}
     * @memberof Approval
     */
    'result'?: string;
    /**
     * 
     * @type {string}
     * @memberof Approval
     */
    'type'?: string | null;
}
/**
 * 
 * @export
 * @interface ApprovalComment
 */
export interface ApprovalComment {
    /**
     * The comment text
     * @type {string}
     * @memberof ApprovalComment
     */
    'comment'?: string;
    /**
     * The name of the commenter
     * @type {string}
     * @memberof ApprovalComment
     */
    'commenter'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof ApprovalComment
     */
    'date'?: string | null;
}
/**
 * 
 * @export
 * @interface ApprovalForwardHistory
 */
export interface ApprovalForwardHistory {
    /**
     * Display name of approver from whom the approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'oldApproverName'?: string;
    /**
     * Display name of approver to whom the approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'newApproverName'?: string;
    /**
     * Comment made while forwarding.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'comment'?: string | null;
    /**
     * Time at which approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'modified'?: string;
    /**
     * Display name of forwarder who forwarded the approval.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'forwarderName'?: string | null;
    /**
     * 
     * @type {ReassignmentType}
     * @memberof ApprovalForwardHistory
     */
    'reassignmentType'?: ReassignmentType;
}
/**
 * 
 * @export
 * @interface ApprovalItemDetails
 */
export interface ApprovalItemDetails {
    /**
     * ID of the approval item
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'id'?: string;
    /**
     * The account referenced by the approval item
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'account'?: string;
    /**
     * The name the application/source
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'application'?: string;
    /**
     * The name of the attribute
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'attributeName'?: string;
    /**
     * The operation of the attribute
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'attributeValue'?: string;
    /**
     * 
     * @type {WorkItemState}
     * @memberof ApprovalItemDetails
     */
    'state'?: WorkItemState;
}
/**
 * 
 * @export
 * @interface ApprovalItems
 */
export interface ApprovalItems {
    /**
     * ID of the approval item
     * @type {string}
     * @memberof ApprovalItems
     */
    'id'?: string;
    /**
     * The account referenced by the approval item
     * @type {string}
     * @memberof ApprovalItems
     */
    'account'?: string;
    /**
     * The name the application/source
     * @type {string}
     * @memberof ApprovalItems
     */
    'application'?: string;
    /**
     * The name of the attribute
     * @type {string}
     * @memberof ApprovalItems
     */
    'attributeName'?: string;
    /**
     * The operation of the attribute
     * @type {string}
     * @memberof ApprovalItems
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute
     * @type {string}
     * @memberof ApprovalItems
     */
    'attributeValue'?: string;
    /**
     * 
     * @type {WorkItemState}
     * @memberof ApprovalItems
     */
    'state'?: WorkItemState;
}
/**
 * 
 * @export
 * @interface ApprovalReminderAndEscalationConfig
 */
export interface ApprovalReminderAndEscalationConfig {
    /**
     * Number of days to wait before the first reminder. If no reminders are configured, then this is the number of days to wait before escalation.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'daysUntilEscalation'?: number;
    /**
     * Number of days to wait between reminder notifications.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'daysBetweenReminders'?: number;
    /**
     * Maximum number of reminder notification to send to the reviewer before approval escalation.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'maxReminders'?: number;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'fallbackApproverRef'?: IdentityReferenceWithNameAndEmail | null;
}
/**
 * Describes the individual or group that is responsible for an approval step.
 * @export
 * @enum {string}
 */

export const ApprovalScheme = {
    AppOwner: 'APP_OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    RoleOwner: 'ROLE_OWNER',
    AccessProfileOwner: 'ACCESS_PROFILE_OWNER',
    EntitlementOwner: 'ENTITLEMENT_OWNER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type ApprovalScheme = typeof ApprovalScheme[keyof typeof ApprovalScheme];


/**
 * 
 * @export
 * @interface ApprovalSchemeForRole
 */
export interface ApprovalSchemeForRole {
    /**
     * Describes the individual or group that is responsible for an approval step. Values are as follows.  **OWNER**: Owner of the associated Role  **MANAGER**: Manager of the Identity making the request  **GOVERNANCE_GROUP**: A Governance Group, the ID of which is specified by the **approverId** field
     * @type {string}
     * @memberof ApprovalSchemeForRole
     */
    'approverType'?: ApprovalSchemeForRoleApproverTypeEnum;
    /**
     * Id of the specific approver, used only when approverType is GOVERNANCE_GROUP
     * @type {string}
     * @memberof ApprovalSchemeForRole
     */
    'approverId'?: string | null;
}

export const ApprovalSchemeForRoleApproverTypeEnum = {
    Owner: 'OWNER',
    Manager: 'MANAGER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type ApprovalSchemeForRoleApproverTypeEnum = typeof ApprovalSchemeForRoleApproverTypeEnum[keyof typeof ApprovalSchemeForRoleApproverTypeEnum];

/**
 * Enum representing the non-employee request approval status
 * @export
 * @enum {string}
 */

export const ApprovalStatus = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Pending: 'PENDING',
    NotReady: 'NOT_READY',
    Cancelled: 'CANCELLED'
} as const;

export type ApprovalStatus = typeof ApprovalStatus[keyof typeof ApprovalStatus];


/**
 * 
 * @export
 * @interface ApprovalStatusDto
 */
export interface ApprovalStatusDto {
    /**
     * True if the request for this item was forwarded from one owner to another.
     * @type {boolean}
     * @memberof ApprovalStatusDto
     */
    'forwarded'?: boolean;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof ApprovalStatusDto
     */
    'originalOwner'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof ApprovalStatusDto
     */
    'currentOwner'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof ApprovalStatusDto
     */
    'reviewedBy'?: BaseReferenceDto;
    /**
     * Time at which item was modified.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'modified'?: string;
    /**
     * 
     * @type {ManualWorkItemState}
     * @memberof ApprovalStatusDto
     */
    'status'?: ManualWorkItemState;
    /**
     * 
     * @type {ApprovalScheme}
     * @memberof ApprovalStatusDto
     */
    'scheme'?: ApprovalScheme;
    /**
     * If the request failed, includes any error messages that were generated.
     * @type {Array<ErrorMessageDto>}
     * @memberof ApprovalStatusDto
     */
    'errorMessages'?: Array<ErrorMessageDto>;
    /**
     * Comment, if any, provided by the approver.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'comment'?: string;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'removeDate'?: string;
}
/**
 * 
 * @export
 * @interface ApprovalSummary
 */
export interface ApprovalSummary {
    /**
     * The number of pending access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'pending'?: number;
    /**
     * The number of approved access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'approved'?: number;
    /**
     * The number of rejected access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'rejected'?: number;
}
/**
 * 
 * @export
 * @interface AttributeDefinition
 */
export interface AttributeDefinition {
    /**
     * The name of the attribute.
     * @type {string}
     * @memberof AttributeDefinition
     */
    'name'?: string;
    /**
     * 
     * @type {AttributeDefinitionType}
     * @memberof AttributeDefinition
     */
    'type'?: AttributeDefinitionType;
    /**
     * 
     * @type {AttributeDefinitionSchema}
     * @memberof AttributeDefinition
     */
    'schema'?: AttributeDefinitionSchema;
    /**
     * A human-readable description of the attribute.
     * @type {string}
     * @memberof AttributeDefinition
     */
    'description'?: string;
    /**
     * Flag indicating whether or not the attribute is multi-valued.
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isMultiValued'?: boolean;
    /**
     * Flag indicating whether or not the attribute is an entitlement.
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isEntitlement'?: boolean;
    /**
     * Flag indicating whether or not the attribute represents a group. This can only be `true` if `isEntitlement` is also `true` **and** there is a schema defined for the attribute.. 
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isGroup'?: boolean;
}
/**
 * A reference to the schema on the source to the attribute values map to.
 * @export
 * @interface AttributeDefinitionSchema
 */
export interface AttributeDefinitionSchema {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'type'?: AttributeDefinitionSchemaTypeEnum;
    /**
     * The object ID this reference applies to.
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'id'?: string;
    /**
     * The human-readable display name of the object.
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'name'?: string;
}

export const AttributeDefinitionSchemaTypeEnum = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
} as const;

export type AttributeDefinitionSchemaTypeEnum = typeof AttributeDefinitionSchemaTypeEnum[keyof typeof AttributeDefinitionSchemaTypeEnum];

/**
 * The underlying type of the value which an AttributeDefinition represents.
 * @export
 * @enum {string}
 */

export const AttributeDefinitionType = {
    String: 'STRING',
    Long: 'LONG',
    Int: 'INT',
    Boolean: 'BOOLEAN'
} as const;

export type AttributeDefinitionType = typeof AttributeDefinitionType[keyof typeof AttributeDefinitionType];


/**
 * 
 * @export
 * @interface AttributeRequest
 */
export interface AttributeRequest {
    /**
     * The attribute name
     * @type {string}
     * @memberof AttributeRequest
     */
    'name'?: string;
    /**
     * The operation to perform
     * @type {string}
     * @memberof AttributeRequest
     */
    'op'?: string;
    /**
     * The value of the attribute
     * @type {string}
     * @memberof AttributeRequest
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Base64Decode
 */
export interface Base64Decode {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Base64Decode
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Base64Decode
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Base64Encode
 */
export interface Base64Encode {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Base64Encode
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Base64Encode
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BaseAccess
 */
export interface BaseAccess {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof BaseAccess
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof BaseAccess
     */
    'name'?: string;
    /**
     * The description of the access item
     * @type {string}
     * @memberof BaseAccess
     */
    'description'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccess
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccess
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccess
     */
    'synced'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAccess
     */
    'enabled'?: boolean;
    /**
     * Indicates if the access can be requested
     * @type {boolean}
     * @memberof BaseAccess
     */
    'requestable'?: boolean;
    /**
     * Indicates if comments are required when requesting access
     * @type {boolean}
     * @memberof BaseAccess
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {Owner}
     * @memberof BaseAccess
     */
    'owner'?: Owner;
}
/**
 * 
 * @export
 * @interface BaseAccessAllOf
 */
export interface BaseAccessAllOf {
    /**
     * The description of the access item
     * @type {string}
     * @memberof BaseAccessAllOf
     */
    'description'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccessAllOf
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccessAllOf
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccessAllOf
     */
    'synced'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAccessAllOf
     */
    'enabled'?: boolean;
    /**
     * Indicates if the access can be requested
     * @type {boolean}
     * @memberof BaseAccessAllOf
     */
    'requestable'?: boolean;
    /**
     * Indicates if comments are required when requesting access
     * @type {boolean}
     * @memberof BaseAccessAllOf
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {Owner}
     * @memberof BaseAccessAllOf
     */
    'owner'?: Owner;
}
/**
 * 
 * @export
 * @interface BaseAccount
 */
export interface BaseAccount {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof BaseAccount
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof BaseAccount
     */
    'name'?: string;
    /**
     * The ID of the account
     * @type {string}
     * @memberof BaseAccount
     */
    'accountId'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof BaseAccount
     */
    'source'?: AccountSource;
    /**
     * Indicates if the account is disabled
     * @type {boolean}
     * @memberof BaseAccount
     */
    'disabled'?: boolean;
    /**
     * Indicates if the account is locked
     * @type {boolean}
     * @memberof BaseAccount
     */
    'locked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAccount
     */
    'privileged'?: boolean;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof BaseAccount
     */
    'manuallyCorrelated'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccount
     */
    'passwordLastSet'?: string | null;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof BaseAccount
     */
    'entitlementAttributes'?: { [key: string]: any; } | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccount
     */
    'created'?: string | null;
}
/**
 * 
 * @export
 * @interface BaseAccountAllOf
 */
export interface BaseAccountAllOf {
    /**
     * The ID of the account
     * @type {string}
     * @memberof BaseAccountAllOf
     */
    'accountId'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof BaseAccountAllOf
     */
    'source'?: AccountSource;
    /**
     * Indicates if the account is disabled
     * @type {boolean}
     * @memberof BaseAccountAllOf
     */
    'disabled'?: boolean;
    /**
     * Indicates if the account is locked
     * @type {boolean}
     * @memberof BaseAccountAllOf
     */
    'locked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAccountAllOf
     */
    'privileged'?: boolean;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof BaseAccountAllOf
     */
    'manuallyCorrelated'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccountAllOf
     */
    'passwordLastSet'?: string | null;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof BaseAccountAllOf
     */
    'entitlementAttributes'?: { [key: string]: any; } | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccountAllOf
     */
    'created'?: string | null;
}
/**
 * 
 * @export
 * @interface BaseCommonDto
 */
export interface BaseCommonDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface BaseDocument
 */
export interface BaseDocument {
    /**
     * 
     * @type {string}
     * @memberof BaseDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BaseDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof BaseDocument
     */
    '_type': DocumentType;
}
/**
 * 
 * @export
 * @interface BaseEntitlement
 */
export interface BaseEntitlement {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'name'?: string;
    /**
     * A description of the entitlement
     * @type {string}
     * @memberof BaseEntitlement
     */
    'description'?: string;
    /**
     * The name of the entitlement attribute
     * @type {string}
     * @memberof BaseEntitlement
     */
    'attribute'?: string;
    /**
     * The value of the entitlement
     * @type {string}
     * @memberof BaseEntitlement
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BaseEntitlementAllOf
 */
export interface BaseEntitlementAllOf {
    /**
     * A description of the entitlement
     * @type {string}
     * @memberof BaseEntitlementAllOf
     */
    'description'?: string;
    /**
     * The name of the entitlement attribute
     * @type {string}
     * @memberof BaseEntitlementAllOf
     */
    'attribute'?: string;
    /**
     * The value of the entitlement
     * @type {string}
     * @memberof BaseEntitlementAllOf
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BaseReferenceDto
 */
export interface BaseReferenceDto {
    /**
     * 
     * @type {DtoType}
     * @memberof BaseReferenceDto
     */
    'type'?: DtoType;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof BaseReferenceDto
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof BaseReferenceDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Bound
 */
export interface Bound {
    /**
     * The value of the range\'s endpoint.
     * @type {string}
     * @memberof Bound
     */
    'value': string;
    /**
     * Indicates if the endpoint is included in the range.
     * @type {boolean}
     * @memberof Bound
     */
    'inclusive'?: boolean;
}
/**
 * The bucket to group the results of the aggregation query by.
 * @export
 * @interface BucketAggregation
 */
export interface BucketAggregation {
    /**
     * The name of the bucket aggregate to be included in the result.
     * @type {string}
     * @memberof BucketAggregation
     */
    'name': string;
    /**
     * 
     * @type {BucketType}
     * @memberof BucketAggregation
     */
    'type'?: BucketType;
    /**
     * The field to bucket on. Prefix the field name with \'@\' to reference a nested object.
     * @type {string}
     * @memberof BucketAggregation
     */
    'field': string;
    /**
     * Maximum number of buckets to include.
     * @type {number}
     * @memberof BucketAggregation
     */
    'size'?: number;
    /**
     * Minimum number of documents a bucket should have.
     * @type {number}
     * @memberof BucketAggregation
     */
    'minDocCount'?: number;
}
/**
 * Enum representing the currently supported bucket aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const BucketType = {
    Terms: 'TERMS'
} as const;

export type BucketType = typeof BucketType[keyof typeof BucketType];


/**
 * 
 * @export
 * @interface BulkTaggedObject
 */
export interface BulkTaggedObject {
    /**
     * 
     * @type {Array<TaggedObjectDto>}
     * @memberof BulkTaggedObject
     */
    'objectRefs'?: Array<TaggedObjectDto>;
    /**
     * Label to be applied to an Object
     * @type {Array<string>}
     * @memberof BulkTaggedObject
     */
    'tags'?: Array<string>;
    /**
     * If APPEND, tags are appended to the list of tags for the object. A 400 error is returned if this would add duplicate tags to the object.  If MERGE, tags are merged with the existing tags. Duplicate tags are silently ignored.
     * @type {string}
     * @memberof BulkTaggedObject
     */
    'operation'?: BulkTaggedObjectOperationEnum;
}

export const BulkTaggedObjectOperationEnum = {
    Append: 'APPEND',
    Merge: 'MERGE'
} as const;

export type BulkTaggedObjectOperationEnum = typeof BulkTaggedObjectOperationEnum[keyof typeof BulkTaggedObjectOperationEnum];

/**
 * 
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     * Id of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'id'?: string;
    /**
     * The campaign name. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof Campaign
     */
    'name': string;
    /**
     * The campaign description. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof Campaign
     */
    'description': string;
    /**
     * The campaign\'s completion deadline.
     * @type {string}
     * @memberof Campaign
     */
    'deadline'?: string;
    /**
     * The type of campaign. Could be extended in the future.
     * @type {string}
     * @memberof Campaign
     */
    'type': CampaignTypeEnum;
    /**
     * Enables email notification for this campaign
     * @type {boolean}
     * @memberof Campaign
     */
    'emailNotificationEnabled'?: boolean;
    /**
     * Allows auto revoke for this campaign
     * @type {boolean}
     * @memberof Campaign
     */
    'autoRevokeAllowed'?: boolean;
    /**
     * Enables IAI for this campaign. Accepts true even if the IAI product feature is off. If IAI is turned off then campaigns generated from this template will indicate false. The real value will then be returned if IAI is ever enabled for the org in the future.
     * @type {boolean}
     * @memberof Campaign
     */
    'recommendationsEnabled'?: boolean;
    /**
     * The campaign\'s current status.
     * @type {string}
     * @memberof Campaign
     */
    'status'?: CampaignStatusEnum;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {object}
     * @memberof Campaign
     */
    'correlatedStatus'?: CampaignCorrelatedStatusEnum;
    /**
     * Created time of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'created'?: string;
    /**
     * Modified time of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'modified'?: string;
    /**
     * 
     * @type {CampaignAllOfFilter}
     * @memberof Campaign
     */
    'filter'?: CampaignAllOfFilter;
    /**
     * Determines if comments on sunset date changes are required.
     * @type {boolean}
     * @memberof Campaign
     */
    'sunsetCommentsRequired'?: boolean;
    /**
     * 
     * @type {CampaignAllOfSourceOwnerCampaignInfo}
     * @memberof Campaign
     */
    'sourceOwnerCampaignInfo'?: CampaignAllOfSourceOwnerCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfSearchCampaignInfo}
     * @memberof Campaign
     */
    'searchCampaignInfo'?: CampaignAllOfSearchCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfRoleCompositionCampaignInfo}
     * @memberof Campaign
     */
    'roleCompositionCampaignInfo'?: CampaignAllOfRoleCompositionCampaignInfo;
    /**
     * A list of errors and warnings that have accumulated.
     * @type {Array<CampaignAlert>}
     * @memberof Campaign
     */
    'alerts'?: Array<CampaignAlert>;
    /**
     * The total number of certifications in this campaign.
     * @type {number}
     * @memberof Campaign
     */
    'totalCertifications'?: number;
    /**
     * The number of completed certifications in this campaign.
     * @type {number}
     * @memberof Campaign
     */
    'completedCertifications'?: number;
    /**
     * A list of sources in the campaign that contain \\\"orphan entitlements\\\" (entitlements without a corresponding Managed Attribute). An empty list indicates the campaign has no orphan entitlements. Null indicates there may be unknown orphan entitlements in the campaign (the campaign was created before this feature was implemented).
     * @type {Array<CampaignAllOfSourcesWithOrphanEntitlements>}
     * @memberof Campaign
     */
    'sourcesWithOrphanEntitlements'?: Array<CampaignAllOfSourcesWithOrphanEntitlements>;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof Campaign
     */
    'mandatoryCommentRequirement'?: CampaignMandatoryCommentRequirementEnum;
}

export const CampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
} as const;

export type CampaignTypeEnum = typeof CampaignTypeEnum[keyof typeof CampaignTypeEnum];
export const CampaignStatusEnum = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
} as const;

export type CampaignStatusEnum = typeof CampaignStatusEnum[keyof typeof CampaignStatusEnum];
export const CampaignCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type CampaignCorrelatedStatusEnum = typeof CampaignCorrelatedStatusEnum[keyof typeof CampaignCorrelatedStatusEnum];
export const CampaignMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type CampaignMandatoryCommentRequirementEnum = typeof CampaignMandatoryCommentRequirementEnum[keyof typeof CampaignMandatoryCommentRequirementEnum];

/**
 * 
 * @export
 * @interface CampaignAlert
 */
export interface CampaignAlert {
    /**
     * Denotes the level of the message
     * @type {string}
     * @memberof CampaignAlert
     */
    'level'?: CampaignAlertLevelEnum;
    /**
     * 
     * @type {Array<ErrorMessageDto>}
     * @memberof CampaignAlert
     */
    'localizations'?: Array<ErrorMessageDto>;
}

export const CampaignAlertLevelEnum = {
    Error: 'ERROR',
    Warn: 'WARN',
    Info: 'INFO'
} as const;

export type CampaignAlertLevelEnum = typeof CampaignAlertLevelEnum[keyof typeof CampaignAlertLevelEnum];

/**
 * 
 * @export
 * @interface CampaignAllOf
 */
export interface CampaignAllOf {
    /**
     * Created time of the campaign
     * @type {string}
     * @memberof CampaignAllOf
     */
    'created'?: string;
    /**
     * Modified time of the campaign
     * @type {string}
     * @memberof CampaignAllOf
     */
    'modified'?: string;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {object}
     * @memberof CampaignAllOf
     */
    'correlatedStatus'?: CampaignAllOfCorrelatedStatusEnum;
    /**
     * 
     * @type {CampaignAllOfFilter}
     * @memberof CampaignAllOf
     */
    'filter'?: CampaignAllOfFilter;
    /**
     * Determines if comments on sunset date changes are required.
     * @type {boolean}
     * @memberof CampaignAllOf
     */
    'sunsetCommentsRequired'?: boolean;
    /**
     * 
     * @type {CampaignAllOfSourceOwnerCampaignInfo}
     * @memberof CampaignAllOf
     */
    'sourceOwnerCampaignInfo'?: CampaignAllOfSourceOwnerCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfSearchCampaignInfo}
     * @memberof CampaignAllOf
     */
    'searchCampaignInfo'?: CampaignAllOfSearchCampaignInfo;
    /**
     * 
     * @type {CampaignAllOfRoleCompositionCampaignInfo}
     * @memberof CampaignAllOf
     */
    'roleCompositionCampaignInfo'?: CampaignAllOfRoleCompositionCampaignInfo;
    /**
     * A list of errors and warnings that have accumulated.
     * @type {Array<CampaignAlert>}
     * @memberof CampaignAllOf
     */
    'alerts'?: Array<CampaignAlert>;
    /**
     * The total number of certifications in this campaign.
     * @type {number}
     * @memberof CampaignAllOf
     */
    'totalCertifications'?: number;
    /**
     * The number of completed certifications in this campaign.
     * @type {number}
     * @memberof CampaignAllOf
     */
    'completedCertifications'?: number;
    /**
     * A list of sources in the campaign that contain \\\"orphan entitlements\\\" (entitlements without a corresponding Managed Attribute). An empty list indicates the campaign has no orphan entitlements. Null indicates there may be unknown orphan entitlements in the campaign (the campaign was created before this feature was implemented).
     * @type {Array<CampaignAllOfSourcesWithOrphanEntitlements>}
     * @memberof CampaignAllOf
     */
    'sourcesWithOrphanEntitlements'?: Array<CampaignAllOfSourcesWithOrphanEntitlements>;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof CampaignAllOf
     */
    'mandatoryCommentRequirement'?: CampaignAllOfMandatoryCommentRequirementEnum;
}

export const CampaignAllOfCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type CampaignAllOfCorrelatedStatusEnum = typeof CampaignAllOfCorrelatedStatusEnum[keyof typeof CampaignAllOfCorrelatedStatusEnum];
export const CampaignAllOfMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type CampaignAllOfMandatoryCommentRequirementEnum = typeof CampaignAllOfMandatoryCommentRequirementEnum[keyof typeof CampaignAllOfMandatoryCommentRequirementEnum];

/**
 * Determines which items will be included in this campaign. The default campaign filter is used if this field is left blank.
 * @export
 * @interface CampaignAllOfFilter
 */
export interface CampaignAllOfFilter {
    /**
     * The ID of whatever type of filter is being used.
     * @type {string}
     * @memberof CampaignAllOfFilter
     */
    'id'?: string;
    /**
     * Type of the filter
     * @type {string}
     * @memberof CampaignAllOfFilter
     */
    'type'?: CampaignAllOfFilterTypeEnum;
    /**
     * Name of the filter
     * @type {string}
     * @memberof CampaignAllOfFilter
     */
    'name'?: string;
}

export const CampaignAllOfFilterTypeEnum = {
    CampaignFilter: 'CAMPAIGN_FILTER',
    Rule: 'RULE'
} as const;

export type CampaignAllOfFilterTypeEnum = typeof CampaignAllOfFilterTypeEnum[keyof typeof CampaignAllOfFilterTypeEnum];

/**
 * Optional configuration options for role composition campaigns.
 * @export
 * @interface CampaignAllOfRoleCompositionCampaignInfo
 */
export interface CampaignAllOfRoleCompositionCampaignInfo {
    /**
     * If specified, this identity or governance group will be the reviewer for all certifications in this campaign. The allowed DTO types are IDENTITY and GOVERNANCE_GROUP
     * @type {BaseReferenceDto & object}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'reviewer'?: BaseReferenceDto & object;
    /**
     * Optional list of roles to include in this campaign. Only one of `roleIds` and `query` may be set; if neither are set, all roles are included.
     * @type {Array<string>}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'roleIds'?: Array<string>;
    /**
     * 
     * @type {CampaignAllOfRoleCompositionCampaignInfoRemediatorRef}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'remediatorRef': CampaignAllOfRoleCompositionCampaignInfoRemediatorRef;
    /**
     * Optional search query to scope this campaign to a set of roles. Only one of `roleIds` and `query` may be set; if neither are set, all roles are included.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'query'?: string;
    /**
     * Describes this role composition campaign. Intended for storing the query used, and possibly the number of roles selected/available.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfo
     */
    'description'?: string;
}
/**
 * This determines who remediation tasks will be assigned to. Remediation tasks are created for each revoke decision on items in the campaign. The only legal remediator type is \'IDENTITY\', and the chosen identity must be a Role Admin or Org Admin.
 * @export
 * @interface CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
 */
export interface CampaignAllOfRoleCompositionCampaignInfoRemediatorRef {
    /**
     * Legal Remediator Type
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
     */
    'type': CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum;
    /**
     * The ID of the remediator.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
     */
    'id': string;
    /**
     * The name of the remediator.
     * @type {string}
     * @memberof CampaignAllOfRoleCompositionCampaignInfoRemediatorRef
     */
    'name'?: string;
}

export const CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum = typeof CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum[keyof typeof CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum];

/**
 * Must be set only if the campaign type is SEARCH.
 * @export
 * @interface CampaignAllOfSearchCampaignInfo
 */
export interface CampaignAllOfSearchCampaignInfo {
    /**
     * The type of search campaign represented.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'type': CampaignAllOfSearchCampaignInfoTypeEnum;
    /**
     * Describes this search campaign. Intended for storing the query used, and possibly the number of identities selected/available.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'description'?: string;
    /**
     * If specified, this identity or governance group will be the reviewer for all certifications in this campaign. The allowed DTO types are IDENTITY and GOVERNANCE_GROUP
     * @type {BaseReferenceDto & object}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'reviewer'?: BaseReferenceDto & object;
    /**
     * The scope for the campaign. The campaign will cover identities returned by the query and identities that have access items returned by the query. One of `query` or `identityIds` must be set.
     * @type {string}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'query'?: string;
    /**
     * A direct list of identities to include in this campaign. One of `identityIds` or `query` must be set.
     * @type {Array<string>}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'identityIds'?: Array<string>;
    /**
     * Further reduces the scope of the campaign by excluding identities (from `query` or `identityIds`) that do not have this access.
     * @type {Array<AccessConstraint>}
     * @memberof CampaignAllOfSearchCampaignInfo
     */
    'accessConstraints'?: Array<AccessConstraint>;
}

export const CampaignAllOfSearchCampaignInfoTypeEnum = {
    Identity: 'IDENTITY',
    Access: 'ACCESS'
} as const;

export type CampaignAllOfSearchCampaignInfoTypeEnum = typeof CampaignAllOfSearchCampaignInfoTypeEnum[keyof typeof CampaignAllOfSearchCampaignInfoTypeEnum];

/**
 * Must be set only if the campaign type is SOURCE_OWNER.
 * @export
 * @interface CampaignAllOfSourceOwnerCampaignInfo
 */
export interface CampaignAllOfSourceOwnerCampaignInfo {
    /**
     * The list of sources to be included in the campaign.
     * @type {Array<string>}
     * @memberof CampaignAllOfSourceOwnerCampaignInfo
     */
    'sourceIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CampaignAllOfSourcesWithOrphanEntitlements
 */
export interface CampaignAllOfSourcesWithOrphanEntitlements {
    /**
     * Id of the source
     * @type {string}
     * @memberof CampaignAllOfSourcesWithOrphanEntitlements
     */
    'id'?: string;
    /**
     * Type
     * @type {string}
     * @memberof CampaignAllOfSourcesWithOrphanEntitlements
     */
    'type'?: CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum;
    /**
     * Name of the source
     * @type {string}
     * @memberof CampaignAllOfSourcesWithOrphanEntitlements
     */
    'name'?: string;
}

export const CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum = {
    Source: 'SOURCE'
} as const;

export type CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum = typeof CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum[keyof typeof CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum];

/**
 * 
 * @export
 * @interface CampaignReference
 */
export interface CampaignReference {
    /**
     * The unique ID of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'id': string;
    /**
     * The name of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'name': string;
    /**
     * The type of object that is being referenced.
     * @type {string}
     * @memberof CampaignReference
     */
    'type': CampaignReferenceTypeEnum;
    /**
     * The type of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'campaignType': CampaignReferenceCampaignTypeEnum;
    /**
     * The description of the campaign set by the admin who created it.
     * @type {string}
     * @memberof CampaignReference
     */
    'description': string | null;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {object}
     * @memberof CampaignReference
     */
    'correlatedStatus': CampaignReferenceCorrelatedStatusEnum;
    /**
     * Determines whether comments are required for decisions during certification reviews. You can require comments for all decisions, revoke-only decisions, or no decisions. By default, comments are not required for decisions.
     * @type {string}
     * @memberof CampaignReference
     */
    'mandatoryCommentRequirement': CampaignReferenceMandatoryCommentRequirementEnum;
}

export const CampaignReferenceTypeEnum = {
    Campaign: 'CAMPAIGN'
} as const;

export type CampaignReferenceTypeEnum = typeof CampaignReferenceTypeEnum[keyof typeof CampaignReferenceTypeEnum];
export const CampaignReferenceCampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH'
} as const;

export type CampaignReferenceCampaignTypeEnum = typeof CampaignReferenceCampaignTypeEnum[keyof typeof CampaignReferenceCampaignTypeEnum];
export const CampaignReferenceCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type CampaignReferenceCorrelatedStatusEnum = typeof CampaignReferenceCorrelatedStatusEnum[keyof typeof CampaignReferenceCorrelatedStatusEnum];
export const CampaignReferenceMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
} as const;

export type CampaignReferenceMandatoryCommentRequirementEnum = typeof CampaignReferenceMandatoryCommentRequirementEnum[keyof typeof CampaignReferenceMandatoryCommentRequirementEnum];

/**
 * Request body payload for cancel access request endpoint.
 * @export
 * @interface CancelAccessRequest
 */
export interface CancelAccessRequest {
    /**
     * ID of the account activity object corresponding to the access request.
     * @type {string}
     * @memberof CancelAccessRequest
     */
    'accountActivityId': string;
    /**
     * Reason for cancelling the pending access request.
     * @type {string}
     * @memberof CancelAccessRequest
     */
    'comment': string;
}
/**
 * Provides additional details for a request that has been cancelled.
 * @export
 * @interface CancelledRequestDetails
 */
export interface CancelledRequestDetails {
    /**
     * Comment made by the owner when cancelling the associated request.
     * @type {string}
     * @memberof CancelledRequestDetails
     */
    'comment'?: string;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof CancelledRequestDetails
     */
    'owner'?: BaseReferenceDto;
    /**
     * Date comment was added by the owner when cancelling the associated request
     * @type {string}
     * @memberof CancelledRequestDetails
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface Certification
 */
export interface Certification {
    /**
     * id of the certification
     * @type {string}
     * @memberof Certification
     */
    'id'?: string;
    /**
     * name of the certification
     * @type {string}
     * @memberof Certification
     */
    'name'?: string;
    /**
     * 
     * @type {CampaignReference}
     * @memberof Certification
     */
    'campaign'?: CampaignReference;
    /**
     * Have all decisions been made?
     * @type {boolean}
     * @memberof Certification
     */
    'completed'?: boolean;
    /**
     * The number of identities for whom all decisions have been made and are complete.
     * @type {number}
     * @memberof Certification
     */
    'identitiesCompleted'?: number;
    /**
     * The total number of identities in the Certification, both complete and incomplete.
     * @type {number}
     * @memberof Certification
     */
    'identitiesTotal'?: number;
    /**
     * created date
     * @type {string}
     * @memberof Certification
     */
    'created'?: string;
    /**
     * modified date
     * @type {string}
     * @memberof Certification
     */
    'modified'?: string;
    /**
     * The number of approve/revoke/acknowledge decisions that have been made.
     * @type {number}
     * @memberof Certification
     */
    'decisionsMade'?: number;
    /**
     * The total number of approve/revoke/acknowledge decisions.
     * @type {number}
     * @memberof Certification
     */
    'decisionsTotal'?: number;
    /**
     * The due date of the certification.
     * @type {string}
     * @memberof Certification
     */
    'due'?: string;
    /**
     * The date the reviewer signed off on the Certification.
     * @type {string}
     * @memberof Certification
     */
    'signed'?: string | null;
    /**
     * 
     * @type {Reviewer}
     * @memberof Certification
     */
    'reviewer'?: Reviewer;
    /**
     * 
     * @type {Reassignment}
     * @memberof Certification
     */
    'reassignment'?: Reassignment | null;
    /**
     * Identifies if the certification has an error
     * @type {boolean}
     * @memberof Certification
     */
    'hasErrors'?: boolean;
    /**
     * Description of the certification error
     * @type {string}
     * @memberof Certification
     */
    'errorMessage'?: string | null;
    /**
     * 
     * @type {CertificationPhase}
     * @memberof Certification
     */
    'phase'?: CertificationPhase;
}
/**
 * The decision to approve or revoke the review item
 * @export
 * @enum {string}
 */

export const CertificationDecision = {
    Approve: 'APPROVE',
    Revoke: 'REVOKE'
} as const;

export type CertificationDecision = typeof CertificationDecision[keyof typeof CertificationDecision];


/**
 * 
 * @export
 * @interface CertificationIdentitySummary
 */
export interface CertificationIdentitySummary {
    /**
     * The ID of the identity summary
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'id'?: string;
    /**
     * Name of the linked identity
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'name'?: string;
    /**
     * The ID of the identity being certified
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'identityId'?: string;
    /**
     * Indicates whether the review items for the linked identity\'s certification have been completed
     * @type {boolean}
     * @memberof CertificationIdentitySummary
     */
    'completed'?: boolean;
}
/**
 * The current phase of the campaign. * `STAGED`: The campaign is waiting to be activated. * `ACTIVE`: The campaign is active. * `SIGNED`: The reviewer has signed off on the campaign, and it is considered complete. 
 * @export
 * @enum {string}
 */

export const CertificationPhase = {
    Staged: 'STAGED',
    Active: 'ACTIVE',
    Signed: 'SIGNED'
} as const;

export type CertificationPhase = typeof CertificationPhase[keyof typeof CertificationPhase];


/**
 * 
 * @export
 * @interface CertificationReference
 */
export interface CertificationReference {
    /**
     * The id of the certification.
     * @type {string}
     * @memberof CertificationReference
     */
    'id'?: string;
    /**
     * The name of the certification.
     * @type {string}
     * @memberof CertificationReference
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CertificationReference
     */
    'type'?: CertificationReferenceTypeEnum;
    /**
     * 
     * @type {Reviewer}
     * @memberof CertificationReference
     */
    'reviewer'?: Reviewer;
}

export const CertificationReferenceTypeEnum = {
    Certification: 'CERTIFICATION'
} as const;

export type CertificationReferenceTypeEnum = typeof CertificationReferenceTypeEnum[keyof typeof CertificationReferenceTypeEnum];

/**
 * 
 * @export
 * @interface CertificationTask
 */
export interface CertificationTask {
    /**
     * The ID of the certification task.
     * @type {string}
     * @memberof CertificationTask
     */
    'id'?: string;
    /**
     * The type of the certification task. More values may be added in the future.
     * @type {string}
     * @memberof CertificationTask
     */
    'type'?: CertificationTaskTypeEnum;
    /**
     * The type of item that is being operated on by this task whose ID is stored in the targetId field.
     * @type {string}
     * @memberof CertificationTask
     */
    'targetType'?: CertificationTaskTargetTypeEnum;
    /**
     * The ID of the item being operated on by this task.
     * @type {string}
     * @memberof CertificationTask
     */
    'targetId'?: string;
    /**
     * The status of the task.
     * @type {string}
     * @memberof CertificationTask
     */
    'status'?: CertificationTaskStatusEnum;
    /**
     * 
     * @type {Array<ErrorMessageDto>}
     * @memberof CertificationTask
     */
    'errors'?: Array<ErrorMessageDto>;
    /**
     * Reassignment trails that lead to self certification identity
     * @type {Array<ReassignmentTrailDTO>}
     * @memberof CertificationTask
     */
    'reassignmentTrailDTOs'?: Array<ReassignmentTrailDTO>;
    /**
     * The date and time on which this task was created.
     * @type {string}
     * @memberof CertificationTask
     */
    'created'?: string;
}

export const CertificationTaskTypeEnum = {
    Reassign: 'REASSIGN',
    AdminReassign: 'ADMIN_REASSIGN',
    CompleteCertification: 'COMPLETE_CERTIFICATION',
    FinishCertification: 'FINISH_CERTIFICATION',
    CompleteCampaign: 'COMPLETE_CAMPAIGN',
    ActivateCampaign: 'ACTIVATE_CAMPAIGN',
    CampaignCreate: 'CAMPAIGN_CREATE',
    CampaignDelete: 'CAMPAIGN_DELETE'
} as const;

export type CertificationTaskTypeEnum = typeof CertificationTaskTypeEnum[keyof typeof CertificationTaskTypeEnum];
export const CertificationTaskTargetTypeEnum = {
    Certification: 'CERTIFICATION',
    Campaign: 'CAMPAIGN'
} as const;

export type CertificationTaskTargetTypeEnum = typeof CertificationTaskTargetTypeEnum[keyof typeof CertificationTaskTargetTypeEnum];
export const CertificationTaskStatusEnum = {
    Queued: 'QUEUED',
    InProgress: 'IN_PROGRESS',
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type CertificationTaskStatusEnum = typeof CertificationTaskStatusEnum[keyof typeof CertificationTaskStatusEnum];

/**
 * Type of an API Client indicating public or confidentials use
 * @export
 * @enum {string}
 */

export const ClientType = {
    Confidential: 'CONFIDENTIAL',
    Public: 'PUBLIC'
} as const;

export type ClientType = typeof ClientType[keyof typeof ClientType];


/**
 * 
 * @export
 * @interface Column
 */
export interface Column {
    /**
     * The name of the field. 
     * @type {string}
     * @memberof Column
     */
    'field': string;
    /**
     * The value of the header. 
     * @type {string}
     * @memberof Column
     */
    'header'?: string;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * Id of the identity making the comment
     * @type {string}
     * @memberof Comment
     */
    'commenterId'?: string;
    /**
     * Human-readable display name of the identity making the comment
     * @type {string}
     * @memberof Comment
     */
    'commenterName'?: string;
    /**
     * Content of the comment
     * @type {string}
     * @memberof Comment
     */
    'body'?: string;
    /**
     * Date and time comment was made
     * @type {string}
     * @memberof Comment
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface CommentDto
 */
export interface CommentDto {
    /**
     * Content of the comment
     * @type {string}
     * @memberof CommentDto
     */
    'comment'?: string;
    /**
     * 
     * @type {CommentDtoAuthor}
     * @memberof CommentDto
     */
    'author'?: CommentDtoAuthor;
    /**
     * Date and time comment was created
     * @type {string}
     * @memberof CommentDto
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface CommentDtoAuthor
 */
export interface CommentDtoAuthor {
    /**
     * 
     * @type {DtoType}
     * @memberof CommentDtoAuthor
     */
    'type'?: DtoType;
    /**
     * ID of the author
     * @type {string}
     * @memberof CommentDtoAuthor
     */
    'id'?: string;
    /**
     * Human-readable display name of the identity making the comment
     * @type {string}
     * @memberof CommentDtoAuthor
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CompletedApproval
 */
export interface CompletedApproval {
    /**
     * The approval id.
     * @type {string}
     * @memberof CompletedApproval
     */
    'id'?: string;
    /**
     * The name of the approval.
     * @type {string}
     * @memberof CompletedApproval
     */
    'name'?: string;
    /**
     * When the approval was created.
     * @type {string}
     * @memberof CompletedApproval
     */
    'created'?: string;
    /**
     * When the approval was modified last time.
     * @type {string}
     * @memberof CompletedApproval
     */
    'modified'?: string;
    /**
     * When the access-request was created.
     * @type {string}
     * @memberof CompletedApproval
     */
    'requestCreated'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof CompletedApproval
     */
    'requestType'?: AccessRequestType;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof CompletedApproval
     */
    'requester'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof CompletedApproval
     */
    'requestedFor'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof CompletedApproval
     */
    'reviewedBy'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof CompletedApproval
     */
    'owner'?: BaseReferenceDto;
    /**
     * 
     * @type {RequestableObjectReference}
     * @memberof CompletedApproval
     */
    'requestedObject'?: RequestableObjectReference;
    /**
     * 
     * @type {CommentDto}
     * @memberof CompletedApproval
     */
    'requesterComment'?: CommentDto;
    /**
     * 
     * @type {CompletedApprovalReviewerComment}
     * @memberof CompletedApproval
     */
    'reviewerComment'?: CompletedApprovalReviewerComment | null;
    /**
     * The history of the previous reviewers comments.
     * @type {Array<CommentDto>}
     * @memberof CompletedApproval
     */
    'previousReviewersComments'?: Array<CommentDto>;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof CompletedApproval
     */
    'forwardHistory'?: Array<ApprovalForwardHistory>;
    /**
     * When true the rejector has to provide comments when rejecting
     * @type {boolean}
     * @memberof CompletedApproval
     */
    'commentRequiredWhenRejected'?: boolean;
    /**
     * 
     * @type {CompletedApprovalState}
     * @memberof CompletedApproval
     */
    'state'?: CompletedApprovalState;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof CompletedApproval
     */
    'removeDate'?: string | null;
    /**
     * If true, then the request was to change the remove date or sunset date.
     * @type {boolean}
     * @memberof CompletedApproval
     */
    'removeDateUpdateRequested'?: boolean;
    /**
     * The remove date or sunset date that was assigned at the time of the request.
     * @type {string}
     * @memberof CompletedApproval
     */
    'currentRemoveDate'?: string | null;
    /**
     * 
     * @type {SodViolationContextCheckCompleted}
     * @memberof CompletedApproval
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted;
}
/**
 * The approval\'s reviewer\'s comment.
 * @export
 * @interface CompletedApprovalReviewerComment
 */
export interface CompletedApprovalReviewerComment {
    /**
     * Content of the comment
     * @type {string}
     * @memberof CompletedApprovalReviewerComment
     */
    'comment'?: string;
    /**
     * 
     * @type {CommentDtoAuthor}
     * @memberof CompletedApprovalReviewerComment
     */
    'author'?: CommentDtoAuthor;
    /**
     * Date and time comment was created
     * @type {string}
     * @memberof CompletedApprovalReviewerComment
     */
    'created'?: string;
}
/**
 * Enum represents completed approval object\'s state.
 * @export
 * @enum {string}
 */

export const CompletedApprovalState = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type CompletedApprovalState = typeof CompletedApprovalState[keyof typeof CompletedApprovalState];


/**
 * The status after completion.
 * @export
 * @enum {string}
 */

export const CompletionStatus = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Incomplete: 'INCOMPLETE',
    Pending: 'PENDING'
} as const;

export type CompletionStatus = typeof CompletionStatus[keyof typeof CompletionStatus];


/**
 * 
 * @export
 * @interface Concatenation
 */
export interface Concatenation {
    /**
     * An array of items to join together
     * @type {Array<object>}
     * @memberof Concatenation
     */
    'values': Array<object>;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Concatenation
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Concatenation
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Conditional
 */
export interface Conditional {
    /**
     * A comparison statement that follows the structure of `ValueA eq ValueB` where `ValueA` and `ValueB` are static strings or outputs of other transforms.   The `eq` operator is the only valid comparison
     * @type {string}
     * @memberof Conditional
     */
    'expression': string;
    /**
     * The output of the transform if the expression evalutes to true
     * @type {string}
     * @memberof Conditional
     */
    'positiveCondition': string;
    /**
     * The output of the transform if the expression evalutes to false
     * @type {string}
     * @memberof Conditional
     */
    'negativeCondition': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Conditional
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Conditional
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ConflictingAccessCriteria
 */
export interface ConflictingAccessCriteria {
    /**
     * 
     * @type {AccessCriteria}
     * @memberof ConflictingAccessCriteria
     */
    'leftCriteria'?: AccessCriteria;
    /**
     * 
     * @type {AccessCriteria}
     * @memberof ConflictingAccessCriteria
     */
    'rightCriteria'?: AccessCriteria;
}
/**
 * 
 * @export
 * @interface CreateOAuthClientRequest
 */
export interface CreateOAuthClientRequest {
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'businessName'?: string | null;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'homepageUrl'?: string | null;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'name': string | null;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'description': string | null;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientRequest
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientRequest
     */
    'refreshTokenValiditySeconds'?: number;
    /**
     * A list of the approved redirect URIs. Provide one or more URIs when assigning the AUTHORIZATION_CODE grant type to a new OAuth Client.
     * @type {Array<string>}
     * @memberof CreateOAuthClientRequest
     */
    'redirectUris'?: Array<string> | null;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof CreateOAuthClientRequest
     */
    'grantTypes': Array<GrantType> | null;
    /**
     * 
     * @type {AccessType}
     * @memberof CreateOAuthClientRequest
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof CreateOAuthClientRequest
     */
    'type'?: ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal within the product.
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'internal'?: boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'strongAuthSupported'?: boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'claimsSupported'?: boolean;
    /**
     * Scopes of the API Client. If no scope is specified, the client will be created with the default scope \"sp:scopes:all\". This means the API Client will have all the rights of the owner who created it.
     * @type {Array<string>}
     * @memberof CreateOAuthClientRequest
     */
    'scope'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreateOAuthClientResponse
 */
export interface CreateOAuthClientResponse {
    /**
     * ID of the OAuth client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'id': string;
    /**
     * Secret of the OAuth client (This field is only returned on the intial create call.)
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'secret': string;
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'businessName': string;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'homepageUrl': string;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'name': string;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'description': string;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientResponse
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientResponse
     */
    'refreshTokenValiditySeconds': number;
    /**
     * A list of the approved redirect URIs used with the authorization_code flow
     * @type {Array<string>}
     * @memberof CreateOAuthClientResponse
     */
    'redirectUris': Array<string>;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof CreateOAuthClientResponse
     */
    'grantTypes': Array<GrantType>;
    /**
     * 
     * @type {AccessType}
     * @memberof CreateOAuthClientResponse
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof CreateOAuthClientResponse
     */
    'type': ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal to IDN
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'internal': boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'strongAuthSupported': boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'claimsSupported': boolean;
    /**
     * The date and time, down to the millisecond, when the API Client was created
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when the API Client was last updated
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'modified': string;
    /**
     * Scopes of the API Client.
     * @type {Array<string>}
     * @memberof CreateOAuthClientResponse
     */
    'scope': Array<string> | null;
}
/**
 * Object for specifying the name of a personal access token to create
 * @export
 * @interface CreatePersonalAccessTokenRequest
 */
export interface CreatePersonalAccessTokenRequest {
    /**
     * The name of the personal access token (PAT) to be created. Cannot be the same as another PAT owned by the user for whom this PAT is being created.
     * @type {string}
     * @memberof CreatePersonalAccessTokenRequest
     */
    'name': string;
    /**
     * Scopes of the personal  access token. If no scope is specified, the token will be created with the default scope \"sp:scopes:all\". This means the personal access token will have all the rights of the owner who created it.
     * @type {Array<string>}
     * @memberof CreatePersonalAccessTokenRequest
     */
    'scope'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreatePersonalAccessTokenResponse
 */
export interface CreatePersonalAccessTokenResponse {
    /**
     * The ID of the personal access token (to be used as the username for Basic Auth).
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'id': string;
    /**
     * The secret of the personal access token (to be used as the password for Basic Auth).
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'secret': string;
    /**
     * Scopes of the personal  access token.
     * @type {Array<string>}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'scope': Array<string> | null;
    /**
     * The name of the personal access token. Cannot be the same as other personal access tokens owned by a user.
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'owner': BaseReferenceDto;
    /**
     * The date and time, down to the millisecond, when this personal access token was created.
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'created': string;
}
/**
 * 
 * @export
 * @interface CreateSavedSearchRequest
 */
export interface CreateSavedSearchRequest {
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'description'?: string | null;
    /**
     * Indicates if the saved search is public. 
     * @type {boolean}
     * @memberof CreateSavedSearchRequest
     */
    'public'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof CreateSavedSearchRequest
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof CreateSavedSearchRequest
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof CreateSavedSearchRequest
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof CreateSavedSearchRequest
     */
    'fields'?: Array<string> | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof CreateSavedSearchRequest
     */
    'sort'?: Array<string>;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof CreateSavedSearchRequest
     */
    'filters'?: SavedSearchDetailFilters | null;
}
/**
 * 
 * @export
 * @interface CreateScheduledSearchRequest
 */
export interface CreateScheduledSearchRequest {
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'description'?: string | null;
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'savedSearchId': string;
    /**
     * The date the scheduled search was initially created.
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'created'?: string;
    /**
     * The last date the scheduled search was modified.
     * @type {string}
     * @memberof CreateScheduledSearchRequest
     */
    'modified'?: string;
    /**
     * 
     * @type {Schedule}
     * @memberof CreateScheduledSearchRequest
     */
    'schedule': Schedule;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof CreateScheduledSearchRequest
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof CreateScheduledSearchRequest
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should not be suppressed if search returns no results. 
     * @type {boolean}
     * @memberof CreateScheduledSearchRequest
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof CreateScheduledSearchRequest
     */
    'displayQueryDetails'?: boolean;
}
/**
 * 
 * @export
 * @interface DateCompare
 */
export interface DateCompare {
    /**
     * 
     * @type {DateCompareFirstDate}
     * @memberof DateCompare
     */
    'firstDate': DateCompareFirstDate;
    /**
     * 
     * @type {DateCompareSecondDate}
     * @memberof DateCompare
     */
    'secondDate': DateCompareSecondDate;
    /**
     * This is the comparison to perform. | Operation | Description | | --------- | ------- | | LT        | Strictly less than: firstDate < secondDate | | LTE       | Less than or equal to: firstDate <= secondDate | | GT        | Strictly greater than: firstDate > secondDate | | GTE       | Greater than or equal to: firstDate >= secondDate | 
     * @type {string}
     * @memberof DateCompare
     */
    'operator': DateCompareOperatorEnum;
    /**
     * The output of the transform if the expression evalutes to true
     * @type {string}
     * @memberof DateCompare
     */
    'positiveCondition': string;
    /**
     * The output of the transform if the expression evalutes to false
     * @type {string}
     * @memberof DateCompare
     */
    'negativeCondition': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateCompare
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateCompare
     */
    'input'?: { [key: string]: any; };
}

export const DateCompareOperatorEnum = {
    Lt: 'LT',
    Lte: 'LTE',
    Gt: 'GT',
    Gte: 'GTE'
} as const;

export type DateCompareOperatorEnum = typeof DateCompareOperatorEnum[keyof typeof DateCompareOperatorEnum];

/**
 * @type DateCompareFirstDate
 * This is the first date to consider (The date that would be on the left hand side of the comparison operation).
 * @export
 */
export type DateCompareFirstDate = AccountAttribute | DateFormat;

/**
 * @type DateCompareSecondDate
 * This is the second date to consider (The date that would be on the right hand side of the comparison operation).
 * @export
 */
export type DateCompareSecondDate = AccountAttribute | DateFormat;

/**
 * 
 * @export
 * @interface DateFormat
 */
export interface DateFormat {
    /**
     * 
     * @type {DateFormatInputFormat}
     * @memberof DateFormat
     */
    'inputFormat'?: DateFormatInputFormat;
    /**
     * 
     * @type {DateFormatOutputFormat}
     * @memberof DateFormat
     */
    'outputFormat'?: DateFormatOutputFormat;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateFormat
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateFormat
     */
    'input'?: { [key: string]: any; };
}
/**
 * @type DateFormatInputFormat
 * A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.  *If no inputFormat is provided, the transform assumes that it is in ISO8601 format*
 * @export
 */
export type DateFormatInputFormat = NamedConstructs | string;

/**
 * @type DateFormatOutputFormat
 * A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.  *If no inputFormat is provided, the transform assumes that it is in ISO8601 format*
 * @export
 */
export type DateFormatOutputFormat = NamedConstructs | string;

/**
 * 
 * @export
 * @interface DateMath
 */
export interface DateMath {
    /**
     * A string value of the date and time components to operation on, along with the math operations to execute. 
     * @type {string}
     * @memberof DateMath
     */
    'expression': string;
    /**
     * A boolean value to indicate whether the transform should round up or down when a rounding `/` operation is defined in the expression.    If not provided, the transform will default to `false`   `true` indicates the transform should round up (i.e., truncate the fractional date/time component indicated and then add one unit of that component)   `false` indicates the transform should round down (i.e., truncate the fractional date/time component indicated) 
     * @type {boolean}
     * @memberof DateMath
     */
    'roundUp'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateMath
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateMath
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface DecomposeDiacriticalMarks
 */
export interface DecomposeDiacriticalMarks {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DecomposeDiacriticalMarks
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DecomposeDiacriticalMarks
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface DeleteNonEmployeeRecordsInBulkRequest
 */
export interface DeleteNonEmployeeRecordsInBulkRequest {
    /**
     * List of non-employee ids.
     * @type {Array<string>}
     * @memberof DeleteNonEmployeeRecordsInBulkRequest
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteSource202Response
 */
export interface DeleteSource202Response {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'type'?: DeleteSource202ResponseTypeEnum;
    /**
     * ID of the task result
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'id'?: string;
    /**
     * Human-readable display name of the task result (should be null/empty)
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'name'?: string;
}

export const DeleteSource202ResponseTypeEnum = {
    TaskResult: 'TASK_RESULT'
} as const;

export type DeleteSource202ResponseTypeEnum = typeof DeleteSource202ResponseTypeEnum[keyof typeof DeleteSource202ResponseTypeEnum];

/**
 * 
 * @export
 * @interface DisplayReference
 */
export interface DisplayReference {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof DisplayReference
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof DisplayReference
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisplayReference
     */
    'displayName'?: string;
}
/**
 * 
 * @export
 * @interface DisplayReferenceAllOf
 */
export interface DisplayReferenceAllOf {
    /**
     * 
     * @type {string}
     * @memberof DisplayReferenceAllOf
     */
    'displayName'?: string;
}
/**
 * Enum representing the currently supported document types.  Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const DocumentType = {
    Accessprofile: 'accessprofile',
    Accountactivity: 'accountactivity',
    Account: 'account',
    Aggregation: 'aggregation',
    Entitlement: 'entitlement',
    Event: 'event',
    Identity: 'identity',
    Role: 'role'
} as const;

export type DocumentType = typeof DocumentType[keyof typeof DocumentType];


/**
 * An enumeration of the types of DTOs supported within the IdentityNow infrastructure.
 * @export
 * @enum {string}
 */

export const DtoType = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG',
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestApproval: 'ACCESS_REQUEST_APPROVAL',
    Account: 'ACCOUNT',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    CampaignFilter: 'CAMPAIGN_FILTER',
    Certification: 'CERTIFICATION',
    Cluster: 'CLUSTER',
    ConnectorSchema: 'CONNECTOR_SCHEMA',
    Entitlement: 'ENTITLEMENT',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY',
    IdentityProfile: 'IDENTITY_PROFILE',
    IdentityRequest: 'IDENTITY_REQUEST',
    LifecycleState: 'LIFECYCLE_STATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    Role: 'ROLE',
    Rule: 'RULE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    TagCategory: 'TAG_CATEGORY',
    TaskResult: 'TASK_RESULT',
    ReportResult: 'REPORT_RESULT',
    SodViolation: 'SOD_VIOLATION',
    AccountActivity: 'ACCOUNT_ACTIVITY'
} as const;

export type DtoType = typeof DtoType[keyof typeof DtoType];


/**
 * 
 * @export
 * @interface E164phone
 */
export interface E164phone {
    /**
     * This is an optional attribute that can be used to define the region of the phone number to format into.   If defaultRegion is not provided, it will take US as the default country.   The format of the country code should be in [ISO 3166-1 alpha-2 format](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) 
     * @type {string}
     * @memberof E164phone
     */
    'defaultRegion'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof E164phone
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof E164phone
     */
    'input'?: { [key: string]: any; };
}
/**
 * This is used for representing email configuration for a lifecycle state
 * @export
 * @interface EmailNotificationOption
 */
export interface EmailNotificationOption {
    /**
     * If true, then the manager is notified of the lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifyManagers'?: boolean;
    /**
     * If true, then all the admins are notified of the lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifyAllAdmins'?: boolean;
    /**
     * If true, then the users specified in \"emailAddressList\" below are notified of lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifySpecificUsers'?: boolean;
    /**
     * List of user email addresses. If \"notifySpecificUsers\" option is true, then these users are notified of lifecycle state change.
     * @type {Array<string>}
     * @memberof EmailNotificationOption
     */
    'emailAddressList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Entitlement
 */
export interface Entitlement {
    /**
     * The entitlement id
     * @type {string}
     * @memberof Entitlement
     */
    'id'?: string;
    /**
     * The entitlement name
     * @type {string}
     * @memberof Entitlement
     */
    'name'?: string;
    /**
     * The entitlement attribute name
     * @type {string}
     * @memberof Entitlement
     */
    'attribute'?: string;
    /**
     * The value of the entitlement
     * @type {string}
     * @memberof Entitlement
     */
    'value'?: string;
    /**
     * The object type of the entitlement from the source schema
     * @type {string}
     * @memberof Entitlement
     */
    'sourceSchemaObjectType'?: string;
    /**
     * The description of the entitlement
     * @type {string}
     * @memberof Entitlement
     */
    'description'?: string;
    /**
     * True if the entitlement is privileged
     * @type {boolean}
     * @memberof Entitlement
     */
    'privileged'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof Entitlement
     */
    'cloudGoverned'?: boolean;
    /**
     * Time when the entitlement was created
     * @type {string}
     * @memberof Entitlement
     */
    'created'?: string;
    /**
     * Time when the entitlement was last modified
     * @type {string}
     * @memberof Entitlement
     */
    'modified'?: string;
    /**
     * 
     * @type {EntitlementSource}
     * @memberof Entitlement
     */
    'source'?: EntitlementSource;
    /**
     * A map of free-form key-value pairs from the source system
     * @type {{ [key: string]: any; }}
     * @memberof Entitlement
     */
    'attributes'?: { [key: string]: any; };
    /**
     * List of IDs of segments, if any, to which this Entitlement is assigned.
     * @type {Array<string>}
     * @memberof Entitlement
     */
    'segments'?: Array<string> | null;
    /**
     * 
     * @type {Array<PermissionDto>}
     * @memberof Entitlement
     */
    'directPermissions'?: Array<PermissionDto>;
}
/**
 * Entitlement
 * @export
 * @interface EntitlementDocument
 */
export interface EntitlementDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof EntitlementDocument
     */
    '_type': DocumentType;
    /**
     * A description of the entitlement
     * @type {string}
     * @memberof EntitlementDocument
     */
    'description'?: string;
    /**
     * The name of the entitlement attribute
     * @type {string}
     * @memberof EntitlementDocument
     */
    'attribute'?: string;
    /**
     * The value of the entitlement
     * @type {string}
     * @memberof EntitlementDocument
     */
    'value'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EntitlementDocument
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EntitlementDocument
     */
    'synced'?: string | null;
    /**
     * The display name of the entitlement
     * @type {string}
     * @memberof EntitlementDocument
     */
    'displayName'?: string;
    /**
     * 
     * @type {Reference1}
     * @memberof EntitlementDocument
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementDocument
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EntitlementDocument
     */
    'identityCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntitlementDocument
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EntitlementDocumentAllOf
 */
export interface EntitlementDocumentAllOf {
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EntitlementDocumentAllOf
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EntitlementDocumentAllOf
     */
    'synced'?: string | null;
    /**
     * The display name of the entitlement
     * @type {string}
     * @memberof EntitlementDocumentAllOf
     */
    'displayName'?: string;
    /**
     * 
     * @type {Reference1}
     * @memberof EntitlementDocumentAllOf
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementDocumentAllOf
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EntitlementDocumentAllOf
     */
    'identityCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntitlementDocumentAllOf
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EntitlementDto
 */
export interface EntitlementDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'modified'?: string;
    /**
     * Name of the entitlement attribute
     * @type {string}
     * @memberof EntitlementDto
     */
    'attribute'?: string;
    /**
     * Raw value of the entitlement
     * @type {string}
     * @memberof EntitlementDto
     */
    'value'?: string;
    /**
     * Entitlment description
     * @type {string}
     * @memberof EntitlementDto
     */
    'description'?: string;
    /**
     * Entitlement attributes
     * @type {{ [key: string]: any; }}
     * @memberof EntitlementDto
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Schema objectType on the given application that maps to an Account Group
     * @type {string}
     * @memberof EntitlementDto
     */
    'sourceSchemaObjectType'?: string;
    /**
     * Determines if this Entitlement is privileged.
     * @type {boolean}
     * @memberof EntitlementDto
     */
    'privileged'?: boolean;
    /**
     * Determines if this Entitlement is goverened in the cloud.
     * @type {boolean}
     * @memberof EntitlementDto
     */
    'cloudGoverned'?: boolean;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof EntitlementDto
     */
    'source'?: BaseReferenceDto;
}
/**
 * Entitlement object that represents entitlement
 * @export
 * @interface EntitlementDtoAllOf
 */
export interface EntitlementDtoAllOf {
    /**
     * Name of the entitlement attribute
     * @type {string}
     * @memberof EntitlementDtoAllOf
     */
    'attribute'?: string;
    /**
     * Raw value of the entitlement
     * @type {string}
     * @memberof EntitlementDtoAllOf
     */
    'value'?: string;
    /**
     * Entitlment description
     * @type {string}
     * @memberof EntitlementDtoAllOf
     */
    'description'?: string;
    /**
     * Entitlement attributes
     * @type {{ [key: string]: any; }}
     * @memberof EntitlementDtoAllOf
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Schema objectType on the given application that maps to an Account Group
     * @type {string}
     * @memberof EntitlementDtoAllOf
     */
    'sourceSchemaObjectType'?: string;
    /**
     * Determines if this Entitlement is privileged.
     * @type {boolean}
     * @memberof EntitlementDtoAllOf
     */
    'privileged'?: boolean;
    /**
     * Determines if this Entitlement is goverened in the cloud.
     * @type {boolean}
     * @memberof EntitlementDtoAllOf
     */
    'cloudGoverned'?: boolean;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof EntitlementDtoAllOf
     */
    'source'?: BaseReferenceDto;
}
/**
 * 
 * @export
 * @interface EntitlementRef
 */
export interface EntitlementRef {
    /**
     * The ID of the Entitlement
     * @type {string}
     * @memberof EntitlementRef
     */
    'id'?: string;
    /**
     * The type of the Entitlement, will always be ENTITLEMENT
     * @type {string}
     * @memberof EntitlementRef
     */
    'type'?: EntitlementRefTypeEnum;
    /**
     * The display name of the Entitlement
     * @type {string}
     * @memberof EntitlementRef
     */
    'name'?: string;
}

export const EntitlementRefTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type EntitlementRefTypeEnum = typeof EntitlementRefTypeEnum[keyof typeof EntitlementRefTypeEnum];

/**
 * 
 * @export
 * @interface EntitlementRequestConfig
 */
export interface EntitlementRequestConfig {
    /**
     * Flag for allowing entitlement request.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'allowEntitlementRequest'?: boolean;
    /**
     * Flag for requiring comments while submitting an entitlement request.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'requestCommentsRequired'?: boolean;
    /**
     * Flag for requiring comments while rejecting an entitlement request.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'deniedCommentsRequired'?: boolean;
    /**
     * Approval schemes for granting entitlement request. This can be empty if no approval is needed. Multiple schemes must be comma-separated. The valid schemes are \"entitlementOwner\", \"sourceOwner\", \"manager\" and \"workgroup:{id}\". Multiple workgroups (governance groups) can be used. 
     * @type {string}
     * @memberof EntitlementRequestConfig
     */
    'grantRequestApprovalSchemes'?: string;
}
/**
 * 
 * @export
 * @interface EntitlementSource
 */
export interface EntitlementSource {
    /**
     * The source ID
     * @type {string}
     * @memberof EntitlementSource
     */
    'id'?: string;
    /**
     * The source type, will always be \"SOURCE\"
     * @type {string}
     * @memberof EntitlementSource
     */
    'type'?: string;
    /**
     * The source name
     * @type {string}
     * @memberof EntitlementSource
     */
    'name'?: string;
}
/**
 * EntitlementReference
 * @export
 * @interface EntitlementSummary
 */
export interface EntitlementSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof EntitlementSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof EntitlementSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof EntitlementSummary
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof EntitlementSummary
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummary
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'attribute'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummary
     */
    'standalone'?: boolean;
}
/**
 * 
 * @export
 * @interface EntitlementSummaryAllOf
 */
export interface EntitlementSummaryAllOf {
    /**
     * 
     * @type {Reference1}
     * @memberof EntitlementSummaryAllOf
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummaryAllOf
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummaryAllOf
     */
    'attribute'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummaryAllOf
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummaryAllOf
     */
    'standalone'?: boolean;
}
/**
 * 
 * @export
 * @interface ErrorMessageDto
 */
export interface ErrorMessageDto {
    /**
     * The locale for the message text, a BCP 47 language tag.
     * @type {string}
     * @memberof ErrorMessageDto
     */
    'locale'?: string;
    /**
     * 
     * @type {LocaleOrigin}
     * @memberof ErrorMessageDto
     */
    'localeOrigin'?: LocaleOrigin;
    /**
     * Actual text of the error message in the indicated locale.
     * @type {string}
     * @memberof ErrorMessageDto
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponseDto
 */
export interface ErrorResponseDto {
    /**
     * Fine-grained error code providing more detail of the error.
     * @type {string}
     * @memberof ErrorResponseDto
     */
    'detailCode'?: string;
    /**
     * Unique tracking id for the error.
     * @type {string}
     * @memberof ErrorResponseDto
     */
    'trackingId'?: string;
    /**
     * Generic localized reason for error
     * @type {Array<ErrorMessageDto>}
     * @memberof ErrorResponseDto
     */
    'messages'?: Array<ErrorMessageDto>;
    /**
     * Plain-text descriptive reasons to provide additional detail to the text provided in the messages field
     * @type {Array<ErrorMessageDto>}
     * @memberof ErrorResponseDto
     */
    'causes'?: Array<ErrorMessageDto>;
}
/**
 * Event
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof Event
     */
    '_type': DocumentType;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Event
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Event
     */
    'synced'?: string | null;
    /**
     * The action that was performed
     * @type {string}
     * @memberof Event
     */
    'action'?: string;
    /**
     * The type of event
     * @type {string}
     * @memberof Event
     */
    'type'?: string;
    /**
     * 
     * @type {NameType}
     * @memberof Event
     */
    'actor'?: NameType;
    /**
     * 
     * @type {NameType}
     * @memberof Event
     */
    'target'?: NameType;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'stack'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'details'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Event
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Event
     */
    'objects'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'operation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'technicalName'?: string;
}
/**
 * 
 * @export
 * @interface EventAllOf
 */
export interface EventAllOf {
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EventAllOf
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EventAllOf
     */
    'synced'?: string | null;
    /**
     * The action that was performed
     * @type {string}
     * @memberof EventAllOf
     */
    'action'?: string;
    /**
     * The type of event
     * @type {string}
     * @memberof EventAllOf
     */
    'type'?: string;
    /**
     * 
     * @type {NameType}
     * @memberof EventAllOf
     */
    'actor'?: NameType;
    /**
     * 
     * @type {NameType}
     * @memberof EventAllOf
     */
    'target'?: NameType;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'stack'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'details'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof EventAllOf
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof EventAllOf
     */
    'objects'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'operation'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'technicalName'?: string;
}
/**
 * Event
 * @export
 * @interface EventDocument
 */
export interface EventDocument {
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof EventDocument
     */
    '_type': DocumentType;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EventDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EventDocument
     */
    'synced'?: string | null;
    /**
     * The action that was performed
     * @type {string}
     * @memberof EventDocument
     */
    'action'?: string;
    /**
     * The type of event
     * @type {string}
     * @memberof EventDocument
     */
    'type'?: string;
    /**
     * 
     * @type {NameType}
     * @memberof EventDocument
     */
    'actor'?: NameType;
    /**
     * 
     * @type {NameType}
     * @memberof EventDocument
     */
    'target'?: NameType;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'stack'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'details'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof EventDocument
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof EventDocument
     */
    'objects'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'operation'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'technicalName'?: string;
}
/**
 * 
 * @export
 * @interface ExceptionAccessCriteria
 */
export interface ExceptionAccessCriteria {
    /**
     * 
     * @type {ExceptionCriteria}
     * @memberof ExceptionAccessCriteria
     */
    'leftCriteria'?: ExceptionCriteria;
    /**
     * 
     * @type {ExceptionCriteria}
     * @memberof ExceptionAccessCriteria
     */
    'rightCriteria'?: ExceptionCriteria;
}
/**
 * 
 * @export
 * @interface ExceptionCriteria
 */
export interface ExceptionCriteria {
    /**
     * List of exception criteria. There is a min of 1 and max of 50 items in the list.
     * @type {Array<ExceptionCriteriaCriteriaListInner>}
     * @memberof ExceptionCriteria
     */
    'criteriaList'?: Array<ExceptionCriteriaCriteriaListInner>;
}
/**
 * Access reference with addition of boolean existing flag to indicate whether the access was extant
 * @export
 * @interface ExceptionCriteriaAccess
 */
export interface ExceptionCriteriaAccess {
    /**
     * 
     * @type {DtoType}
     * @memberof ExceptionCriteriaAccess
     */
    'type'?: DtoType;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaAccess
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaAccess
     */
    'name'?: string;
    /**
     * Whether the subject identity already had that access or not
     * @type {boolean}
     * @memberof ExceptionCriteriaAccess
     */
    'existing'?: boolean;
}
/**
 * The types of objects supported for SOD violations
 * @export
 * @interface ExceptionCriteriaCriteriaListInner
 */
export interface ExceptionCriteriaCriteriaListInner {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'type'?: ExceptionCriteriaCriteriaListInnerTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'name'?: string;
    /**
     * Whether the subject identity already had that access or not
     * @type {boolean}
     * @memberof ExceptionCriteriaCriteriaListInner
     */
    'existing'?: boolean;
}

export const ExceptionCriteriaCriteriaListInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type ExceptionCriteriaCriteriaListInnerTypeEnum = typeof ExceptionCriteriaCriteriaListInnerTypeEnum[keyof typeof ExceptionCriteriaCriteriaListInnerTypeEnum];

/**
 * The current state of execution.
 * @export
 * @enum {string}
 */

export const ExecutionStatus = {
    Executing: 'EXECUTING',
    Verifying: 'VERIFYING',
    Terminated: 'TERMINATED',
    Completed: 'COMPLETED'
} as const;

export type ExecutionStatus = typeof ExecutionStatus[keyof typeof ExecutionStatus];


/**
 * 
 * @export
 * @interface ExpansionItem
 */
export interface ExpansionItem {
    /**
     * The ID of the account
     * @type {string}
     * @memberof ExpansionItem
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpansionItem
     */
    'cause'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ExpansionItem
     */
    'name'?: string;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof ExpansionItem
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * 
     * @type {AccountSource}
     * @memberof ExpansionItem
     */
    'source'?: AccountSource;
}
/**
 * 
 * @export
 * @interface Expression
 */
export interface Expression {
    /**
     * Operator for the expression
     * @type {string}
     * @memberof Expression
     */
    'operator'?: ExpressionOperatorEnum;
    /**
     * Name for the attribute
     * @type {string}
     * @memberof Expression
     */
    'attribute'?: string;
    /**
     * 
     * @type {Value}
     * @memberof Expression
     */
    'value'?: Value;
    /**
     * List of expressions
     * @type {Array<Value>}
     * @memberof Expression
     */
    'children'?: Array<Value> | null;
}

export const ExpressionOperatorEnum = {
    And: 'AND',
    Equals: 'EQUALS'
} as const;

export type ExpressionOperatorEnum = typeof ExpressionOperatorEnum[keyof typeof ExpressionOperatorEnum];

/**
 * 
 * @export
 * @interface FieldDetailsDto
 */
export interface FieldDetailsDto {
    /**
     * The name of the attribute.
     * @type {string}
     * @memberof FieldDetailsDto
     */
    'name'?: string;
    /**
     * The transform to apply to the field
     * @type {object}
     * @memberof FieldDetailsDto
     */
    'transform'?: object;
    /**
     * Attributes required for the transform
     * @type {object}
     * @memberof FieldDetailsDto
     */
    'attributes'?: object;
    /**
     * Flag indicating whether or not the attribute is required.
     * @type {boolean}
     * @memberof FieldDetailsDto
     */
    'isRequired'?: boolean;
    /**
     * The type of the attribute.
     * @type {string}
     * @memberof FieldDetailsDto
     */
    'type'?: string;
    /**
     * Flag indicating whether or not the attribute is multi-valued.
     * @type {boolean}
     * @memberof FieldDetailsDto
     */
    'isMultiValued'?: boolean;
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {FilterType}
     * @memberof Filter
     */
    'type'?: FilterType;
    /**
     * 
     * @type {Range}
     * @memberof Filter
     */
    'range'?: Range;
    /**
     * The terms to be filtered.
     * @type {Array<string>}
     * @memberof Filter
     */
    'terms'?: Array<string>;
    /**
     * Indicates if the filter excludes results.
     * @type {boolean}
     * @memberof Filter
     */
    'exclude'?: boolean;
}
/**
 * An additional filter to constrain the results of the search query.
 * @export
 * @interface FilterAggregation
 */
export interface FilterAggregation {
    /**
     * The name of the filter aggregate to be included in the result.
     * @type {string}
     * @memberof FilterAggregation
     */
    'name': string;
    /**
     * 
     * @type {SearchFilterType}
     * @memberof FilterAggregation
     */
    'type'?: SearchFilterType;
    /**
     * The search field to apply the filter to.  Prefix the field name with \'@\' to reference a nested object. 
     * @type {string}
     * @memberof FilterAggregation
     */
    'field': string;
    /**
     * The value to filter on.
     * @type {string}
     * @memberof FilterAggregation
     */
    'value': string;
}
/**
 * Enum representing the currently supported filter types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const FilterType = {
    Exists: 'EXISTS',
    Range: 'RANGE',
    Terms: 'TERMS'
} as const;

export type FilterType = typeof FilterType[keyof typeof FilterType];


/**
 * 
 * @export
 * @interface FirstValid
 */
export interface FirstValid {
    /**
     * An array of attributes to evaluate for existence.
     * @type {Array<object>}
     * @memberof FirstValid
     */
    'values': Array<object>;
    /**
     * a true or false value representing to move on to the next option if an error (like an Null Pointer Exception) were to occur.
     * @type {boolean}
     * @memberof FirstValid
     */
    'ignoreErrors'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof FirstValid
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface FormDetails
 */
export interface FormDetails {
    /**
     * ID of the form
     * @type {string}
     * @memberof FormDetails
     */
    'id'?: string;
    /**
     * Name of the form
     * @type {string}
     * @memberof FormDetails
     */
    'name'?: string;
    /**
     * The form title
     * @type {string}
     * @memberof FormDetails
     */
    'title'?: string;
    /**
     * The form subtitle.
     * @type {string}
     * @memberof FormDetails
     */
    'subtitle'?: string;
    /**
     * The name of the user that should be shown this form
     * @type {string}
     * @memberof FormDetails
     */
    'targetUser'?: string;
    /**
     * 
     * @type {SectionDetails}
     * @memberof FormDetails
     */
    'sections'?: SectionDetails;
}
/**
 * 
 * @export
 * @interface FormItemDetails
 */
export interface FormItemDetails {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof FormItemDetails
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ForwardApprovalDto
 */
export interface ForwardApprovalDto {
    /**
     * The Id of the new owner
     * @type {string}
     * @memberof ForwardApprovalDto
     */
    'newOwnerId': string;
    /**
     * The comment provided by the forwarder
     * @type {string}
     * @memberof ForwardApprovalDto
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface GenerateRandomString
 */
export interface GenerateRandomString {
    /**
     * This must always be set to \"Cloud Services Deployment Utility\"
     * @type {string}
     * @memberof GenerateRandomString
     */
    'name': string;
    /**
     * The operation to perform `generateRandomString`
     * @type {string}
     * @memberof GenerateRandomString
     */
    'operation': string;
    /**
     * This must be either \"true\" or \"false\" to indicate whether the generator logic should include numbers
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'includeNumbers': boolean;
    /**
     * This must be either \"true\" or \"false\" to indicate whether the generator logic should include special characters
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'includeSpecialChars': boolean;
    /**
     * This specifies how long the randomly generated string needs to be   >NOTE Due to identity attribute data constraints, the maximum allowable value is 450 characters 
     * @type {string}
     * @memberof GenerateRandomString
     */
    'length': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface GenericRule
 */
export interface GenericRule {
    /**
     * This is the name of the Generic rule that needs to be invoked by the transform
     * @type {string}
     * @memberof GenericRule
     */
    'name': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GenericRule
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * @type GetActiveCampaigns200ResponseInner
 * @export
 */
export type GetActiveCampaigns200ResponseInner = Campaign | SlimCampaign;

/**
 * 
 * @export
 * @interface GetOAuthClientResponse
 */
export interface GetOAuthClientResponse {
    /**
     * ID of the OAuth client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'id': string;
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'businessName': string | null;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'homepageUrl': string | null;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'name': string;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'description': string | null;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof GetOAuthClientResponse
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof GetOAuthClientResponse
     */
    'refreshTokenValiditySeconds': number;
    /**
     * A list of the approved redirect URIs used with the authorization_code flow
     * @type {Array<string>}
     * @memberof GetOAuthClientResponse
     */
    'redirectUris': Array<string> | null;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof GetOAuthClientResponse
     */
    'grantTypes': Array<GrantType>;
    /**
     * 
     * @type {AccessType}
     * @memberof GetOAuthClientResponse
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof GetOAuthClientResponse
     */
    'type': ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal to IDN
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'internal': boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'strongAuthSupported': boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'claimsSupported': boolean;
    /**
     * The date and time, down to the millisecond, when the API Client was created
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when the API Client was last updated
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'modified': string;
    /**
     * The date and time, down to the millisecond, when this API Client was last used to generate an access token. This timestamp does not get updated on every API Client usage, but only once a day. This property can be useful for identifying which API Clients are no longer actively used and can be removed.
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'lastUsed'?: string | null;
    /**
     * Scopes of the API Client.
     * @type {Array<string>}
     * @memberof GetOAuthClientResponse
     */
    'scope': Array<string> | null;
}
/**
 * 
 * @export
 * @interface GetPersonalAccessTokenResponse
 */
export interface GetPersonalAccessTokenResponse {
    /**
     * The ID of the personal access token (to be used as the username for Basic Auth).
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'id': string;
    /**
     * The name of the personal access token. Cannot be the same as other personal access tokens owned by a user.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'name': string;
    /**
     * Scopes of the personal  access token.
     * @type {Array<string>}
     * @memberof GetPersonalAccessTokenResponse
     */
    'scope': Array<string> | null;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof GetPersonalAccessTokenResponse
     */
    'owner': BaseReferenceDto;
    /**
     * The date and time, down to the millisecond, when this personal access token was created.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when this personal access token was last used to generate an access token. This timestamp does not get updated on every PAT usage, but only once a day. This property can be useful for identifying which PATs are no longer actively used and can be removed.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'lastUsed'?: string | null;
}
/**
 * 
 * @export
 * @interface GetReferenceIdentityAttribute
 */
export interface GetReferenceIdentityAttribute {
    /**
     * This must always be set to \"Cloud Services Deployment Utility\"
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'name': string;
    /**
     * The operation to perform `getReferenceIdentityAttribute`
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'operation': string;
    /**
     * This is the SailPoint User Name (uid) value of the identity whose attribute is desired  As a convenience feature, you can use the `manager` keyword to dynamically look up the user\'s manager and then get that manager\'s identity attribute. 
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'uid': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GetReferenceIdentityAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * OAuth2 Grant Type
 * @export
 * @enum {string}
 */

export const GrantType = {
    ClientCredentials: 'CLIENT_CREDENTIALS',
    AuthorizationCode: 'AUTHORIZATION_CODE',
    RefreshToken: 'REFRESH_TOKEN'
} as const;

export type GrantType = typeof GrantType[keyof typeof GrantType];


/**
 * 
 * @export
 * @interface ISO3166
 */
export interface ISO3166 {
    /**
     * An optional value to denote which ISO 3166 format to return. Valid values are:   `alpha2` - Two-character country code (e.g., \"US\"); this is the default value if no format is supplied   `alpha3` - Three-character country code (e.g., \"USA\")   `numeric` - The numeric country code (e.g., \"840\") 
     * @type {string}
     * @memberof ISO3166
     */
    'format'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof ISO3166
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof ISO3166
     */
    'input'?: { [key: string]: any; };
}
/**
 * @type IdentityAccess
 * @export
 */
export type IdentityAccess = AccessProfileEntitlement | AccessProfileRole | AccessProfileSummary;

/**
 * 
 * @export
 * @interface IdentityAttribute
 */
export interface IdentityAttribute {
    /**
     * The system (camel-cased) name of the identity attribute to bring in
     * @type {string}
     * @memberof IdentityAttribute
     */
    'name': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof IdentityAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof IdentityAttribute
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface IdentityAttribute1
 */
export interface IdentityAttribute1 {
    /**
     * The attribute key
     * @type {string}
     * @memberof IdentityAttribute1
     */
    'key'?: string;
    /**
     * Human-readable display name of the attribute
     * @type {string}
     * @memberof IdentityAttribute1
     */
    'name'?: string;
    /**
     * The attribute value
     * @type {string}
     * @memberof IdentityAttribute1
     */
    'value'?: string;
}
/**
 * Defines all the identity attribute mapping configurations. This defines how to generate or collect data for each identity attributes in identity refresh process.
 * @export
 * @interface IdentityAttributeConfig
 */
export interface IdentityAttributeConfig {
    /**
     * The backend will only promote values if the profile/mapping is enabled.
     * @type {boolean}
     * @memberof IdentityAttributeConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<IdentityAttributeTransform>}
     * @memberof IdentityAttributeConfig
     */
    'attributeTransforms'?: Array<IdentityAttributeTransform>;
}
/**
 * Defines a transformation definition for an identity attribute.
 * @export
 * @interface IdentityAttributeTransform
 */
export interface IdentityAttributeTransform {
    /**
     * Name of the identity attribute.
     * @type {string}
     * @memberof IdentityAttributeTransform
     */
    'identityAttributeName'?: string;
    /**
     * 
     * @type {TransformDefinition}
     * @memberof IdentityAttributeTransform
     */
    'transformDefinition'?: TransformDefinition;
}
/**
 * 
 * @export
 * @interface IdentityCertDecisionSummary
 */
export interface IdentityCertDecisionSummary {
    /**
     * Number of entitlement decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementDecisionsMade'?: number;
    /**
     * Number of access profile decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfileDecisionsMade'?: number;
    /**
     * Number of role decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'roleDecisionsMade'?: number;
    /**
     * Number of account decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountDecisionsMade'?: number;
    /**
     * The total number of entitlement decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementDecisionsTotal'?: number;
    /**
     * The total number of access profile decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfileDecisionsTotal'?: number;
    /**
     * The total number of role decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'roleDecisionsTotal'?: number;
    /**
     * The total number of account decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountDecisionsTotal'?: number;
    /**
     * The number of entitlement decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementsApproved'?: number;
    /**
     * The number of entitlement decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementsRevoked'?: number;
    /**
     * The number of access profile decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfilesApproved'?: number;
    /**
     * The number of access profile decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfilesRevoked'?: number;
    /**
     * The number of role decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'rolesApproved'?: number;
    /**
     * The number of role decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'rolesRevoked'?: number;
    /**
     * The number of account decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountsApproved'?: number;
    /**
     * The number of account decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountsRevoked'?: number;
}
/**
 * 
 * @export
 * @interface IdentityCertificationDto
 */
export interface IdentityCertificationDto {
    /**
     * id of the certification
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'id'?: string;
    /**
     * name of the certification
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'name'?: string;
    /**
     * 
     * @type {CampaignReference}
     * @memberof IdentityCertificationDto
     */
    'campaign'?: CampaignReference;
    /**
     * Have all decisions been made?
     * @type {boolean}
     * @memberof IdentityCertificationDto
     */
    'completed'?: boolean;
    /**
     * The number of identities for whom all decisions have been made and are complete.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'identitiesCompleted'?: number;
    /**
     * The total number of identities in the Certification, both complete and incomplete.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'identitiesTotal'?: number;
    /**
     * created date
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'created'?: string;
    /**
     * modified date
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'modified'?: string;
    /**
     * The number of approve/revoke/acknowledge decisions that have been made.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'decisionsMade'?: number;
    /**
     * The total number of approve/revoke/acknowledge decisions.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'decisionsTotal'?: number;
    /**
     * The due date of the certification.
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'due'?: string;
    /**
     * The date the reviewer signed off on the Certification.
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'signed'?: string | null;
    /**
     * 
     * @type {Reviewer}
     * @memberof IdentityCertificationDto
     */
    'reviewer'?: Reviewer;
    /**
     * 
     * @type {Reassignment}
     * @memberof IdentityCertificationDto
     */
    'reassignment'?: Reassignment | null;
    /**
     * Identifies if the certification has an error
     * @type {boolean}
     * @memberof IdentityCertificationDto
     */
    'hasErrors'?: boolean;
    /**
     * Description of the certification error
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'errorMessage'?: string | null;
    /**
     * 
     * @type {CertificationPhase}
     * @memberof IdentityCertificationDto
     */
    'phase'?: CertificationPhase;
}
/**
 * Identity
 * @export
 * @interface IdentityDocument
 */
export interface IdentityDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof IdentityDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof IdentityDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof IdentityDocument
     */
    '_type': DocumentType;
    /**
     * The display name of the identity
     * @type {string}
     * @memberof IdentityDocument
     */
    'displayName'?: string;
    /**
     * The first name of the identity
     * @type {string}
     * @memberof IdentityDocument
     */
    'firstName'?: string;
    /**
     * The last name of the identity
     * @type {string}
     * @memberof IdentityDocument
     */
    'lastName'?: string;
    /**
     * The identity\'s primary email address
     * @type {string}
     * @memberof IdentityDocument
     */
    'email'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocument
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocument
     */
    'synced'?: string | null;
    /**
     * The phone number of the identity
     * @type {string}
     * @memberof IdentityDocument
     */
    'phone'?: string;
    /**
     * Indicates if the identity is inactive
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'inactive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'protected'?: boolean;
    /**
     * The identity\'s status in SailPoint
     * @type {string}
     * @memberof IdentityDocument
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDocument
     */
    'employeeNumber'?: string;
    /**
     * 
     * @type {DisplayReference}
     * @memberof IdentityDocument
     */
    'manager'?: DisplayReference;
    /**
     * Indicates if this identity is a manager of other identities
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'isManager'?: boolean;
    /**
     * 
     * @type {Reference1}
     * @memberof IdentityDocument
     */
    'identityProfile'?: Reference1;
    /**
     * 
     * @type {Reference1}
     * @memberof IdentityDocument
     */
    'source'?: Reference1;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof IdentityDocument
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof IdentityDocument
     */
    'processingState'?: string | null;
    /**
     * 
     * @type {ProcessingDetails}
     * @memberof IdentityDocument
     */
    'processingDetails'?: ProcessingDetails;
    /**
     * List of accounts associated with the identity
     * @type {Array<BaseAccount>}
     * @memberof IdentityDocument
     */
    'accounts'?: Array<BaseAccount>;
    /**
     * Number of accounts associated with the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'accountCount'?: number;
    /**
     * The list of applications the identity has access to
     * @type {Array<App>}
     * @memberof IdentityDocument
     */
    'apps'?: Array<App>;
    /**
     * The number of applications the identity has access to
     * @type {number}
     * @memberof IdentityDocument
     */
    'appCount'?: number;
    /**
     * The list of access items assigned to the identity
     * @type {Array<IdentityAccess>}
     * @memberof IdentityDocument
     */
    'access'?: Array<IdentityAccess>;
    /**
     * The number of access items assigned to the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'accessCount'?: number;
    /**
     * The number of access profiles assigned to the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'accessProfileCount'?: number;
    /**
     * The number of entitlements assigned to the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'entitlementCount'?: number;
    /**
     * The number of roles assigned to the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'roleCount'?: number;
    /**
     * 
     * @type {Owns}
     * @memberof IdentityDocument
     */
    'owns'?: Owns;
    /**
     * 
     * @type {Array<string>}
     * @memberof IdentityDocument
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IdentityDocumentAllOf
 */
export interface IdentityDocumentAllOf {
    /**
     * The first name of the identity
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'firstName'?: string;
    /**
     * The last name of the identity
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'lastName'?: string;
    /**
     * The display name of the identity
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'displayName'?: string;
    /**
     * The identity\'s primary email address
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'email'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'synced'?: string | null;
    /**
     * The phone number of the identity
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'phone'?: string;
    /**
     * Indicates if the identity is inactive
     * @type {boolean}
     * @memberof IdentityDocumentAllOf
     */
    'inactive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IdentityDocumentAllOf
     */
    'protected'?: boolean;
    /**
     * The identity\'s status in SailPoint
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'employeeNumber'?: string;
    /**
     * 
     * @type {DisplayReference}
     * @memberof IdentityDocumentAllOf
     */
    'manager'?: DisplayReference;
    /**
     * Indicates if this identity is a manager of other identities
     * @type {boolean}
     * @memberof IdentityDocumentAllOf
     */
    'isManager'?: boolean;
    /**
     * 
     * @type {Reference1}
     * @memberof IdentityDocumentAllOf
     */
    'identityProfile'?: Reference1;
    /**
     * 
     * @type {Reference1}
     * @memberof IdentityDocumentAllOf
     */
    'source'?: Reference1;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof IdentityDocumentAllOf
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'processingState'?: string | null;
    /**
     * 
     * @type {ProcessingDetails}
     * @memberof IdentityDocumentAllOf
     */
    'processingDetails'?: ProcessingDetails;
    /**
     * List of accounts associated with the identity
     * @type {Array<BaseAccount>}
     * @memberof IdentityDocumentAllOf
     */
    'accounts'?: Array<BaseAccount>;
    /**
     * Number of accounts associated with the identity
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'accountCount'?: number;
    /**
     * The list of applications the identity has access to
     * @type {Array<App>}
     * @memberof IdentityDocumentAllOf
     */
    'apps'?: Array<App>;
    /**
     * The number of applications the identity has access to
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'appCount'?: number;
    /**
     * The list of access items assigned to the identity
     * @type {Array<IdentityAccess>}
     * @memberof IdentityDocumentAllOf
     */
    'access'?: Array<IdentityAccess>;
    /**
     * The number of access items assigned to the identity
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'accessCount'?: number;
    /**
     * The number of access profiles assigned to the identity
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'accessProfileCount'?: number;
    /**
     * The number of entitlements assigned to the identity
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'entitlementCount'?: number;
    /**
     * The number of roles assigned to the identity
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'roleCount'?: number;
    /**
     * 
     * @type {Owns}
     * @memberof IdentityDocumentAllOf
     */
    'owns'?: Owns;
    /**
     * 
     * @type {Array<string>}
     * @memberof IdentityDocumentAllOf
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IdentityExceptionReportReference
 */
export interface IdentityExceptionReportReference {
    /**
     * The id of the task result.
     * @type {string}
     * @memberof IdentityExceptionReportReference
     */
    'taskResultId'?: string;
    /**
     * The name of the report.
     * @type {string}
     * @memberof IdentityExceptionReportReference
     */
    'reportName'?: string;
}
/**
 * 
 * @export
 * @interface IdentityProfile
 */
export interface IdentityProfile {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'modified'?: string;
    /**
     * The description of the Identity Profile.
     * @type {string}
     * @memberof IdentityProfile
     */
    'description'?: string | null;
    /**
     * 
     * @type {IdentityProfileAllOfOwner}
     * @memberof IdentityProfile
     */
    'owner'?: IdentityProfileAllOfOwner | null;
    /**
     * The priority for an Identity Profile.
     * @type {number}
     * @memberof IdentityProfile
     */
    'priority'?: number;
    /**
     * 
     * @type {IdentityProfileAllOfAuthoritativeSource}
     * @memberof IdentityProfile
     */
    'authoritativeSource': IdentityProfileAllOfAuthoritativeSource;
    /**
     * True if a identity refresh is needed. Typically triggered when a change on the source has been made.
     * @type {boolean}
     * @memberof IdentityProfile
     */
    'identityRefreshRequired'?: boolean;
    /**
     * The number of identities that belong to the Identity Profile.
     * @type {number}
     * @memberof IdentityProfile
     */
    'identityCount'?: number;
    /**
     * 
     * @type {IdentityAttributeConfig}
     * @memberof IdentityProfile
     */
    'identityAttributeConfig'?: IdentityAttributeConfig;
    /**
     * 
     * @type {IdentityExceptionReportReference}
     * @memberof IdentityProfile
     */
    'identityExceptionReportReference'?: IdentityExceptionReportReference | null;
    /**
     * Indicates the value of requiresPeriodicRefresh attribute for the Identity Profile.
     * @type {boolean}
     * @memberof IdentityProfile
     */
    'hasTimeBasedAttr'?: boolean;
}
/**
 * 
 * @export
 * @interface IdentityProfileAllOf
 */
export interface IdentityProfileAllOf {
    /**
     * The description of the Identity Profile.
     * @type {string}
     * @memberof IdentityProfileAllOf
     */
    'description'?: string | null;
    /**
     * 
     * @type {IdentityProfileAllOfOwner}
     * @memberof IdentityProfileAllOf
     */
    'owner'?: IdentityProfileAllOfOwner | null;
    /**
     * The priority for an Identity Profile.
     * @type {number}
     * @memberof IdentityProfileAllOf
     */
    'priority'?: number;
    /**
     * 
     * @type {IdentityProfileAllOfAuthoritativeSource}
     * @memberof IdentityProfileAllOf
     */
    'authoritativeSource': IdentityProfileAllOfAuthoritativeSource;
    /**
     * True if a identity refresh is needed. Typically triggered when a change on the source has been made.
     * @type {boolean}
     * @memberof IdentityProfileAllOf
     */
    'identityRefreshRequired'?: boolean;
    /**
     * The number of identities that belong to the Identity Profile.
     * @type {number}
     * @memberof IdentityProfileAllOf
     */
    'identityCount'?: number;
    /**
     * 
     * @type {IdentityAttributeConfig}
     * @memberof IdentityProfileAllOf
     */
    'identityAttributeConfig'?: IdentityAttributeConfig;
    /**
     * 
     * @type {IdentityExceptionReportReference}
     * @memberof IdentityProfileAllOf
     */
    'identityExceptionReportReference'?: IdentityExceptionReportReference | null;
    /**
     * Indicates the value of requiresPeriodicRefresh attribute for the Identity Profile.
     * @type {boolean}
     * @memberof IdentityProfileAllOf
     */
    'hasTimeBasedAttr'?: boolean;
}
/**
 * 
 * @export
 * @interface IdentityProfileAllOfAuthoritativeSource
 */
export interface IdentityProfileAllOfAuthoritativeSource {
    /**
     * Type of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'type'?: IdentityProfileAllOfAuthoritativeSourceTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'name'?: string;
}

export const IdentityProfileAllOfAuthoritativeSourceTypeEnum = {
    Source: 'SOURCE'
} as const;

export type IdentityProfileAllOfAuthoritativeSourceTypeEnum = typeof IdentityProfileAllOfAuthoritativeSourceTypeEnum[keyof typeof IdentityProfileAllOfAuthoritativeSourceTypeEnum];

/**
 * The owner of the Identity Profile.
 * @export
 * @interface IdentityProfileAllOfOwner
 */
export interface IdentityProfileAllOfOwner {
    /**
     * Type of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'type'?: IdentityProfileAllOfOwnerTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'name'?: string;
}

export const IdentityProfileAllOfOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type IdentityProfileAllOfOwnerTypeEnum = typeof IdentityProfileAllOfOwnerTypeEnum[keyof typeof IdentityProfileAllOfOwnerTypeEnum];

/**
 * Identity Profile exported object
 * @export
 * @interface IdentityProfileExportedObject
 */
export interface IdentityProfileExportedObject {
    /**
     * Version or object from the target service.
     * @type {number}
     * @memberof IdentityProfileExportedObject
     */
    'version'?: number;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof IdentityProfileExportedObject
     */
    'self'?: BaseReferenceDto;
    /**
     * 
     * @type {IdentityProfile}
     * @memberof IdentityProfileExportedObject
     */
    'object'?: IdentityProfile;
}
/**
 * The manager for the identity.
 * @export
 * @interface IdentityReference
 */
export interface IdentityReference {
    /**
     * 
     * @type {DtoType}
     * @memberof IdentityReference
     */
    'type'?: DtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof IdentityReference
     */
    'id'?: string;
    /**
     * Human-readable display name of identity.
     * @type {string}
     * @memberof IdentityReference
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface IdentityReferenceWithNameAndEmail
 */
export interface IdentityReferenceWithNameAndEmail {
    /**
     * The type can only be IDENTITY. This is read-only
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'type'?: string;
    /**
     * Identity id.
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'id'?: string;
    /**
     * Human-readable display name of identity. This is read-only
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'name'?: string;
    /**
     * Email address of identity. This is read-only
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface IdentitySummary
 */
export interface IdentitySummary {
    /**
     * ID of this identity summary
     * @type {string}
     * @memberof IdentitySummary
     */
    'id'?: string;
    /**
     * Human-readable display name of identity
     * @type {string}
     * @memberof IdentitySummary
     */
    'name'?: string;
    /**
     * ID of the identity that this summary represents
     * @type {string}
     * @memberof IdentitySummary
     */
    'identityId'?: string;
    /**
     * Indicates if all access items for this summary have been decided on
     * @type {boolean}
     * @memberof IdentitySummary
     */
    'completed'?: boolean;
}
/**
 * An identity with a set of access to be added
 * @export
 * @interface IdentityWithNewAccess
 */
export interface IdentityWithNewAccess {
    /**
     * Identity id to be checked.
     * @type {string}
     * @memberof IdentityWithNewAccess
     */
    'identityId': string;
    /**
     * The list of ENTITLEMENTs to consider for calculating possible violations in a preventive check.
     * @type {Array<IdentityWithNewAccessAccessRefsInner>}
     * @memberof IdentityWithNewAccess
     */
    'accessRefs': Array<IdentityWithNewAccessAccessRefsInner>;
}
/**
 * An identity with a set of access to be added
 * @export
 * @interface IdentityWithNewAccess1
 */
export interface IdentityWithNewAccess1 {
    /**
     * Set of identity id\'s to be checked.
     * @type {string}
     * @memberof IdentityWithNewAccess1
     */
    'identityId': string;
    /**
     * The bundle of access profiles to be added to the identities specified. All references must be ENTITLEMENT type.
     * @type {Array<BaseReferenceDto>}
     * @memberof IdentityWithNewAccess1
     */
    'accessRefs': Array<BaseReferenceDto>;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on completion of the violation check.
     * @type {{ [key: string]: string; }}
     * @memberof IdentityWithNewAccess1
     */
    'clientMetadata'?: { [key: string]: string; };
}
/**
 * The types of objects supported for SOD violations
 * @export
 * @interface IdentityWithNewAccessAccessRefsInner
 */
export interface IdentityWithNewAccessAccessRefsInner {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof IdentityWithNewAccessAccessRefsInner
     */
    'type'?: IdentityWithNewAccessAccessRefsInnerTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityWithNewAccessAccessRefsInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityWithNewAccessAccessRefsInner
     */
    'name'?: string;
}

export const IdentityWithNewAccessAccessRefsInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type IdentityWithNewAccessAccessRefsInnerTypeEnum = typeof IdentityWithNewAccessAccessRefsInnerTypeEnum[keyof typeof IdentityWithNewAccessAccessRefsInnerTypeEnum];

/**
 * 
 * @export
 * @interface ImportNonEmployeeRecordsInBulkRequest
 */
export interface ImportNonEmployeeRecordsInBulkRequest {
    /**
     * 
     * @type {any}
     * @memberof ImportNonEmployeeRecordsInBulkRequest
     */
    'data': any;
}
/**
 * Enum representing the currently supported indices. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const Index = {
    Accessprofiles: 'accessprofiles',
    Accountactivities: 'accountactivities',
    Entitlements: 'entitlements',
    Events: 'events',
    Identities: 'identities',
    Roles: 'roles',
    Star: '*'
} as const;

export type Index = typeof Index[keyof typeof Index];


/**
 * 
 * @export
 * @interface IndexOf
 */
export interface IndexOf {
    /**
     * A substring to search for, searches the entire calling string, and returns the index of the first occurrence of the specified substring.
     * @type {string}
     * @memberof IndexOf
     */
    'substring': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof IndexOf
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof IndexOf
     */
    'input'?: { [key: string]: any; };
}
/**
 * Inner Hit query object that will cause the specified nested type to be returned as the result matching the supplied query.
 * @export
 * @interface InnerHit
 */
export interface InnerHit {
    /**
     * The search query using the Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL extended by SailPoint to support Nested queries.
     * @type {string}
     * @memberof InnerHit
     */
    'query': string;
    /**
     * The nested type to use in the inner hits query.  The nested type [Nested Type](https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html) refers to a document \"nested\" within another document. For example, an identity can have nested documents for access, accounts, and apps.
     * @type {string}
     * @memberof InnerHit
     */
    'type': string;
}
/**
 * A JSONPatch document as defined by [RFC 6902 - JSON Patch](https://tools.ietf.org/html/rfc6902)
 * @export
 * @interface JsonPatch
 */
export interface JsonPatch {
    /**
     * Operations to be applied
     * @type {Array<JsonPatchOperation>}
     * @memberof JsonPatch
     */
    'operations'?: Array<JsonPatchOperation>;
}
/**
 * A JSONPatch Operation as defined by [RFC 6902 - JSON Patch](https://tools.ietf.org/html/rfc6902)
 * @export
 * @interface JsonPatchOperation
 */
export interface JsonPatchOperation {
    /**
     * The operation to be performed
     * @type {string}
     * @memberof JsonPatchOperation
     */
    'op': JsonPatchOperationOpEnum;
    /**
     * A string JSON Pointer representing the target path to an element to be affected by the operation
     * @type {string}
     * @memberof JsonPatchOperation
     */
    'path': string;
    /**
     * 
     * @type {JsonPatchOperationValue}
     * @memberof JsonPatchOperation
     */
    'value'?: JsonPatchOperationValue;
}

export const JsonPatchOperationOpEnum = {
    Add: 'add',
    Remove: 'remove',
    Replace: 'replace',
    Move: 'move',
    Copy: 'copy',
    Test: 'test'
} as const;

export type JsonPatchOperationOpEnum = typeof JsonPatchOperationOpEnum[keyof typeof JsonPatchOperationOpEnum];

/**
 * The value to be used for the operation, required for \"add\" and \"replace\" operations
 * @export
 * @interface JsonPatchOperationValue
 */
export interface JsonPatchOperationValue {
}
/**
 * 
 * @export
 * @interface JsonPatchOperationValueAnyOfInner
 */
export interface JsonPatchOperationValueAnyOfInner {
}
/**
 * 
 * @export
 * @interface LeftPad
 */
export interface LeftPad {
    /**
     * An integer value for the desired length of the final output string
     * @type {string}
     * @memberof LeftPad
     */
    'length': string;
    /**
     * A string value representing the character that the incoming data should be padded with to get to the desired length   If not provided, the transform will default to a single space (\" \") character for padding 
     * @type {string}
     * @memberof LeftPad
     */
    'padding'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof LeftPad
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof LeftPad
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface LifecycleState
 */
export interface LifecycleState {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'modified'?: string;
    /**
     * Whether the lifecycle state is enabled or disabled.
     * @type {boolean}
     * @memberof LifecycleState
     */
    'enabled'?: boolean;
    /**
     * The technical name for lifecycle state. This is for internal use.
     * @type {string}
     * @memberof LifecycleState
     */
    'technicalName': string;
    /**
     * Lifecycle state description.
     * @type {string}
     * @memberof LifecycleState
     */
    'description'?: string;
    /**
     * Number of identities that have the lifecycle state.
     * @type {number}
     * @memberof LifecycleState
     */
    'identityCount'?: number;
    /**
     * 
     * @type {EmailNotificationOption}
     * @memberof LifecycleState
     */
    'emailNotificationOption'?: EmailNotificationOption;
    /**
     * 
     * @type {Array<AccountAction>}
     * @memberof LifecycleState
     */
    'accountActions'?: Array<AccountAction>;
    /**
     * List of unique access-profile IDs that are associated with the lifecycle state.
     * @type {Set<string>}
     * @memberof LifecycleState
     */
    'accessProfileIds'?: Set<string>;
}
/**
 * 
 * @export
 * @interface LifecycleStateAllOf
 */
export interface LifecycleStateAllOf {
    /**
     * Whether the lifecycle state is enabled or disabled.
     * @type {boolean}
     * @memberof LifecycleStateAllOf
     */
    'enabled'?: boolean;
    /**
     * The technical name for lifecycle state. This is for internal use.
     * @type {string}
     * @memberof LifecycleStateAllOf
     */
    'technicalName': string;
    /**
     * Lifecycle state description.
     * @type {string}
     * @memberof LifecycleStateAllOf
     */
    'description'?: string;
    /**
     * Number of identities that have the lifecycle state.
     * @type {number}
     * @memberof LifecycleStateAllOf
     */
    'identityCount'?: number;
    /**
     * 
     * @type {EmailNotificationOption}
     * @memberof LifecycleStateAllOf
     */
    'emailNotificationOption'?: EmailNotificationOption;
    /**
     * 
     * @type {Array<AccountAction>}
     * @memberof LifecycleStateAllOf
     */
    'accountActions'?: Array<AccountAction>;
    /**
     * List of unique access-profile IDs that are associated with the lifecycle state.
     * @type {Set<string>}
     * @memberof LifecycleStateAllOf
     */
    'accessProfileIds'?: Set<string>;
}
/**
 * 
 * @export
 * @interface ListAccessProfiles401Response
 */
export interface ListAccessProfiles401Response {
    /**
     * A message describing the error
     * @type {object}
     * @memberof ListAccessProfiles401Response
     */
    'error'?: object;
}
/**
 * 
 * @export
 * @interface ListAccessProfiles429Response
 */
export interface ListAccessProfiles429Response {
    /**
     * A message describing the error
     * @type {object}
     * @memberof ListAccessProfiles429Response
     */
    'message'?: object;
}
/**
 * An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const LocaleOrigin = {
    Default: 'DEFAULT',
    Request: 'REQUEST'
} as const;

export type LocaleOrigin = typeof LocaleOrigin[keyof typeof LocaleOrigin];


/**
 * 
 * @export
 * @interface Lookup
 */
export interface Lookup {
    /**
     * This is a JSON object of key-value pairs. The key is the string that will attempt to be matched to the input, and the value is the output string that should be returned if the key is matched   >**Note** the use of the optional default key value here; if none of the three countries in the above example match the input string, the transform will return \"Unknown Region\" for the attribute that is mapped to this transform. 
     * @type {{ [key: string]: any; }}
     * @memberof Lookup
     */
    'table': { [key: string]: any; };
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Lookup
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Lookup
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Lower
 */
export interface Lower {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Lower
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Lower
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ManagerCorrelationMapping
 */
export interface ManagerCorrelationMapping {
    /**
     * Name of the attribute to use for manager correlation. The value found on the account attribute will be used to lookup the manager\'s identity.
     * @type {string}
     * @memberof ManagerCorrelationMapping
     */
    'accountAttribute'?: string;
    /**
     * Name of the identity attribute to search when trying to find a manager using the value from the accountAttribute.
     * @type {string}
     * @memberof ManagerCorrelationMapping
     */
    'identityAttribute'?: string;
}
/**
 * 
 * @export
 * @interface ManualWorkItemDetails
 */
export interface ManualWorkItemDetails {
    /**
     * True if the request for this item was forwarded from one owner to another.
     * @type {boolean}
     * @memberof ManualWorkItemDetails
     */
    'forwarded'?: boolean;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof ManualWorkItemDetails
     */
    'originalOwner'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof ManualWorkItemDetails
     */
    'currentOwner'?: BaseReferenceDto;
    /**
     * Time at which item was modified.
     * @type {string}
     * @memberof ManualWorkItemDetails
     */
    'modified'?: string;
    /**
     * 
     * @type {ManualWorkItemState}
     * @memberof ManualWorkItemDetails
     */
    'status'?: ManualWorkItemState;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof ManualWorkItemDetails
     */
    'forwardHistory'?: Array<ApprovalForwardHistory>;
}
/**
 * Indicates the state of the request processing for this item: * PENDING: The request for this item is awaiting processing. * APPROVED: The request for this item has been approved. * REJECTED: The request for this item was rejected. * EXPIRED: The request for this item expired with no action taken. * CANCELLED: The request for this item was cancelled with no user action. * ARCHIVED: The request for this item has been archived after completion.
 * @export
 * @enum {string}
 */

export const ManualWorkItemState = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED',
    Archived: 'ARCHIVED'
} as const;

export type ManualWorkItemState = typeof ManualWorkItemState[keyof typeof ManualWorkItemState];


/**
 * The calculation done on the results of the query
 * @export
 * @interface MetricAggregation
 */
export interface MetricAggregation {
    /**
     * The name of the metric aggregate to be included in the result. If the metric aggregation is omitted, the resulting aggregation will be a count of the documents in the search results.
     * @type {string}
     * @memberof MetricAggregation
     */
    'name': string;
    /**
     * 
     * @type {MetricType}
     * @memberof MetricAggregation
     */
    'type'?: MetricType;
    /**
     * The field the calculation is performed on.  Prefix the field name with \'@\' to reference a nested object. 
     * @type {string}
     * @memberof MetricAggregation
     */
    'field': string;
}
/**
 * Enum representing the currently supported metric aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const MetricType = {
    Count: 'COUNT',
    UniqueCount: 'UNIQUE_COUNT',
    Avg: 'AVG',
    Sum: 'SUM',
    Median: 'MEDIAN',
    Min: 'MIN',
    Max: 'MAX'
} as const;

export type MetricType = typeof MetricType[keyof typeof MetricType];


/**
 * 
 * @export
 * @interface MultiPolicyRequest
 */
export interface MultiPolicyRequest {
    /**
     * Multi-policy report will be run for this list of ids
     * @type {Array<string>}
     * @memberof MultiPolicyRequest
     */
    'filteredPolicyList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NameNormalizer
 */
export interface NameNormalizer {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof NameNormalizer
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof NameNormalizer
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface NameType
 */
export interface NameType {
    /**
     * the actor or target name
     * @type {string}
     * @memberof NameType
     */
    'name'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof NameType
     */
    'type'?: DtoType;
}
/**
 * | Construct       | Date Time Pattern | Description | | ---------       | ----------------- | ----------- | | ISO8601         | `yyyy-MM-dd\'T\'HH:mm:ss.SSSX` | The ISO8601 standard. |           | LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    | | PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. | | EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. | | EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. | 
 * @export
 * @enum {string}
 */

export const NamedConstructs = {
    Iso8601: 'ISO8601',
    Ldap: 'LDAP',
    PeopleSoft: 'PEOPLE_SOFT',
    EpochTimeJava: 'EPOCH_TIME_JAVA',
    EpochTimeWin32: 'EPOCH_TIME_WIN32'
} as const;

export type NamedConstructs = typeof NamedConstructs[keyof typeof NamedConstructs];


/**
 * The nested aggregation object.
 * @export
 * @interface NestedAggregation
 */
export interface NestedAggregation {
    /**
     * The name of the nested aggregate to be included in the result.
     * @type {string}
     * @memberof NestedAggregation
     */
    'name': string;
    /**
     * The type of the nested object.
     * @type {string}
     * @memberof NestedAggregation
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalDecision
 */
export interface NonEmployeeApprovalDecision {
    /**
     * Comment on the approval item.
     * @type {string}
     * @memberof NonEmployeeApprovalDecision
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItem
 */
export interface NonEmployeeApprovalItem {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItem
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItem
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItem
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeRequestLite}
     * @memberof NonEmployeeApprovalItem
     */
    'nonEmployeeRequest'?: NonEmployeeRequestLite;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemAllOf
 */
export interface NonEmployeeApprovalItemAllOf {
    /**
     * 
     * @type {NonEmployeeRequestLite}
     * @memberof NonEmployeeApprovalItemAllOf
     */
    'nonEmployeeRequest'?: NonEmployeeRequestLite;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemBase
 */
export interface NonEmployeeApprovalItemBase {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemDetail
 */
export interface NonEmployeeApprovalItemDetail {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeRequestWithoutApprovalItem}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'nonEmployeeRequest'?: NonEmployeeRequestWithoutApprovalItem;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemDetailAllOf
 */
export interface NonEmployeeApprovalItemDetailAllOf {
    /**
     * 
     * @type {NonEmployeeRequestWithoutApprovalItem}
     * @memberof NonEmployeeApprovalItemDetailAllOf
     */
    'nonEmployeeRequest'?: NonEmployeeRequestWithoutApprovalItem;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalSummary
 */
export interface NonEmployeeApprovalSummary {
    /**
     * The number of approved non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'approved'?: number;
    /**
     * The number of pending non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'pending'?: number;
    /**
     * The number of rejected non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'rejected'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeBulkUploadJob
 */
export interface NonEmployeeBulkUploadJob {
    /**
     * The bulk upload job\'s ID. (UUID)
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'id'?: string;
    /**
     * The ID of the source to bulk-upload non-employees to. (UUID)
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'sourceId'?: string;
    /**
     * The date-time the job was submitted.
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'created'?: string;
    /**
     * The date-time that the job was last updated.
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'modified'?: string;
    /**
     * Returns the following values indicating the progress or result of the bulk upload job. \"PENDING\" means the job is queued and waiting to be processed. \"IN_PROGRESS\" means the job is currently being processed. \"COMPLETED\" means the job has been completed without any errors. \"ERROR\" means the job failed to process with errors. 
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'status'?: NonEmployeeBulkUploadJobStatusEnum;
}

export const NonEmployeeBulkUploadJobStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
} as const;

export type NonEmployeeBulkUploadJobStatusEnum = typeof NonEmployeeBulkUploadJobStatusEnum[keyof typeof NonEmployeeBulkUploadJobStatusEnum];

/**
 * 
 * @export
 * @interface NonEmployeeBulkUploadStatus
 */
export interface NonEmployeeBulkUploadStatus {
    /**
     * Returns the following values indicating the progress or result of the bulk upload job. \"PENDING\" means the job is queued and waiting to be processed. \"IN_PROGRESS\" means the job is currently being processed. \"COMPLETED\" means the job has been completed without any errors. \"ERROR\" means the job failed to process with errors. null means job has been submitted to the source. 
     * @type {string}
     * @memberof NonEmployeeBulkUploadStatus
     */
    'status'?: NonEmployeeBulkUploadStatusStatusEnum;
}

export const NonEmployeeBulkUploadStatusStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
} as const;

export type NonEmployeeBulkUploadStatusStatusEnum = typeof NonEmployeeBulkUploadStatusStatusEnum[keyof typeof NonEmployeeBulkUploadStatusStatusEnum];

/**
 * Identifies if the identity is a normal identity or a governance group
 * @export
 * @enum {string}
 */

export const NonEmployeeIdentityDtoType = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type NonEmployeeIdentityDtoType = typeof NonEmployeeIdentityDtoType[keyof typeof NonEmployeeIdentityDtoType];


/**
 * 
 * @export
 * @interface NonEmployeeIdentityReferenceWithId
 */
export interface NonEmployeeIdentityReferenceWithId {
    /**
     * 
     * @type {NonEmployeeIdentityDtoType}
     * @memberof NonEmployeeIdentityReferenceWithId
     */
    'type'?: NonEmployeeIdentityDtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof NonEmployeeIdentityReferenceWithId
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeIdnUserRequest
 */
export interface NonEmployeeIdnUserRequest {
    /**
     * Identity id.
     * @type {string}
     * @memberof NonEmployeeIdnUserRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRecord
 */
export interface NonEmployeeRecord {
    /**
     * Non-Employee record id.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'id'?: string;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'manager'?: string;
    /**
     * Non-Employee\'s source id.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'sourceId'?: string;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRecord
     */
    'data'?: { [key: string]: string; };
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRejectApprovalDecision
 */
export interface NonEmployeeRejectApprovalDecision {
    /**
     * Comment on the approval item.
     * @type {string}
     * @memberof NonEmployeeRejectApprovalDecision
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequest
 */
export interface NonEmployeeRequest {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'description'?: string;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLite}
     * @memberof NonEmployeeRequest
     */
    'nonEmployeeSource'?: NonEmployeeSourceLite;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequest
     */
    'data'?: { [key: string]: string; };
    /**
     * List of approval item for the request
     * @type {Array<NonEmployeeApprovalItemBase>}
     * @memberof NonEmployeeRequest
     */
    'approvalItems'?: Array<NonEmployeeApprovalItemBase>;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequest
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestAllOf
 */
export interface NonEmployeeRequestAllOf {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLite}
     * @memberof NonEmployeeRequestAllOf
     */
    'nonEmployeeSource'?: NonEmployeeSourceLite;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestAllOf
     */
    'data'?: { [key: string]: string; };
    /**
     * List of approval item for the request
     * @type {Array<NonEmployeeApprovalItemBase>}
     * @memberof NonEmployeeRequestAllOf
     */
    'approvalItems'?: Array<NonEmployeeApprovalItemBase>;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequestAllOf
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestBody
 */
export interface NonEmployeeRequestBody {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'accountName': string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'firstName': string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'lastName': string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'email': string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'phone': string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'manager': string;
    /**
     * Non-Employee\'s source id.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'sourceId': string;
    /**
     * Attribute blob/bag for a non-employee, 10 attributes is the maximum size supported.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestBody
     */
    'data'?: { [key: string]: string; };
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'startDate': string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'endDate': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestLite
 */
export interface NonEmployeeRequestLite {
    /**
     * Non-Employee request id.
     * @type {string}
     * @memberof NonEmployeeRequestLite
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeRequestLite
     */
    'requester'?: NonEmployeeIdentityReferenceWithId;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestSummary
 */
export interface NonEmployeeRequestSummary {
    /**
     * The number of approved non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'approved'?: number;
    /**
     * The number of rejected non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'rejected'?: number;
    /**
     * The number of pending non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'pending'?: number;
    /**
     * The number of non-employee records on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'nonEmployeeCount'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestWithoutApprovalItem
 */
export interface NonEmployeeRequestWithoutApprovalItem {
    /**
     * Non-Employee request id.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'requester'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLiteWithSchemaAttributes}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'nonEmployeeSource'?: NonEmployeeSourceLiteWithSchemaAttributes;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestWithoutApprovalItemAllOf
 */
export interface NonEmployeeRequestWithoutApprovalItemAllOf {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLiteWithSchemaAttributes}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'nonEmployeeSource'?: NonEmployeeSourceLiteWithSchemaAttributes;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSchemaAttribute
 */
export interface NonEmployeeSchemaAttribute {
    /**
     * Schema Attribute Id
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'id'?: string;
    /**
     * True if this schema attribute is mandatory on all non-employees sources.
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttribute
     */
    'system'?: boolean;
    /**
     * When the schema attribute was last modified.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'modified'?: string;
    /**
     * When the schema attribute was created.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeSchemaAttributeType}
     * @memberof NonEmployeeSchemaAttribute
     */
    'type': NonEmployeeSchemaAttributeType;
    /**
     * Label displayed on the UI for this schema attribute.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'label': string;
    /**
     * The technical name of the attribute. Must be unique per source.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'technicalName': string;
    /**
     * help text displayed by UI.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'helpText'?: string;
    /**
     * Hint text that fills UI box.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'placeholder'?: string;
    /**
     * If true, the schema attribute is required for all non-employees in the source
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttribute
     */
    'required'?: boolean;
}
/**
 * 
 * @export
 * @interface NonEmployeeSchemaAttributeBody
 */
export interface NonEmployeeSchemaAttributeBody {
    /**
     * Type of the attribute. Only type \'TEXT\' is supported for custom attributes.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'type': string;
    /**
     * Label displayed on the UI for this schema attribute.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'label': string;
    /**
     * The technical name of the attribute. Must be unique per source.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'technicalName': string;
    /**
     * help text displayed by UI.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'helpText'?: string;
    /**
     * Hint text that fills UI box.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'placeholder'?: string;
    /**
     * If true, the schema attribute is required for all non-employees in the source
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'required'?: boolean;
}
/**
 * Enum representing the type of data a schema attribute accepts.
 * @export
 * @enum {string}
 */

export const NonEmployeeSchemaAttributeType = {
    Text: 'TEXT',
    Date: 'DATE',
    Identity: 'IDENTITY'
} as const;

export type NonEmployeeSchemaAttributeType = typeof NonEmployeeSchemaAttributeType[keyof typeof NonEmployeeSchemaAttributeType];


/**
 * 
 * @export
 * @interface NonEmployeeSource
 */
export interface NonEmployeeSource {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSource
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSource
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceAllOf
 */
export interface NonEmployeeSourceAllOf {
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceAllOf
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceAllOf
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceAllOf
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceAllOf
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLite
 */
export interface NonEmployeeSourceLite {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLiteWithSchemaAttributes
 */
export interface NonEmployeeSourceLiteWithSchemaAttributes {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'description'?: string;
    /**
     * List of schema attributes associated with this non-employee source.
     * @type {Array<NonEmployeeSchemaAttribute>}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'schemaAttributes'?: Array<NonEmployeeSchemaAttribute>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLiteWithSchemaAttributesAllOf
 */
export interface NonEmployeeSourceLiteWithSchemaAttributesAllOf {
    /**
     * List of schema attributes associated with this non-employee source.
     * @type {Array<NonEmployeeSchemaAttribute>}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributesAllOf
     */
    'schemaAttributes'?: Array<NonEmployeeSchemaAttribute>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceRequestBody
 */
export interface NonEmployeeSourceRequestBody {
    /**
     * Name of non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'name': string;
    /**
     * Description of non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'description': string;
    /**
     * 
     * @type {NonEmployeeIdnUserRequest}
     * @memberof NonEmployeeSourceRequestBody
     */
    'owner': NonEmployeeIdnUserRequest;
    /**
     * The ID for the management workgroup that contains source sub-admins
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'managementWorkgroup'?: string;
    /**
     * List of approvers.
     * @type {Array<NonEmployeeIdnUserRequest>}
     * @memberof NonEmployeeSourceRequestBody
     */
    'approvers'?: Array<NonEmployeeIdnUserRequest>;
    /**
     * List of account managers.
     * @type {Array<NonEmployeeIdnUserRequest>}
     * @memberof NonEmployeeSourceRequestBody
     */
    'accountManagers'?: Array<NonEmployeeIdnUserRequest>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithCloudExternalId
 */
export interface NonEmployeeSourceWithCloudExternalId {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'created'?: string;
    /**
     * Legacy ID used for sources from the V1 API. This attribute will be removed from a future version of the API and will not be considered a breaking change. No clients should rely on this ID always being present.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'cloudExternalId'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithCloudExternalIdAllOf
 */
export interface NonEmployeeSourceWithCloudExternalIdAllOf {
    /**
     * Legacy ID used for sources from the V1 API. This attribute will be removed from a future version of the API and will not be considered a breaking change. No clients should rely on this ID always being present.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalIdAllOf
     */
    'cloudExternalId'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithNECount
 */
export interface NonEmployeeSourceWithNECount {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithNECount
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithNECount
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'created'?: string;
    /**
     * Number of non-employee records associated with this source.
     * @type {number}
     * @memberof NonEmployeeSourceWithNECount
     */
    'nonEmployeeCount'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithNECountAllOf
 */
export interface NonEmployeeSourceWithNECountAllOf {
    /**
     * Number of non-employee records associated with this source.
     * @type {number}
     * @memberof NonEmployeeSourceWithNECountAllOf
     */
    'nonEmployeeCount'?: number;
}
/**
 * Response model for import of a single object.
 * @export
 * @interface ObjectImportResult
 */
export interface ObjectImportResult {
    /**
     * Informational messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'infos': Array<SpConfigMessage>;
    /**
     * Warning messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'warnings': Array<SpConfigMessage>;
    /**
     * Error messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'errors': Array<SpConfigMessage>;
    /**
     * References to objects that were created or updated by the import.
     * @type {Array<BaseReferenceDto>}
     * @memberof ObjectImportResult
     */
    'importedObjects': Array<BaseReferenceDto>;
}
/**
 * 
 * @export
 * @interface OriginalRequest
 */
export interface OriginalRequest {
    /**
     * the account id
     * @type {string}
     * @memberof OriginalRequest
     */
    'accountId'?: string;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof OriginalRequest
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * the operation that was used
     * @type {string}
     * @memberof OriginalRequest
     */
    'op'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof OriginalRequest
     */
    'source'?: AccountSource;
}
/**
 * 
 * @export
 * @interface Owner
 */
export interface Owner {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof Owner
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof Owner
     */
    'name'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof Owner
     */
    'type'?: DtoType;
    /**
     * The email of the identity
     * @type {string}
     * @memberof Owner
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface OwnerAllOf
 */
export interface OwnerAllOf {
    /**
     * The email of the identity
     * @type {string}
     * @memberof OwnerAllOf
     */
    'email'?: string;
}
/**
 * The owner of this object.
 * @export
 * @interface OwnerReference
 */
export interface OwnerReference {
    /**
     * 
     * @type {DtoType}
     * @memberof OwnerReference
     */
    'type'?: DtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof OwnerReference
     */
    'id'?: string;
    /**
     * Human-readable display name of the owner. It may be left null or omitted in a POST or PATCH. If set, it must match the current value of the owner\'s display name, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof OwnerReference
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Owns
 */
export interface Owns {
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'sources'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'entitlements'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'accessProfiles'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'roles'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'apps'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'governanceGroups'?: Array<Reference1>;
    /**
     * 
     * @type {boolean}
     * @memberof Owns
     */
    'fallbackApprover'?: boolean;
}
/**
 * 
 * @export
 * @interface PasswordChangeRequest
 */
export interface PasswordChangeRequest {
    /**
     * The identity ID that requested the password change
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'identityId'?: string;
    /**
     * The RSA encrypted password
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'encryptedPassword'?: string;
    /**
     * The encryption key ID
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'publicKeyId'?: string;
    /**
     * Account ID of the account This is specified per account schema in the source configuration. It is used to distinguish accounts. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-ID-for-a/ta-p/80350
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'accountId'?: string;
    /**
     * The ID of the source for which identity is requesting the password change
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'sourceId'?: string;
}
/**
 * 
 * @export
 * @interface PasswordChangeResponse
 */
export interface PasswordChangeResponse {
    /**
     * The password change request ID
     * @type {string}
     * @memberof PasswordChangeResponse
     */
    'requestId'?: string | null;
    /**
     * Password change state
     * @type {string}
     * @memberof PasswordChangeResponse
     */
    'state'?: PasswordChangeResponseStateEnum;
}

export const PasswordChangeResponseStateEnum = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
} as const;

export type PasswordChangeResponseStateEnum = typeof PasswordChangeResponseStateEnum[keyof typeof PasswordChangeResponseStateEnum];

/**
 * 
 * @export
 * @interface PasswordInfo
 */
export interface PasswordInfo {
    /**
     * Identity ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'identityId'?: string;
    /**
     * source ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'sourceId'?: string;
    /**
     * public key ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'publicKeyId'?: string;
    /**
     * User\'s public key with Base64 encoding
     * @type {string}
     * @memberof PasswordInfo
     */
    'publicKey'?: string;
    /**
     * Account info related to queried identity and source
     * @type {Array<PasswordInfoAccount>}
     * @memberof PasswordInfo
     */
    'accounts'?: Array<PasswordInfoAccount>;
    /**
     * Password constraints
     * @type {Array<string>}
     * @memberof PasswordInfo
     */
    'policies'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PasswordInfoAccount
 */
export interface PasswordInfoAccount {
    /**
     * Account ID of the account. This is specified per account schema in the source configuration. It is used to distinguish accounts. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-ID-for-a/ta-p/80350
     * @type {string}
     * @memberof PasswordInfoAccount
     */
    'accountId'?: string;
    /**
     * Display name of the account. This is specified per account schema in the source configuration. It is used to display name of the account. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-Name-for/ta-p/74008
     * @type {string}
     * @memberof PasswordInfoAccount
     */
    'accountName'?: string;
}
/**
 * 
 * @export
 * @interface PasswordInfoQueryDTO
 */
export interface PasswordInfoQueryDTO {
    /**
     * The login name of the user
     * @type {string}
     * @memberof PasswordInfoQueryDTO
     */
    'userName'?: string;
    /**
     * The display name of the source
     * @type {string}
     * @memberof PasswordInfoQueryDTO
     */
    'sourceName'?: string;
}
/**
 * 
 * @export
 * @interface PasswordOrgConfig
 */
export interface PasswordOrgConfig {
    /**
     * Indicator whether custom password instructions feature is enabled. The default value is false.
     * @type {boolean}
     * @memberof PasswordOrgConfig
     */
    'customInstructionsEnabled'?: boolean;
    /**
     * Indicator whether \"digit token\" feature is enabled. The default value is false.
     * @type {boolean}
     * @memberof PasswordOrgConfig
     */
    'digitTokenEnabled'?: boolean;
    /**
     * The duration of \"digit token\" in minutes. The default value is 5.
     * @type {number}
     * @memberof PasswordOrgConfig
     */
    'digitTokenDurationMinutes'?: number;
    /**
     * The length of \"digit token\". The default value is 6.
     * @type {number}
     * @memberof PasswordOrgConfig
     */
    'digitTokenLength'?: number;
}
/**
 * 
 * @export
 * @interface PasswordStatus
 */
export interface PasswordStatus {
    /**
     * The password change request ID
     * @type {string}
     * @memberof PasswordStatus
     */
    'requestId'?: string | null;
    /**
     * Password change state
     * @type {string}
     * @memberof PasswordStatus
     */
    'state'?: PasswordStatusStateEnum;
    /**
     * The errors during the password change request
     * @type {Array<string>}
     * @memberof PasswordStatus
     */
    'errors'?: Array<string>;
    /**
     * List of source IDs in the password change request
     * @type {Array<string>}
     * @memberof PasswordStatus
     */
    'sourceIds'?: Array<string>;
}

export const PasswordStatusStateEnum = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
} as const;

export type PasswordStatusStateEnum = typeof PasswordStatusStateEnum[keyof typeof PasswordStatusStateEnum];

/**
 * 
 * @export
 * @interface PasswordSyncGroup
 */
export interface PasswordSyncGroup {
    /**
     * ID of the sync group
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'id'?: string;
    /**
     * Name of the sync group
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'name'?: string;
    /**
     * ID of the password policy
     * @type {string}
     * @memberof PasswordSyncGroup
     */
    'passwordPolicyId'?: string;
    /**
     * List of password managed sources IDs
     * @type {Array<string>}
     * @memberof PasswordSyncGroup
     */
    'sourceIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PendingApproval
 */
export interface PendingApproval {
    /**
     * The approval id.
     * @type {string}
     * @memberof PendingApproval
     */
    'id'?: string;
    /**
     * The name of the approval.
     * @type {string}
     * @memberof PendingApproval
     */
    'name'?: string;
    /**
     * When the approval was created.
     * @type {string}
     * @memberof PendingApproval
     */
    'created'?: string;
    /**
     * When the approval was modified last time.
     * @type {string}
     * @memberof PendingApproval
     */
    'modified'?: string;
    /**
     * When the access-request was created.
     * @type {string}
     * @memberof PendingApproval
     */
    'requestCreated'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof PendingApproval
     */
    'requestType'?: AccessRequestType;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof PendingApproval
     */
    'requester'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof PendingApproval
     */
    'requestedFor'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof PendingApproval
     */
    'owner'?: BaseReferenceDto;
    /**
     * 
     * @type {RequestableObjectReference}
     * @memberof PendingApproval
     */
    'requestedObject'?: RequestableObjectReference;
    /**
     * 
     * @type {CommentDto}
     * @memberof PendingApproval
     */
    'requesterComment'?: CommentDto;
    /**
     * The history of the previous reviewers comments.
     * @type {Array<CommentDto>}
     * @memberof PendingApproval
     */
    'previousReviewersComments'?: Array<CommentDto>;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof PendingApproval
     */
    'forwardHistory'?: Array<ApprovalForwardHistory>;
    /**
     * When true the rejector has to provide comments when rejecting
     * @type {boolean}
     * @memberof PendingApproval
     */
    'commentRequiredWhenRejected'?: boolean;
    /**
     * 
     * @type {PendingApprovalAction}
     * @memberof PendingApproval
     */
    'actionInProcess'?: PendingApprovalAction;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof PendingApproval
     */
    'removeDate'?: string;
    /**
     * If true, then the request is to change the remove date or sunset date.
     * @type {boolean}
     * @memberof PendingApproval
     */
    'removeDateUpdateRequested'?: boolean;
    /**
     * The remove date or sunset date that was assigned at the time of the request.
     * @type {string}
     * @memberof PendingApproval
     */
    'currentRemoveDate'?: string;
    /**
     * 
     * @type {SodViolationContextCheckCompleted}
     * @memberof PendingApproval
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted;
}
/**
 * Enum represents action that is being processed on an approval.
 * @export
 * @enum {string}
 */

export const PendingApprovalAction = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Forwarded: 'FORWARDED'
} as const;

export type PendingApprovalAction = typeof PendingApprovalAction[keyof typeof PendingApprovalAction];


/**
 * Simplified DTO for the Permission objects stored in SailPoint\'s database. The data is aggregated from customer systems and is free-form, so its appearance can vary largely between different clients/customers.
 * @export
 * @interface PermissionDto
 */
export interface PermissionDto {
    /**
     * All the rights (e.g. actions) that this permission allows on the target
     * @type {Array<string>}
     * @memberof PermissionDto
     */
    'rights'?: Array<string>;
    /**
     * The target the permission would grants rights on.
     * @type {string}
     * @memberof PermissionDto
     */
    'target'?: string;
}
/**
 * Provides additional details about the pre-approval trigger for this request.
 * @export
 * @interface PreApprovalTriggerDetails
 */
export interface PreApprovalTriggerDetails {
    /**
     * Comment left for the pre-approval decision
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'comment'?: string;
    /**
     * The reviewer of the pre-approval decision
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'reviewer'?: string;
    /**
     * The decision of the pre-approval trigger
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'decision'?: PreApprovalTriggerDetailsDecisionEnum;
}

export const PreApprovalTriggerDetailsDecisionEnum = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type PreApprovalTriggerDetailsDecisionEnum = typeof PreApprovalTriggerDetailsDecisionEnum[keyof typeof PreApprovalTriggerDetailsDecisionEnum];

/**
 * 
 * @export
 * @interface ProcessingDetails
 */
export interface ProcessingDetails {
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof ProcessingDetails
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'stage'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProcessingDetails
     */
    'retryCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'stackTrace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'message'?: string;
}
/**
 * Specification of a Service Desk integration provisioning configuration.
 * @export
 * @interface ProvisioningConfig
 */
export interface ProvisioningConfig {
    /**
     * Specifies whether this configuration is used to manage provisioning requests for all sources from the org.  If true, no managedResourceRefs are allowed.
     * @type {boolean}
     * @memberof ProvisioningConfig
     */
    'universalManager'?: boolean;
    /**
     * References to sources for the Service Desk integration template.  May only be specified if universalManager is false.
     * @type {Array<ProvisioningConfigManagedResourceRefsInner>}
     * @memberof ProvisioningConfig
     */
    'managedResourceRefs'?: Array<ProvisioningConfigManagedResourceRefsInner>;
    /**
     * 
     * @type {ProvisioningConfigPlanInitializerScript}
     * @memberof ProvisioningConfig
     */
    'planInitializerScript'?: ProvisioningConfigPlanInitializerScript;
    /**
     * Name of an attribute that when true disables the saving of ProvisioningRequest objects whenever plans are sent through this integration.
     * @type {boolean}
     * @memberof ProvisioningConfig
     */
    'noProvisioningRequests'?: boolean;
    /**
     * When saving pending requests is enabled, this defines the number of hours the request is allowed to live before it is considered expired and no longer affects plan compilation.
     * @type {number}
     * @memberof ProvisioningConfig
     */
    'provisioningRequestExpiration'?: number;
}
/**
 * 
 * @export
 * @interface ProvisioningConfigManagedResourceRefsInner
 */
export interface ProvisioningConfigManagedResourceRefsInner {
    /**
     * The type of object being referenced
     * @type {object}
     * @memberof ProvisioningConfigManagedResourceRefsInner
     */
    'type'?: ProvisioningConfigManagedResourceRefsInnerTypeEnum;
    /**
     * ID of the source
     * @type {object}
     * @memberof ProvisioningConfigManagedResourceRefsInner
     */
    'id'?: object;
    /**
     * Human-readable display name of the source
     * @type {object}
     * @memberof ProvisioningConfigManagedResourceRefsInner
     */
    'name'?: object;
}

export const ProvisioningConfigManagedResourceRefsInnerTypeEnum = {
    Source: 'SOURCE'
} as const;

export type ProvisioningConfigManagedResourceRefsInnerTypeEnum = typeof ProvisioningConfigManagedResourceRefsInnerTypeEnum[keyof typeof ProvisioningConfigManagedResourceRefsInnerTypeEnum];

/**
 * This is a reference to a plan initializer script.
 * @export
 * @interface ProvisioningConfigPlanInitializerScript
 */
export interface ProvisioningConfigPlanInitializerScript {
    /**
     * This is a Rule that allows provisioning instruction changes.
     * @type {string}
     * @memberof ProvisioningConfigPlanInitializerScript
     */
    'source'?: string;
}
/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel1
 */
export interface ProvisioningCriteriaLevel1 {
    /**
     * 
     * @type {ProvisioningCriteriaOperation}
     * @memberof ProvisioningCriteriaLevel1
     */
    'operation'?: ProvisioningCriteriaOperation;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel1
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel1
     */
    'value'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes.
     * @type {Array<ProvisioningCriteriaLevel2>}
     * @memberof ProvisioningCriteriaLevel1
     */
    'children'?: Array<ProvisioningCriteriaLevel2> | null;
}
/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel2
 */
export interface ProvisioningCriteriaLevel2 {
    /**
     * 
     * @type {ProvisioningCriteriaOperation}
     * @memberof ProvisioningCriteriaLevel2
     */
    'operation'?: ProvisioningCriteriaOperation;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel2
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel2
     */
    'value'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes.
     * @type {Array<ProvisioningCriteriaLevel3>}
     * @memberof ProvisioningCriteriaLevel2
     */
    'children'?: Array<ProvisioningCriteriaLevel3> | null;
}
/**
 * Defines matching criteria for an Account to be provisioned with a specific Access Profile
 * @export
 * @interface ProvisioningCriteriaLevel3
 */
export interface ProvisioningCriteriaLevel3 {
    /**
     * 
     * @type {ProvisioningCriteriaOperation}
     * @memberof ProvisioningCriteriaLevel3
     */
    'operation'?: ProvisioningCriteriaOperation;
    /**
     * Name of the Account attribute to be tested. If **operation** is one of EQUALS, NOT_EQUALS, CONTAINS, or HAS, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel3
     */
    'attribute'?: string | null;
    /**
     * String value to test the Account attribute w/r/t the specified operation. If the operation is one of EQUALS, NOT_EQUALS, or CONTAINS, this field is required. Otherwise, specifying it is an error. If the Attribute is not String-typed, it will be converted to the appropriate type.
     * @type {string}
     * @memberof ProvisioningCriteriaLevel3
     */
    'value'?: string;
}
/**
 * Supported operations on ProvisioningCriteria
 * @export
 * @enum {string}
 */

export const ProvisioningCriteriaOperation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    Has: 'HAS',
    And: 'AND',
    Or: 'OR'
} as const;

export type ProvisioningCriteriaOperation = typeof ProvisioningCriteriaOperation[keyof typeof ProvisioningCriteriaOperation];


/**
 * Provides additional details about provisioning for this request.
 * @export
 * @interface ProvisioningDetails
 */
export interface ProvisioningDetails {
    /**
     * Ordered CSV of sub phase references to objects that contain more information about provisioning. For example, this can contain \"manualWorkItemDetails\" which indicate that there is further information in that object for this phase.
     * @type {string}
     * @memberof ProvisioningDetails
     */
    'orderedSubPhaseReferences'?: string;
}
/**
 * 
 * @export
 * @interface ProvisioningPolicy
 */
export interface ProvisioningPolicy {
    /**
     * the provisioning policy name
     * @type {string}
     * @memberof ProvisioningPolicy
     */
    'name': string;
    /**
     * the description of the provisioning policy
     * @type {string}
     * @memberof ProvisioningPolicy
     */
    'description'?: string;
    /**
     * 
     * @type {UsageType}
     * @memberof ProvisioningPolicy
     */
    'usageType'?: UsageType;
    /**
     * 
     * @type {Array<FieldDetailsDto>}
     * @memberof ProvisioningPolicy
     */
    'fields'?: Array<FieldDetailsDto>;
}
/**
 * 
 * @export
 * @interface ProvisioningPolicyDto
 */
export interface ProvisioningPolicyDto {
    /**
     * the provisioning policy name
     * @type {string}
     * @memberof ProvisioningPolicyDto
     */
    'name': string;
    /**
     * the description of the provisioning policy
     * @type {string}
     * @memberof ProvisioningPolicyDto
     */
    'description'?: string;
    /**
     * 
     * @type {UsageType}
     * @memberof ProvisioningPolicyDto
     */
    'usageType'?: UsageType;
    /**
     * 
     * @type {Array<FieldDetailsDto>}
     * @memberof ProvisioningPolicyDto
     */
    'fields'?: Array<FieldDetailsDto>;
}
/**
 * Provisioning state of an account activity item
 * @export
 * @enum {string}
 */

export const ProvisioningState = {
    Pending: 'PENDING',
    Finished: 'FINISHED',
    Unverifiable: 'UNVERIFIABLE',
    Commited: 'COMMITED',
    Failed: 'FAILED',
    Retry: 'RETRY'
} as const;

export type ProvisioningState = typeof ProvisioningState[keyof typeof ProvisioningState];


/**
 * Details about a public identity
 * @export
 * @interface PublicIdentity
 */
export interface PublicIdentity {
    /**
     * Identity id
     * @type {string}
     * @memberof PublicIdentity
     */
    'id'?: string;
    /**
     * Human-readable display name of identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'name'?: string;
    /**
     * Alternate unique identifier for the identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'alias'?: string;
    /**
     * Email address of identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'email'?: string | null;
    /**
     * The lifecycle status for the identity
     * @type {string}
     * @memberof PublicIdentity
     */
    'status'?: string | null;
    /**
     * 
     * @type {IdentityReference}
     * @memberof PublicIdentity
     */
    'manager'?: IdentityReference | null;
    /**
     * The public identity attributes of the identity
     * @type {Array<IdentityAttribute1>}
     * @memberof PublicIdentity
     */
    'attributes'?: Array<IdentityAttribute1>;
}
/**
 * Used to map an attribute key for an Identity to its display name.
 * @export
 * @interface PublicIdentityAttributeConfig
 */
export interface PublicIdentityAttributeConfig {
    /**
     * The attribute key
     * @type {string}
     * @memberof PublicIdentityAttributeConfig
     */
    'key'?: string;
    /**
     * The attribute display name
     * @type {string}
     * @memberof PublicIdentityAttributeConfig
     */
    'name'?: string;
}
/**
 * Details of up to 5 Identity attributes that will be publicly accessible for all Identities to anyone in the org.
 * @export
 * @interface PublicIdentityConfig
 */
export interface PublicIdentityConfig {
    /**
     * Up to 5 identity attributes that will be available to everyone in the org for all users in the org.
     * @type {Array<PublicIdentityAttributeConfig>}
     * @memberof PublicIdentityConfig
     */
    'attributes'?: Array<PublicIdentityAttributeConfig>;
    /**
     * When this configuration was last modified.
     * @type {string}
     * @memberof PublicIdentityConfig
     */
    'modified'?: string | null;
    /**
     * 
     * @type {IdentityReference}
     * @memberof PublicIdentityConfig
     */
    'modifiedBy'?: IdentityReference | null;
}
/**
 * Query parameters used to construct an Elasticsearch query object.
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * The query using the Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL extended by SailPoint to support Nested queries.
     * @type {string}
     * @memberof Query
     */
    'query'?: string;
    /**
     * The fields to which the specified query will be applied.  The available fields are dependent on the indice(s) being searched on.  Please refer to the response schema of this API for a list of available fields.
     * @type {Array<string>}
     * @memberof Query
     */
    'fields'?: Array<string>;
    /**
     * The time zone to be applied to any range query related to dates.
     * @type {string}
     * @memberof Query
     */
    'timeZone'?: string;
    /**
     * 
     * @type {InnerHit}
     * @memberof Query
     */
    'innerHit'?: InnerHit;
}
/**
 * Allows the query results to be filtered by specifying a list of fields to include and/or exclude from the result documents.
 * @export
 * @interface QueryResultFilter
 */
export interface QueryResultFilter {
    /**
     * The list of field names to include in the result documents.
     * @type {Array<string>}
     * @memberof QueryResultFilter
     */
    'includes'?: Array<string>;
    /**
     * The list of field names to exclude from the result documents.
     * @type {Array<string>}
     * @memberof QueryResultFilter
     */
    'excludes'?: Array<string>;
}
/**
 * The type of query to use.  By default, the `SAILPOINT` query type is used, which requires the `query` object to be defined in the request body. To use the `queryDsl` or `typeAheadQuery` objects in the request, you must set the type to `DSL` or `TYPEAHEAD` accordingly. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const QueryType = {
    Dsl: 'DSL',
    Sailpoint: 'SAILPOINT',
    Typeahead: 'TYPEAHEAD'
} as const;

export type QueryType = typeof QueryType[keyof typeof QueryType];


/**
 * Configuration of maximum number days and interval for checking Service Desk integration queue status
 * @export
 * @interface QueuedCheckConfigDetails
 */
export interface QueuedCheckConfigDetails {
    /**
     * interval in minutes between status checks
     * @type {string}
     * @memberof QueuedCheckConfigDetails
     */
    'provisioningStatusCheckIntervalMinutes': string;
    /**
     * maximum number of days to check
     * @type {string}
     * @memberof QueuedCheckConfigDetails
     */
    'provisioningMaxStatusCheckDays': string;
}
/**
 * 
 * @export
 * @interface RandomAlphaNumeric
 */
export interface RandomAlphaNumeric {
    /**
     * This is an integer value specifying the size/number of characters the random string must contain   * This value must be a positive number and cannot be blank   * If no length is provided, the transform will default to a value of `32`   * Due to identity attribute data constraints, the maximum allowable value is `450` characters 
     * @type {string}
     * @memberof RandomAlphaNumeric
     */
    'length'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RandomAlphaNumeric
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RandomAlphaNumeric
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface RandomNumeric
 */
export interface RandomNumeric {
    /**
     * This is an integer value specifying the size/number of characters the random string must contain   * This value must be a positive number and cannot be blank   * If no length is provided, the transform will default to a value of `32`   * Due to identity attribute data constraints, the maximum allowable value is `450` characters 
     * @type {string}
     * @memberof RandomNumeric
     */
    'length'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RandomNumeric
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RandomNumeric
     */
    'input'?: { [key: string]: any; };
}
/**
 * The range of values to be filtered.
 * @export
 * @interface Range
 */
export interface Range {
    /**
     * 
     * @type {Bound}
     * @memberof Range
     */
    'lower'?: Bound;
    /**
     * 
     * @type {Bound}
     * @memberof Range
     */
    'upper'?: Bound;
}
/**
 * 
 * @export
 * @interface ReassignReference
 */
export interface ReassignReference {
    /**
     * The ID of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignReference
     */
    'id': string;
    /**
     * The type of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignReference
     */
    'type': ReassignReferenceTypeEnum;
}

export const ReassignReferenceTypeEnum = {
    TargetSummary: 'TARGET_SUMMARY',
    Item: 'ITEM',
    IdentitySummary: 'IDENTITY_SUMMARY'
} as const;

export type ReassignReferenceTypeEnum = typeof ReassignReferenceTypeEnum[keyof typeof ReassignReferenceTypeEnum];

/**
 * 
 * @export
 * @interface Reassignment
 */
export interface Reassignment {
    /**
     * 
     * @type {CertificationReference}
     * @memberof Reassignment
     */
    'from'?: CertificationReference;
    /**
     * The comment entered when the Certification was reassigned
     * @type {string}
     * @memberof Reassignment
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface ReassignmentReference
 */
export interface ReassignmentReference {
    /**
     * The ID of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignmentReference
     */
    'id': string;
    /**
     * The type of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignmentReference
     */
    'type': ReassignmentReferenceTypeEnum;
}

export const ReassignmentReferenceTypeEnum = {
    TargetSummary: 'TARGET_SUMMARY',
    Item: 'ITEM',
    IdentitySummary: 'IDENTITY_SUMMARY'
} as const;

export type ReassignmentReferenceTypeEnum = typeof ReassignmentReferenceTypeEnum[keyof typeof ReassignmentReferenceTypeEnum];

/**
 * 
 * @export
 * @interface ReassignmentTrailDTO
 */
export interface ReassignmentTrailDTO {
    /**
     * The ID of previous owner identity.
     * @type {string}
     * @memberof ReassignmentTrailDTO
     */
    'previousOwner'?: string;
    /**
     * The ID of new owner identity.
     * @type {string}
     * @memberof ReassignmentTrailDTO
     */
    'newOwner'?: string;
    /**
     * The type of reassignment.
     * @type {string}
     * @memberof ReassignmentTrailDTO
     */
    'reassignmentType'?: string;
}
/**
 * The approval reassignment type.  * MANUAL_REASSIGNMENT: An approval with this reassignment type has been specifically reassigned by the approval task\'s owner, from their queue to someone else\'s.  * AUTOMATIC_REASSIGNMENT: An approval with this reassignment type has been automatically reassigned from another approver\'s queue, according to that approver\'s reassignment configuration. The approver\'s reassignment configuration may be set up to automatically reassign approval tasks for a defined (or possibly open-ended) period of time. * AUTO_ESCALATION: An approval with this reassignment type has been automatically reassigned from another approver\'s queue, according to the request\'s escalation configuration. For more information about escalation configuration, refer to [Setting Global Reminders and Escalation Policies](https://documentation.sailpoint.com/saas/help/requests/config_emails.html). * SELF_REVIEW_DELEGATION: An approval with this reassignment type has been automatically reassigned by the system to prevent self-review. This helps prevent situations like a requester being tasked with approving their own request. For more information about preventing self-review, refer to [Self-review Prevention](https://documentation.sailpoint.com/saas/help/users/work_reassignment.html#self-review-prevention) and [Preventing Self-approval](https://documentation.sailpoint.com/saas/help/requests/config_ap_roles.html#preventing-self-approval).
 * @export
 * @enum {string}
 */

export const ReassignmentType = {
    ManualReassignment: 'MANUAL_REASSIGNMENT',
    AutomaticReassignment: 'AUTOMATIC_REASSIGNMENT',
    AutoEscalation: 'AUTO_ESCALATION',
    SelfReviewDelegation: 'SELF_REVIEW_DELEGATION'
} as const;

export type ReassignmentType = typeof ReassignmentType[keyof typeof ReassignmentType];


/**
 * 
 * @export
 * @interface Reference
 */
export interface Reference {
    /**
     * This ID specifies the name of the pre-existing transform which you want to use within your current transform
     * @type {string}
     * @memberof Reference
     */
    'id': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Reference
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Reference
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Reference1
 */
export interface Reference1 {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof Reference1
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof Reference1
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RemediationItemDetails
 */
export interface RemediationItemDetails {
    /**
     * The ID of the certification
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'id'?: string;
    /**
     * The ID of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetId'?: string;
    /**
     * The name of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetName'?: string;
    /**
     * The display name of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetDisplayName'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'applicationName'?: string;
    /**
     * The name of the attribute being certified
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeName'?: string;
    /**
     * The operation of the certification on the attribute
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute being certified
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeValue'?: string;
    /**
     * The native identity of the target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'nativeIdentity'?: string;
}
/**
 * 
 * @export
 * @interface RemediationItems
 */
export interface RemediationItems {
    /**
     * The ID of the certification
     * @type {string}
     * @memberof RemediationItems
     */
    'id'?: string;
    /**
     * The ID of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetId'?: string;
    /**
     * The name of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetName'?: string;
    /**
     * The display name of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetDisplayName'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof RemediationItems
     */
    'applicationName'?: string;
    /**
     * The name of the attribute being certified
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeName'?: string;
    /**
     * The operation of the certification on the attribute
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute being certified
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeValue'?: string;
    /**
     * The native identity of the target
     * @type {string}
     * @memberof RemediationItems
     */
    'nativeIdentity'?: string;
}
/**
 * 
 * @export
 * @interface Replace
 */
export interface Replace {
    /**
     * This can be a string or a regex pattern in which you want to replace.
     * @type {string}
     * @memberof Replace
     */
    'regex': string;
    /**
     * This is the replacement string that should be substituded wherever the string or pattern is found.
     * @type {string}
     * @memberof Replace
     */
    'replacement': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Replace
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Replace
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ReplaceAll
 */
export interface ReplaceAll {
    /**
     * An attribute of key-value pairs. Each pair identifies the pattern to search for as its key, and the replacement string as its value.
     * @type {{ [key: string]: any; }}
     * @memberof ReplaceAll
     */
    'table': { [key: string]: any; };
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof ReplaceAll
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof ReplaceAll
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ReportResultReference
 */
export interface ReportResultReference {
    /**
     * 
     * @type {DtoType}
     * @memberof ReportResultReference
     */
    'type'?: DtoType;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ReportResultReference
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ReportResultReference
     */
    'name'?: string;
    /**
     * Status of a violation report
     * @type {string}
     * @memberof ReportResultReference
     */
    'status'?: ReportResultReferenceStatusEnum;
}

export const ReportResultReferenceStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
} as const;

export type ReportResultReferenceStatusEnum = typeof ReportResultReferenceStatusEnum[keyof typeof ReportResultReferenceStatusEnum];

/**
 * 
 * @export
 * @interface ReportResultReferenceAllOf
 */
export interface ReportResultReferenceAllOf {
    /**
     * Status of a violation report
     * @type {string}
     * @memberof ReportResultReferenceAllOf
     */
    'status'?: ReportResultReferenceAllOfStatusEnum;
}

export const ReportResultReferenceAllOfStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
} as const;

export type ReportResultReferenceAllOfStatusEnum = typeof ReportResultReferenceAllOfStatusEnum[keyof typeof ReportResultReferenceAllOfStatusEnum];

/**
 * 
 * @export
 * @interface RequestOnBehalfOfConfig
 */
export interface RequestOnBehalfOfConfig {
    /**
     * If anyone can request access for anyone.
     * @type {boolean}
     * @memberof RequestOnBehalfOfConfig
     */
    'allowRequestOnBehalfOfAnyoneByAnyone'?: boolean;
    /**
     * If a manager can request access for his/her direct reports.
     * @type {boolean}
     * @memberof RequestOnBehalfOfConfig
     */
    'allowRequestOnBehalfOfEmployeeByManager'?: boolean;
}
/**
 * 
 * @export
 * @interface Requestability
 */
export interface Requestability {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof Requestability
     */
    'commentsRequired'?: boolean;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof Requestability
     */
    'denialCommentsRequired'?: boolean;
    /**
     * List describing the steps in approving the request
     * @type {Array<AccessProfileApprovalScheme>}
     * @memberof Requestability
     */
    'approvalSchemes'?: Array<AccessProfileApprovalScheme>;
}
/**
 * 
 * @export
 * @interface RequestabilityForRole
 */
export interface RequestabilityForRole {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof RequestabilityForRole
     */
    'commentsRequired'?: boolean | null;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof RequestabilityForRole
     */
    'denialCommentsRequired'?: boolean | null;
    /**
     * List describing the steps in approving the request
     * @type {Array<ApprovalSchemeForRole>}
     * @memberof RequestabilityForRole
     */
    'approvalSchemes'?: Array<ApprovalSchemeForRole>;
}
/**
 * 
 * @export
 * @interface RequestableObject
 */
export interface RequestableObject {
    /**
     * Id of the requestable object itself
     * @type {string}
     * @memberof RequestableObject
     */
    'id'?: string;
    /**
     * Human-readable display name of the requestable object
     * @type {string}
     * @memberof RequestableObject
     */
    'name'?: string;
    /**
     * The time when the requestable object was created
     * @type {string}
     * @memberof RequestableObject
     */
    'created'?: string;
    /**
     * The time when the requestable object was last modified
     * @type {string}
     * @memberof RequestableObject
     */
    'modified'?: string | null;
    /**
     * Description of the requestable object.
     * @type {string}
     * @memberof RequestableObject
     */
    'description'?: string;
    /**
     * 
     * @type {RequestableObjectType}
     * @memberof RequestableObject
     */
    'type'?: RequestableObjectType;
    /**
     * 
     * @type {RequestableObjectRequestStatus}
     * @memberof RequestableObject
     */
    'requestStatus'?: RequestableObjectRequestStatus;
    /**
     * If *requestStatus* is *PENDING*, indicates the id of the associated account activity.
     * @type {string}
     * @memberof RequestableObject
     */
    'identityRequestId'?: string | null;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof RequestableObject
     */
    'ownerRef'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * Whether the requester must provide comments when requesting the object.
     * @type {boolean}
     * @memberof RequestableObject
     */
    'requestCommentsRequired'?: boolean;
}
/**
 * 
 * @export
 * @interface RequestableObjectReference
 */
export interface RequestableObjectReference {
    /**
     * Id of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'id'?: string;
    /**
     * Name of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'name'?: string;
    /**
     * Description of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'description'?: string;
    /**
     * Type of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'type'?: RequestableObjectReferenceTypeEnum;
}

export const RequestableObjectReferenceTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestableObjectReferenceTypeEnum = typeof RequestableObjectReferenceTypeEnum[keyof typeof RequestableObjectReferenceTypeEnum];

/**
 * Status indicating the ability of an access request for the object to be made by or on behalf of the identity specified by *identity-id*. *AVAILABLE* indicates the object is available to request. *PENDING* indicates the object is unavailable because the identity has a pending request in flight. *ASSIGNED* indicates the object is unavailable because the identity already has the indicated role or access profile. If *identity-id* is not specified (allowed only for admin users), then status will be *AVAILABLE* for all results.
 * @export
 * @enum {string}
 */

export const RequestableObjectRequestStatus = {
    Available: 'AVAILABLE',
    Pending: 'PENDING',
    Assigned: 'ASSIGNED'
} as const;

export type RequestableObjectRequestStatus = typeof RequestableObjectRequestStatus[keyof typeof RequestableObjectRequestStatus];


/**
 * Enum represented the currently supported requestable object types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const RequestableObjectType = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestableObjectType = typeof RequestableObjectType[keyof typeof RequestableObjectType];


/**
 * 
 * @export
 * @interface RequestedItemStatus
 */
export interface RequestedItemStatus {
    /**
     * Human-readable display name of the item being requested.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'name'?: string;
    /**
     * Type of requested object.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'type'?: RequestedItemStatusTypeEnum;
    /**
     * 
     * @type {CancelledRequestDetails}
     * @memberof RequestedItemStatus
     */
    'cancelledRequestDetails'?: CancelledRequestDetails;
    /**
     * List of list of localized error messages, if any, encountered during the approval/provisioning process.
     * @type {Array<Array<ErrorMessageDto>>}
     * @memberof RequestedItemStatus
     */
    'errorMessages'?: Array<Array<ErrorMessageDto>> | null;
    /**
     * 
     * @type {RequestedItemStatusRequestState}
     * @memberof RequestedItemStatus
     */
    'state'?: RequestedItemStatusRequestState;
    /**
     * Approval details for each item.
     * @type {Array<ApprovalStatusDto>}
     * @memberof RequestedItemStatus
     */
    'approvalDetails'?: Array<ApprovalStatusDto>;
    /**
     * Manual work items created for provisioning the item.
     * @type {Array<ManualWorkItemDetails>}
     * @memberof RequestedItemStatus
     */
    'manualWorkItemDetails'?: Array<ManualWorkItemDetails> | null;
    /**
     * Id of associated account activity item.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'accountActivityItemId'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof RequestedItemStatus
     */
    'requestType'?: AccessRequestType;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'created'?: string;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof RequestedItemStatus
     */
    'requester'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof RequestedItemStatus
     */
    'requestedFor'?: BaseReferenceDto;
    /**
     * 
     * @type {CommentDto}
     * @memberof RequestedItemStatus
     */
    'requesterComment'?: CommentDto;
    /**
     * 
     * @type {SodViolationContextCheckCompleted}
     * @memberof RequestedItemStatus
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted;
    /**
     * 
     * @type {ProvisioningDetails}
     * @memberof RequestedItemStatus
     */
    'provisioningDetails'?: ProvisioningDetails;
    /**
     * 
     * @type {PreApprovalTriggerDetails}
     * @memberof RequestedItemStatus
     */
    'preApprovalTriggerDetails'?: PreApprovalTriggerDetails;
    /**
     * A list of Phases that the Access Request has gone through in order, to help determine the status of the request.
     * @type {Array<AccessRequestPhases>}
     * @memberof RequestedItemStatus
     */
    'accessRequestPhases'?: Array<AccessRequestPhases>;
    /**
     * Description associated to the requested object.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'description'?: string;
    /**
     * When the role access is scheduled for removal.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'removeDate'?: string | null;
    /**
     * True if the request can be canceled.
     * @type {boolean}
     * @memberof RequestedItemStatus
     */
    'cancelable'?: boolean;
    /**
     * This is the account activity id.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'accessRequestId'?: string;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request
     * @type {{ [key: string]: string; }}
     * @memberof RequestedItemStatus
     */
    'clientMetadata'?: { [key: string]: string; } | null;
}

export const RequestedItemStatusTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestedItemStatusTypeEnum = typeof RequestedItemStatusTypeEnum[keyof typeof RequestedItemStatusTypeEnum];

/**
 * Indicates the state of an access request: * EXECUTING: The request is executing, which indicates the system is doing some processing. * REQUEST_COMPLETED: Indicates the request  has been completed. * CANCELLED: The request was cancelled with no user input. * TERMINATED: The request has been terminated before it was able to complete. * PROVISIONING_VERIFICATION_PENDING: The request has finished any approval steps and provisioning is waiting to be verified. * REJECTED: The request was rejected. * PROVISIONING_FAILED: The request has failed to complete. * NOT_ALL_ITEMS_PROVISIONED: One or more of the requested items failed to complete, but there were one or more  successes. * ERROR: An error occurred during request processing.
 * @export
 * @enum {string}
 */

export const RequestedItemStatusRequestState = {
    Executing: 'EXECUTING',
    RequestCompleted: 'REQUEST_COMPLETED',
    Cancelled: 'CANCELLED',
    Terminated: 'TERMINATED',
    ProvisioningVerificationPending: 'PROVISIONING_VERIFICATION_PENDING',
    Rejected: 'REJECTED',
    ProvisioningFailed: 'PROVISIONING_FAILED',
    NotAllItemsProvisioned: 'NOT_ALL_ITEMS_PROVISIONED',
    Error: 'ERROR'
} as const;

export type RequestedItemStatusRequestState = typeof RequestedItemStatusRequestState[keyof typeof RequestedItemStatusRequestState];


/**
 * 
 * @export
 * @interface ReviewDecision
 */
export interface ReviewDecision {
    /**
     * The id of the review decision
     * @type {string}
     * @memberof ReviewDecision
     */
    'id': string;
    /**
     * 
     * @type {CertificationDecision}
     * @memberof ReviewDecision
     */
    'decision': CertificationDecision;
    /**
     * The date at which a user\'s access should be taken away. Should only be set for `REVOKE` decisions.
     * @type {string}
     * @memberof ReviewDecision
     */
    'proposedEndDate'?: string;
    /**
     * Indicates whether decision should be marked as part of a larger bulk decision
     * @type {boolean}
     * @memberof ReviewDecision
     */
    'bulk': boolean;
    /**
     * 
     * @type {ReviewRecommendation}
     * @memberof ReviewDecision
     */
    'recommendation'?: ReviewRecommendation;
    /**
     * Comments recorded when the decision was made
     * @type {string}
     * @memberof ReviewDecision
     */
    'comments'?: string;
}
/**
 * 
 * @export
 * @interface ReviewReassign
 */
export interface ReviewReassign {
    /**
     * 
     * @type {Array<ReassignReference>}
     * @memberof ReviewReassign
     */
    'reassign': Array<ReassignReference>;
    /**
     * The ID of the identity to which the certification is reassigned
     * @type {string}
     * @memberof ReviewReassign
     */
    'reassignTo': string;
    /**
     * The reason comment for why the reassign was made
     * @type {string}
     * @memberof ReviewReassign
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface ReviewRecommendation
 */
export interface ReviewRecommendation {
    /**
     * The recommendation from IAI at the time of the decision. This field will be null if no recommendation was made.
     * @type {string}
     * @memberof ReviewRecommendation
     */
    'recommendation'?: string | null;
    /**
     * A list of reasons for the recommendation.
     * @type {Array<string>}
     * @memberof ReviewRecommendation
     */
    'reasons'?: Array<string>;
    /**
     * The time at which the recommendation was recorded.
     * @type {string}
     * @memberof ReviewRecommendation
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface ReviewableAccessProfile
 */
export interface ReviewableAccessProfile {
    /**
     * The id of the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'id'?: string;
    /**
     * Name of the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'name'?: string;
    /**
     * Information about the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'description'?: string;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableAccessProfile
     */
    'privileged'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof ReviewableAccessProfile
     */
    'cloudGoverned'?: boolean;
    /**
     * The date at which a user\'s access expires
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableAccessProfile
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * A list of entitlements associated with this Access Profile
     * @type {Array<ReviewableEntitlement>}
     * @memberof ReviewableAccessProfile
     */
    'entitlements'?: Array<ReviewableEntitlement>;
    /**
     * Date the Access Profile was created.
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'created'?: string;
    /**
     * Date the Access Profile was last modified.
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface ReviewableEntitlement
 */
export interface ReviewableEntitlement {
    /**
     * The id for the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'id'?: string;
    /**
     * The name of the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'name'?: string;
    /**
     * Information about the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'description'?: string | null;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableEntitlement
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * The name of the attribute on the source
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'attributeName'?: string;
    /**
     * The value of the attribute on the source
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'attributeValue'?: string;
    /**
     * The schema object type on the source used to represent the entitlement and its attributes
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceSchemaObjectType'?: string;
    /**
     * The name of the source for which this entitlement belongs
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceName'?: string;
    /**
     * The type of the source for which the entitlement belongs
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceType'?: string;
    /**
     * Indicates if the entitlement has permissions
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'hasPermissions'?: boolean;
    /**
     * Indicates if the entitlement is a representation of an account permission
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'isPermission'?: boolean;
    /**
     * Indicates whether the entitlement can be revoked
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'revocable'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'cloudGoverned'?: boolean;
    /**
     * 
     * @type {ReviewableEntitlementAccount}
     * @memberof ReviewableEntitlement
     */
    'account'?: ReviewableEntitlementAccount | null;
}
/**
 * Information about the status of the entitlement
 * @export
 * @interface ReviewableEntitlementAccount
 */
export interface ReviewableEntitlementAccount {
    /**
     * The native identity for this account
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'nativeIdentity'?: string;
    /**
     * Indicates whether this account is currently disabled
     * @type {boolean}
     * @memberof ReviewableEntitlementAccount
     */
    'disabled'?: boolean;
    /**
     * Indicates whether this account is currently locked
     * @type {boolean}
     * @memberof ReviewableEntitlementAccount
     */
    'locked'?: boolean;
    /**
     * 
     * @type {DtoType}
     * @memberof ReviewableEntitlementAccount
     */
    'type'?: DtoType;
    /**
     * The id associated with the account
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'id'?: string | null;
    /**
     * The account name
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'name'?: string | null;
    /**
     * When the account was created
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'created'?: string | null;
    /**
     * When the account was last modified
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'modified'?: string | null;
}
/**
 * 
 * @export
 * @interface ReviewableRole
 */
export interface ReviewableRole {
    /**
     * The id for the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'id'?: string;
    /**
     * The name of the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'name'?: string;
    /**
     * Information about the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'description'?: string;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableRole
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableRole
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * Indicates whether the Role can be revoked or requested
     * @type {boolean}
     * @memberof ReviewableRole
     */
    'revocable'?: boolean;
    /**
     * The date when a user\'s access expires.
     * @type {string}
     * @memberof ReviewableRole
     */
    'endDate'?: string;
    /**
     * The list of Access Profiles associated with this Role
     * @type {Array<ReviewableAccessProfile>}
     * @memberof ReviewableRole
     */
    'accessProfiles'?: Array<ReviewableAccessProfile>;
}
/**
 * 
 * @export
 * @interface Reviewer
 */
export interface Reviewer {
    /**
     * The id of the reviewer.
     * @type {string}
     * @memberof Reviewer
     */
    'id'?: string;
    /**
     * The name of the reviewer.
     * @type {string}
     * @memberof Reviewer
     */
    'name'?: string;
    /**
     * The email of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'email'?: string;
    /**
     * The type of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'type'?: ReviewerTypeEnum;
    /**
     * The created date of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'created'?: string | null;
    /**
     * The modified date of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'modified'?: string | null;
}

export const ReviewerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type ReviewerTypeEnum = typeof ReviewerTypeEnum[keyof typeof ReviewerTypeEnum];

/**
 * 
 * @export
 * @interface Revocability
 */
export interface Revocability {
    /**
     * Whether the requester of the containing object must provide comments justifying the request
     * @type {boolean}
     * @memberof Revocability
     */
    'commentsRequired'?: boolean | null;
    /**
     * Whether an approver must provide comments when denying the request
     * @type {boolean}
     * @memberof Revocability
     */
    'denialCommentsRequired'?: boolean | null;
    /**
     * List describing the steps in approving the revocation request
     * @type {Array<AccessProfileApprovalScheme>}
     * @memberof Revocability
     */
    'approvalSchemes'?: Array<AccessProfileApprovalScheme>;
}
/**
 * 
 * @export
 * @interface RightPad
 */
export interface RightPad {
    /**
     * An integer value for the desired length of the final output string
     * @type {string}
     * @memberof RightPad
     */
    'length': string;
    /**
     * A string value representing the character that the incoming data should be padded with to get to the desired length   If not provided, the transform will default to a single space (\" \") character for padding 
     * @type {string}
     * @memberof RightPad
     */
    'padding'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RightPad
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RightPad
     */
    'input'?: { [key: string]: any; };
}
/**
 * A Role
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * The id of the Role. This field must be left null when creating an Role, otherwise a 400 Bad Request error will result.
     * @type {string}
     * @memberof Role
     */
    'id'?: string;
    /**
     * The human-readable display name of the Role
     * @type {string}
     * @memberof Role
     */
    'name': string;
    /**
     * Date the Role was created
     * @type {string}
     * @memberof Role
     */
    'created'?: string;
    /**
     * Date the Role was last modified.
     * @type {string}
     * @memberof Role
     */
    'modified'?: string;
    /**
     * A human-readable description of the Role
     * @type {string}
     * @memberof Role
     */
    'description'?: string | null;
    /**
     * 
     * @type {OwnerReference}
     * @memberof Role
     */
    'owner': OwnerReference | null;
    /**
     * 
     * @type {Array<AccessProfileRef>}
     * @memberof Role
     */
    'accessProfiles'?: Array<AccessProfileRef> | null;
    /**
     * 
     * @type {RoleMembershipSelector}
     * @memberof Role
     */
    'membership'?: RoleMembershipSelector | null;
    /**
     * This field is not directly modifiable and is generally expected to be *null*. In very rare instances, some Roles may have been created using membership selection criteria that are no longer fully supported. While these Roles will still work, they should be migrated to STANDARD or IDENTITY_LIST selection criteria. This field exists for informational purposes as an aid to such migration.
     * @type {{ [key: string]: any; }}
     * @memberof Role
     */
    'legacyMembershipInfo'?: { [key: string]: any; } | null;
    /**
     * Whether the Role is enabled or not.
     * @type {boolean}
     * @memberof Role
     */
    'enabled'?: boolean;
    /**
     * Whether the Role can be the target of access requests.
     * @type {boolean}
     * @memberof Role
     */
    'requestable'?: boolean;
    /**
     * 
     * @type {RequestabilityForRole}
     * @memberof Role
     */
    'accessRequestConfig'?: RequestabilityForRole;
    /**
     * 
     * @type {Revocability}
     * @memberof Role
     */
    'revocationRequestConfig'?: Revocability;
    /**
     * List of IDs of segments, if any, to which this Role is assigned.
     * @type {Array<string>}
     * @memberof Role
     */
    'segments'?: Array<string> | null;
}
/**
 * Type which indicates how a particular Identity obtained a particular Role
 * @export
 * @enum {string}
 */

export const RoleAssignmentSourceType = {
    AccessRequest: 'ACCESS_REQUEST',
    RoleMembership: 'ROLE_MEMBERSHIP'
} as const;

export type RoleAssignmentSourceType = typeof RoleAssignmentSourceType[keyof typeof RoleAssignmentSourceType];


/**
 * Refers to a specific Identity attribute, Account attibute, or Entitlement used in Role membership criteria
 * @export
 * @interface RoleCriteriaKey
 */
export interface RoleCriteriaKey {
    /**
     * 
     * @type {RoleCriteriaKeyType}
     * @memberof RoleCriteriaKey
     */
    'type': RoleCriteriaKeyType;
    /**
     * The name of the attribute or entitlement to which the associated criteria applies.
     * @type {string}
     * @memberof RoleCriteriaKey
     */
    'property': string;
    /**
     * ID of the Source from which an account attribute or entitlement is drawn. Required if type is ACCOUNT or ENTITLEMENT
     * @type {string}
     * @memberof RoleCriteriaKey
     */
    'sourceId'?: string | null;
}
/**
 * Indicates whether the associated criteria represents an expression on identity attributes, account attributes, or entitlements, respectively.
 * @export
 * @enum {string}
 */

export const RoleCriteriaKeyType = {
    Identity: 'IDENTITY',
    Account: 'ACCOUNT',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RoleCriteriaKeyType = typeof RoleCriteriaKeyType[keyof typeof RoleCriteriaKeyType];


/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel1
 */
export interface RoleCriteriaLevel1 {
    /**
     * 
     * @type {RoleCriteriaOperation}
     * @memberof RoleCriteriaLevel1
     */
    'operation'?: RoleCriteriaOperation;
    /**
     * 
     * @type {RoleCriteriaKey}
     * @memberof RoleCriteriaLevel1
     */
    'key'?: RoleCriteriaKey | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel1
     */
    'stringValue'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes. Additionally, AND nodes can only be children or OR nodes and vice-versa.
     * @type {Array<RoleCriteriaLevel2>}
     * @memberof RoleCriteriaLevel1
     */
    'children'?: Array<RoleCriteriaLevel2> | null;
}
/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel2
 */
export interface RoleCriteriaLevel2 {
    /**
     * 
     * @type {RoleCriteriaOperation}
     * @memberof RoleCriteriaLevel2
     */
    'operation'?: RoleCriteriaOperation;
    /**
     * 
     * @type {RoleCriteriaKey}
     * @memberof RoleCriteriaLevel2
     */
    'key'?: RoleCriteriaKey | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel2
     */
    'stringValue'?: string | null;
    /**
     * Array of child criteria. Required if the operation is AND or OR, otherwise it must be left null. A maximum of three levels of criteria are supported, including leaf nodes. Additionally, AND nodes can only be children or OR nodes and vice-versa.
     * @type {Array<RoleCriteriaLevel3>}
     * @memberof RoleCriteriaLevel2
     */
    'children'?: Array<RoleCriteriaLevel3> | null;
}
/**
 * Defines STANDARD type Role membership
 * @export
 * @interface RoleCriteriaLevel3
 */
export interface RoleCriteriaLevel3 {
    /**
     * 
     * @type {RoleCriteriaOperation}
     * @memberof RoleCriteriaLevel3
     */
    'operation'?: RoleCriteriaOperation;
    /**
     * 
     * @type {RoleCriteriaKey}
     * @memberof RoleCriteriaLevel3
     */
    'key'?: RoleCriteriaKey | null;
    /**
     * String value to test the Identity attribute, Account attribute, or Entitlement specified in the key w/r/t the specified operation. If this criteria is a leaf node, that is, if the operation is one of EQUALS, NOT_EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH, this field is required. Otherwise, specifying it is an error.
     * @type {string}
     * @memberof RoleCriteriaLevel3
     */
    'stringValue'?: string;
}
/**
 * An operation
 * @export
 * @enum {string}
 */

export const RoleCriteriaOperation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    And: 'AND',
    Or: 'OR'
} as const;

export type RoleCriteriaOperation = typeof RoleCriteriaOperation[keyof typeof RoleCriteriaOperation];


/**
 * Role
 * @export
 * @interface RoleDocument
 */
export interface RoleDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof RoleDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof RoleDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof RoleDocument
     */
    '_type': DocumentType;
    /**
     * The description of the access item
     * @type {string}
     * @memberof RoleDocument
     */
    'description'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof RoleDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof RoleDocument
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof RoleDocument
     */
    'synced'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RoleDocument
     */
    'enabled'?: boolean;
    /**
     * Indicates if the access can be requested
     * @type {boolean}
     * @memberof RoleDocument
     */
    'requestable'?: boolean;
    /**
     * Indicates if comments are required when requesting access
     * @type {boolean}
     * @memberof RoleDocument
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {Owner}
     * @memberof RoleDocument
     */
    'owner'?: Owner;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof RoleDocument
     */
    'accessProfiles'?: Array<Reference1>;
    /**
     * 
     * @type {number}
     * @memberof RoleDocument
     */
    'accessProfileCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleDocument
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RoleDocumentAllOf
 */
export interface RoleDocumentAllOf {
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof RoleDocumentAllOf
     */
    'accessProfiles'?: Array<Reference1>;
    /**
     * 
     * @type {number}
     * @memberof RoleDocumentAllOf
     */
    'accessProfileCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleDocumentAllOf
     */
    'tags'?: Array<string>;
}
/**
 * A subset of the fields of an Identity which is a member of a Role.
 * @export
 * @interface RoleIdentity
 */
export interface RoleIdentity {
    /**
     * The ID of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'id'?: string;
    /**
     * The alias / username of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'aliasName'?: string;
    /**
     * The human-readable display name of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'name'?: string;
    /**
     * Email address of the Identity
     * @type {string}
     * @memberof RoleIdentity
     */
    'email'?: string;
    /**
     * 
     * @type {RoleAssignmentSourceType}
     * @memberof RoleIdentity
     */
    'roleAssignmentSource'?: RoleAssignmentSourceType;
}
/**
 * A reference to an Identity in an IDENTITY_LIST role membership criteria.
 * @export
 * @interface RoleMembershipIdentity
 */
export interface RoleMembershipIdentity {
    /**
     * 
     * @type {DtoType}
     * @memberof RoleMembershipIdentity
     */
    'type'?: DtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof RoleMembershipIdentity
     */
    'id'?: string;
    /**
     * Human-readable display name of the Identity.
     * @type {string}
     * @memberof RoleMembershipIdentity
     */
    'name'?: string | null;
    /**
     * User name of the Identity
     * @type {string}
     * @memberof RoleMembershipIdentity
     */
    'aliasName'?: string | null;
}
/**
 * When present, specifies that the Role is to be granted to Identities which either satisfy specific criteria or which are members of a given list of Identities.
 * @export
 * @interface RoleMembershipSelector
 */
export interface RoleMembershipSelector {
    /**
     * 
     * @type {RoleMembershipSelectorType}
     * @memberof RoleMembershipSelector
     */
    'type'?: RoleMembershipSelectorType;
    /**
     * 
     * @type {RoleCriteriaLevel1}
     * @memberof RoleMembershipSelector
     */
    'criteria'?: RoleCriteriaLevel1 | null;
    /**
     * Defines role membership as being exclusive to the specified Identities, when type is IDENTITY_LIST.
     * @type {Array<RoleMembershipIdentity>}
     * @memberof RoleMembershipSelector
     */
    'identities'?: Array<RoleMembershipIdentity> | null;
}
/**
 * This enum characterizes the type of a Role\'s membership selector. Only the following two are fully supported:  STANDARD: Indicates that Role membership is defined in terms of a criteria expression  IDENTITY_LIST: Indicates that Role membership is conferred on the specific identities listed
 * @export
 * @enum {string}
 */

export const RoleMembershipSelectorType = {
    Standard: 'STANDARD',
    IdentityList: 'IDENTITY_LIST'
} as const;

export type RoleMembershipSelectorType = typeof RoleMembershipSelectorType[keyof typeof RoleMembershipSelectorType];


/**
 * Role
 * @export
 * @interface RoleSummary
 */
export interface RoleSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof RoleSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof RoleSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleSummary
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof RoleSummary
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof RoleSummary
     */
    'description'?: string | null;
    /**
     * 
     * @type {DisplayReference}
     * @memberof RoleSummary
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummary
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummary
     */
    'revocable'?: boolean;
}
/**
 * 
 * @export
 * @interface RoleSummaryAllOf
 */
export interface RoleSummaryAllOf {
    /**
     * 
     * @type {DisplayReference}
     * @memberof RoleSummaryAllOf
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummaryAllOf
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummaryAllOf
     */
    'revocable'?: boolean;
}
/**
 * @type Rule
 * @export
 */
export type Rule = GenerateRandomString | GenericRule | GetReferenceIdentityAttribute;

/**
 * 
 * @export
 * @interface SavedSearch
 */
export interface SavedSearch {
    /**
     * The saved search ID. 
     * @type {string}
     * @memberof SavedSearch
     */
    'id'?: string;
    /**
     * 
     * @type {TypedReference}
     * @memberof SavedSearch
     */
    'owner'?: TypedReference;
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof SavedSearch
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof SavedSearch
     */
    'description'?: string | null;
    /**
     * Indicates if the saved search is public. 
     * @type {boolean}
     * @memberof SavedSearch
     */
    'public'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearch
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearch
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof SavedSearch
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof SavedSearch
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof SavedSearch
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof SavedSearch
     */
    'fields'?: Array<string> | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof SavedSearch
     */
    'sort'?: Array<string>;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof SavedSearch
     */
    'filters'?: SavedSearchDetailFilters | null;
}
/**
 * 
 * @export
 * @interface SavedSearchAllOf
 */
export interface SavedSearchAllOf {
    /**
     * The saved search ID. 
     * @type {string}
     * @memberof SavedSearchAllOf
     */
    'id'?: string;
    /**
     * 
     * @type {TypedReference}
     * @memberof SavedSearchAllOf
     */
    'owner'?: TypedReference;
}
/**
 * 
 * @export
 * @interface SavedSearchDetail
 */
export interface SavedSearchDetail {
    /**
     * Indicates if the saved search is public. 
     * @type {boolean}
     * @memberof SavedSearchDetail
     */
    'public'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof SavedSearchDetail
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof SavedSearchDetail
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof SavedSearchDetail
     */
    'fields'?: Array<string> | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof SavedSearchDetail
     */
    'sort'?: Array<string>;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof SavedSearchDetail
     */
    'filters'?: SavedSearchDetailFilters | null;
}
/**
 * 
 * @export
 * @interface SavedSearchDetailFilters
 */
export interface SavedSearchDetailFilters {
    /**
     * 
     * @type {FilterType}
     * @memberof SavedSearchDetailFilters
     */
    'type'?: FilterType;
    /**
     * 
     * @type {Range}
     * @memberof SavedSearchDetailFilters
     */
    'range'?: Range;
    /**
     * The terms to be filtered.
     * @type {Array<string>}
     * @memberof SavedSearchDetailFilters
     */
    'terms'?: Array<string>;
    /**
     * Indicates if the filter excludes results.
     * @type {boolean}
     * @memberof SavedSearchDetailFilters
     */
    'exclude'?: boolean;
}
/**
 * 
 * @export
 * @interface SavedSearchName
 */
export interface SavedSearchName {
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof SavedSearchName
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof SavedSearchName
     */
    'description'?: string | null;
}
/**
 * The schedule information.
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * 
     * @type {ScheduleType}
     * @memberof Schedule
     */
    'type': ScheduleType;
    /**
     * 
     * @type {ScheduleDays}
     * @memberof Schedule
     */
    'days'?: ScheduleDays;
    /**
     * 
     * @type {ScheduleHours}
     * @memberof Schedule
     */
    'hours': ScheduleHours;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Schedule
     */
    'expiration'?: string | null;
    /**
     * The GMT formatted timezone the schedule will run in (ex. GMT-06:00).  If no timezone is specified, the org\'s default timezone is used.
     * @type {string}
     * @memberof Schedule
     */
    'timeZoneId'?: string | null;
}
/**
 * 
 * @export
 * @interface ScheduleDays
 */
export interface ScheduleDays {
    /**
     * 
     * @type {SelectorType}
     * @memberof ScheduleDays
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof ScheduleDays
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof ScheduleDays
     */
    'interval'?: number | null;
}
/**
 * 
 * @export
 * @interface ScheduleHours
 */
export interface ScheduleHours {
    /**
     * 
     * @type {SelectorType}
     * @memberof ScheduleHours
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof ScheduleHours
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof ScheduleHours
     */
    'interval'?: number | null;
}
/**
 * Enum representing the currently supported schedule types.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const ScheduleType = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Calendar: 'CALENDAR'
} as const;

export type ScheduleType = typeof ScheduleType[keyof typeof ScheduleType];


/**
 * 
 * @export
 * @interface ScheduledSearch
 */
export interface ScheduledSearch {
    /**
     * The scheduled search ID.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'id': string;
    /**
     * 
     * @type {ScheduledSearchAllOfOwner}
     * @memberof ScheduledSearch
     */
    'owner': ScheduledSearchAllOfOwner;
    /**
     * The ID of the scheduled search owner.  Please use the `id` in the `owner` object instead. 
     * @type {string}
     * @memberof ScheduledSearch
     * @deprecated
     */
    'ownerId': string;
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearch
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearch
     */
    'description'?: string | null;
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'savedSearchId': string;
    /**
     * The date the scheduled search was initially created.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'created'?: string;
    /**
     * The last date the scheduled search was modified.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'modified'?: string;
    /**
     * 
     * @type {Schedule}
     * @memberof ScheduledSearch
     */
    'schedule': Schedule;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof ScheduledSearch
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should not be suppressed if search returns no results. 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'displayQueryDetails'?: boolean;
}
/**
 * 
 * @export
 * @interface ScheduledSearchAllOf
 */
export interface ScheduledSearchAllOf {
    /**
     * The scheduled search ID.
     * @type {string}
     * @memberof ScheduledSearchAllOf
     */
    'id'?: string;
    /**
     * 
     * @type {ScheduledSearchAllOfOwner}
     * @memberof ScheduledSearchAllOf
     */
    'owner'?: ScheduledSearchAllOfOwner;
    /**
     * The ID of the scheduled search owner.  Please use the `id` in the `owner` object instead. 
     * @type {string}
     * @memberof ScheduledSearchAllOf
     * @deprecated
     */
    'ownerId'?: string;
}
/**
 * The owner of the scheduled search
 * @export
 * @interface ScheduledSearchAllOfOwner
 */
export interface ScheduledSearchAllOfOwner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof ScheduledSearchAllOfOwner
     */
    'type': ScheduledSearchAllOfOwnerTypeEnum;
    /**
     * The ID of the referenced object
     * @type {string}
     * @memberof ScheduledSearchAllOfOwner
     */
    'id': string;
}

export const ScheduledSearchAllOfOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type ScheduledSearchAllOfOwnerTypeEnum = typeof ScheduledSearchAllOfOwnerTypeEnum[keyof typeof ScheduledSearchAllOfOwnerTypeEnum];

/**
 * 
 * @export
 * @interface ScheduledSearchName
 */
export interface ScheduledSearchName {
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearchName
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearchName
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * The id of the Schema.
     * @type {string}
     * @memberof Schema
     */
    'id'?: string;
    /**
     * The name of the Schema.
     * @type {string}
     * @memberof Schema
     */
    'name'?: string;
    /**
     * The name of the object type on the native system that the schema represents.
     * @type {string}
     * @memberof Schema
     */
    'nativeObjectType'?: string;
    /**
     * The name of the attribute used to calculate the unique identifier for an object in the schema.
     * @type {string}
     * @memberof Schema
     */
    'identityAttribute'?: string;
    /**
     * The name of the attribute used to calculate the display value for an object in the schema.
     * @type {string}
     * @memberof Schema
     */
    'displayAttribute'?: string;
    /**
     * The name of the attribute whose values represent other objects in a hierarchy. Only relevant to group schemas.
     * @type {string}
     * @memberof Schema
     */
    'hierarchyAttribute'?: string;
    /**
     * Flag indicating whether or not the include permissions with the object data when aggregating the schema.
     * @type {boolean}
     * @memberof Schema
     */
    'includePermissions'?: boolean;
    /**
     * The features that the schema supports.
     * @type {Array<SourceFeature>}
     * @memberof Schema
     */
    'features'?: Array<SourceFeature>;
    /**
     * Holds any extra configuration data that the schema may require.
     * @type {object}
     * @memberof Schema
     */
    'configuration'?: object;
    /**
     * The attribute definitions which form the schema.
     * @type {Array<AttributeDefinition>}
     * @memberof Schema
     */
    'attributes'?: Array<AttributeDefinition>;
    /**
     * The date the Schema was created.
     * @type {string}
     * @memberof Schema
     */
    'created'?: string;
    /**
     * The date the Schema was last modified.
     * @type {string}
     * @memberof Schema
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface Search
 */
export interface Search {
    /**
     * The names of the Elasticsearch indices in which to search. If none are provided, then all indices will be searched.
     * @type {Array<Index>}
     * @memberof Search
     */
    'indices'?: Array<Index>;
    /**
     * 
     * @type {QueryType}
     * @memberof Search
     */
    'queryType'?: QueryType;
    /**
     * 
     * @type {string}
     * @memberof Search
     */
    'queryVersion'?: string;
    /**
     * 
     * @type {Query}
     * @memberof Search
     */
    'query'?: Query;
    /**
     * The search query using the Elasticsearch [Query DSL](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl.html) syntax.
     * @type {object}
     * @memberof Search
     */
    'queryDsl'?: object;
    /**
     * 
     * @type {TypeAheadQuery}
     * @memberof Search
     */
    'typeAheadQuery'?: TypeAheadQuery;
    /**
     * Indicates whether nested objects from returned search results should be included.
     * @type {boolean}
     * @memberof Search
     */
    'includeNested'?: boolean;
    /**
     * 
     * @type {QueryResultFilter}
     * @memberof Search
     */
    'queryResultFilter'?: QueryResultFilter;
    /**
     * 
     * @type {AggregationType}
     * @memberof Search
     */
    'aggregationType'?: AggregationType;
    /**
     * 
     * @type {string}
     * @memberof Search
     */
    'aggregationsVersion'?: string;
    /**
     * The aggregation search query using Elasticsearch [Aggregations](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations.html) syntax.
     * @type {object}
     * @memberof Search
     */
    'aggregationsDsl'?: object;
    /**
     * 
     * @type {SearchAggregationSpecification}
     * @memberof Search
     */
    'aggregations'?: SearchAggregationSpecification;
    /**
     * The fields to be used to sort the search results. Use + or - to specify the sort direction.
     * @type {Array<string>}
     * @memberof Search
     */
    'sort'?: Array<string>;
    /**
     * Used to begin the search window at the values specified. This parameter consists of the last values of the sorted fields in the current record set. This is used to expand the Elasticsearch limit of 10K records by shifting the 10K window to begin at this value. It is recommended that you always include the ID of the object in addition to any other fields on this parameter in order to ensure you don\'t get duplicate results while paging. For example, when searching for identities, if you are sorting by displayName you will also want to include ID, for example [\"displayName\", \"id\"].  If the last identity ID in the search result is 2c91808375d8e80a0175e1f88a575221 and the last displayName is \"John Doe\", then using that displayName and ID will start a new search after this identity. The searchAfter value will look like [\"John Doe\",\"2c91808375d8e80a0175e1f88a575221\"]
     * @type {Array<string>}
     * @memberof Search
     */
    'searchAfter'?: Array<string>;
    /**
     * The filters to be applied for each filtered field name.
     * @type {{ [key: string]: Filter; }}
     * @memberof Search
     */
    'filters'?: { [key: string]: Filter; };
}
/**
 * 
 * @export
 * @interface SearchAggregationSpecification
 */
export interface SearchAggregationSpecification {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof SearchAggregationSpecification
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof SearchAggregationSpecification
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof SearchAggregationSpecification
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof SearchAggregationSpecification
     */
    'bucket'?: BucketAggregation;
    /**
     * 
     * @type {SubSearchAggregationSpecification}
     * @memberof SearchAggregationSpecification
     */
    'subAggregation'?: SubSearchAggregationSpecification;
}
/**
 * 
 * @export
 * @interface SearchAggregationSpecificationAllOf
 */
export interface SearchAggregationSpecificationAllOf {
    /**
     * 
     * @type {SubSearchAggregationSpecification}
     * @memberof SearchAggregationSpecificationAllOf
     */
    'subAggregation'?: SubSearchAggregationSpecification;
}
/**
 * 
 * @export
 * @interface SearchArguments
 */
export interface SearchArguments {
    /**
     * The ID of the scheduled search that triggered the saved search execution. 
     * @type {string}
     * @memberof SearchArguments
     */
    'scheduleId'?: string;
    /**
     * 
     * @type {SearchArgumentsOwner}
     * @memberof SearchArguments
     */
    'owner'?: SearchArgumentsOwner;
    /**
     * The email recipients of the scheduled search being tested. 
     * @type {Array<TypedReference>}
     * @memberof SearchArguments
     */
    'recipients'?: Array<TypedReference>;
}
/**
 * The owner of the scheduled search being tested. 
 * @export
 * @interface SearchArgumentsOwner
 */
export interface SearchArgumentsOwner {
    /**
     * 
     * @type {DtoType}
     * @memberof SearchArgumentsOwner
     */
    'type': DtoType;
    /**
     * The id of the object. 
     * @type {string}
     * @memberof SearchArgumentsOwner
     */
    'id': string;
}
/**
 * @type SearchDocument
 * @export
 */
export type SearchDocument = AccessProfileDocument | AccountActivityDocument | AccountDocument | AggregationDocument | EntitlementDocument | EventDocument | IdentityDocument | RoleDocument;

/**
 * Enum representing the currently supported filter aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const SearchFilterType = {
    Term: 'TERM'
} as const;

export type SearchFilterType = typeof SearchFilterType[keyof typeof SearchFilterType];


/**
 * 
 * @export
 * @interface SearchIdentityReference
 */
export interface SearchIdentityReference {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof SearchIdentityReference
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof SearchIdentityReference
     */
    'name'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof SearchIdentityReference
     */
    'type'?: DtoType;
}
/**
 * 
 * @export
 * @interface SearchIdentityReferenceAllOf
 */
export interface SearchIdentityReferenceAllOf {
    /**
     * 
     * @type {DtoType}
     * @memberof SearchIdentityReferenceAllOf
     */
    'type'?: DtoType;
}
/**
 * 
 * @export
 * @interface SearchSchedule
 */
export interface SearchSchedule {
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof SearchSchedule
     */
    'savedSearchId': string;
    /**
     * The date the scheduled search was initially created.
     * @type {string}
     * @memberof SearchSchedule
     */
    'created'?: string;
    /**
     * The last date the scheduled search was modified.
     * @type {string}
     * @memberof SearchSchedule
     */
    'modified'?: string;
    /**
     * 
     * @type {Schedule}
     * @memberof SearchSchedule
     */
    'schedule': Schedule;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof SearchSchedule
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should not be suppressed if search returns no results. 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'displayQueryDetails'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchScheduleRecipientsInner
 */
export interface SearchScheduleRecipientsInner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SearchScheduleRecipientsInner
     */
    'type': SearchScheduleRecipientsInnerTypeEnum;
    /**
     * The ID of the referenced object
     * @type {string}
     * @memberof SearchScheduleRecipientsInner
     */
    'id': string;
}

export const SearchScheduleRecipientsInnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SearchScheduleRecipientsInnerTypeEnum = typeof SearchScheduleRecipientsInnerTypeEnum[keyof typeof SearchScheduleRecipientsInnerTypeEnum];

/**
 * 
 * @export
 * @interface SectionDetails
 */
export interface SectionDetails {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof SectionDetails
     */
    'name'?: string;
    /**
     * Label of the section
     * @type {string}
     * @memberof SectionDetails
     */
    'label'?: string;
    /**
     * List of FormItems. FormItems can be SectionDetails and/or FieldDetails
     * @type {Array<object>}
     * @memberof SectionDetails
     */
    'formItems'?: Array<object>;
}
/**
 * 
 * @export
 * @interface SectionDetailsAllOf
 */
export interface SectionDetailsAllOf {
    /**
     * Label of the section
     * @type {string}
     * @memberof SectionDetailsAllOf
     */
    'label'?: string;
    /**
     * List of FormItems. FormItems can be SectionDetails and/or FieldDetails
     * @type {Array<object>}
     * @memberof SectionDetailsAllOf
     */
    'formItems'?: Array<object>;
}
/**
 * 
 * @export
 * @interface Segment
 */
export interface Segment {
    /**
     * The id of the Segment.
     * @type {string}
     * @memberof Segment
     */
    'id'?: string;
    /**
     * Segment Business Name
     * @type {string}
     * @memberof Segment
     */
    'name'?: string;
    /**
     * The time when this Segment is created
     * @type {string}
     * @memberof Segment
     */
    'created'?: string;
    /**
     * The time when this Segment is modified
     * @type {string}
     * @memberof Segment
     */
    'modified'?: string;
    /**
     * Optional description of the Segment
     * @type {string}
     * @memberof Segment
     */
    'description'?: string;
    /**
     * 
     * @type {OwnerReference}
     * @memberof Segment
     */
    'owner'?: OwnerReference | null;
    /**
     * 
     * @type {VisibilityCriteria}
     * @memberof Segment
     */
    'visibilityCriteria'?: VisibilityCriteria;
    /**
     * Whether the Segment is currently active. Inactive segments have no effect.
     * @type {boolean}
     * @memberof Segment
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface Selector
 */
export interface Selector {
    /**
     * 
     * @type {SelectorType}
     * @memberof Selector
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Selector
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Selector
     */
    'interval'?: number | null;
}
/**
 * Enum representing the currently supported selector types.  LIST - the *values* array contains one or more distinct values.  RANGE - the *values* array contains two values: the start and end of the range, inclusive.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const SelectorType = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type SelectorType = typeof SelectorType[keyof typeof SelectorType];


/**
 * 
 * @export
 * @interface ServiceDeskIntegrationDto
 */
export interface ServiceDeskIntegrationDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'modified'?: string;
    /**
     * Description of the Service Desk integration
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'description': string;
    /**
     * Service Desk integration types  - ServiceNowSDIM - ServiceNow 
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'type': string;
    /**
     * Reference to the identity that is the owner of this Service Desk integration
     * @type {BaseReferenceDto}
     * @memberof ServiceDeskIntegrationDto
     */
    'ownerRef'?: BaseReferenceDto;
    /**
     * Reference to the source cluster for this Service Desk integration
     * @type {BaseReferenceDto}
     * @memberof ServiceDeskIntegrationDto
     */
    'clusterRef'?: BaseReferenceDto;
    /**
     * ID of the cluster for the Service Desk integration (replaced by clusterRef, retained for backward compatibility)
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     * @deprecated
     */
    'cluster'?: string;
    /**
     * Source IDs for the Service Desk integration (replaced by provisioningConfig.managedSResourceRefs, but retained here for backward compatibility)
     * @type {Array<string>}
     * @memberof ServiceDeskIntegrationDto
     * @deprecated
     */
    'managedSources'?: Array<string>;
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationDto
     */
    'provisioningConfig'?: ProvisioningConfig;
    /**
     * Attributes of the Service Desk integration.  Validation constraints enforced by the implementation.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationDto
     */
    'attributes': { [key: string]: any; };
    /**
     * Reference to beforeProvisioningRule for this Service Desk integration
     * @type {BaseReferenceDto}
     * @memberof ServiceDeskIntegrationDto
     */
    'beforeProvisioningRule'?: BaseReferenceDto;
}
/**
 * Specification of a Service Desk integration
 * @export
 * @interface ServiceDeskIntegrationDtoAllOf
 */
export interface ServiceDeskIntegrationDtoAllOf {
    /**
     * Description of the Service Desk integration
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'description': string;
    /**
     * Service Desk integration types  - ServiceNowSDIM - ServiceNow 
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'type': string;
    /**
     * Reference to the identity that is the owner of this Service Desk integration
     * @type {BaseReferenceDto}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'ownerRef'?: BaseReferenceDto;
    /**
     * Reference to the source cluster for this Service Desk integration
     * @type {BaseReferenceDto}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'clusterRef'?: BaseReferenceDto;
    /**
     * ID of the cluster for the Service Desk integration (replaced by clusterRef, retained for backward compatibility)
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOf
     * @deprecated
     */
    'cluster'?: string;
    /**
     * Source IDs for the Service Desk integration (replaced by provisioningConfig.managedSResourceRefs, but retained here for backward compatibility)
     * @type {Array<string>}
     * @memberof ServiceDeskIntegrationDtoAllOf
     * @deprecated
     */
    'managedSources'?: Array<string>;
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'provisioningConfig'?: ProvisioningConfig;
    /**
     * Attributes of the Service Desk integration.  Validation constraints enforced by the implementation.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'attributes': { [key: string]: any; };
    /**
     * Reference to beforeProvisioningRule for this Service Desk integration
     * @type {BaseReferenceDto}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'beforeProvisioningRule'?: BaseReferenceDto;
}
/**
 * 
 * @export
 * @interface ServiceDeskIntegrationTemplateDto
 */
export interface ServiceDeskIntegrationTemplateDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'modified'?: string;
    /**
     * The \'type\' property specifies the type of the Service Desk integration template.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'type': string;
    /**
     * The \'attributes\' property value is a map of attributes available for integrations using this Service Desk integration template.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'provisioningConfig': ProvisioningConfig;
}
/**
 * This is the model for a Service Desk integration template, used to create and edit Service Desk Integrations.
 * @export
 * @interface ServiceDeskIntegrationTemplateDtoAllOf
 */
export interface ServiceDeskIntegrationTemplateDtoAllOf {
    /**
     * The \'type\' property specifies the type of the Service Desk integration template.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDtoAllOf
     */
    'type': string;
    /**
     * The \'attributes\' property value is a map of attributes available for integrations using this Service Desk integration template.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationTemplateDtoAllOf
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationTemplateDtoAllOf
     */
    'provisioningConfig': ProvisioningConfig;
}
/**
 * This represents a Service Desk Integration template type.
 * @export
 * @interface ServiceDeskIntegrationTemplateType
 */
export interface ServiceDeskIntegrationTemplateType {
    /**
     * This is the name of the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'name'?: string;
    /**
     * This is the type value for the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'type': string;
    /**
     * This is the scriptName attribute value for the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'scriptName': string;
}
/**
 * 
 * @export
 * @interface SetLifecycleState200Response
 */
export interface SetLifecycleState200Response {
    /**
     * The ID of the IdentityRequest object that was generated when the workflow launches
     * @type {string}
     * @memberof SetLifecycleState200Response
     */
    'accountActivityId'?: string;
}
/**
 * 
 * @export
 * @interface SetLifecycleStateRequest
 */
export interface SetLifecycleStateRequest {
    /**
     * The ID of the lifecycle state to set
     * @type {string}
     * @memberof SetLifecycleStateRequest
     */
    'lifecycleStateId'?: string;
}
/**
 * 
 * @export
 * @interface SlimCampaign
 */
export interface SlimCampaign {
    /**
     * Id of the campaign
     * @type {string}
     * @memberof SlimCampaign
     */
    'id'?: string;
    /**
     * The campaign name. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof SlimCampaign
     */
    'name': string;
    /**
     * The campaign description. If this object is part of a template, special formatting applies; see the `/campaign-templates/{id}/generate` endpoint documentation for details.
     * @type {string}
     * @memberof SlimCampaign
     */
    'description': string;
    /**
     * The campaign\'s completion deadline.
     * @type {string}
     * @memberof SlimCampaign
     */
    'deadline'?: string;
    /**
     * The type of campaign. Could be extended in the future.
     * @type {string}
     * @memberof SlimCampaign
     */
    'type': SlimCampaignTypeEnum;
    /**
     * Enables email notification for this campaign
     * @type {boolean}
     * @memberof SlimCampaign
     */
    'emailNotificationEnabled'?: boolean;
    /**
     * Allows auto revoke for this campaign
     * @type {boolean}
     * @memberof SlimCampaign
     */
    'autoRevokeAllowed'?: boolean;
    /**
     * Enables IAI for this campaign. Accepts true even if the IAI product feature is off. If IAI is turned off then campaigns generated from this template will indicate false. The real value will then be returned if IAI is ever enabled for the org in the future.
     * @type {boolean}
     * @memberof SlimCampaign
     */
    'recommendationsEnabled'?: boolean;
    /**
     * The campaign\'s current status.
     * @type {string}
     * @memberof SlimCampaign
     */
    'status'?: SlimCampaignStatusEnum;
    /**
     * The correlatedStatus of the campaign. Only SOURCE_OWNER campaigns can be Uncorrelated. An Uncorrelated certification campaign only includes Uncorrelated identities (An identity is uncorrelated if it has no accounts on an authoritative source).
     * @type {string}
     * @memberof SlimCampaign
     */
    'correlatedStatus'?: SlimCampaignCorrelatedStatusEnum;
}

export const SlimCampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
} as const;

export type SlimCampaignTypeEnum = typeof SlimCampaignTypeEnum[keyof typeof SlimCampaignTypeEnum];
export const SlimCampaignStatusEnum = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
} as const;

export type SlimCampaignStatusEnum = typeof SlimCampaignStatusEnum[keyof typeof SlimCampaignStatusEnum];
export const SlimCampaignCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
} as const;

export type SlimCampaignCorrelatedStatusEnum = typeof SlimCampaignCorrelatedStatusEnum[keyof typeof SlimCampaignCorrelatedStatusEnum];

/**
 * Details of the Entitlement criteria
 * @export
 * @interface SodExemptCriteria
 */
export interface SodExemptCriteria {
    /**
     * If the entitlement already belonged to the user or not.
     * @type {boolean}
     * @memberof SodExemptCriteria
     */
    'existing'?: boolean;
    /**
     * 
     * @type {DtoType}
     * @memberof SodExemptCriteria
     */
    'type'?: DtoType;
    /**
     * Entitlement ID
     * @type {string}
     * @memberof SodExemptCriteria
     */
    'id'?: string;
    /**
     * Entitlement name
     * @type {string}
     * @memberof SodExemptCriteria
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface SodPolicy
 */
export interface SodPolicy {
    /**
     * Policy id
     * @type {string}
     * @memberof SodPolicy
     */
    'id'?: string;
    /**
     * Policy Business Name
     * @type {string}
     * @memberof SodPolicy
     */
    'name'?: string;
    /**
     * The time when this SOD policy is created.
     * @type {string}
     * @memberof SodPolicy
     */
    'created'?: string;
    /**
     * The time when this SOD policy is modified.
     * @type {string}
     * @memberof SodPolicy
     */
    'modified'?: string;
    /**
     * Optional description of the SOD policy
     * @type {string}
     * @memberof SodPolicy
     */
    'description'?: string | null;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof SodPolicy
     */
    'ownerRef'?: BaseReferenceDto;
    /**
     * Optional External Policy Reference
     * @type {string}
     * @memberof SodPolicy
     */
    'externalPolicyReference'?: string | null;
    /**
     * Search query of the SOD policy
     * @type {string}
     * @memberof SodPolicy
     */
    'policyQuery'?: string;
    /**
     * Optional compensating controls(Mitigating Controls)
     * @type {string}
     * @memberof SodPolicy
     */
    'compensatingControls'?: string | null;
    /**
     * Optional correction advice
     * @type {string}
     * @memberof SodPolicy
     */
    'correctionAdvice'?: string | null;
    /**
     * whether the policy is enforced or not
     * @type {string}
     * @memberof SodPolicy
     */
    'state'?: SodPolicyStateEnum;
    /**
     * tags for this policy object
     * @type {Array<string>}
     * @memberof SodPolicy
     */
    'tags'?: Array<string>;
    /**
     * Policy\'s creator ID
     * @type {string}
     * @memberof SodPolicy
     */
    'creatorId'?: string;
    /**
     * Policy\'s modifier ID
     * @type {string}
     * @memberof SodPolicy
     */
    'modifierId'?: string | null;
    /**
     * 
     * @type {ViolationOwnerAssignmentConfig}
     * @memberof SodPolicy
     */
    'violationOwnerAssignmentConfig'?: ViolationOwnerAssignmentConfig;
    /**
     * defines whether a policy has been scheduled or not
     * @type {boolean}
     * @memberof SodPolicy
     */
    'scheduled'?: boolean;
    /**
     * whether a policy is query based or conflicting access based
     * @type {string}
     * @memberof SodPolicy
     */
    'type'?: SodPolicyTypeEnum;
    /**
     * 
     * @type {SodPolicyConflictingAccessCriteria}
     * @memberof SodPolicy
     */
    'conflictingAccessCriteria'?: SodPolicyConflictingAccessCriteria;
}

export const SodPolicyStateEnum = {
    Enforced: 'ENFORCED',
    NotEnforced: 'NOT_ENFORCED'
} as const;

export type SodPolicyStateEnum = typeof SodPolicyStateEnum[keyof typeof SodPolicyStateEnum];
export const SodPolicyTypeEnum = {
    General: 'GENERAL',
    ConflictingAccessBased: 'CONFLICTING_ACCESS_BASED'
} as const;

export type SodPolicyTypeEnum = typeof SodPolicyTypeEnum[keyof typeof SodPolicyTypeEnum];

/**
 * 
 * @export
 * @interface SodPolicyConflictingAccessCriteria
 */
export interface SodPolicyConflictingAccessCriteria {
    /**
     * 
     * @type {AccessCriteria}
     * @memberof SodPolicyConflictingAccessCriteria
     */
    'leftCriteria'?: AccessCriteria;
    /**
     * 
     * @type {AccessCriteria}
     * @memberof SodPolicyConflictingAccessCriteria
     */
    'rightCriteria'?: AccessCriteria;
}
/**
 * 
 * @export
 * @interface SodPolicySchedule
 */
export interface SodPolicySchedule {
    /**
     * SOD Policy schedule name
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'name'?: string;
    /**
     * The time when this SOD policy schedule is created.
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'created'?: string;
    /**
     * The time when this SOD policy schedule is modified.
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'modified'?: string;
    /**
     * SOD Policy schedule description
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'description'?: string;
    /**
     * 
     * @type {Schedule}
     * @memberof SodPolicySchedule
     */
    'schedule'?: Schedule;
    /**
     * 
     * @type {Array<BaseReferenceDto>}
     * @memberof SodPolicySchedule
     */
    'recipients'?: Array<BaseReferenceDto>;
    /**
     * Indicates if empty results need to be emailed
     * @type {boolean}
     * @memberof SodPolicySchedule
     */
    'emailEmptyResults'?: boolean;
    /**
     * Policy\'s creator ID
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'creatorId'?: string;
    /**
     * Policy\'s modifier ID
     * @type {string}
     * @memberof SodPolicySchedule
     */
    'modifierId'?: string;
}
/**
 * An object referencing an SOD violation check
 * @export
 * @interface SodViolationCheck
 */
export interface SodViolationCheck {
    /**
     * The id of the original request
     * @type {string}
     * @memberof SodViolationCheck
     */
    'requestId': string;
    /**
     * The date-time when this request was created.
     * @type {string}
     * @memberof SodViolationCheck
     */
    'created'?: string;
}
/**
 * The inner object representing the completed SOD Violation check
 * @export
 * @interface SodViolationCheckResult
 */
export interface SodViolationCheckResult {
    /**
     * 
     * @type {ErrorMessageDto}
     * @memberof SodViolationCheckResult
     */
    'message'?: ErrorMessageDto;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on completion of the violation check.
     * @type {{ [key: string]: string; }}
     * @memberof SodViolationCheckResult
     */
    'clientMetadata'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<SodViolationContext>}
     * @memberof SodViolationCheckResult
     */
    'violationContexts'?: Array<SodViolationContext>;
    /**
     * A list of the Policies that were violated
     * @type {Array<BaseReferenceDto>}
     * @memberof SodViolationCheckResult
     */
    'violatedPolicies'?: Array<BaseReferenceDto>;
}
/**
 * The contextual information of the violated criteria
 * @export
 * @interface SodViolationContext
 */
export interface SodViolationContext {
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof SodViolationContext
     */
    'policy'?: BaseReferenceDto;
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteria}
     * @memberof SodViolationContext
     */
    'conflictingAccessCriteria'?: SodViolationContextConflictingAccessCriteria;
}
/**
 * An object referencing a completed SOD violation check
 * @export
 * @interface SodViolationContextCheckCompleted
 */
export interface SodViolationContextCheckCompleted {
    /**
     * The status of SOD violation check
     * @type {string}
     * @memberof SodViolationContextCheckCompleted
     */
    'state'?: SodViolationContextCheckCompletedStateEnum;
    /**
     * The id of the Violation check event
     * @type {string}
     * @memberof SodViolationContextCheckCompleted
     */
    'uuid'?: string;
    /**
     * 
     * @type {SodViolationCheckResult}
     * @memberof SodViolationContextCheckCompleted
     */
    'violationCheckResult'?: SodViolationCheckResult;
}

export const SodViolationContextCheckCompletedStateEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type SodViolationContextCheckCompletedStateEnum = typeof SodViolationContextCheckCompletedStateEnum[keyof typeof SodViolationContextCheckCompletedStateEnum];

/**
 * The object which contains the left and right hand side of the entitlements that got violated according to the policy.
 * @export
 * @interface SodViolationContextConflictingAccessCriteria
 */
export interface SodViolationContextConflictingAccessCriteria {
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteriaLeftCriteria}
     * @memberof SodViolationContextConflictingAccessCriteria
     */
    'leftCriteria'?: SodViolationContextConflictingAccessCriteriaLeftCriteria;
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteriaLeftCriteria}
     * @memberof SodViolationContextConflictingAccessCriteria
     */
    'rightCriteria'?: SodViolationContextConflictingAccessCriteriaLeftCriteria;
}
/**
 * 
 * @export
 * @interface SodViolationContextConflictingAccessCriteriaLeftCriteria
 */
export interface SodViolationContextConflictingAccessCriteriaLeftCriteria {
    /**
     * 
     * @type {Array<SodExemptCriteria>}
     * @memberof SodViolationContextConflictingAccessCriteriaLeftCriteria
     */
    'criteriaList'?: Array<SodExemptCriteria>;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * the id of the Source
     * @type {string}
     * @memberof Source
     */
    'id'?: string;
    /**
     * Human-readable name of the source
     * @type {string}
     * @memberof Source
     */
    'name': string;
    /**
     * Human-readable description of the source
     * @type {string}
     * @memberof Source
     */
    'description'?: string;
    /**
     * 
     * @type {SourceOwner}
     * @memberof Source
     */
    'owner': SourceOwner;
    /**
     * 
     * @type {SourceCluster}
     * @memberof Source
     */
    'cluster'?: SourceCluster;
    /**
     * 
     * @type {SourceAccountCorrelationConfig}
     * @memberof Source
     */
    'accountCorrelationConfig'?: SourceAccountCorrelationConfig;
    /**
     * 
     * @type {SourceAccountCorrelationRule}
     * @memberof Source
     */
    'accountCorrelationRule'?: SourceAccountCorrelationRule;
    /**
     * 
     * @type {ManagerCorrelationMapping}
     * @memberof Source
     */
    'managerCorrelationMapping'?: ManagerCorrelationMapping;
    /**
     * 
     * @type {SourceManagerCorrelationRule}
     * @memberof Source
     */
    'managerCorrelationRule'?: SourceManagerCorrelationRule;
    /**
     * 
     * @type {SourceBeforeProvisioningRule}
     * @memberof Source
     */
    'beforeProvisioningRule'?: SourceBeforeProvisioningRule;
    /**
     * List of references to Schema objects
     * @type {Array<SourceSchemasInner>}
     * @memberof Source
     */
    'schemas'?: Array<SourceSchemasInner>;
    /**
     * List of references to the associated PasswordPolicy objects.
     * @type {Array<SourcePasswordPoliciesInner>}
     * @memberof Source
     */
    'passwordPolicies'?: Array<SourcePasswordPoliciesInner>;
    /**
     * Optional features that can be supported by a source.
     * @type {Array<SourceFeature>}
     * @memberof Source
     */
    'features'?: Array<SourceFeature>;
    /**
     * Specifies the type of system being managed e.g. Active Directory, Workday, etc.. If you are creating a Delimited File source, you must set the `provisionasCsv` query parameter to `true`. 
     * @type {string}
     * @memberof Source
     */
    'type'?: string;
    /**
     * Connector script name.
     * @type {string}
     * @memberof Source
     */
    'connector': string;
    /**
     * The fully qualified name of the Java class that implements the connector interface.
     * @type {string}
     * @memberof Source
     */
    'connectorClass'?: string;
    /**
     * Connector specific configuration; will differ from type to type.
     * @type {object}
     * @memberof Source
     */
    'connectorAttributes'?: object;
    /**
     * Number from 0 to 100 that specifies when to skip the delete phase.
     * @type {number}
     * @memberof Source
     */
    'deleteThreshold'?: number;
    /**
     * When true indicates the source is referenced by an IdentityProfile.
     * @type {boolean}
     * @memberof Source
     */
    'authoritative'?: boolean;
    /**
     * 
     * @type {SourceManagementWorkgroup}
     * @memberof Source
     */
    'managementWorkgroup'?: SourceManagementWorkgroup;
    /**
     * When true indicates a healthy source
     * @type {boolean}
     * @memberof Source
     */
    'healthy'?: boolean;
    /**
     * A status identifier, giving specific information on why a source is healthy or not
     * @type {string}
     * @memberof Source
     */
    'status'?: string;
    /**
     * Timestamp showing when a source health check was last performed
     * @type {string}
     * @memberof Source
     */
    'since'?: string;
    /**
     * The id of connector
     * @type {string}
     * @memberof Source
     */
    'connectorId'?: string;
    /**
     * The name of the connector that was chosen on source creation
     * @type {string}
     * @memberof Source
     */
    'connectorName'?: string;
    /**
     * The type of connection (direct or file)
     * @type {string}
     * @memberof Source
     */
    'connectionType'?: string;
    /**
     * The connector implementstion id
     * @type {string}
     * @memberof Source
     */
    'connectorImplementstionId'?: string;
}
/**
 * Reference to an Account Correlation Config object
 * @export
 * @interface SourceAccountCorrelationConfig
 */
export interface SourceAccountCorrelationConfig {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'type'?: SourceAccountCorrelationConfigTypeEnum;
    /**
     * ID of the account correlation config
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'id'?: string;
    /**
     * Human-readable display name of the account correlation config
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'name'?: string;
}

export const SourceAccountCorrelationConfigTypeEnum = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG'
} as const;

export type SourceAccountCorrelationConfigTypeEnum = typeof SourceAccountCorrelationConfigTypeEnum[keyof typeof SourceAccountCorrelationConfigTypeEnum];

/**
 * Reference to a Rule that can do COMPLEX correlation, should only be used when accountCorrelationConfig can\'t be used.
 * @export
 * @interface SourceAccountCorrelationRule
 */
export interface SourceAccountCorrelationRule {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'type'?: SourceAccountCorrelationRuleTypeEnum;
    /**
     * ID of the rule
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'id'?: string;
    /**
     * Human-readable display name of the rule
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'name'?: string;
}

export const SourceAccountCorrelationRuleTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceAccountCorrelationRuleTypeEnum = typeof SourceAccountCorrelationRuleTypeEnum[keyof typeof SourceAccountCorrelationRuleTypeEnum];

/**
 * Rule that runs on the CCG and allows for customization of provisioning plans before the connector is called.
 * @export
 * @interface SourceBeforeProvisioningRule
 */
export interface SourceBeforeProvisioningRule {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'type'?: SourceBeforeProvisioningRuleTypeEnum;
    /**
     * ID of the rule
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'id'?: string;
    /**
     * Human-readable display name of the rule
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'name'?: string;
}

export const SourceBeforeProvisioningRuleTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceBeforeProvisioningRuleTypeEnum = typeof SourceBeforeProvisioningRuleTypeEnum[keyof typeof SourceBeforeProvisioningRuleTypeEnum];

/**
 * Reference to the associated Cluster
 * @export
 * @interface SourceCluster
 */
export interface SourceCluster {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceCluster
     */
    'type'?: SourceClusterTypeEnum;
    /**
     * ID of the cluster
     * @type {string}
     * @memberof SourceCluster
     */
    'id'?: string;
    /**
     * Human-readable display name of the cluster
     * @type {string}
     * @memberof SourceCluster
     */
    'name'?: string;
}

export const SourceClusterTypeEnum = {
    Cluster: 'CLUSTER'
} as const;

export type SourceClusterTypeEnum = typeof SourceClusterTypeEnum[keyof typeof SourceClusterTypeEnum];

/**
 * Optional features that can be supported by an source. * AUTHENTICATE: The source supports pass-through authentication. * COMPOSITE: The source supports composite source creation. * DIRECT_PERMISSIONS: The source supports returning DirectPermissions. * DISCOVER_SCHEMA: The source supports discovering schemas for users and groups. * ENABLE The source supports reading if an account is enabled or disabled. * MANAGER_LOOKUP: The source supports looking up managers as they are encountered in a feed. This is the opposite of NO_RANDOM_ACCESS. * NO_RANDOM_ACCESS: The source does not support random access and the getObject() methods should not be called and expected to perform. * PROXY: The source can serve as a proxy for another source. When an source has a proxy, all connector calls made with that source are redirected through the connector for the proxy source. * SEARCH * TEMPLATE * UNLOCK: The source supports reading if an account is locked or unlocked. * UNSTRUCTURED_TARGETS: The source supports returning unstructured Targets. * SHAREPOINT_TARGET: The source supports returning unstructured Target data for SharePoint. It will be typically used by AD, LDAP sources. * PROVISIONING: The source can both read and write accounts. Having this feature implies that the provision() method is implemented. It also means that direct and target permissions can also be provisioned if they can be returned by aggregation. * GROUP_PROVISIONING: The source can both read and write groups. Having this feature implies that the provision() method is implemented. * SYNC_PROVISIONING: The source can provision accounts synchronously. * PASSWORD: The source can provision password changes. Since sources can never read passwords, this is should only be used in conjunction with the PROVISIONING feature. * CURRENT_PASSWORD: Some source types support verification of the current password * ACCOUNT_ONLY_REQUEST: The source supports requesting accounts without entitlements. * ADDITIONAL_ACCOUNT_REQUEST: The source supports requesting additional accounts. * NO_AGGREGATION: A source that does not support aggregation. * GROUPS_HAVE_MEMBERS: The source models group memberships with a member attribute on the group object rather than a groups attribute on the account object. This effects the implementation of delta account aggregation. * NO_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for accounts. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for accounts. * NO_GROUP_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for groups. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for groups. * NO_UNSTRUCTURED_TARGETS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING. * NO_DIRECT_PERMISSIONS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING.
 * @export
 * @enum {string}
 */

export const SourceFeature = {
    Authenticate: 'AUTHENTICATE',
    Composite: 'COMPOSITE',
    DirectPermissions: 'DIRECT_PERMISSIONS',
    DiscoverSchema: 'DISCOVER_SCHEMA',
    Enable: 'ENABLE',
    ManagerLookup: 'MANAGER_LOOKUP',
    NoRandomAccess: 'NO_RANDOM_ACCESS',
    Proxy: 'PROXY',
    Search: 'SEARCH',
    Template: 'TEMPLATE',
    Unlock: 'UNLOCK',
    UnstructuredTargets: 'UNSTRUCTURED_TARGETS',
    SharepointTarget: 'SHAREPOINT_TARGET',
    Provisioning: 'PROVISIONING',
    GroupProvisioning: 'GROUP_PROVISIONING',
    SyncProvisioning: 'SYNC_PROVISIONING',
    Password: 'PASSWORD',
    CurrentPassword: 'CURRENT_PASSWORD',
    AccountOnlyRequest: 'ACCOUNT_ONLY_REQUEST',
    AdditionalAccountRequest: 'ADDITIONAL_ACCOUNT_REQUEST',
    NoAggregation: 'NO_AGGREGATION',
    GroupsHaveMembers: 'GROUPS_HAVE_MEMBERS',
    NoPermissionsProvisioning: 'NO_PERMISSIONS_PROVISIONING',
    NoGroupPermissionsProvisioning: 'NO_GROUP_PERMISSIONS_PROVISIONING',
    NoUnstructuredTargetsProvisioning: 'NO_UNSTRUCTURED_TARGETS_PROVISIONING',
    NoDirectPermissionsProvisioning: 'NO_DIRECT_PERMISSIONS_PROVISIONING'
} as const;

export type SourceFeature = typeof SourceFeature[keyof typeof SourceFeature];


/**
 * Dto for source health data
 * @export
 * @interface SourceHealthDto
 */
export interface SourceHealthDto {
    /**
     * the id of the Source
     * @type {string}
     * @memberof SourceHealthDto
     */
    'id'?: string;
    /**
     * Specifies the type of system being managed e.g. Active Directory, Workday, etc.. If you are creating a Delimited File source, you must set the `provisionasCsv` query parameter to `true`. 
     * @type {string}
     * @memberof SourceHealthDto
     */
    'type'?: string;
    /**
     * the name of the source
     * @type {string}
     * @memberof SourceHealthDto
     */
    'name'?: string;
    /**
     * source\'s org
     * @type {string}
     * @memberof SourceHealthDto
     */
    'org'?: string;
    /**
     * Is the source authoritative
     * @type {boolean}
     * @memberof SourceHealthDto
     */
    'isAuthoritative'?: boolean;
    /**
     * Is the source in a cluster
     * @type {boolean}
     * @memberof SourceHealthDto
     */
    'isCluster'?: boolean;
    /**
     * source\'s hostname
     * @type {string}
     * @memberof SourceHealthDto
     */
    'hostname'?: string;
    /**
     * source\'s pod
     * @type {string}
     * @memberof SourceHealthDto
     */
    'pod'?: string;
    /**
     * The version of the iqService
     * @type {string}
     * @memberof SourceHealthDto
     */
    'iqServiceVersion'?: string;
    /**
     * connection test result
     * @type {string}
     * @memberof SourceHealthDto
     */
    'status'?: SourceHealthDtoStatusEnum;
}

export const SourceHealthDtoStatusEnum = {
    ErrorCluster: 'SOURCE_STATE_ERROR_CLUSTER',
    ErrorSource: 'SOURCE_STATE_ERROR_SOURCE',
    ErrorVa: 'SOURCE_STATE_ERROR_VA',
    FailureCluster: 'SOURCE_STATE_FAILURE_CLUSTER',
    FailureSource: 'SOURCE_STATE_FAILURE_SOURCE',
    Healthy: 'SOURCE_STATE_HEALTHY',
    UncheckedCluster: 'SOURCE_STATE_UNCHECKED_CLUSTER',
    UncheckedClusterNoSources: 'SOURCE_STATE_UNCHECKED_CLUSTER_NO_SOURCES',
    UncheckedSource: 'SOURCE_STATE_UNCHECKED_SOURCE',
    UncheckedSourceNoAccounts: 'SOURCE_STATE_UNCHECKED_SOURCE_NO_ACCOUNTS'
} as const;

export type SourceHealthDtoStatusEnum = typeof SourceHealthDtoStatusEnum[keyof typeof SourceHealthDtoStatusEnum];

/**
 * Reference to Management Workgroup for this Source
 * @export
 * @interface SourceManagementWorkgroup
 */
export interface SourceManagementWorkgroup {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'type'?: SourceManagementWorkgroupTypeEnum;
    /**
     * ID of the management workgroup
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'id'?: string;
    /**
     * Human-readable display name of the management workgroup
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'name'?: string;
}

export const SourceManagementWorkgroupTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type SourceManagementWorkgroupTypeEnum = typeof SourceManagementWorkgroupTypeEnum[keyof typeof SourceManagementWorkgroupTypeEnum];

/**
 * Reference to the ManagerCorrelationRule, only used when a simple filter isn\'t sufficient.
 * @export
 * @interface SourceManagerCorrelationRule
 */
export interface SourceManagerCorrelationRule {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'type'?: SourceManagerCorrelationRuleTypeEnum;
    /**
     * ID of the rule
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'id'?: string;
    /**
     * Human-readable display name of the rule
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'name'?: string;
}

export const SourceManagerCorrelationRuleTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceManagerCorrelationRuleTypeEnum = typeof SourceManagerCorrelationRuleTypeEnum[keyof typeof SourceManagerCorrelationRuleTypeEnum];

/**
 * Reference to an owning Identity Object
 * @export
 * @interface SourceOwner
 */
export interface SourceOwner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceOwner
     */
    'type'?: SourceOwnerTypeEnum;
    /**
     * ID of the identity
     * @type {string}
     * @memberof SourceOwner
     */
    'id'?: string;
    /**
     * Human-readable display name of the identity
     * @type {string}
     * @memberof SourceOwner
     */
    'name'?: string;
}

export const SourceOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SourceOwnerTypeEnum = typeof SourceOwnerTypeEnum[keyof typeof SourceOwnerTypeEnum];

/**
 * 
 * @export
 * @interface SourcePasswordPoliciesInner
 */
export interface SourcePasswordPoliciesInner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'type'?: SourcePasswordPoliciesInnerTypeEnum;
    /**
     * ID of the policy
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the policy
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'name'?: string;
}

export const SourcePasswordPoliciesInnerTypeEnum = {
    PasswordPolicy: 'PASSWORD_POLICY'
} as const;

export type SourcePasswordPoliciesInnerTypeEnum = typeof SourcePasswordPoliciesInnerTypeEnum[keyof typeof SourcePasswordPoliciesInnerTypeEnum];

/**
 * 
 * @export
 * @interface SourceSchemasInner
 */
export interface SourceSchemasInner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'type'?: SourceSchemasInnerTypeEnum;
    /**
     * ID of the schema
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the schema
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'name'?: string;
}

export const SourceSchemasInnerTypeEnum = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
} as const;

export type SourceSchemasInnerTypeEnum = typeof SourceSchemasInnerTypeEnum[keyof typeof SourceSchemasInnerTypeEnum];

/**
 * Message model for Config Import/Export.
 * @export
 * @interface SpConfigMessage
 */
export interface SpConfigMessage {
    /**
     * Message key.
     * @type {string}
     * @memberof SpConfigMessage
     */
    'key': string;
    /**
     * Message text.
     * @type {string}
     * @memberof SpConfigMessage
     */
    'text': string;
    /**
     * Message details if any, in key:value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof SpConfigMessage
     */
    'details': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Split
 */
export interface Split {
    /**
     * This can be either a single character or a regex expression, and is used by the transform to identify the break point between two substrings in the incoming data
     * @type {string}
     * @memberof Split
     */
    'delimiter': string;
    /**
     * An integer value for the desired array element after the incoming data has been split into a list; the array is a 0-based object, so the first array element would be index 0, the second element would be index 1, etc.
     * @type {string}
     * @memberof Split
     */
    'index': string;
    /**
     * A boolean (true/false) value which indicates whether an exception should be thrown and returned as an output when an index is out of bounds with the resultant array (i.e., the provided index value is larger than the size of the array)   `true` - The transform should return \"IndexOutOfBoundsException\"   `false` - The transform should return null   If not provided, the transform will default to false and return a null 
     * @type {boolean}
     * @memberof Split
     */
    'throws'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Split
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Split
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Static
 */
export interface Static {
    /**
     * This must evaluate to a JSON string, either through a fixed value or through conditional logic using the Apache Velocity Template Language.
     * @type {string}
     * @memberof Static
     */
    'values': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Static
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface SubSearchAggregationSpecification
 */
export interface SubSearchAggregationSpecification {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'bucket'?: BucketAggregation;
    /**
     * 
     * @type {Aggregations}
     * @memberof SubSearchAggregationSpecification
     */
    'subAggregation'?: Aggregations;
}
/**
 * 
 * @export
 * @interface SubSearchAggregationSpecificationAllOf
 */
export interface SubSearchAggregationSpecificationAllOf {
    /**
     * 
     * @type {Aggregations}
     * @memberof SubSearchAggregationSpecificationAllOf
     */
    'subAggregation'?: Aggregations;
}
/**
 * 
 * @export
 * @interface Substring
 */
export interface Substring {
    /**
     * The index of the first character to include in the returned substring.   If `begin` is set to -1, the transform will begin at character 0 of the input data 
     * @type {number}
     * @memberof Substring
     */
    'begin': number;
    /**
     * This integer value is the number of characters to add to the begin attribute when returning a substring.   This attribute is only used if begin is not -1. 
     * @type {number}
     * @memberof Substring
     */
    'beginOffset'?: number;
    /**
     * The index of the first character to exclude from the returned substring.  If end is -1 or not provided at all, the substring transform will return everything up to the end of the input string. 
     * @type {number}
     * @memberof Substring
     */
    'end'?: number;
    /**
     * This integer value is the number of characters to add to the end attribute when returning a substring.   This attribute is only used if end is provided and is not -1. 
     * @type {number}
     * @memberof Substring
     */
    'endOffset'?: number;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Substring
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Substring
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface TaggedObject
 */
export interface TaggedObject {
    /**
     * 
     * @type {TaggedObjectDto}
     * @memberof TaggedObject
     */
    'objectRef'?: TaggedObjectDto;
    /**
     * Labels to be applied to an Object
     * @type {Array<string>}
     * @memberof TaggedObject
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TaggedObjectDto
 */
export interface TaggedObjectDto {
    /**
     * 
     * @type {DtoType}
     * @memberof TaggedObjectDto
     */
    'type'?: DtoType;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof TaggedObjectDto
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof TaggedObjectDto
     */
    'name'?: string | null;
}
/**
 * The representation of an internally- or customer-defined transform.
 * @export
 * @interface Transform
 */
export interface Transform {
    /**
     * Unique ID of this transform
     * @type {string}
     * @memberof Transform
     */
    'id'?: string;
    /**
     * Unique name of this transform
     * @type {string}
     * @memberof Transform
     */
    'name': string;
    /**
     * The type of transform operation
     * @type {string}
     * @memberof Transform
     */
    'type': TransformTypeEnum;
    /**
     * 
     * @type {TransformAttributes}
     * @memberof Transform
     */
    'attributes': TransformAttributes;
    /**
     * Indicates whether this is an internal SailPoint-created transform or a customer-created transform
     * @type {boolean}
     * @memberof Transform
     */
    'internal'?: boolean;
}

export const TransformTypeEnum = {
    AccountAttribute: 'accountAttribute',
    Base64Decode: 'base64Decode',
    Base64Encode: 'base64Encode',
    Concat: 'concat',
    Conditional: 'conditional',
    DateCompare: 'dateCompare',
    DateFormat: 'dateFormat',
    DateMath: 'dateMath',
    DecomposeDiacriticalMarks: 'decomposeDiacriticalMarks',
    E164phone: 'e164phone',
    FirstValid: 'firstValid',
    Rule: 'rule',
    IdentityAttribute: 'identityAttribute',
    IndexOf: 'indexOf',
    Iso3166: 'iso3166',
    LastIndexOf: 'lastIndexOf',
    LeftPad: 'leftPad',
    Lookup: 'lookup',
    Lower: 'lower',
    NormalizeNames: 'normalizeNames',
    RandomAlphaNumeric: 'randomAlphaNumeric',
    RandomNumeric: 'randomNumeric',
    Reference: 'reference',
    ReplaceAll: 'replaceAll',
    Replace: 'replace',
    RightPad: 'rightPad',
    Split: 'split',
    Static: 'static',
    Substring: 'substring',
    Trim: 'trim',
    Upper: 'upper',
    UsernameGenerator: 'usernameGenerator',
    Uuid: 'uuid'
} as const;

export type TransformTypeEnum = typeof TransformTypeEnum[keyof typeof TransformTypeEnum];

/**
 * @type TransformAttributes
 * Meta-data about the transform. Values in this list are specific to the type of transform to be executed.
 * @export
 */
export type TransformAttributes = AccountAttribute | Base64Decode | Base64Encode | Concatenation | Conditional | DateCompare | DateFormat | DateMath | DecomposeDiacriticalMarks | E164phone | FirstValid | ISO3166 | IdentityAttribute | IndexOf | LeftPad | Lookup | Lower | NameNormalizer | RandomAlphaNumeric | RandomNumeric | Reference | Replace | ReplaceAll | RightPad | Rule | Split | Static | Substring | Trim | UUIDGenerator | Upper;

/**
 * 
 * @export
 * @interface TransformDefinition
 */
export interface TransformDefinition {
    /**
     * The type of the transform definition.
     * @type {string}
     * @memberof TransformDefinition
     */
    'type'?: string;
    /**
     * Arbitrary key-value pairs to store any metadata for the object
     * @type {{ [key: string]: TransformDefinitionAttributesValue; }}
     * @memberof TransformDefinition
     */
    'attributes'?: { [key: string]: TransformDefinitionAttributesValue; };
}
/**
 * 
 * @export
 * @interface TransformDefinitionAttributesValue
 */
export interface TransformDefinitionAttributesValue {
}
/**
 * 
 * @export
 * @interface Trim
 */
export interface Trim {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Trim
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Trim
     */
    'input'?: { [key: string]: any; };
}
/**
 * Query parameters used to construct an Elasticsearch type ahead query object.  The typeAheadQuery performs a search for top values beginning with the typed values. For example, typing \"Jo\" results in top hits matching \"Jo.\" Typing \"Job\" results in top hits matching \"Job.\" 
 * @export
 * @interface TypeAheadQuery
 */
export interface TypeAheadQuery {
    /**
     * The type ahead query string used to construct a phrase prefix match query.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'query': string;
    /**
     * The field on which to perform the type ahead search.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'field': string;
    /**
     * The nested type.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'nestedType'?: string;
    /**
     * The number of suffixes the last term will be expanded into. Influences the performance of the query and the number results returned. Valid values: 1 to 1000.
     * @type {number}
     * @memberof TypeAheadQuery
     */
    'maxExpansions'?: number;
}
/**
 * A typed reference to the object. 
 * @export
 * @interface TypedReference
 */
export interface TypedReference {
    /**
     * 
     * @type {DtoType}
     * @memberof TypedReference
     */
    'type': DtoType;
    /**
     * The id of the object. 
     * @type {string}
     * @memberof TypedReference
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface UUIDGenerator
 */
export interface UUIDGenerator {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof UUIDGenerator
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdatePasswordDictionaryRequest
 */
export interface UpdatePasswordDictionaryRequest {
    /**
     * 
     * @type {any}
     * @memberof UpdatePasswordDictionaryRequest
     */
    'file'?: any;
}
/**
 * 
 * @export
 * @interface Upper
 */
export interface Upper {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Upper
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Upper
     */
    'input'?: { [key: string]: any; };
}
/**
 * The type of ProvisioningPolicy usage.
 * @export
 * @enum {string}
 */

export const UsageType = {
    Create: 'CREATE',
    Update: 'UPDATE',
    Delete: 'DELETE',
    Assign: 'ASSIGN',
    Unassign: 'UNASSIGN',
    CreateGroup: 'CREATE_GROUP',
    UpdateGroup: 'UPDATE_GROUP',
    DeleteGroup: 'DELETE_GROUP',
    Register: 'REGISTER',
    CreateIdentity: 'CREATE_IDENTITY',
    UpdateIdentity: 'UPDATE_IDENTITY',
    EditGroup: 'EDIT_GROUP',
    Enable: 'ENABLE',
    Disable: 'DISABLE',
    Unlock: 'UNLOCK',
    ChangePassword: 'CHANGE_PASSWORD'
} as const;

export type UsageType = typeof UsageType[keyof typeof UsageType];


/**
 * 
 * @export
 * @interface Value
 */
export interface Value {
    /**
     * The type of attribute value
     * @type {string}
     * @memberof Value
     */
    'type'?: string;
    /**
     * The attribute value
     * @type {string}
     * @memberof Value
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ViolationContext
 */
export interface ViolationContext {
    /**
     * 
     * @type {ViolationContextPolicy}
     * @memberof ViolationContext
     */
    'policy'?: ViolationContextPolicy;
    /**
     * 
     * @type {ExceptionAccessCriteria}
     * @memberof ViolationContext
     */
    'conflictingAccessCriteria'?: ExceptionAccessCriteria;
}
/**
 * The types of objects supported for SOD violations
 * @export
 * @interface ViolationContextPolicy
 */
export interface ViolationContextPolicy {
    /**
     * The type of object that is referenced
     * @type {object}
     * @memberof ViolationContextPolicy
     */
    'type'?: ViolationContextPolicyTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ViolationContextPolicy
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViolationContextPolicy
     */
    'name'?: string;
}

export const ViolationContextPolicyTypeEnum = {
    Entitlement: 'ENTITLEMENT'
} as const;

export type ViolationContextPolicyTypeEnum = typeof ViolationContextPolicyTypeEnum[keyof typeof ViolationContextPolicyTypeEnum];

/**
 * 
 * @export
 * @interface ViolationContextPolicyAllOf
 */
export interface ViolationContextPolicyAllOf {
    /**
     * 
     * @type {string}
     * @memberof ViolationContextPolicyAllOf
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViolationContextPolicyAllOf
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ViolationOwnerAssignmentConfig
 */
export interface ViolationOwnerAssignmentConfig {
    /**
     * Details about the violations owner. MANAGER - identity\'s manager STATIC - Governance Group or Identity
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfig
     */
    'assignmentRule'?: ViolationOwnerAssignmentConfigAssignmentRuleEnum;
    /**
     * 
     * @type {ViolationOwnerAssignmentConfigOwnerRef}
     * @memberof ViolationOwnerAssignmentConfig
     */
    'ownerRef'?: ViolationOwnerAssignmentConfigOwnerRef;
}

export const ViolationOwnerAssignmentConfigAssignmentRuleEnum = {
    Manager: 'MANAGER',
    Static: 'STATIC',
    Null: 'null'
} as const;

export type ViolationOwnerAssignmentConfigAssignmentRuleEnum = typeof ViolationOwnerAssignmentConfigAssignmentRuleEnum[keyof typeof ViolationOwnerAssignmentConfigAssignmentRuleEnum];

/**
 * 
 * @export
 * @interface ViolationOwnerAssignmentConfigOwnerRef
 */
export interface ViolationOwnerAssignmentConfigOwnerRef {
    /**
     * 
     * @type {DtoType}
     * @memberof ViolationOwnerAssignmentConfigOwnerRef
     */
    'type'?: DtoType;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigOwnerRef
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof ViolationOwnerAssignmentConfigOwnerRef
     */
    'name'?: string;
}
/**
 * An object containing a listing of the SOD violation reasons detected by this check.
 * @export
 * @interface ViolationPrediction
 */
export interface ViolationPrediction {
    /**
     * List of Violation Contexts
     * @type {Array<ViolationContext>}
     * @memberof ViolationPrediction
     */
    'violationContexts'?: Array<ViolationContext>;
}
/**
 * 
 * @export
 * @interface VisibilityCriteria
 */
export interface VisibilityCriteria {
    /**
     * 
     * @type {Expression}
     * @memberof VisibilityCriteria
     */
    'expression'?: Expression;
}
/**
 * The state of a work item
 * @export
 * @enum {string}
 */

export const WorkItemState = {
    Finished: 'FINISHED',
    Rejected: 'REJECTED',
    Returned: 'RETURNED',
    Expired: 'EXPIRED',
    Pending: 'PENDING',
    Canceled: 'CANCELED'
} as const;

export type WorkItemState = typeof WorkItemState[keyof typeof WorkItemState];


/**
 * The type of the work item
 * @export
 * @enum {string}
 */

export const WorkItemType = {
    Unknown: 'UNKNOWN',
    Generic: 'GENERIC',
    Certification: 'CERTIFICATION',
    Remediation: 'REMEDIATION',
    Delegation: 'DELEGATION',
    Approval: 'APPROVAL',
    Violationreview: 'VIOLATIONREVIEW',
    Form: 'FORM',
    Policyviolation: 'POLICYVIOLATION',
    Challenge: 'CHALLENGE',
    Impactanalysis: 'IMPACTANALYSIS',
    Signoff: 'SIGNOFF',
    Event: 'EVENT',
    Manualaction: 'MANUALACTION',
    Test: 'TEST'
} as const;

export type WorkItemType = typeof WorkItemType[keyof typeof WorkItemType];


/**
 * 
 * @export
 * @interface WorkItems
 */
export interface WorkItems {
    /**
     * ID of the work item
     * @type {string}
     * @memberof WorkItems
     */
    'id'?: string;
    /**
     * ID of the requester
     * @type {string}
     * @memberof WorkItems
     */
    'requesterId'?: string;
    /**
     * The displayname of the requester
     * @type {string}
     * @memberof WorkItems
     */
    'requesterDisplayName'?: string;
    /**
     * The ID of the owner
     * @type {string}
     * @memberof WorkItems
     */
    'ownerId'?: string;
    /**
     * The name of the owner
     * @type {string}
     * @memberof WorkItems
     */
    'ownerName'?: string;
    /**
     * Time when the work item was created
     * @type {string}
     * @memberof WorkItems
     */
    'created'?: string;
    /**
     * Time when the work item was last updated
     * @type {string}
     * @memberof WorkItems
     */
    'modified'?: string;
    /**
     * The description of the work item
     * @type {string}
     * @memberof WorkItems
     */
    'description'?: string;
    /**
     * 
     * @type {WorkItemState}
     * @memberof WorkItems
     */
    'state'?: WorkItemState;
    /**
     * 
     * @type {WorkItemType}
     * @memberof WorkItems
     */
    'type'?: WorkItemType;
    /**
     * 
     * @type {RemediationItemDetails}
     * @memberof WorkItems
     */
    'remediationItems'?: RemediationItemDetails;
    /**
     * 
     * @type {ApprovalItemDetails}
     * @memberof WorkItems
     */
    'approvalItems'?: ApprovalItemDetails;
    /**
     * The work item name
     * @type {string}
     * @memberof WorkItems
     */
    'name'?: string;
    /**
     * The time at which the work item completed
     * @type {string}
     * @memberof WorkItems
     */
    'completed'?: string;
    /**
     * The number of items in the work item
     * @type {number}
     * @memberof WorkItems
     */
    'numItems'?: number;
    /**
     * 
     * @type {FormDetails}
     * @memberof WorkItems
     */
    'form'?: FormDetails;
    /**
     * An array of errors that ocurred during the work item
     * @type {Array<string>}
     * @memberof WorkItems
     */
    'errors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WorkItemsCount
 */
export interface WorkItemsCount {
    /**
     * The count of work items
     * @type {number}
     * @memberof WorkItemsCount
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface WorkItemsSummary
 */
export interface WorkItemsSummary {
    /**
     * The count of open work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'open'?: number;
    /**
     * The count of completed work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'completed'?: number;
    /**
     * The count of total work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'total'?: number;
}

/**
 * AccessProfilesApi - axios parameter creator
 * @export
 */
export const AccessProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates an Access Profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the Access Profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create an Access Profile
         * @param {AccessProfile} accessProfile 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessProfile: async (accessProfile: AccessProfile, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessProfile' is not null or undefined
            assertParamExists('createAccessProfile', 'accessProfile', accessProfile)
            const localVarPath = `/access-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessProfile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API initiates a bulk deletion of one or more Access Profiles.  By default, if any of the indicated Access Profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated Access Profiles will be deleted.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to delete Access Profiles which are associated with Sources they are able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequest} accessProfileBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfilesInBulk: async (accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessProfileBulkDeleteRequest' is not null or undefined
            assertParamExists('deleteAccessProfilesInBulk', 'accessProfileBulkDeleteRequest', accessProfileBulkDeleteRequest)
            const localVarPath = `/access-profiles/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessProfileBulkDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfile: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccessProfile', 'id', id)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the containing Access Profile
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following Entitlement fields and operators: **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfileEntitlements: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccessProfileEntitlements', 'id', id)
            const localVarPath = `/access-profiles/{id}/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of Access Profiles.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Access Profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessProfiles: async (forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSegmentIds !== undefined) {
                localVarQueryParameter['for-segment-ids'] = forSegmentIds;
            }

            if (includeUnsegmented !== undefined) {
                localVarQueryParameter['include-unsegmented'] = includeUnsegmented;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.  >  Patching the value of the **requestable** field is only supported for customers enabled with the new Request Center. Otherwise, attempting to modify this field results in a 400 error.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessProfile: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchAccessProfile', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchAccessProfile', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/access-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessProfilesApi - functional programming interface
 * @export
 */
export const AccessProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates an Access Profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the Access Profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create an Access Profile
         * @param {AccessProfile} accessProfile 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessProfile(accessProfile: AccessProfile, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessProfile(accessProfile, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API initiates a bulk deletion of one or more Access Profiles.  By default, if any of the indicated Access Profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated Access Profiles will be deleted.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to delete Access Profiles which are associated with Sources they are able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequest} accessProfileBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfileBulkDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessProfile(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessProfile(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the containing Access Profile
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following Entitlement fields and operators: **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessProfileEntitlements(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Entitlement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessProfileEntitlements(id, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of Access Profiles.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Access Profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessProfiles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessProfiles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.  >  Patching the value of the **requestable** field is only supported for customers enabled with the new Request Center. Otherwise, attempting to modify this field results in a 400 error.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccessProfile(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAccessProfile(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessProfilesApi - factory interface
 * @export
 */
export const AccessProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessProfilesApiFp(configuration)
    return {
        /**
         * This API creates an Access Profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the Access Profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create an Access Profile
         * @param {AccessProfile} accessProfile 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessProfile(accessProfile: AccessProfile, axiosOptions?: any): AxiosPromise<AccessProfile> {
            return localVarFp.createAccessProfile(accessProfile, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API initiates a bulk deletion of one or more Access Profiles.  By default, if any of the indicated Access Profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated Access Profiles will be deleted.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to delete Access Profiles which are associated with Sources they are able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequest} accessProfileBulkDeleteRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest, axiosOptions?: any): AxiosPromise<AccessProfileBulkDeleteResponse> {
            return localVarFp.deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfile(id: string, axiosOptions?: any): AxiosPromise<AccessProfile> {
            return localVarFp.getAccessProfile(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the containing Access Profile
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following Entitlement fields and operators: **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfileEntitlements(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<Entitlement>> {
            return localVarFp.getAccessProfileEntitlements(id, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of Access Profiles.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Access Profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessProfiles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: any): AxiosPromise<Array<AccessProfile>> {
            return localVarFp.listAccessProfiles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.  >  Patching the value of the **requestable** field is only supported for customers enabled with the new Request Center. Otherwise, attempting to modify this field results in a 400 error.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessProfile(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<AccessProfile> {
            return localVarFp.patchAccessProfile(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiCreateAccessProfileRequest
 */
export interface AccessProfilesApiCreateAccessProfileRequest {
    /**
     * 
     * @type {AccessProfile}
     * @memberof AccessProfilesApiCreateAccessProfile
     */
    readonly accessProfile: AccessProfile
}

/**
 * Request parameters for deleteAccessProfilesInBulk operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiDeleteAccessProfilesInBulkRequest
 */
export interface AccessProfilesApiDeleteAccessProfilesInBulkRequest {
    /**
     * 
     * @type {AccessProfileBulkDeleteRequest}
     * @memberof AccessProfilesApiDeleteAccessProfilesInBulk
     */
    readonly accessProfileBulkDeleteRequest: AccessProfileBulkDeleteRequest
}

/**
 * Request parameters for getAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiGetAccessProfileRequest
 */
export interface AccessProfilesApiGetAccessProfileRequest {
    /**
     * ID of the Access Profile
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfile
     */
    readonly id: string
}

/**
 * Request parameters for getAccessProfileEntitlements operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiGetAccessProfileEntitlementsRequest
 */
export interface AccessProfilesApiGetAccessProfileEntitlementsRequest {
    /**
     * ID of the containing Access Profile
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following Entitlement fields and operators: **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
     * @type {string}
     * @memberof AccessProfilesApiGetAccessProfileEntitlements
     */
    readonly sorters?: string
}

/**
 * Request parameters for listAccessProfiles operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiListAccessProfilesRequest
 */
export interface AccessProfilesApiListAccessProfilesRequest {
    /**
     * If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly forSubadmin?: string

    /**
     * Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created, modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly sorters?: string

    /**
     * If present and not empty, additionally filters Access Profiles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
     * @type {string}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly forSegmentIds?: string

    /**
     * Whether or not the response list should contain unsegmented Access Profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
     * @type {boolean}
     * @memberof AccessProfilesApiListAccessProfiles
     */
    readonly includeUnsegmented?: boolean
}

/**
 * Request parameters for patchAccessProfile operation in AccessProfilesApi.
 * @export
 * @interface AccessProfilesApiPatchAccessProfileRequest
 */
export interface AccessProfilesApiPatchAccessProfileRequest {
    /**
     * ID of the Access Profile to patch
     * @type {string}
     * @memberof AccessProfilesApiPatchAccessProfile
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperation>}
     * @memberof AccessProfilesApiPatchAccessProfile
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * AccessProfilesApi - object-oriented interface
 * @export
 * @class AccessProfilesApi
 * @extends {BaseAPI}
 */
export class AccessProfilesApi extends BaseAPI {
    /**
     * This API creates an Access Profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the Access Profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.
     * @summary Create an Access Profile
     * @param {AccessProfilesApiCreateAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public createAccessProfile(requestParameters: AccessProfilesApiCreateAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).createAccessProfile(requestParameters.accessProfile, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API initiates a bulk deletion of one or more Access Profiles.  By default, if any of the indicated Access Profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated Access Profiles will be deleted.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to delete Access Profiles which are associated with Sources they are able to administer.
     * @summary Delete Access Profile(s)
     * @param {AccessProfilesApiDeleteAccessProfilesInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public deleteAccessProfilesInBulk(requestParameters: AccessProfilesApiDeleteAccessProfilesInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).deleteAccessProfilesInBulk(requestParameters.accessProfileBulkDeleteRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get an Access Profile
     * @param {AccessProfilesApiGetAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public getAccessProfile(requestParameters: AccessProfilesApiGetAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).getAccessProfile(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lists the Entitlements associated with a given Access Profile  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the Source associated with the given Access Profile
     * @summary List Access Profile\'s Entitlements
     * @param {AccessProfilesApiGetAccessProfileEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public getAccessProfileEntitlements(requestParameters: AccessProfilesApiGetAccessProfileEntitlementsRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).getAccessProfileEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of Access Profiles.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary List Access Profiles
     * @param {AccessProfilesApiListAccessProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public listAccessProfiles(requestParameters: AccessProfilesApiListAccessProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).listAccessProfiles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.  >  Patching the value of the **requestable** field is only supported for customers enabled with the new Request Center. Otherwise, attempting to modify this field results in a 400 error.
     * @summary Patch a specified Access Profile
     * @param {AccessProfilesApiPatchAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    public patchAccessProfile(requestParameters: AccessProfilesApiPatchAccessProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessProfilesApiFp(this.configuration).patchAccessProfile(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccessRequestApprovalsApi - axios parameter creator
 * @export
 */
export const AccessRequestApprovalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approves an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveAccessRequest: async (approvalId: string, commentDto?: CommentDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('approveAccessRequest', 'approvalId', approvalId)
            const localVarPath = `/access-request-approvals/{approvalId}/approve`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint forwards an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forwards an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardAccessRequest: async (approvalId: string, forwardApprovalDto: ForwardApprovalDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('forwardAccessRequest', 'approvalId', approvalId)
            // verify required parameter 'forwardApprovalDto' is not null or undefined
            assertParamExists('forwardAccessRequest', 'forwardApprovalDto', forwardApprovalDto)
            const localVarPath = `/access-request-approvals/{approvalId}/forward`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forwardApprovalDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Get the number of access-requests-approvals
         * @param {string} [ownerId] The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestApprovalSummary: async (ownerId?: string, fromDate?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/approval-summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = fromDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Rejects an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectAccessRequest: async (approvalId: string, commentDto?: CommentDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('rejectAccessRequest', 'approvalId', approvalId)
            const localVarPath = `/access-request-approvals/{approvalId}/reject`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRequestApprovalsApi - functional programming interface
 * @export
 */
export const AccessRequestApprovalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessRequestApprovalsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approves an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveAccessRequest(approvalId: string, commentDto?: CommentDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveAccessRequest(approvalId, commentDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint forwards an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forwards an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async forwardAccessRequest(approvalId: string, forwardApprovalDto: ForwardApprovalDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forwardAccessRequest(approvalId, forwardApprovalDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Get the number of access-requests-approvals
         * @param {string} [ownerId] The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestApprovalSummary(ownerId?: string, fromDate?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestApprovalSummary(ownerId, fromDate, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCompletedApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompletedApproval>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCompletedApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPendingApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PendingApproval>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPendingApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Rejects an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectAccessRequest(approvalId: string, commentDto?: CommentDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectAccessRequest(approvalId, commentDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessRequestApprovalsApi - factory interface
 * @export
 */
export const AccessRequestApprovalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessRequestApprovalsApiFp(configuration)
    return {
        /**
         * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approves an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveAccessRequest(approvalId: string, commentDto?: CommentDto, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.approveAccessRequest(approvalId, commentDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint forwards an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forwards an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardAccessRequest(approvalId: string, forwardApprovalDto: ForwardApprovalDto, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.forwardAccessRequest(approvalId, forwardApprovalDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Get the number of access-requests-approvals
         * @param {string} [ownerId] The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestApprovalSummary(ownerId?: string, fromDate?: string, axiosOptions?: any): AxiosPromise<ApprovalSummary> {
            return localVarFp.getAccessRequestApprovalSummary(ownerId, fromDate, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<CompletedApproval>> {
            return localVarFp.listCompletedApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<PendingApproval>> {
            return localVarFp.listPendingApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Rejects an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectAccessRequest(approvalId: string, commentDto?: CommentDto, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.rejectAccessRequest(approvalId, commentDto, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveAccessRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiApproveAccessRequestRequest
 */
export interface AccessRequestApprovalsApiApproveAccessRequestRequest {
    /**
     * The id of the approval.
     * @type {string}
     * @memberof AccessRequestApprovalsApiApproveAccessRequest
     */
    readonly approvalId: string

    /**
     * Reviewer\&#39;s comment.
     * @type {CommentDto}
     * @memberof AccessRequestApprovalsApiApproveAccessRequest
     */
    readonly commentDto?: CommentDto
}

/**
 * Request parameters for forwardAccessRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiForwardAccessRequestRequest
 */
export interface AccessRequestApprovalsApiForwardAccessRequestRequest {
    /**
     * The id of the approval.
     * @type {string}
     * @memberof AccessRequestApprovalsApiForwardAccessRequest
     */
    readonly approvalId: string

    /**
     * Information about the forwarded approval.
     * @type {ForwardApprovalDto}
     * @memberof AccessRequestApprovalsApiForwardAccessRequest
     */
    readonly forwardApprovalDto: ForwardApprovalDto
}

/**
 * Request parameters for getAccessRequestApprovalSummary operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest
 */
export interface AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest {
    /**
     * The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiGetAccessRequestApprovalSummary
     */
    readonly ownerId?: string

    /**
     * From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format
     * @type {string}
     * @memberof AccessRequestApprovalsApiGetAccessRequestApprovalSummary
     */
    readonly fromDate?: string
}

/**
 * Request parameters for listCompletedApprovals operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiListCompletedApprovalsRequest
 */
export interface AccessRequestApprovalsApiListCompletedApprovalsRequest {
    /**
     * If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for listPendingApprovals operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiListPendingApprovalsRequest
 */
export interface AccessRequestApprovalsApiListPendingApprovalsRequest {
    /**
     * If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for rejectAccessRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiRejectAccessRequestRequest
 */
export interface AccessRequestApprovalsApiRejectAccessRequestRequest {
    /**
     * The id of the approval.
     * @type {string}
     * @memberof AccessRequestApprovalsApiRejectAccessRequest
     */
    readonly approvalId: string

    /**
     * Reviewer\&#39;s comment.
     * @type {CommentDto}
     * @memberof AccessRequestApprovalsApiRejectAccessRequest
     */
    readonly commentDto?: CommentDto
}

/**
 * AccessRequestApprovalsApi - object-oriented interface
 * @export
 * @class AccessRequestApprovalsApi
 * @extends {BaseAPI}
 */
export class AccessRequestApprovalsApi extends BaseAPI {
    /**
     * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Approves an access request approval.
     * @param {AccessRequestApprovalsApiApproveAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public approveAccessRequest(requestParameters: AccessRequestApprovalsApiApproveAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).approveAccessRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint forwards an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Forwards an access request approval.
     * @param {AccessRequestApprovalsApiForwardAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public forwardAccessRequest(requestParameters: AccessRequestApprovalsApiForwardAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).forwardAccessRequest(requestParameters.approvalId, requestParameters.forwardApprovalDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
     * @summary Get the number of access-requests-approvals
     * @param {AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public getAccessRequestApprovalSummary(requestParameters: AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).getAccessRequestApprovalSummary(requestParameters.ownerId, requestParameters.fromDate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
     * @summary Completed Access Request Approvals List
     * @param {AccessRequestApprovalsApiListCompletedApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public listCompletedApprovals(requestParameters: AccessRequestApprovalsApiListCompletedApprovalsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).listCompletedApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
     * @summary Pending Access Request Approvals List
     * @param {AccessRequestApprovalsApiListPendingApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public listPendingApprovals(requestParameters: AccessRequestApprovalsApiListPendingApprovalsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).listPendingApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
     * @summary Rejects an access request approval.
     * @param {AccessRequestApprovalsApiRejectAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public rejectAccessRequest(requestParameters: AccessRequestApprovalsApiRejectAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).rejectAccessRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccessRequestsApi - axios parameter creator
 * @export
 */
export const AccessRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest: async (cancelAccessRequest: CancelAccessRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelAccessRequest' is not null or undefined
            assertParamExists('cancelAccessRequest', 'cancelAccessRequest', cancelAccessRequest)
            const localVarPath = `/access-requests/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelAccessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users, see \'/beta/access-request-config\' endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, Access Profiles and Entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If removeDate is specified, then the access will be removed on that date and time only for Roles and Access Profiles. Entitlements are currently unsupported for removeDate. * Roles, Access Profiles, and Entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * [Roles, Access Profiles] RemoveData can be specified only if access don\'t have a sunset date. * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  NOTE: There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit an Access Request
         * @param {AccessRequest} accessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest: async (accessRequest: AccessRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequest' is not null or undefined
            assertParamExists('createAccessRequest', 'accessRequest', accessRequest)
            const localVarPath = `/access-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus: async (requestedFor?: string, requestedBy?: string, regardingIdentity?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (requestedBy !== undefined) {
                localVarQueryParameter['requested-by'] = requestedBy;
            }

            if (regardingIdentity !== undefined) {
                localVarQueryParameter['regarding-identity'] = regardingIdentity;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessRequestConfig: async (accessRequestConfig: AccessRequestConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequestConfig' is not null or undefined
            assertParamExists('updateAccessRequestConfig', 'accessRequestConfig', accessRequestConfig)
            const localVarPath = `/access-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequestConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRequestsApi - functional programming interface
 * @export
 */
export const AccessRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelAccessRequest(cancelAccessRequest: CancelAccessRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelAccessRequest(cancelAccessRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users, see \'/beta/access-request-config\' endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, Access Profiles and Entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If removeDate is specified, then the access will be removed on that date and time only for Roles and Access Profiles. Entitlements are currently unsupported for removeDate. * Roles, Access Profiles, and Entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * [Roles, Access Profiles] RemoveData can be specified only if access don\'t have a sunset date. * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  NOTE: There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit an Access Request
         * @param {AccessRequest} accessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessRequest(accessRequest: AccessRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessRequest(accessRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessRequestStatus(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RequestedItemStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessRequestStatus(requestedFor, requestedBy, regardingIdentity, count, limit, offset, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccessRequestConfig(accessRequestConfig: AccessRequestConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccessRequestConfig(accessRequestConfig, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessRequestsApi - factory interface
 * @export
 */
export const AccessRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessRequestsApiFp(configuration)
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest(cancelAccessRequest: CancelAccessRequest, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.cancelAccessRequest(cancelAccessRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users, see \'/beta/access-request-config\' endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, Access Profiles and Entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If removeDate is specified, then the access will be removed on that date and time only for Roles and Access Profiles. Entitlements are currently unsupported for removeDate. * Roles, Access Profiles, and Entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * [Roles, Access Profiles] RemoveData can be specified only if access don\'t have a sunset date. * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  NOTE: There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit an Access Request
         * @param {AccessRequest} accessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest(accessRequest: AccessRequest, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.createAccessRequest(accessRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig(axiosOptions?: any): AxiosPromise<AccessRequestConfig> {
            return localVarFp.getAccessRequestConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<RequestedItemStatus>> {
            return localVarFp.listAccessRequestStatus(requestedFor, requestedBy, regardingIdentity, count, limit, offset, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessRequestConfig(accessRequestConfig: AccessRequestConfig, axiosOptions?: any): AxiosPromise<AccessRequestConfig> {
            return localVarFp.updateAccessRequestConfig(accessRequestConfig, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelAccessRequest operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiCancelAccessRequestRequest
 */
export interface AccessRequestsApiCancelAccessRequestRequest {
    /**
     * 
     * @type {CancelAccessRequest}
     * @memberof AccessRequestsApiCancelAccessRequest
     */
    readonly cancelAccessRequest: CancelAccessRequest
}

/**
 * Request parameters for createAccessRequest operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiCreateAccessRequestRequest
 */
export interface AccessRequestsApiCreateAccessRequestRequest {
    /**
     * 
     * @type {AccessRequest}
     * @memberof AccessRequestsApiCreateAccessRequest
     */
    readonly accessRequest: AccessRequest
}

/**
 * Request parameters for listAccessRequestStatus operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiListAccessRequestStatusRequest
 */
export interface AccessRequestsApiListAccessRequestStatusRequest {
    /**
     * Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly requestedFor?: string

    /**
     * Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly requestedBy?: string

    /**
     * Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly regardingIdentity?: string

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
     * @type {boolean}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly count?: boolean

    /**
     * Max number of results to return.
     * @type {number}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
     * @type {number}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in*
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId**
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly sorters?: string
}

/**
 * Request parameters for updateAccessRequestConfig operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiUpdateAccessRequestConfigRequest
 */
export interface AccessRequestsApiUpdateAccessRequestConfigRequest {
    /**
     * 
     * @type {AccessRequestConfig}
     * @memberof AccessRequestsApiUpdateAccessRequestConfig
     */
    readonly accessRequestConfig: AccessRequestConfig
}

/**
 * AccessRequestsApi - object-oriented interface
 * @export
 * @class AccessRequestsApi
 * @extends {BaseAPI}
 */
export class AccessRequestsApi extends BaseAPI {
    /**
     * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
     * @summary Cancel Access Request
     * @param {AccessRequestsApiCancelAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public cancelAccessRequest(requestParameters: AccessRequestsApiCancelAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).cancelAccessRequest(requestParameters.cancelAccessRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users, see \'/beta/access-request-config\' endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, Access Profiles and Entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If removeDate is specified, then the access will be removed on that date and time only for Roles and Access Profiles. Entitlements are currently unsupported for removeDate. * Roles, Access Profiles, and Entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * [Roles, Access Profiles] RemoveData can be specified only if access don\'t have a sunset date. * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  NOTE: There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
     * @summary Submit an Access Request
     * @param {AccessRequestsApiCreateAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public createAccessRequest(requestParameters: AccessRequestsApiCreateAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).createAccessRequest(requestParameters.accessRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the current access-request configuration.
     * @summary Get Access Request Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public getAccessRequestConfig(axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).getAccessRequestConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
     * @summary Access Request Status
     * @param {AccessRequestsApiListAccessRequestStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public listAccessRequestStatus(requestParameters: AccessRequestsApiListAccessRequestStatusRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).listAccessRequestStatus(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.count, requestParameters.limit, requestParameters.offset, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Access Request Configuration
     * @param {AccessRequestsApiUpdateAccessRequestConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public updateAccessRequestConfig(requestParameters: AccessRequestsApiUpdateAccessRequestConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).updateAccessRequestConfig(requestParameters.accessRequestConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountActivitiesApi - axios parameter creator
 * @export
 */
export const AccountActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountActivity', 'id', id)
            const localVarPath = `/account-activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Filtering is supported for the following fields and operators:  **type**: *eq, in* (See the &#x60;type&#x60; property in the response schema for possible values)  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities: async (requestedFor?: string, requestedBy?: string, regardingIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account-activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (requestedBy !== undefined) {
                localVarQueryParameter['requested-by'] = requestedBy;
            }

            if (regardingIdentity !== undefined) {
                localVarQueryParameter['regarding-identity'] = regardingIdentity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountActivitiesApi - functional programming interface
 * @export
 */
export const AccountActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountActivity(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountActivity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountActivity(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Filtering is supported for the following fields and operators:  **type**: *eq, in* (See the &#x60;type&#x60; property in the response schema for possible values)  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountActivities(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountActivity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountActivities(requestedFor, requestedBy, regardingIdentity, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountActivitiesApi - factory interface
 * @export
 */
export const AccountActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountActivitiesApiFp(configuration)
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity(id: string, axiosOptions?: any): AxiosPromise<AccountActivity> {
            return localVarFp.getAccountActivity(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Filtering is supported for the following fields and operators:  **type**: *eq, in* (See the &#x60;type&#x60; property in the response schema for possible values)  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<AccountActivity>> {
            return localVarFp.listAccountActivities(requestedFor, requestedBy, regardingIdentity, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAccountActivity operation in AccountActivitiesApi.
 * @export
 * @interface AccountActivitiesApiGetAccountActivityRequest
 */
export interface AccountActivitiesApiGetAccountActivityRequest {
    /**
     * The account activity id
     * @type {string}
     * @memberof AccountActivitiesApiGetAccountActivity
     */
    readonly id: string
}

/**
 * Request parameters for listAccountActivities operation in AccountActivitiesApi.
 * @export
 * @interface AccountActivitiesApiListAccountActivitiesRequest
 */
export interface AccountActivitiesApiListAccountActivitiesRequest {
    /**
     * The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly requestedFor?: string

    /**
     * The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly requestedBy?: string

    /**
     * The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly regardingIdentity?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Filtering is supported for the following fields and operators:  **type**: *eq, in* (See the &#x60;type&#x60; property in the response schema for possible values)  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **type, created, modified**
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly sorters?: string
}

/**
 * AccountActivitiesApi - object-oriented interface
 * @export
 * @class AccountActivitiesApi
 * @extends {BaseAPI}
 */
export class AccountActivitiesApi extends BaseAPI {
    /**
     * This gets a single account activity by its id.
     * @summary Get an Account Activity
     * @param {AccountActivitiesApiGetAccountActivityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesApi
     */
    public getAccountActivity(requestParameters: AccountActivitiesApiGetAccountActivityRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountActivitiesApiFp(this.configuration).getAccountActivity(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of account activities that satisfy the given query parameters.
     * @summary List Account Activities
     * @param {AccountActivitiesApiListAccountActivitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesApi
     */
    public listAccountActivities(requestParameters: AccountActivitiesApiListAccountActivitiesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccountActivitiesApiFp(this.configuration).listAccountActivities(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API submits an account creation task and returns the task ID.   The `sourceId` where this account will be created must be included in the `attributes` object. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (accountAttributesCreate: AccountAttributesCreate, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountAttributesCreate' is not null or undefined
            assertParamExists('createAccount', 'accountAttributesCreate', accountAttributesCreate)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAttributesCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits an account delete task and returns the task ID. This operation can only be used on Flat File Sources. Any attempt to execute this request on the source of other type will result in an error response with a status code of 400. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Account
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAccount', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount: async (id: string, accountToggleRequest: AccountToggleRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('disableAccount', 'id', id)
            // verify required parameter 'accountToggleRequest' is not null or undefined
            assertParamExists('disableAccount', 'accountToggleRequest', accountToggleRequest)
            const localVarPath = `/accounts/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountToggleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount: async (id: string, accountToggleRequest: AccountToggleRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enableAccount', 'id', id)
            // verify required parameter 'accountToggleRequest' is not null or undefined
            assertParamExists('enableAccount', 'accountToggleRequest', accountToggleRequest)
            const localVarPath = `/accounts/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountToggleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Details
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements: async (id: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountEntitlements', 'id', id)
            const localVarPath = `/accounts/{id}/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **identityId**: *eq*  **name**: *eq, in*  **nativeIdentity**: *eq, in*  **sourceId**: *eq, in*  **uncorrelated**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **created**, **modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API. >**NOTE: The PUT Account API is designated only for Delimited File sources.**
         * @summary Update Account
         * @param {string} id The account ID
         * @param {AccountAttributes} accountAttributes 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount: async (id: string, accountAttributes: AccountAttributes, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putAccount', 'id', id)
            // verify required parameter 'accountAttributes' is not null or undefined
            assertParamExists('putAccount', 'accountAttributes', accountAttributes)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAttributes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reloadAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reloadAccount', 'id', id)
            const localVarPath = `/accounts/{id}/reload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account id
         * @param {AccountUnlockRequest} accountUnlockRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount: async (id: string, accountUnlockRequest: AccountUnlockRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlockAccount', 'id', id)
            // verify required parameter 'accountUnlockRequest' is not null or undefined
            assertParamExists('unlockAccount', 'accountUnlockRequest', accountUnlockRequest)
            const localVarPath = `/accounts/{id}/unlock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUnlockRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to modify the following fields: * `identityId`  * `manuallyCorrelated`  >**NOTE: All other fields cannot be modified.**  The request must provide a JSONPatch payload.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAccount', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateAccount', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API submits an account creation task and returns the task ID.   The `sourceId` where this account will be created must be included in the `attributes` object. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(accountAttributesCreate: AccountAttributesCreate, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(accountAttributesCreate, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits an account delete task and returns the task ID. This operation can only be used on Flat File Sources. Any attempt to execute this request on the source of other type will result in an error response with a status code of 400. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Account
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async disableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableAccount(id, accountToggleRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async enableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableAccount(id, accountToggleRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Details
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountEntitlements(id: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntitlementDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountEntitlements(id, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **identityId**: *eq*  **name**: *eq, in*  **nativeIdentity**: *eq, in*  **sourceId**: *eq, in*  **uncorrelated**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **created**, **modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API. >**NOTE: The PUT Account API is designated only for Delimited File sources.**
         * @summary Update Account
         * @param {string} id The account ID
         * @param {AccountAttributes} accountAttributes 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putAccount(id: string, accountAttributes: AccountAttributes, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAccount(id, accountAttributes, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async reloadAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reloadAccount(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account id
         * @param {AccountUnlockRequest} accountUnlockRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async unlockAccount(id: string, accountUnlockRequest: AccountUnlockRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockAccount(id, accountUnlockRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to modify the following fields: * `identityId`  * `manuallyCorrelated`  >**NOTE: All other fields cannot be modified.**  The request must provide a JSONPatch payload.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * This API submits an account creation task and returns the task ID.   The `sourceId` where this account will be created must be included in the `attributes` object. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(accountAttributesCreate: AccountAttributesCreate, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.createAccount(accountAttributesCreate, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits an account delete task and returns the task ID. This operation can only be used on Flat File Sources. Any attempt to execute this request on the source of other type will result in an error response with a status code of 400. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Account
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(id: string, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.deleteAccount(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.disableAccount(id, accountToggleRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.enableAccount(id, accountToggleRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Details
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: string, axiosOptions?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements(id: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<EntitlementDto>> {
            return localVarFp.getAccountEntitlements(id, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **identityId**: *eq*  **name**: *eq, in*  **nativeIdentity**: *eq, in*  **sourceId**: *eq, in*  **uncorrelated**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **created**, **modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<Account>> {
            return localVarFp.listAccounts(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API. >**NOTE: The PUT Account API is designated only for Delimited File sources.**
         * @summary Update Account
         * @param {string} id The account ID
         * @param {AccountAttributes} accountAttributes 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount(id: string, accountAttributes: AccountAttributes, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.putAccount(id, accountAttributes, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reloadAccount(id: string, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.reloadAccount(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account id
         * @param {AccountUnlockRequest} accountUnlockRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount(id: string, accountUnlockRequest: AccountUnlockRequest, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.unlockAccount(id, accountUnlockRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to modify the following fields: * `identityId`  * `manuallyCorrelated`  >**NOTE: All other fields cannot be modified.**  The request must provide a JSONPatch payload.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.updateAccount(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiCreateAccountRequest
 */
export interface AccountsApiCreateAccountRequest {
    /**
     * 
     * @type {AccountAttributesCreate}
     * @memberof AccountsApiCreateAccount
     */
    readonly accountAttributesCreate: AccountAttributesCreate
}

/**
 * Request parameters for deleteAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDeleteAccountRequest
 */
export interface AccountsApiDeleteAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsApiDeleteAccount
     */
    readonly id: string
}

/**
 * Request parameters for disableAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDisableAccountRequest
 */
export interface AccountsApiDisableAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiDisableAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountToggleRequest}
     * @memberof AccountsApiDisableAccount
     */
    readonly accountToggleRequest: AccountToggleRequest
}

/**
 * Request parameters for enableAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiEnableAccountRequest
 */
export interface AccountsApiEnableAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiEnableAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountToggleRequest}
     * @memberof AccountsApiEnableAccount
     */
    readonly accountToggleRequest: AccountToggleRequest
}

/**
 * Request parameters for getAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountRequest
 */
export interface AccountsApiGetAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsApiGetAccount
     */
    readonly id: string
}

/**
 * Request parameters for getAccountEntitlements operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountEntitlementsRequest
 */
export interface AccountsApiGetAccountEntitlementsRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly count?: boolean
}

/**
 * Request parameters for listAccounts operation in AccountsApi.
 * @export
 * @interface AccountsApiListAccountsRequest
 */
export interface AccountsApiListAccountsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiListAccounts
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiListAccounts
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountsApiListAccounts
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **identityId**: *eq*  **name**: *eq, in*  **nativeIdentity**: *eq, in*  **sourceId**: *eq, in*  **uncorrelated**: *eq*
     * @type {string}
     * @memberof AccountsApiListAccounts
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **created**, **modified**
     * @type {string}
     * @memberof AccountsApiListAccounts
     */
    readonly sorters?: string
}

/**
 * Request parameters for putAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiPutAccountRequest
 */
export interface AccountsApiPutAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsApiPutAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountAttributes}
     * @memberof AccountsApiPutAccount
     */
    readonly accountAttributes: AccountAttributes
}

/**
 * Request parameters for reloadAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiReloadAccountRequest
 */
export interface AccountsApiReloadAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiReloadAccount
     */
    readonly id: string
}

/**
 * Request parameters for unlockAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiUnlockAccountRequest
 */
export interface AccountsApiUnlockAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiUnlockAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountUnlockRequest}
     * @memberof AccountsApiUnlockAccount
     */
    readonly accountUnlockRequest: AccountUnlockRequest
}

/**
 * Request parameters for updateAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiUpdateAccountRequest
 */
export interface AccountsApiUpdateAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsApiUpdateAccount
     */
    readonly id: string

    /**
     * A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperation>}
     * @memberof AccountsApiUpdateAccount
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * This API submits an account creation task and returns the task ID.   The `sourceId` where this account will be created must be included in the `attributes` object. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Account
     * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(requestParameters: AccountsApiCreateAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(requestParameters.accountAttributesCreate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits an account delete task and returns the task ID. This operation can only be used on Flat File Sources. Any attempt to execute this request on the source of other type will result in an error response with a status code of 400. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete Account
     * @param {AccountsApiDeleteAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(requestParameters: AccountsApiDeleteAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Disable Account
     * @param {AccountsApiDisableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public disableAccount(requestParameters: AccountsApiDisableAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).disableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Enable Account
     * @param {AccountsApiEnableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public enableAccount(requestParameters: AccountsApiEnableAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).enableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Account Details
     * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(requestParameters: AccountsApiGetAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Account Entitlements
     * @param {AccountsApiGetAccountEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountEntitlements(requestParameters: AccountsApiGetAccountEntitlementsRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Accounts List
     * @param {AccountsApiListAccountsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccounts(requestParameters: AccountsApiListAccountsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccounts(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API. >**NOTE: The PUT Account API is designated only for Delimited File sources.**
     * @summary Update Account
     * @param {AccountsApiPutAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public putAccount(requestParameters: AccountsApiPutAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).putAccount(requestParameters.id, requestParameters.accountAttributes, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Reload Account
     * @param {AccountsApiReloadAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public reloadAccount(requestParameters: AccountsApiReloadAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).reloadAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Unlock Account
     * @param {AccountsApiUnlockAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public unlockAccount(requestParameters: AccountsApiUnlockAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).unlockAccount(requestParameters.id, requestParameters.accountUnlockRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to modify the following fields: * `identityId`  * `manuallyCorrelated`  >**NOTE: All other fields cannot be modified.**  The request must provide a JSONPatch payload.  A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Account
     * @param {AccountsApiUpdateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(requestParameters: AccountsApiUpdateAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificationCampaignsApi - axios parameter creator
 * @export
 */
export const CertificationCampaignsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Certification Campaign with the information provided in the request body.
         * @summary Create a campaign
         * @param {Campaign} campaign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign: async (campaign: Campaign, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaign' is not null or undefined
            assertParamExists('createCampaign', 'campaign', campaign)
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets campaigns and returns them in a list. Can provide increased level of detail for each campaign if provided the correct query.
         * @summary List Campaigns
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**, **created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCampaigns: async (detail?: 'SLIM' | 'FULL', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (detail !== undefined) {
                localVarQueryParameter['detail'] = detail;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information for an existing campaign using the campaign\'s ID. Authorized callers must be a reviewer for this campaign, an ORG_ADMIN, or a CERT_ADMIN.
         * @summary Get a campaign
         * @param {string} id The ID of the campaign to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassign} adminReviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        move: async (id: string, adminReviewReassign: AdminReviewReassign, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('move', 'id', id)
            // verify required parameter 'adminReviewReassign' is not null or undefined
            assertParamExists('move', 'adminReviewReassign', adminReviewReassign)
            const localVarPath = `/campaigns/{id}/reassign`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminReviewReassign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Submits a job to activate the campaign with the given Id. The campaign must be staged. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Activate a Campaign
         * @param {string} id The campaign id
         * @param {ActivateCampaignOptions} [activateCampaignOptions] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign: async (id: string, activateCampaignOptions?: ActivateCampaignOptions, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activateCampaignOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationCampaignsApi - functional programming interface
 * @export
 */
export const CertificationCampaignsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationCampaignsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Certification Campaign with the information provided in the request body.
         * @summary Create a campaign
         * @param {Campaign} campaign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaign(campaign: Campaign, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaign(campaign, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets campaigns and returns them in a list. Can provide increased level of detail for each campaign if provided the correct query.
         * @summary List Campaigns
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**, **created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveCampaigns(detail?: 'SLIM' | 'FULL', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetActiveCampaigns200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveCampaigns(detail, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves information for an existing campaign using the campaign\'s ID. Authorized callers must be a reviewer for this campaign, an ORG_ADMIN, or a CERT_ADMIN.
         * @summary Get a campaign
         * @param {string} id The ID of the campaign to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaign(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlimCampaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaign(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassign} adminReviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async move(id: string, adminReviewReassign: AdminReviewReassign, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.move(id, adminReviewReassign, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submits a job to activate the campaign with the given Id. The campaign must be staged. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Activate a Campaign
         * @param {string} id The campaign id
         * @param {ActivateCampaignOptions} [activateCampaignOptions] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startCampaign(id: string, activateCampaignOptions?: ActivateCampaignOptions, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCampaign(id, activateCampaignOptions, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificationCampaignsApi - factory interface
 * @export
 */
export const CertificationCampaignsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationCampaignsApiFp(configuration)
    return {
        /**
         * Creates a new Certification Campaign with the information provided in the request body.
         * @summary Create a campaign
         * @param {Campaign} campaign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign(campaign: Campaign, axiosOptions?: any): AxiosPromise<Campaign> {
            return localVarFp.createCampaign(campaign, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets campaigns and returns them in a list. Can provide increased level of detail for each campaign if provided the correct query.
         * @summary List Campaigns
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**, **created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCampaigns(detail?: 'SLIM' | 'FULL', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<GetActiveCampaigns200ResponseInner>> {
            return localVarFp.getActiveCampaigns(detail, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves information for an existing campaign using the campaign\'s ID. Authorized callers must be a reviewer for this campaign, an ORG_ADMIN, or a CERT_ADMIN.
         * @summary Get a campaign
         * @param {string} id The ID of the campaign to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign(id: string, axiosOptions?: any): AxiosPromise<SlimCampaign> {
            return localVarFp.getCampaign(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassign} adminReviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        move(id: string, adminReviewReassign: AdminReviewReassign, axiosOptions?: any): AxiosPromise<CertificationTask> {
            return localVarFp.move(id, adminReviewReassign, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Submits a job to activate the campaign with the given Id. The campaign must be staged. Requires roles of CERT_ADMIN and ORG_ADMIN
         * @summary Activate a Campaign
         * @param {string} id The campaign id
         * @param {ActivateCampaignOptions} [activateCampaignOptions] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign(id: string, activateCampaignOptions?: ActivateCampaignOptions, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.startCampaign(id, activateCampaignOptions, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiCreateCampaignRequest
 */
export interface CertificationCampaignsApiCreateCampaignRequest {
    /**
     * 
     * @type {Campaign}
     * @memberof CertificationCampaignsApiCreateCampaign
     */
    readonly campaign: Campaign
}

/**
 * Request parameters for getActiveCampaigns operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetActiveCampaignsRequest
 */
export interface CertificationCampaignsApiGetActiveCampaignsRequest {
    /**
     * Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
     * @type {'SLIM' | 'FULL'}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly detail?: 'SLIM' | 'FULL'

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
     * @type {string}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**, **created**
     * @type {string}
     * @memberof CertificationCampaignsApiGetActiveCampaigns
     */
    readonly sorters?: string
}

/**
 * Request parameters for getCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiGetCampaignRequest
 */
export interface CertificationCampaignsApiGetCampaignRequest {
    /**
     * The ID of the campaign to be retrieved
     * @type {string}
     * @memberof CertificationCampaignsApiGetCampaign
     */
    readonly id: string
}

/**
 * Request parameters for move operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiMoveRequest
 */
export interface CertificationCampaignsApiMoveRequest {
    /**
     * The certification campaign ID
     * @type {string}
     * @memberof CertificationCampaignsApiMove
     */
    readonly id: string

    /**
     * 
     * @type {AdminReviewReassign}
     * @memberof CertificationCampaignsApiMove
     */
    readonly adminReviewReassign: AdminReviewReassign
}

/**
 * Request parameters for startCampaign operation in CertificationCampaignsApi.
 * @export
 * @interface CertificationCampaignsApiStartCampaignRequest
 */
export interface CertificationCampaignsApiStartCampaignRequest {
    /**
     * The campaign id
     * @type {string}
     * @memberof CertificationCampaignsApiStartCampaign
     */
    readonly id: string

    /**
     * Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
     * @type {ActivateCampaignOptions}
     * @memberof CertificationCampaignsApiStartCampaign
     */
    readonly activateCampaignOptions?: ActivateCampaignOptions
}

/**
 * CertificationCampaignsApi - object-oriented interface
 * @export
 * @class CertificationCampaignsApi
 * @extends {BaseAPI}
 */
export class CertificationCampaignsApi extends BaseAPI {
    /**
     * Creates a new Certification Campaign with the information provided in the request body.
     * @summary Create a campaign
     * @param {CertificationCampaignsApiCreateCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public createCampaign(requestParameters: CertificationCampaignsApiCreateCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).createCampaign(requestParameters.campaign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets campaigns and returns them in a list. Can provide increased level of detail for each campaign if provided the correct query.
     * @summary List Campaigns
     * @param {CertificationCampaignsApiGetActiveCampaignsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getActiveCampaigns(requestParameters: CertificationCampaignsApiGetActiveCampaignsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getActiveCampaigns(requestParameters.detail, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves information for an existing campaign using the campaign\'s ID. Authorized callers must be a reviewer for this campaign, an ORG_ADMIN, or a CERT_ADMIN.
     * @summary Get a campaign
     * @param {CertificationCampaignsApiGetCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public getCampaign(requestParameters: CertificationCampaignsApiGetCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).getCampaign(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API reassigns the specified certifications from one identity to another. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Reassign Certifications
     * @param {CertificationCampaignsApiMoveRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public move(requestParameters: CertificationCampaignsApiMoveRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).move(requestParameters.id, requestParameters.adminReviewReassign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a job to activate the campaign with the given Id. The campaign must be staged. Requires roles of CERT_ADMIN and ORG_ADMIN
     * @summary Activate a Campaign
     * @param {CertificationCampaignsApiStartCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    public startCampaign(requestParameters: CertificationCampaignsApiStartCampaignRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationCampaignsApiFp(this.configuration).startCampaign(requestParameters.id, requestParameters.activateCampaignOptions, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificationSummariesApi - axios parameter creator
 * @export
 */
export const CertificationSummariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityAccessSummaries: async (id: string, type: 'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityAccessSummaries', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getIdentityAccessSummaries', 'type', type)
            const localVarPath = `/certifications/{id}/access-summaries/{type}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityDecisionSummary: async (id: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityDecisionSummary', 'id', id)
            const localVarPath = `/certifications/{id}/decision-summary`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummaries: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentitySummaries', 'id', id)
            const localVarPath = `/certifications/{id}/identity-summaries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummary: async (id: string, identitySummaryId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentitySummary', 'id', id)
            // verify required parameter 'identitySummaryId' is not null or undefined
            assertParamExists('getIdentitySummary', 'identitySummaryId', identitySummaryId)
            const localVarPath = `/certifications/{id}/identity-summaries/{identitySummaryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"identitySummaryId"}}`, encodeURIComponent(String(identitySummaryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationSummariesApi - functional programming interface
 * @export
 */
export const CertificationSummariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationSummariesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityAccessSummaries(id: string, type: 'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityAccessSummaries(id, type, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityDecisionSummary(id: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertDecisionSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityDecisionSummary(id, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentitySummaries(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CertificationIdentitySummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentitySummaries(id, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentitySummary(id: string, identitySummaryId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationIdentitySummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentitySummary(id, identitySummaryId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificationSummariesApi - factory interface
 * @export
 */
export const CertificationSummariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationSummariesApiFp(configuration)
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityAccessSummaries(id: string, type: 'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<AccessSummary>> {
            return localVarFp.getIdentityAccessSummaries(id, type, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityDecisionSummary(id: string, filters?: string, axiosOptions?: any): AxiosPromise<IdentityCertDecisionSummary> {
            return localVarFp.getIdentityDecisionSummary(id, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummaries(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<CertificationIdentitySummary>> {
            return localVarFp.getIdentitySummaries(id, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummary(id: string, identitySummaryId: string, axiosOptions?: any): AxiosPromise<CertificationIdentitySummary> {
            return localVarFp.getIdentitySummary(id, identitySummaryId, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getIdentityAccessSummaries operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentityAccessSummariesRequest
 */
export interface CertificationSummariesApiGetIdentityAccessSummariesRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly id: string

    /**
     * The type of access review item to retrieve summaries for
     * @type {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly type: 'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly sorters?: string
}

/**
 * Request parameters for getIdentityDecisionSummary operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentityDecisionSummaryRequest
 */
export interface CertificationSummariesApiGetIdentityDecisionSummaryRequest {
    /**
     * The certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityDecisionSummary
     */
    readonly id: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityDecisionSummary
     */
    readonly filters?: string
}

/**
 * Request parameters for getIdentitySummaries operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentitySummariesRequest
 */
export interface CertificationSummariesApiGetIdentitySummariesRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly sorters?: string
}

/**
 * Request parameters for getIdentitySummary operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentitySummaryRequest
 */
export interface CertificationSummariesApiGetIdentitySummaryRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummary
     */
    readonly id: string

    /**
     * The identity summary ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummary
     */
    readonly identitySummaryId: string
}

/**
 * CertificationSummariesApi - object-oriented interface
 * @export
 * @class CertificationSummariesApi
 * @extends {BaseAPI}
 */
export class CertificationSummariesApi extends BaseAPI {
    /**
     * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Access Summaries
     * @param {CertificationSummariesApiGetIdentityAccessSummariesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentityAccessSummaries(requestParameters: CertificationSummariesApiGetIdentityAccessSummariesRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentityAccessSummaries(requestParameters.id, requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Summary of Certification Decisions
     * @param {CertificationSummariesApiGetIdentityDecisionSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentityDecisionSummary(requestParameters: CertificationSummariesApiGetIdentityDecisionSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentityDecisionSummary(requestParameters.id, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Identity Summaries for Campaign Certification
     * @param {CertificationSummariesApiGetIdentitySummariesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentitySummaries(requestParameters: CertificationSummariesApiGetIdentitySummariesRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentitySummaries(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Summary for Identity
     * @param {CertificationSummariesApiGetIdentitySummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentitySummary(requestParameters: CertificationSummariesApiGetIdentitySummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentitySummary(requestParameters.id, requestParameters.identitySummaryId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificationsApi - axios parameter creator
 * @export
 */
export const CertificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertification: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityCertification', 'id', id)
            const localVarPath = `/certifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type / access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessReviewItems: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, entitlements?: string, accessProfiles?: string, roles?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listIdentityAccessReviewItems', 'id', id)
            const localVarPath = `/certifications/{id}/access-review-items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (entitlements !== undefined) {
                localVarQueryParameter['entitlements'] = entitlements;
            }

            if (accessProfiles !== undefined) {
                localVarQueryParameter['access-profiles'] = accessProfiles;
            }

            if (roles !== undefined) {
                localVarQueryParameter['roles'] = roles;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of identity campaign certifications that satisfy the given query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Campaign Certifications by IDs
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **campaign.id**: *eq, in* **phase**: *eq* **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityCertifications: async (reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/certifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (reviewerIdentity !== undefined) {
                localVarQueryParameter['reviewer-identity'] = reviewerIdentity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        makeIdentityDecision: async (id: string, reviewDecision: Array<ReviewDecision>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('makeIdentityDecision', 'id', id)
            // verify required parameter 'reviewDecision' is not null or undefined
            assertParamExists('makeIdentityDecision', 'reviewDecision', reviewDecision)
            const localVarPath = `/certifications/{id}/decide`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertifications: async (id: string, reviewReassign: ReviewReassign, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reassignIdentityCertifications', 'id', id)
            // verify required parameter 'reviewReassign' is not null or undefined
            assertParamExists('reassignIdentityCertifications', 'reviewReassign', reviewReassign)
            const localVarPath = `/certifications/{id}/reassign`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewReassign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        signOffIdentityCertification: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signOffIdentityCertification', 'id', id)
            const localVarPath = `/certifications/{id}/sign-off`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationsApi - functional programming interface
 * @export
 */
export const CertificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityCertification(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityCertification(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type / access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityAccessReviewItems(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, entitlements?: string, accessProfiles?: string, roles?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessReviewItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityAccessReviewItems(id, limit, offset, count, filters, sorters, entitlements, accessProfiles, roles, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of identity campaign certifications that satisfy the given query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Campaign Certifications by IDs
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **campaign.id**: *eq, in* **phase**: *eq* **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityCertifications(reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityCertificationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityCertifications(reviewerIdentity, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async makeIdentityDecision(id: string, reviewDecision: Array<ReviewDecision>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.makeIdentityDecision(id, reviewDecision, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async reassignIdentityCertifications(id: string, reviewReassign: ReviewReassign, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reassignIdentityCertifications(id, reviewReassign, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async signOffIdentityCertification(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signOffIdentityCertification(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificationsApi - factory interface
 * @export
 */
export const CertificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationsApiFp(configuration)
    return {
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertification(id: string, axiosOptions?: any): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.getIdentityCertification(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type / access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessReviewItems(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, entitlements?: string, accessProfiles?: string, roles?: string, axiosOptions?: any): AxiosPromise<Array<AccessReviewItem>> {
            return localVarFp.listIdentityAccessReviewItems(id, limit, offset, count, filters, sorters, entitlements, accessProfiles, roles, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of identity campaign certifications that satisfy the given query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Campaign Certifications by IDs
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **campaign.id**: *eq, in* **phase**: *eq* **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityCertifications(reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<IdentityCertificationDto>> {
            return localVarFp.listIdentityCertifications(reviewerIdentity, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        makeIdentityDecision(id: string, reviewDecision: Array<ReviewDecision>, axiosOptions?: any): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.makeIdentityDecision(id, reviewDecision, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertifications(id: string, reviewReassign: ReviewReassign, axiosOptions?: any): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.reassignIdentityCertifications(id, reviewReassign, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        signOffIdentityCertification(id: string, axiosOptions?: any): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.signOffIdentityCertification(id, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getIdentityCertification operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetIdentityCertificationRequest
 */
export interface CertificationsApiGetIdentityCertificationRequest {
    /**
     * The certification id
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertification
     */
    readonly id: string
}

/**
 * Request parameters for listIdentityAccessReviewItems operation in CertificationsApi.
 * @export
 * @interface CertificationsApiListIdentityAccessReviewItemsRequest
 */
export interface CertificationsApiListIdentityAccessReviewItemsRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type / access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly sorters?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly entitlements?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly accessProfiles?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly roles?: string
}

/**
 * Request parameters for listIdentityCertifications operation in CertificationsApi.
 * @export
 * @interface CertificationsApiListIdentityCertificationsRequest
 */
export interface CertificationsApiListIdentityCertificationsRequest {
    /**
     * The ID of reviewer identity. *me* indicates the current user.
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly reviewerIdentity?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **campaign.id**: *eq, in* **phase**: *eq* **completed**: *eq, ne*
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, due, signed**
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly sorters?: string
}

/**
 * Request parameters for makeIdentityDecision operation in CertificationsApi.
 * @export
 * @interface CertificationsApiMakeIdentityDecisionRequest
 */
export interface CertificationsApiMakeIdentityDecisionRequest {
    /**
     * The ID of the identity campaign certification on which to make decisions
     * @type {string}
     * @memberof CertificationsApiMakeIdentityDecision
     */
    readonly id: string

    /**
     * A non-empty array of decisions to be made.
     * @type {Array<ReviewDecision>}
     * @memberof CertificationsApiMakeIdentityDecision
     */
    readonly reviewDecision: Array<ReviewDecision>
}

/**
 * Request parameters for reassignIdentityCertifications operation in CertificationsApi.
 * @export
 * @interface CertificationsApiReassignIdentityCertificationsRequest
 */
export interface CertificationsApiReassignIdentityCertificationsRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiReassignIdentityCertifications
     */
    readonly id: string

    /**
     * 
     * @type {ReviewReassign}
     * @memberof CertificationsApiReassignIdentityCertifications
     */
    readonly reviewReassign: ReviewReassign
}

/**
 * Request parameters for signOffIdentityCertification operation in CertificationsApi.
 * @export
 * @interface CertificationsApiSignOffIdentityCertificationRequest
 */
export interface CertificationsApiSignOffIdentityCertificationRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiSignOffIdentityCertification
     */
    readonly id: string
}

/**
 * CertificationsApi - object-oriented interface
 * @export
 * @class CertificationsApi
 * @extends {BaseAPI}
 */
export class CertificationsApi extends BaseAPI {
    /**
     * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Identity Certification by ID
     * @param {CertificationsApiGetIdentityCertificationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getIdentityCertification(requestParameters: CertificationsApiGetIdentityCertificationRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getIdentityCertification(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary List of Access Review Items
     * @param {CertificationsApiListIdentityAccessReviewItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public listIdentityAccessReviewItems(requestParameters: CertificationsApiListIdentityAccessReviewItemsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).listIdentityAccessReviewItems(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.entitlements, requestParameters.accessProfiles, requestParameters.roles, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of identity campaign certifications that satisfy the given query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Identity Campaign Certifications by IDs
     * @param {CertificationsApiListIdentityCertificationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public listIdentityCertifications(requestParameters: CertificationsApiListIdentityCertificationsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).listIdentityCertifications(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Decide on a Certification Item
     * @param {CertificationsApiMakeIdentityDecisionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public makeIdentityDecision(requestParameters: CertificationsApiMakeIdentityDecisionRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).makeIdentityDecision(requestParameters.id, requestParameters.reviewDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Reassign Identities or Items
     * @param {CertificationsApiReassignIdentityCertificationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public reassignIdentityCertifications(requestParameters: CertificationsApiReassignIdentityCertificationsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).reassignIdentityCertifications(requestParameters.id, requestParameters.reviewReassign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Finalize Identity Certification Decisions
     * @param {CertificationsApiSignOffIdentityCertificationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public signOffIdentityCertification(requestParameters: CertificationsApiSignOffIdentityCertificationRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).signOffIdentityCertification(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdentityProfilesApi - axios parameter creator
 * @export
 */
export const IdentityProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-profiles/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getDefaultIdentityAttributeConfig', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/default-identity-attribute-config`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles: async (identityProfileExportedObject: Array<IdentityProfileExportedObject>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileExportedObject' is not null or undefined
            assertParamExists('importIdentityProfiles', 'identityProfileExportedObject', identityProfileExportedObject)
            const localVarPath = `/identity-profiles/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProfileExportedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityProfilesApi - functional programming interface
 * @export
 */
export const IdentityProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProfileExportedObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultIdentityAttributeConfig(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityAttributeConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultIdentityAttributeConfig(identityProfileId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityProfile(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityProfile(identityProfileId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importIdentityProfiles(identityProfileExportedObject: Array<IdentityProfileExportedObject>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectImportResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importIdentityProfiles(identityProfileExportedObject, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdentityProfilesApi - factory interface
 * @export
 */
export const IdentityProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityProfilesApiFp(configuration)
    return {
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<IdentityProfileExportedObject>> {
            return localVarFp.exportIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig(identityProfileId: string, axiosOptions?: any): AxiosPromise<IdentityAttributeConfig> {
            return localVarFp.getDefaultIdentityAttributeConfig(identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile(identityProfileId: string, axiosOptions?: any): AxiosPromise<IdentityProfile> {
            return localVarFp.getIdentityProfile(identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles(identityProfileExportedObject: Array<IdentityProfileExportedObject>, axiosOptions?: any): AxiosPromise<ObjectImportResult> {
            return localVarFp.importIdentityProfiles(identityProfileExportedObject, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<IdentityProfile>> {
            return localVarFp.listIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for exportIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiExportIdentityProfilesRequest
 */
export interface IdentityProfilesApiExportIdentityProfilesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
     * @type {string}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
     * @type {string}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly sorters?: string
}

/**
 * Request parameters for getDefaultIdentityAttributeConfig operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest
 */
export interface IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest {
    /**
     * The Identity Profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiGetDefaultIdentityAttributeConfig
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for getIdentityProfile operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiGetIdentityProfileRequest
 */
export interface IdentityProfilesApiGetIdentityProfileRequest {
    /**
     * The Identity Profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiGetIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for importIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiImportIdentityProfilesRequest
 */
export interface IdentityProfilesApiImportIdentityProfilesRequest {
    /**
     * Previously exported Identity Profiles.
     * @type {Array<IdentityProfileExportedObject>}
     * @memberof IdentityProfilesApiImportIdentityProfiles
     */
    readonly identityProfileExportedObject: Array<IdentityProfileExportedObject>
}

/**
 * Request parameters for listIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiListIdentityProfilesRequest
 */
export interface IdentityProfilesApiListIdentityProfilesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
     * @type {string}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
     * @type {string}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly sorters?: string
}

/**
 * IdentityProfilesApi - object-oriented interface
 * @export
 * @class IdentityProfilesApi
 * @extends {BaseAPI}
 */
export class IdentityProfilesApi extends BaseAPI {
    /**
     * This exports existing identity profiles in the format specified by the sp-config service.
     * @summary Export Identity Profiles
     * @param {IdentityProfilesApiExportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public exportIdentityProfiles(requestParameters: IdentityProfilesApiExportIdentityProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).exportIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
     * @summary Get default Identity Attribute Config
     * @param {IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public getDefaultIdentityAttributeConfig(requestParameters: IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).getDefaultIdentityAttributeConfig(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Get single Identity Profile
     * @param {IdentityProfilesApiGetIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public getIdentityProfile(requestParameters: IdentityProfilesApiGetIdentityProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).getIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This imports previously exported identity profiles.
     * @summary Import Identity Profiles
     * @param {IdentityProfilesApiImportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public importIdentityProfiles(requestParameters: IdentityProfilesApiImportIdentityProfilesRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).importIdentityProfiles(requestParameters.identityProfileExportedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
     * @summary Identity Profiles List
     * @param {IdentityProfilesApiListIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public listIdentityProfiles(requestParameters: IdentityProfilesApiListIdentityProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).listIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LifecycleStatesApi - axios parameter creator
 * @export
 */
export const LifecycleStatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a new Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {LifecycleState} lifecycleState Lifecycle State
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createLifecycleState: async (identityProfileId: string, lifecycleState: LifecycleState, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('createLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleState' is not null or undefined
            assertParamExists('createLifecycleState', 'lifecycleState', lifecycleState)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lifecycleState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes the Lifecycle State using it\'s ID. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State by ID
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteLifecycleState: async (identityProfileId: string, lifecycleStateId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('deleteLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('deleteLifecycleState', 'lifecycleStateId', lifecycleStateId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Retrieves Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleState: async (identityProfileId: string, lifecycleStateId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('getLifecycleState', 'lifecycleStateId', lifecycleStateId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the LifecycleStates associated with IdentityProfiles. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId The IdentityProfile id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listLifecycleStates: async (identityProfileId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('listLifecycleStates', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will set/update an identity\'s lifecycle state to the one provided and updates the corresponding Identity Profile. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId The ID of the identity to update
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setLifecycleState: async (identityId: string, setLifecycleStateRequest: SetLifecycleStateRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('setLifecycleState', 'identityId', identityId)
            // verify required parameter 'setLifecycleStateRequest' is not null or undefined
            assertParamExists('setLifecycleState', 'setLifecycleStateRequest', setLifecycleStateRequest)
            const localVarPath = `/identities/{identity-id}/set-lifecycle-state`
                .replace(`{${"identity-id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setLifecycleStateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates individual Lifecycle State fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates: async (identityProfileId: string, lifecycleStateId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('updateLifecycleStates', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('updateLifecycleStates', 'lifecycleStateId', lifecycleStateId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateLifecycleStates', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * LifecycleStatesApi - functional programming interface
 * @export
 */
export const LifecycleStatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LifecycleStatesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a new Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {LifecycleState} lifecycleState Lifecycle State
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createLifecycleState(identityProfileId: string, lifecycleState: LifecycleState, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLifecycleState(identityProfileId, lifecycleState, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint deletes the Lifecycle State using it\'s ID. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State by ID
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseReferenceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLifecycleState(identityProfileId, lifecycleStateId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves a Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Retrieves Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLifecycleState(identityProfileId, lifecycleStateId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point lists all the LifecycleStates associated with IdentityProfiles. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId The IdentityProfile id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listLifecycleStates(identityProfileId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifecycleState>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLifecycleStates(identityProfileId, limit, offset, count, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will set/update an identity\'s lifecycle state to the one provided and updates the corresponding Identity Profile. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId The ID of the identity to update
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setLifecycleState(identityId: string, setLifecycleStateRequest: SetLifecycleStateRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetLifecycleState200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setLifecycleState(identityId, setLifecycleStateRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint updates individual Lifecycle State fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateLifecycleStates(identityProfileId: string, lifecycleStateId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLifecycleStates(identityProfileId, lifecycleStateId, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LifecycleStatesApi - factory interface
 * @export
 */
export const LifecycleStatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LifecycleStatesApiFp(configuration)
    return {
        /**
         * This API creates a new Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {LifecycleState} lifecycleState Lifecycle State
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createLifecycleState(identityProfileId: string, lifecycleState: LifecycleState, axiosOptions?: any): AxiosPromise<LifecycleState> {
            return localVarFp.createLifecycleState(identityProfileId, lifecycleState, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes the Lifecycle State using it\'s ID. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State by ID
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: any): AxiosPromise<BaseReferenceDto> {
            return localVarFp.deleteLifecycleState(identityProfileId, lifecycleStateId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Retrieves Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: any): AxiosPromise<LifecycleState> {
            return localVarFp.getLifecycleState(identityProfileId, lifecycleStateId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the LifecycleStates associated with IdentityProfiles. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId The IdentityProfile id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listLifecycleStates(identityProfileId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: any): AxiosPromise<Array<LifecycleState>> {
            return localVarFp.listLifecycleStates(identityProfileId, limit, offset, count, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will set/update an identity\'s lifecycle state to the one provided and updates the corresponding Identity Profile. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId The ID of the identity to update
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setLifecycleState(identityId: string, setLifecycleStateRequest: SetLifecycleStateRequest, axiosOptions?: any): AxiosPromise<SetLifecycleState200Response> {
            return localVarFp.setLifecycleState(identityId, setLifecycleStateRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates individual Lifecycle State fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates(identityProfileId: string, lifecycleStateId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<LifecycleState> {
            return localVarFp.updateLifecycleStates(identityProfileId, lifecycleStateId, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiCreateLifecycleStateRequest
 */
export interface LifecycleStatesApiCreateLifecycleStateRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesApiCreateLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State
     * @type {LifecycleState}
     * @memberof LifecycleStatesApiCreateLifecycleState
     */
    readonly lifecycleState: LifecycleState
}

/**
 * Request parameters for deleteLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiDeleteLifecycleStateRequest
 */
export interface LifecycleStatesApiDeleteLifecycleStateRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesApiDeleteLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State ID
     * @type {string}
     * @memberof LifecycleStatesApiDeleteLifecycleState
     */
    readonly lifecycleStateId: string
}

/**
 * Request parameters for getLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiGetLifecycleStateRequest
 */
export interface LifecycleStatesApiGetLifecycleStateRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State ID
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleState
     */
    readonly lifecycleStateId: string
}

/**
 * Request parameters for listLifecycleStates operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiListLifecycleStatesRequest
 */
export interface LifecycleStatesApiListLifecycleStatesRequest {
    /**
     * The IdentityProfile id
     * @type {string}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly identityProfileId: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly sorters?: string
}

/**
 * Request parameters for setLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiSetLifecycleStateRequest
 */
export interface LifecycleStatesApiSetLifecycleStateRequest {
    /**
     * The ID of the identity to update
     * @type {string}
     * @memberof LifecycleStatesApiSetLifecycleState
     */
    readonly identityId: string

    /**
     * 
     * @type {SetLifecycleStateRequest}
     * @memberof LifecycleStatesApiSetLifecycleState
     */
    readonly setLifecycleStateRequest: SetLifecycleStateRequest
}

/**
 * Request parameters for updateLifecycleStates operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiUpdateLifecycleStatesRequest
 */
export interface LifecycleStatesApiUpdateLifecycleStatesRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State ID
     * @type {string}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly lifecycleStateId: string

    /**
     * A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
     * @type {Array<JsonPatchOperation>}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * LifecycleStatesApi - object-oriented interface
 * @export
 * @class LifecycleStatesApi
 * @extends {BaseAPI}
 */
export class LifecycleStatesApi extends BaseAPI {
    /**
     * This API creates a new Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Create Lifecycle State
     * @param {LifecycleStatesApiCreateLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public createLifecycleState(requestParameters: LifecycleStatesApiCreateLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).createLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleState, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes the Lifecycle State using it\'s ID. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Delete Lifecycle State by ID
     * @param {LifecycleStatesApiDeleteLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public deleteLifecycleState(requestParameters: LifecycleStatesApiDeleteLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).deleteLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Retrieves Lifecycle State
     * @param {LifecycleStatesApiGetLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public getLifecycleState(requestParameters: LifecycleStatesApiGetLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).getLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the LifecycleStates associated with IdentityProfiles. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Lists LifecycleStates
     * @param {LifecycleStatesApiListLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public listLifecycleStates(requestParameters: LifecycleStatesApiListLifecycleStatesRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).listLifecycleStates(requestParameters.identityProfileId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will set/update an identity\'s lifecycle state to the one provided and updates the corresponding Identity Profile. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Set Lifecycle State
     * @param {LifecycleStatesApiSetLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public setLifecycleState(requestParameters: LifecycleStatesApiSetLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).setLifecycleState(requestParameters.identityId, requestParameters.setLifecycleStateRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates individual Lifecycle State fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Update Lifecycle State
     * @param {LifecycleStatesApiUpdateLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public updateLifecycleStates(requestParameters: LifecycleStatesApiUpdateLifecycleStatesRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).updateLifecycleStates(requestParameters.identityProfileId, requestParameters.lifecycleStateId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NonEmployeeLifecycleManagementApi - axios parameter creator
 * @export
 */
export const NonEmployeeLifecycleManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveNonEmployeeRequest: async (id: string, nonEmployeeApprovalDecision: NonEmployeeApprovalDecision, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveNonEmployeeRequest', 'id', id)
            // verify required parameter 'nonEmployeeApprovalDecision' is not null or undefined
            assertParamExists('approveNonEmployeeRequest', 'nonEmployeeApprovalDecision', nonEmployeeApprovalDecision)
            const localVarPath = `/non-employee-approvals/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeApprovalDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRecord: async (nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('createNonEmployeeRecord', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRequest: async (nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('createNonEmployeeRequest', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSource: async (nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeSourceRequestBody' is not null or undefined
            assertParamExists('createNonEmployeeSource', 'nonEmployeeSourceRequestBody', nonEmployeeSourceRequestBody)
            const localVarPath = `/non-employee-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeSourceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSourceSchemaAttributes: async (sourceId: string, nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            // verify required parameter 'nonEmployeeSchemaAttributeBody' is not null or undefined
            assertParamExists('createNonEmployeeSourceSchemaAttributes', 'nonEmployeeSchemaAttributeBody', nonEmployeeSchemaAttributeBody)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeSchemaAttributeBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecord: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNonEmployeeRecord', 'id', id)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordsInBulkRequest} deleteNonEmployeeRecordsInBulkRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecordsInBulk: async (deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteNonEmployeeRecordsInBulkRequest' is not null or undefined
            assertParamExists('deleteNonEmployeeRecordsInBulk', 'deleteNonEmployeeRecordsInBulkRequest', deleteNonEmployeeRecordsInBulkRequest)
            const localVarPath = `/non-employee-records/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteNonEmployeeRecordsInBulkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRequest: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNonEmployeeRequest', 'id', id)
            const localVarPath = `/non-employee-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('deleteNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSource: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSource', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSourceSchemaAttributes: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeRecords: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportNonEmployeeRecords', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/non-employees/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeSourceSchemaTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportNonEmployeeSourceSchemaTemplate', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/schema-attributes-template/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApproval: async (id: string, includeDetail?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeApproval', 'id', id)
            const localVarPath = `/non-employee-approvals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (includeDetail !== undefined) {
                localVarQueryParameter['include-detail'] = includeDetail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApprovalSummary: async (requestedFor: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('getNonEmployeeApprovalSummary', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-approvals/summary/{requested-for}`
                .replace(`{${"requested-for"}}`, encodeURIComponent(String(requestedFor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeBulkUploadStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeBulkUploadStatus', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/non-employee-bulk-upload/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRecord: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeRecord', 'id', id)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequest: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNonEmployeeRequest', 'id', id)
            const localVarPath = `/non-employee-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequestSummary: async (requestedFor: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('getNonEmployeeRequestSummary', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-requests/summary/{requested-for}`
                .replace(`{${"requested-for"}}`, encodeURIComponent(String(requestedFor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('getNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSource: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSource', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSourceSchemaAttributes: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {any} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importNonEmployeeRecordsInBulk: async (id: string, data: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importNonEmployeeRecordsInBulk', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('importNonEmployeeRecordsInBulk', 'data', data)
            const localVarPath = `/non-employee-sources/{id}/non-employee-bulk-upload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **approvalStatus**: *eq*  *Example:* approvalStatus eq \&quot;PENDING\&quot;
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeApprovals: async (requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/non-employee-approvals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRecords: async (limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/non-employee-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRequests: async (requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('listNonEmployeeRequests', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeSources: async (requestedFor: string, limit?: number, offset?: number, count?: boolean, nonEmployeeCount?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('listNonEmployeeSources', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (nonEmployeeCount !== undefined) {
                localVarQueryParameter['non-employee-count'] = nonEmployeeCount;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeRecord: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchNonEmployeeRecord', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchNonEmployeeRecord', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSchemaAttribute: async (attributeId: string, sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'sourceId', sourceId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchNonEmployeeSchemaAttribute', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSource: async (sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('patchNonEmployeeSource', 'sourceId', sourceId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchNonEmployeeSource', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectNonEmployeeRequest: async (id: string, nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectNonEmployeeRequest', 'id', id)
            // verify required parameter 'nonEmployeeRejectApprovalDecision' is not null or undefined
            assertParamExists('rejectNonEmployeeRequest', 'nonEmployeeRejectApprovalDecision', nonEmployeeRejectApprovalDecision)
            const localVarPath = `/non-employee-approvals/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRejectApprovalDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateNonEmployeeRecord: async (id: string, nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateNonEmployeeRecord', 'id', id)
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('updateNonEmployeeRecord', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * NonEmployeeLifecycleManagementApi - functional programming interface
 * @export
 */
export const NonEmployeeLifecycleManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NonEmployeeLifecycleManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveNonEmployeeRequest(id: string, nonEmployeeApprovalDecision: NonEmployeeApprovalDecision, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveNonEmployeeRequest(id, nonEmployeeApprovalDecision, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeRecord(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeRecord(nonEmployeeRequestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeRequest(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeRequest(nonEmployeeRequestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeSource(nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSourceWithCloudExternalId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeSource(nonEmployeeSourceRequestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createNonEmployeeSourceSchemaAttributes(sourceId: string, nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonEmployeeSourceSchemaAttributes(sourceId, nonEmployeeSchemaAttributeBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRecord(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRecord(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordsInBulkRequest} deleteNonEmployeeRecordsInBulkRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeRequest(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeRequest(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSource(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSource(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportNonEmployeeRecords(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNonEmployeeRecords(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportNonEmployeeSourceSchemaTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNonEmployeeSourceSchemaTemplate(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeApproval(id: string, includeDetail?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeApproval(id, includeDetail, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeApprovalSummary(requestedFor: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeApprovalSummary(requestedFor, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeBulkUploadStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeBulkUploadStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeBulkUploadStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRecord(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRecord(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRequest(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRequest(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeRequestSummary(requestedFor: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequestSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeRequestSummary(requestedFor, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSource(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSource(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeSchemaAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {any} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importNonEmployeeRecordsInBulk(id: string, data: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeBulkUploadJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importNonEmployeeRecordsInBulk(id, data, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **approvalStatus**: *eq*  *Example:* approvalStatus eq \&quot;PENDING\&quot;
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeApprovals(requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeApprovalItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeApprovals(requestedFor, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeRecords(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeRecords(limit, offset, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeRequests(requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeRequest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeRequests(requestedFor, limit, offset, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listNonEmployeeSources(requestedFor: string, limit?: number, offset?: number, count?: boolean, nonEmployeeCount?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeSourceWithNECount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNonEmployeeSources(requestedFor, limit, offset, count, nonEmployeeCount, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeRecord(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeRecord(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeSchemaAttribute(attributeId, sourceId, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchNonEmployeeSource(sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNonEmployeeSource(sourceId, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectNonEmployeeRequest(id: string, nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectNonEmployeeRequest(id, nonEmployeeRejectApprovalDecision, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateNonEmployeeRecord(id: string, nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNonEmployeeRecord(id, nonEmployeeRequestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NonEmployeeLifecycleManagementApi - factory interface
 * @export
 */
export const NonEmployeeLifecycleManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NonEmployeeLifecycleManagementApiFp(configuration)
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveNonEmployeeRequest(id: string, nonEmployeeApprovalDecision: NonEmployeeApprovalDecision, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalItem> {
            return localVarFp.approveNonEmployeeRequest(id, nonEmployeeApprovalDecision, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRecord(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: any): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.createNonEmployeeRecord(nonEmployeeRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRequest(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: any): AxiosPromise<NonEmployeeRequest> {
            return localVarFp.createNonEmployeeRequest(nonEmployeeRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSource(nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody, axiosOptions?: any): AxiosPromise<NonEmployeeSourceWithCloudExternalId> {
            return localVarFp.createNonEmployeeSource(nonEmployeeSourceRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSourceSchemaAttributes(sourceId: string, nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody, axiosOptions?: any): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.createNonEmployeeSourceSchemaAttributes(sourceId, nonEmployeeSchemaAttributeBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecord(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRecord(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordsInBulkRequest} deleteNonEmployeeRecordsInBulkRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRequest(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeRequest(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSource(sourceId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSource(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeRecords(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.exportNonEmployeeRecords(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeSourceSchemaTemplate(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.exportNonEmployeeSourceSchemaTemplate(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApproval(id: string, includeDetail?: boolean, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalItemDetail> {
            return localVarFp.getNonEmployeeApproval(id, includeDetail, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApprovalSummary(requestedFor: string, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalSummary> {
            return localVarFp.getNonEmployeeApprovalSummary(requestedFor, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeBulkUploadStatus(id: string, axiosOptions?: any): AxiosPromise<NonEmployeeBulkUploadStatus> {
            return localVarFp.getNonEmployeeBulkUploadStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRecord(id: string, axiosOptions?: any): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.getNonEmployeeRecord(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequest(id: string, axiosOptions?: any): AxiosPromise<NonEmployeeRequest> {
            return localVarFp.getNonEmployeeRequest(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequestSummary(requestedFor: string, axiosOptions?: any): AxiosPromise<NonEmployeeRequestSummary> {
            return localVarFp.getNonEmployeeRequestSummary(requestedFor, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: any): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.getNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSource(sourceId: string, axiosOptions?: any): AxiosPromise<NonEmployeeSource> {
            return localVarFp.getNonEmployeeSource(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSourceSchemaAttributes(sourceId: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeSchemaAttribute>> {
            return localVarFp.getNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {any} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importNonEmployeeRecordsInBulk(id: string, data: any, axiosOptions?: any): AxiosPromise<NonEmployeeBulkUploadJob> {
            return localVarFp.importNonEmployeeRecordsInBulk(id, data, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **approvalStatus**: *eq*  *Example:* approvalStatus eq \&quot;PENDING\&quot;
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeApprovals(requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeApprovalItem>> {
            return localVarFp.listNonEmployeeApprovals(requestedFor, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRecords(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeRecord>> {
            return localVarFp.listNonEmployeeRecords(limit, offset, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRequests(requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeRequest>> {
            return localVarFp.listNonEmployeeRequests(requestedFor, limit, offset, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeSources(requestedFor: string, limit?: number, offset?: number, count?: boolean, nonEmployeeCount?: boolean, sorters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeSourceWithNECount>> {
            return localVarFp.listNonEmployeeSources(requestedFor, limit, offset, count, nonEmployeeCount, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeRecord(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.patchNonEmployeeRecord(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSchemaAttribute(attributeId: string, sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.patchNonEmployeeSchemaAttribute(attributeId, sourceId, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSource(sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<NonEmployeeSource> {
            return localVarFp.patchNonEmployeeSource(sourceId, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectNonEmployeeRequest(id: string, nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalItem> {
            return localVarFp.rejectNonEmployeeRequest(id, nonEmployeeRejectApprovalDecision, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateNonEmployeeRecord(id: string, nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: any): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.updateNonEmployeeRecord(id, nonEmployeeRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiApproveNonEmployeeRequest
     */
    readonly id: string

    /**
     * 
     * @type {NonEmployeeApprovalDecision}
     * @memberof NonEmployeeLifecycleManagementApiApproveNonEmployeeRequest
     */
    readonly nonEmployeeApprovalDecision: NonEmployeeApprovalDecision
}

/**
 * Request parameters for createNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest {
    /**
     * Non-Employee record creation request body.
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeRecord
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * Request parameters for createNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest {
    /**
     * Non-Employee creation request body
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeRequest
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * Request parameters for createNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest {
    /**
     * Non-Employee source creation request body.
     * @type {NonEmployeeSourceRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeSource
     */
    readonly nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody
}

/**
 * Request parameters for createNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string

    /**
     * 
     * @type {NonEmployeeSchemaAttributeBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributes
     */
    readonly nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody
}

/**
 * Request parameters for deleteNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest {
    /**
     * Non-Employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecord
     */
    readonly id: string
}

/**
 * Request parameters for deleteNonEmployeeRecordsInBulk operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest {
    /**
     * Non-Employee bulk delete request body.
     * @type {DeleteNonEmployeeRecordsInBulkRequest}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulk
     */
    readonly deleteNonEmployeeRecordsInBulkRequest: DeleteNonEmployeeRecordsInBulkRequest
}

/**
 * Request parameters for deleteNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest {
    /**
     * Non-Employee request id in the UUID format
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequest
     */
    readonly id: string
}

/**
 * Request parameters for deleteNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttribute
     */
    readonly sourceId: string
}

/**
 * Request parameters for deleteNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSource
     */
    readonly sourceId: string
}

/**
 * Request parameters for deleteNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string
}

/**
 * Request parameters for exportNonEmployeeRecords operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest
 */
export interface NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiExportNonEmployeeRecords
     */
    readonly id: string
}

/**
 * Request parameters for exportNonEmployeeSourceSchemaTemplate operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest
 */
export interface NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplate
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeApproval operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeApproval
     */
    readonly id: string

    /**
     * The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeApproval
     */
    readonly includeDetail?: boolean
}

/**
 * Request parameters for getNonEmployeeApprovalSummary operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest {
    /**
     * The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummary
     */
    readonly requestedFor: string
}

/**
 * Request parameters for getNonEmployeeBulkUploadStatus operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest {
    /**
     * Source ID (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatus
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest {
    /**
     * Non-Employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeRecord
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest {
    /**
     * Non-Employee request id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeRequest
     */
    readonly id: string
}

/**
 * Request parameters for getNonEmployeeRequestSummary operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest {
    /**
     * The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummary
     */
    readonly requestedFor: string
}

/**
 * Request parameters for getNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttribute
     */
    readonly sourceId: string
}

/**
 * Request parameters for getNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSource
     */
    readonly sourceId: string
}

/**
 * Request parameters for getNonEmployeeSourceSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributes
     */
    readonly sourceId: string
}

/**
 * Request parameters for importNonEmployeeRecordsInBulk operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest
 */
export interface NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulk
     */
    readonly id: string

    /**
     * 
     * @type {any}
     * @memberof NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulk
     */
    readonly data: any
}

/**
 * Request parameters for listNonEmployeeApprovals operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly requestedFor?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **approvalStatus**: *eq*  *Example:* approvalStatus eq \&quot;PENDING\&quot;
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for listNonEmployeeRecords operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRecords
     */
    readonly filters?: string
}

/**
 * Request parameters for listNonEmployeeRequests operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly requestedFor: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeRequests
     */
    readonly filters?: string
}

/**
 * Request parameters for listNonEmployeeSources operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest
 */
export interface NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly requestedFor: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly count?: boolean

    /**
     * The flag to determine whether return a non-employee count associate with source.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly nonEmployeeCount?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **name, created**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiListNonEmployeeSources
     */
    readonly sorters?: string
}

/**
 * Request parameters for patchNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest {
    /**
     * Non-employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeRecord
     */
    readonly id: string

    /**
     * A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeRecord
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for patchNonEmployeeSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttribute
     */
    readonly sourceId: string

    /**
     * A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttribute
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for patchNonEmployeeSource operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest
 */
export interface NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSource
     */
    readonly sourceId: string

    /**
     * A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiPatchNonEmployeeSource
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for rejectNonEmployeeRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiRejectNonEmployeeRequest
     */
    readonly id: string

    /**
     * 
     * @type {NonEmployeeRejectApprovalDecision}
     * @memberof NonEmployeeLifecycleManagementApiRejectNonEmployeeRequest
     */
    readonly nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision
}

/**
 * Request parameters for updateNonEmployeeRecord operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest
 */
export interface NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest {
    /**
     * Non-employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecord
     */
    readonly id: string

    /**
     * Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecord
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * NonEmployeeLifecycleManagementApi - object-oriented interface
 * @export
 * @class NonEmployeeLifecycleManagementApi
 * @extends {BaseAPI}
 */
export class NonEmployeeLifecycleManagementApi extends BaseAPI {
    /**
     * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
     * @summary Approve a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public approveNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).approveNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeApprovalDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee record. Requires role context of `idn:nesr:create`
     * @summary Create Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeRecord(requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
     * @summary Create Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeRequest(requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee source. Requires role context of `idn:nesr:create`
     * @summary Create Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeSource(requestParameters.nonEmployeeSourceRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
     * @summary Create a new Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, requestParameters.nonEmployeeSchemaAttributeBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
     * @summary Delete Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeRecord(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
     * @summary Delete Multiple Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeRecordsInBulk(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeRecordsInBulk(requestParameters.deleteNonEmployeeRecordsInBulkRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
     * @summary Delete Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeRequest(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
     * @summary Delete a Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
     * @summary Delete Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeSource(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
     * @summary Delete all custom schema attributes for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
     * @summary Exports Non-Employee Records to CSV
     * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public exportNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).exportNonEmployeeRecords(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
     * @summary Exports Source Schema Template
     * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public exportNonEmployeeSourceSchemaTemplate(requestParameters: NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).exportNonEmployeeSourceSchemaTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
     * @summary Get a non-employee approval item detail
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeApproval(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeApproval(requestParameters.id, requestParameters.includeDetail, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
     * @summary Get Summary of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeApprovalSummary(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeApprovalSummary(requestParameters.requestedFor, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
     * @summary Obtain the status of bulk upload on the source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeBulkUploadStatus(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeBulkUploadStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee record. Requires role context of `idn:nesr:read`
     * @summary Get a Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeRecord(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
     * @summary Get a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeRequest(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
     * @summary Get Summary of Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeRequestSummary(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeRequestSummary(requestParameters.requestedFor, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
     * @summary Get Schema Attribute Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
     * @summary Get a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeSource(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
     * @summary List Schema Attributes Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getNonEmployeeSourceSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
     * @summary Imports, or Updates, Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public importNonEmployeeRecordsInBulk(requestParameters: NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).importNonEmployeeRecordsInBulk(requestParameters.id, requestParameters.data, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
     * @summary Get List of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeApprovals(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeApprovals(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
     * @summary List Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeRecords(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeRecords(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
     * @summary List Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeRequests(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeRequests(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
     * @summary List Non-Employee Sources
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public listNonEmployeeSources(requestParameters: NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).listNonEmployeeSources(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.nonEmployeeCount, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
     * @summary Patch Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public patchNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).patchNonEmployeeRecord(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
     * @summary Patch a Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public patchNonEmployeeSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).patchNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
     * @summary Patch a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public patchNonEmployeeSource(requestParameters: NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).patchNonEmployeeSource(requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
     * @summary Reject a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public rejectNonEmployeeRequest(requestParameters: NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).rejectNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeRejectApprovalDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
     * @summary Update Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public updateNonEmployeeRecord(requestParameters: NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).updateNonEmployeeRecord(requestParameters.id, requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuthClientsApi - axios parameter creator
 * @export
 */
export const OAuthClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient: async (createOAuthClientRequest: CreateOAuthClientRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOAuthClientRequest' is not null or undefined
            assertParamExists('createOauthClient', 'createOAuthClientRequest', createOAuthClientRequest)
            const localVarPath = `/oauth-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOAuthClientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOauthClient', 'id', id)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOauthClient', 'id', id)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients: async (filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchOauthClient', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchOauthClient', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthClientsApi - functional programming interface
 * @export
 */
export const OAuthClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createOauthClient(createOAuthClientRequest: CreateOAuthClientRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOauthClient(createOAuthClientRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOauthClient(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOauthClient(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getOauthClient(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOauthClient(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listOauthClients(filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOAuthClientResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOauthClients(filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchOauthClient(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOauthClient(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuthClientsApi - factory interface
 * @export
 */
export const OAuthClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthClientsApiFp(configuration)
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient(createOAuthClientRequest: CreateOAuthClientRequest, axiosOptions?: any): AxiosPromise<CreateOAuthClientResponse> {
            return localVarFp.createOauthClient(createOAuthClientRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteOauthClient(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient(id: string, axiosOptions?: any): AxiosPromise<GetOAuthClientResponse> {
            return localVarFp.getOauthClient(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients(filters?: string, axiosOptions?: any): AxiosPromise<Array<GetOAuthClientResponse>> {
            return localVarFp.listOauthClients(filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<GetOAuthClientResponse> {
            return localVarFp.patchOauthClient(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiCreateOauthClientRequest
 */
export interface OAuthClientsApiCreateOauthClientRequest {
    /**
     * 
     * @type {CreateOAuthClientRequest}
     * @memberof OAuthClientsApiCreateOauthClient
     */
    readonly createOAuthClientRequest: CreateOAuthClientRequest
}

/**
 * Request parameters for deleteOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiDeleteOauthClientRequest
 */
export interface OAuthClientsApiDeleteOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiDeleteOauthClient
     */
    readonly id: string
}

/**
 * Request parameters for getOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiGetOauthClientRequest
 */
export interface OAuthClientsApiGetOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiGetOauthClient
     */
    readonly id: string
}

/**
 * Request parameters for listOauthClients operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiListOauthClientsRequest
 */
export interface OAuthClientsApiListOauthClientsRequest {
    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
     * @type {string}
     * @memberof OAuthClientsApiListOauthClients
     */
    readonly filters?: string
}

/**
 * Request parameters for patchOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiPatchOauthClientRequest
 */
export interface OAuthClientsApiPatchOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiPatchOauthClient
     */
    readonly id: string

    /**
     * A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
     * @type {Array<JsonPatchOperation>}
     * @memberof OAuthClientsApiPatchOauthClient
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * OAuthClientsApi - object-oriented interface
 * @export
 * @class OAuthClientsApi
 * @extends {BaseAPI}
 */
export class OAuthClientsApi extends BaseAPI {
    /**
     * This creates an OAuth client.
     * @summary Create OAuth Client
     * @param {OAuthClientsApiCreateOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public createOauthClient(requestParameters: OAuthClientsApiCreateOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).createOauthClient(requestParameters.createOAuthClientRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes an OAuth client.
     * @summary Delete OAuth Client
     * @param {OAuthClientsApiDeleteOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public deleteOauthClient(requestParameters: OAuthClientsApiDeleteOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).deleteOauthClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets details of an OAuth client.
     * @summary Get OAuth Client
     * @param {OAuthClientsApiGetOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public getOauthClient(requestParameters: OAuthClientsApiGetOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).getOauthClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of OAuth clients.
     * @summary List OAuth Clients
     * @param {OAuthClientsApiListOauthClientsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public listOauthClients(requestParameters: OAuthClientsApiListOauthClientsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).listOauthClients(requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This performs a targeted update to the field(s) of an OAuth client.
     * @summary Patch OAuth Client
     * @param {OAuthClientsApiPatchOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public patchOauthClient(requestParameters: OAuthClientsApiPatchOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).patchOauthClient(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordConfigurationApi - axios parameter creator
 * @export
 */
export const PasswordConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordOrgConfig: async (passwordOrgConfig: PasswordOrgConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordOrgConfig' is not null or undefined
            assertParamExists('createPasswordOrgConfig', 'passwordOrgConfig', passwordOrgConfig)
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordOrgConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordOrgConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordOrgConfig: async (passwordOrgConfig: PasswordOrgConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordOrgConfig' is not null or undefined
            assertParamExists('updatePasswordOrgConfig', 'passwordOrgConfig', passwordOrgConfig)
            const localVarPath = `/password-org-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordOrgConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordConfigurationApi - functional programming interface
 * @export
 */
export const PasswordConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPasswordOrgConfig(passwordOrgConfig: PasswordOrgConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPasswordOrgConfig(passwordOrgConfig, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordOrgConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordOrgConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasswordOrgConfig(passwordOrgConfig: PasswordOrgConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordOrgConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasswordOrgConfig(passwordOrgConfig, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordConfigurationApi - factory interface
 * @export
 */
export const PasswordConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordConfigurationApiFp(configuration)
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordOrgConfig(passwordOrgConfig: PasswordOrgConfig, axiosOptions?: any): AxiosPromise<PasswordOrgConfig> {
            return localVarFp.createPasswordOrgConfig(passwordOrgConfig, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordOrgConfig(axiosOptions?: any): AxiosPromise<PasswordOrgConfig> {
            return localVarFp.getPasswordOrgConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordOrgConfig(passwordOrgConfig: PasswordOrgConfig, axiosOptions?: any): AxiosPromise<PasswordOrgConfig> {
            return localVarFp.updatePasswordOrgConfig(passwordOrgConfig, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPasswordOrgConfig operation in PasswordConfigurationApi.
 * @export
 * @interface PasswordConfigurationApiCreatePasswordOrgConfigRequest
 */
export interface PasswordConfigurationApiCreatePasswordOrgConfigRequest {
    /**
     * 
     * @type {PasswordOrgConfig}
     * @memberof PasswordConfigurationApiCreatePasswordOrgConfig
     */
    readonly passwordOrgConfig: PasswordOrgConfig
}

/**
 * Request parameters for updatePasswordOrgConfig operation in PasswordConfigurationApi.
 * @export
 * @interface PasswordConfigurationApiUpdatePasswordOrgConfigRequest
 */
export interface PasswordConfigurationApiUpdatePasswordOrgConfigRequest {
    /**
     * 
     * @type {PasswordOrgConfig}
     * @memberof PasswordConfigurationApiUpdatePasswordOrgConfig
     */
    readonly passwordOrgConfig: PasswordOrgConfig
}

/**
 * PasswordConfigurationApi - object-oriented interface
 * @export
 * @class PasswordConfigurationApi
 * @extends {BaseAPI}
 */
export class PasswordConfigurationApi extends BaseAPI {
    /**
     * This API creates the password org config. Unspecified fields will use default value. Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
     * @summary Create Password Org Config
     * @param {PasswordConfigurationApiCreatePasswordOrgConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    public createPasswordOrgConfig(requestParameters: PasswordConfigurationApiCreatePasswordOrgConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordConfigurationApiFp(this.configuration).createPasswordOrgConfig(requestParameters.passwordOrgConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
     * @summary Get Password Org Config
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    public getPasswordOrgConfig(axiosOptions?: AxiosRequestConfig) {
        return PasswordConfigurationApiFp(this.configuration).getPasswordOrgConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates the password org config for specified fields. Other fields will keep original value. Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
     * @summary Update Password Org Config
     * @param {PasswordConfigurationApiUpdatePasswordOrgConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    public updatePasswordOrgConfig(requestParameters: PasswordConfigurationApiUpdatePasswordOrgConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordConfigurationApiFp(this.configuration).updatePasswordOrgConfig(requestParameters.passwordOrgConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordDictionaryApi - axios parameter creator
 * @export
 */
export const PasswordDictionaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordDictionary: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-dictionary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Dictionary
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordDictionary: async (file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-dictionary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordDictionaryApi - functional programming interface
 * @export
 */
export const PasswordDictionaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordDictionaryApiAxiosParamCreator(configuration)
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordDictionary(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordDictionary(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Dictionary
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasswordDictionary(file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasswordDictionary(file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordDictionaryApi - factory interface
 * @export
 */
export const PasswordDictionaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordDictionaryApiFp(configuration)
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordDictionary(axiosOptions?: any): AxiosPromise<string> {
            return localVarFp.getPasswordDictionary(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Dictionary
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordDictionary(file?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.updatePasswordDictionary(file, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updatePasswordDictionary operation in PasswordDictionaryApi.
 * @export
 * @interface PasswordDictionaryApiUpdatePasswordDictionaryRequest
 */
export interface PasswordDictionaryApiUpdatePasswordDictionaryRequest {
    /**
     * 
     * @type {any}
     * @memberof PasswordDictionaryApiUpdatePasswordDictionary
     */
    readonly file?: any
}

/**
 * PasswordDictionaryApi - object-oriented interface
 * @export
 * @class PasswordDictionaryApi
 * @extends {BaseAPI}
 */
export class PasswordDictionaryApi extends BaseAPI {
    /**
     * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Dictionary
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordDictionaryApi
     */
    public getPasswordDictionary(axiosOptions?: AxiosRequestConfig) {
        return PasswordDictionaryApiFp(this.configuration).getPasswordDictionary(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Password Dictionary
     * @param {PasswordDictionaryApiUpdatePasswordDictionaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordDictionaryApi
     */
    public updatePasswordDictionary(requestParameters: PasswordDictionaryApiUpdatePasswordDictionaryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PasswordDictionaryApiFp(this.configuration).updatePasswordDictionary(requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordManagementApi - axios parameter creator
 * @export
 */
export const PasswordManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordChangeStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPasswordChangeStatus', 'id', id)
            const localVarPath = `/password-change-status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo: async (passwordInfoQueryDTO: PasswordInfoQueryDTO, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordInfoQueryDTO' is not null or undefined
            assertParamExists('queryPasswordInfo', 'passwordInfoQueryDTO', passwordInfoQueryDTO)
            const localVarPath = `/query-password-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordInfoQueryDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPassword: async (passwordChangeRequest: PasswordChangeRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChangeRequest' is not null or undefined
            assertParamExists('setPassword', 'passwordChangeRequest', passwordChangeRequest)
            const localVarPath = `/set-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordManagementApi - functional programming interface
 * @export
 */
export const PasswordManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordChangeStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordChangeStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async queryPasswordInfo(passwordInfoQueryDTO: PasswordInfoQueryDTO, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryPasswordInfo(passwordInfoQueryDTO, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setPassword(passwordChangeRequest: PasswordChangeRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordChangeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPassword(passwordChangeRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordManagementApi - factory interface
 * @export
 */
export const PasswordManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordManagementApiFp(configuration)
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordChangeStatus(id: string, axiosOptions?: any): AxiosPromise<PasswordStatus> {
            return localVarFp.getPasswordChangeStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo(passwordInfoQueryDTO: PasswordInfoQueryDTO, axiosOptions?: any): AxiosPromise<PasswordInfo> {
            return localVarFp.queryPasswordInfo(passwordInfoQueryDTO, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPassword(passwordChangeRequest: PasswordChangeRequest, axiosOptions?: any): AxiosPromise<PasswordChangeResponse> {
            return localVarFp.setPassword(passwordChangeRequest, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPasswordChangeStatus operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiGetPasswordChangeStatusRequest
 */
export interface PasswordManagementApiGetPasswordChangeStatusRequest {
    /**
     * Password change request ID
     * @type {string}
     * @memberof PasswordManagementApiGetPasswordChangeStatus
     */
    readonly id: string
}

/**
 * Request parameters for queryPasswordInfo operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiQueryPasswordInfoRequest
 */
export interface PasswordManagementApiQueryPasswordInfoRequest {
    /**
     * 
     * @type {PasswordInfoQueryDTO}
     * @memberof PasswordManagementApiQueryPasswordInfo
     */
    readonly passwordInfoQueryDTO: PasswordInfoQueryDTO
}

/**
 * Request parameters for setPassword operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiSetPasswordRequest
 */
export interface PasswordManagementApiSetPasswordRequest {
    /**
     * 
     * @type {PasswordChangeRequest}
     * @memberof PasswordManagementApiSetPassword
     */
    readonly passwordChangeRequest: PasswordChangeRequest
}

/**
 * PasswordManagementApi - object-oriented interface
 * @export
 * @class PasswordManagementApi
 * @extends {BaseAPI}
 */
export class PasswordManagementApi extends BaseAPI {
    /**
     * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
     * @summary Get Password Change Request Status
     * @param {PasswordManagementApiGetPasswordChangeStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public getPasswordChangeStatus(requestParameters: PasswordManagementApiGetPasswordChangeStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).getPasswordChangeStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
     * @summary Query Password Info
     * @param {PasswordManagementApiQueryPasswordInfoRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public queryPasswordInfo(requestParameters: PasswordManagementApiQueryPasswordInfoRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).queryPasswordInfo(requestParameters.passwordInfoQueryDTO, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.  
     * @summary Set Identity\'s Password
     * @param {PasswordManagementApiSetPasswordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public setPassword(requestParameters: PasswordManagementApiSetPasswordRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).setPassword(requestParameters.passwordChangeRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordSyncGroupsApi - axios parameter creator
 * @export
 */
export const PasswordSyncGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordSyncGroup: async (passwordSyncGroup: PasswordSyncGroup, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordSyncGroup' is not null or undefined
            assertParamExists('createPasswordSyncGroup', 'passwordSyncGroup', passwordSyncGroup)
            const localVarPath = `/password-sync-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordSyncGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordSyncGroup: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePasswordSyncGroup', 'id', id)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroup: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPasswordSyncGroup', 'id', id)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroups: async (limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password-sync-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSyncGroup: async (id: string, passwordSyncGroup: PasswordSyncGroup, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePasswordSyncGroup', 'id', id)
            // verify required parameter 'passwordSyncGroup' is not null or undefined
            assertParamExists('updatePasswordSyncGroup', 'passwordSyncGroup', passwordSyncGroup)
            const localVarPath = `/password-sync-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordSyncGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordSyncGroupsApi - functional programming interface
 * @export
 */
export const PasswordSyncGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordSyncGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPasswordSyncGroup(passwordSyncGroup: PasswordSyncGroup, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPasswordSyncGroup(passwordSyncGroup, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePasswordSyncGroup(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePasswordSyncGroup(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordSyncGroup(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordSyncGroup(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordSyncGroups(limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PasswordSyncGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordSyncGroups(limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasswordSyncGroup(id: string, passwordSyncGroup: PasswordSyncGroup, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSyncGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasswordSyncGroup(id, passwordSyncGroup, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordSyncGroupsApi - factory interface
 * @export
 */
export const PasswordSyncGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordSyncGroupsApiFp(configuration)
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordSyncGroup(passwordSyncGroup: PasswordSyncGroup, axiosOptions?: any): AxiosPromise<PasswordSyncGroup> {
            return localVarFp.createPasswordSyncGroup(passwordSyncGroup, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordSyncGroup(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deletePasswordSyncGroup(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroup(id: string, axiosOptions?: any): AxiosPromise<PasswordSyncGroup> {
            return localVarFp.getPasswordSyncGroup(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroups(limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<PasswordSyncGroup>> {
            return localVarFp.getPasswordSyncGroups(limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroup} passwordSyncGroup 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSyncGroup(id: string, passwordSyncGroup: PasswordSyncGroup, axiosOptions?: any): AxiosPromise<PasswordSyncGroup> {
            return localVarFp.updatePasswordSyncGroup(id, passwordSyncGroup, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiCreatePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiCreatePasswordSyncGroupRequest {
    /**
     * 
     * @type {PasswordSyncGroup}
     * @memberof PasswordSyncGroupsApiCreatePasswordSyncGroup
     */
    readonly passwordSyncGroup: PasswordSyncGroup
}

/**
 * Request parameters for deletePasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiDeletePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiDeletePasswordSyncGroupRequest {
    /**
     * The ID of password sync group to delete.
     * @type {string}
     * @memberof PasswordSyncGroupsApiDeletePasswordSyncGroup
     */
    readonly id: string
}

/**
 * Request parameters for getPasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiGetPasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiGetPasswordSyncGroupRequest {
    /**
     * The ID of password sync group to retrieve.
     * @type {string}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroup
     */
    readonly id: string
}

/**
 * Request parameters for getPasswordSyncGroups operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiGetPasswordSyncGroupsRequest
 */
export interface PasswordSyncGroupsApiGetPasswordSyncGroupsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroups
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroups
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof PasswordSyncGroupsApiGetPasswordSyncGroups
     */
    readonly count?: boolean
}

/**
 * Request parameters for updatePasswordSyncGroup operation in PasswordSyncGroupsApi.
 * @export
 * @interface PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest
 */
export interface PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest {
    /**
     * The ID of password sync group to update.
     * @type {string}
     * @memberof PasswordSyncGroupsApiUpdatePasswordSyncGroup
     */
    readonly id: string

    /**
     * 
     * @type {PasswordSyncGroup}
     * @memberof PasswordSyncGroupsApiUpdatePasswordSyncGroup
     */
    readonly passwordSyncGroup: PasswordSyncGroup
}

/**
 * PasswordSyncGroupsApi - object-oriented interface
 * @export
 * @class PasswordSyncGroupsApi
 * @extends {BaseAPI}
 */
export class PasswordSyncGroupsApi extends BaseAPI {
    /**
     * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Password Sync Group
     * @param {PasswordSyncGroupsApiCreatePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public createPasswordSyncGroup(requestParameters: PasswordSyncGroupsApiCreatePasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).createPasswordSyncGroup(requestParameters.passwordSyncGroup, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete Password Sync Group by ID
     * @param {PasswordSyncGroupsApiDeletePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public deletePasswordSyncGroup(requestParameters: PasswordSyncGroupsApiDeletePasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).deletePasswordSyncGroup(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Sync Group by ID
     * @param {PasswordSyncGroupsApiGetPasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public getPasswordSyncGroup(requestParameters: PasswordSyncGroupsApiGetPasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).getPasswordSyncGroup(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Sync Group List
     * @param {PasswordSyncGroupsApiGetPasswordSyncGroupsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public getPasswordSyncGroups(requestParameters: PasswordSyncGroupsApiGetPasswordSyncGroupsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).getPasswordSyncGroups(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Password Sync Group by ID
     * @param {PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    public updatePasswordSyncGroup(requestParameters: PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordSyncGroupsApiFp(this.configuration).updatePasswordSyncGroup(requestParameters.id, requestParameters.passwordSyncGroup, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonalAccessTokensApi - axios parameter creator
 * @export
 */
export const PersonalAccessTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken: async (createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonalAccessTokenRequest' is not null or undefined
            assertParamExists('createPersonalAccessToken', 'createPersonalAccessTokenRequest', createPersonalAccessTokenRequest)
            const localVarPath = `/personal-access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonalAccessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePersonalAccessToken', 'id', id)
            const localVarPath = `/personal-access-tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens: async (ownerId?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personal-access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchPersonalAccessToken', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchPersonalAccessToken', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/personal-access-tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonalAccessTokensApi - functional programming interface
 * @export
 */
export const PersonalAccessTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonalAccessTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPersonalAccessToken(createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersonalAccessToken(createPersonalAccessTokenRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePersonalAccessToken(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonalAccessToken(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonalAccessTokens(ownerId?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPersonalAccessTokenResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonalAccessTokens(ownerId, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchPersonalAccessToken(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchPersonalAccessToken(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonalAccessTokensApi - factory interface
 * @export
 */
export const PersonalAccessTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonalAccessTokensApiFp(configuration)
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken(createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest, axiosOptions?: any): AxiosPromise<CreatePersonalAccessTokenResponse> {
            return localVarFp.createPersonalAccessToken(createPersonalAccessTokenRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deletePersonalAccessToken(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens(ownerId?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<GetPersonalAccessTokenResponse>> {
            return localVarFp.listPersonalAccessTokens(ownerId, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<GetPersonalAccessTokenResponse> {
            return localVarFp.patchPersonalAccessToken(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiCreatePersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiCreatePersonalAccessTokenRequest {
    /**
     * Name and scope of personal access token.
     * @type {CreatePersonalAccessTokenRequest}
     * @memberof PersonalAccessTokensApiCreatePersonalAccessToken
     */
    readonly createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest
}

/**
 * Request parameters for deletePersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiDeletePersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiDeletePersonalAccessTokenRequest {
    /**
     * The personal access token id
     * @type {string}
     * @memberof PersonalAccessTokensApiDeletePersonalAccessToken
     */
    readonly id: string
}

/**
 * Request parameters for listPersonalAccessTokens operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiListPersonalAccessTokensRequest
 */
export interface PersonalAccessTokensApiListPersonalAccessTokensRequest {
    /**
     * The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
     * @type {string}
     * @memberof PersonalAccessTokensApiListPersonalAccessTokens
     */
    readonly ownerId?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
     * @type {string}
     * @memberof PersonalAccessTokensApiListPersonalAccessTokens
     */
    readonly filters?: string
}

/**
 * Request parameters for patchPersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiPatchPersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiPatchPersonalAccessTokenRequest {
    /**
     * The Personal Access Token id
     * @type {string}
     * @memberof PersonalAccessTokensApiPatchPersonalAccessToken
     */
    readonly id: string

    /**
     * A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
     * @type {Array<JsonPatchOperation>}
     * @memberof PersonalAccessTokensApiPatchPersonalAccessToken
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * PersonalAccessTokensApi - object-oriented interface
 * @export
 * @class PersonalAccessTokensApi
 * @extends {BaseAPI}
 */
export class PersonalAccessTokensApi extends BaseAPI {
    /**
     * This creates a personal access token.
     * @summary Create Personal Access Token
     * @param {PersonalAccessTokensApiCreatePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public createPersonalAccessToken(requestParameters: PersonalAccessTokensApiCreatePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).createPersonalAccessToken(requestParameters.createPersonalAccessTokenRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a personal access token.
     * @summary Delete Personal Access Token
     * @param {PersonalAccessTokensApiDeletePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public deletePersonalAccessToken(requestParameters: PersonalAccessTokensApiDeletePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).deletePersonalAccessToken(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
     * @summary List Personal Access Tokens
     * @param {PersonalAccessTokensApiListPersonalAccessTokensRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public listPersonalAccessTokens(requestParameters: PersonalAccessTokensApiListPersonalAccessTokensRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).listPersonalAccessTokens(requestParameters.ownerId, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This performs a targeted update to the field(s) of a Personal Access Token.
     * @summary Patch Personal Access Token
     * @param {PersonalAccessTokensApiPatchPersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public patchPersonalAccessToken(requestParameters: PersonalAccessTokensApiPatchPersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).patchPersonalAccessToken(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicIdentitiesApi - axios parameter creator
 * @export
 */
export const PublicIdentitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentities: async (limit?: number, offset?: number, count?: boolean, filters?: string, addCoreFilters?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public-identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (addCoreFilters !== undefined) {
                localVarQueryParameter['add-core-filters'] = addCoreFilters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicIdentitiesApi - functional programming interface
 * @export
 */
export const PublicIdentitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicIdentitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicIdentities(limit?: number, offset?: number, count?: boolean, filters?: string, addCoreFilters?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicIdentity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicIdentities(limit, offset, count, filters, addCoreFilters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicIdentitiesApi - factory interface
 * @export
 */
export const PublicIdentitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicIdentitiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentities(limit?: number, offset?: number, count?: boolean, filters?: string, addCoreFilters?: boolean, sorters?: string, axiosOptions?: any): AxiosPromise<Array<PublicIdentity>> {
            return localVarFp.getPublicIdentities(limit, offset, count, filters, addCoreFilters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPublicIdentities operation in PublicIdentitiesApi.
 * @export
 * @interface PublicIdentitiesApiGetPublicIdentitiesRequest
 */
export interface PublicIdentitiesApiGetPublicIdentitiesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
     * @type {string}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly filters?: string

    /**
     * If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
     * @type {boolean}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly addCoreFilters?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly sorters?: string
}

/**
 * PublicIdentitiesApi - object-oriented interface
 * @export
 * @class PublicIdentitiesApi
 * @extends {BaseAPI}
 */
export class PublicIdentitiesApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of public identities
     * @param {PublicIdentitiesApiGetPublicIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesApi
     */
    public getPublicIdentities(requestParameters: PublicIdentitiesApiGetPublicIdentitiesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesApiFp(this.configuration).getPublicIdentities(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.addCoreFilters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicIdentitiesConfigApi - axios parameter creator
 * @export
 */
export const PublicIdentitiesConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public-identities-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig: async (publicIdentityConfig: PublicIdentityConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicIdentityConfig' is not null or undefined
            assertParamExists('updatePublicIdentityConfig', 'publicIdentityConfig', publicIdentityConfig)
            const localVarPath = `/public-identities-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicIdentityConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicIdentitiesConfigApi - functional programming interface
 * @export
 */
export const PublicIdentitiesConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicIdentitiesConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicIdentityConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIdentityConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicIdentityConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicIdentityConfig(publicIdentityConfig: PublicIdentityConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIdentityConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicIdentityConfig(publicIdentityConfig, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicIdentitiesConfigApi - factory interface
 * @export
 */
export const PublicIdentitiesConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicIdentitiesConfigApiFp(configuration)
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig(axiosOptions?: any): AxiosPromise<PublicIdentityConfig> {
            return localVarFp.getPublicIdentityConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig(publicIdentityConfig: PublicIdentityConfig, axiosOptions?: any): AxiosPromise<PublicIdentityConfig> {
            return localVarFp.updatePublicIdentityConfig(publicIdentityConfig, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updatePublicIdentityConfig operation in PublicIdentitiesConfigApi.
 * @export
 * @interface PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest
 */
export interface PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest {
    /**
     * 
     * @type {PublicIdentityConfig}
     * @memberof PublicIdentitiesConfigApiUpdatePublicIdentityConfig
     */
    readonly publicIdentityConfig: PublicIdentityConfig
}

/**
 * PublicIdentitiesConfigApi - object-oriented interface
 * @export
 * @class PublicIdentitiesConfigApi
 * @extends {BaseAPI}
 */
export class PublicIdentitiesConfigApi extends BaseAPI {
    /**
     * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
     * @summary Get the Public Identities Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigApi
     */
    public getPublicIdentityConfig(axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesConfigApiFp(this.configuration).getPublicIdentityConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
     * @summary Update the Public Identities Configuration
     * @param {PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigApi
     */
    public updatePublicIdentityConfig(requestParameters: PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesConfigApiFp(this.configuration).updatePublicIdentityConfig(requestParameters.publicIdentityConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RequestableObjectsApi - axios parameter creator
 * @export
 */
export const RequestableObjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects: async (identityId?: string, types?: Array<RequestableObjectType>, term?: string, statuses?: Array<RequestableObjectRequestStatus>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/requestable-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (identityId !== undefined) {
                localVarQueryParameter['identity-id'] = identityId;
            }

            if (types) {
                localVarQueryParameter['types'] = types.join(COLLECTION_FORMATS.csv);
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequestableObjectsApi - functional programming interface
 * @export
 */
export const RequestableObjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RequestableObjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listRequestableObjects(identityId?: string, types?: Array<RequestableObjectType>, term?: string, statuses?: Array<RequestableObjectRequestStatus>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RequestableObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRequestableObjects(identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RequestableObjectsApi - factory interface
 * @export
 */
export const RequestableObjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RequestableObjectsApiFp(configuration)
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects(identityId?: string, types?: Array<RequestableObjectType>, term?: string, statuses?: Array<RequestableObjectRequestStatus>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<RequestableObject>> {
            return localVarFp.listRequestableObjects(identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listRequestableObjects operation in RequestableObjectsApi.
 * @export
 * @interface RequestableObjectsApiListRequestableObjectsRequest
 */
export interface RequestableObjectsApiListRequestableObjectsRequest {
    /**
     * If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly identityId?: string

    /**
     * Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
     * @type {Array<RequestableObjectType>}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly types?: Array<RequestableObjectType>

    /**
     * It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly term?: string

    /**
     * Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
     * @type {Array<RequestableObjectRequestStatus>}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly statuses?: Array<RequestableObjectRequestStatus>

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly sorters?: string
}

/**
 * RequestableObjectsApi - object-oriented interface
 * @export
 * @class RequestableObjectsApi
 * @extends {BaseAPI}
 */
export class RequestableObjectsApi extends BaseAPI {
    /**
     * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
     * @summary Requestable Objects List
     * @param {RequestableObjectsApiListRequestableObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestableObjectsApi
     */
    public listRequestableObjects(requestParameters: RequestableObjectsApiListRequestableObjectsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return RequestableObjectsApiFp(this.configuration).listRequestableObjects(requestParameters.identityId, requestParameters.types, requestParameters.term, requestParameters.statuses, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a Role. There is a soft limit of 800 roles per org in IdentityNow.  You will receive an error if you attempt to add more than 800 roles via the API or the UI.  If you need to add roles above this limit, please create a support ticket. A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a ROLE_SUBADMIN may not create a Role including an Access Profile if that Access Profile is associated with a Source with which the ROLE_SUBADMIN is not themselves associated. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {Role} role 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (role: Role, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('createRole', 'role', role)
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **aliasName**, **email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignedIdentities: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoleAssignedIdentities', 'id', id)
            const localVarPath = `/roles/{id}/assigned-identities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **name**: *eq, sw* **created, modified**: *gt, lt, ge, le* **owner.id**: *eq, in* **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSegmentIds !== undefined) {
                localVarQueryParameter['for-segment-ids'] = forSegmentIds;
            }

            if (includeUnsegmented !== undefined) {
                localVarQueryParameter['include-unsegmented'] = includeUnsegmented;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates an existing Role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **name**, **description**, **enabled**, **owner**, **accessProfiles**, **membership**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments** A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRole: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchRole', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchRole', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a Role. There is a soft limit of 800 roles per org in IdentityNow.  You will receive an error if you attempt to add more than 800 roles via the API or the UI.  If you need to add roles above this limit, please create a support ticket. A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a ROLE_SUBADMIN may not create a Role including an Access Profile if that Access Profile is associated with a Source with which the ROLE_SUBADMIN is not themselves associated. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {Role} role 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(role: Role, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(role, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **aliasName**, **email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleAssignedIdentities(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleIdentity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleAssignedIdentities(id, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **name**: *eq, sw* **created, modified**: *gt, lt, ge, le* **owner.id**: *eq, in* **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates an existing Role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **name**, **description**, **enabled**, **owner**, **accessProfiles**, **membership**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments** A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchRole(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRole(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * This API creates a Role. There is a soft limit of 800 roles per org in IdentityNow.  You will receive an error if you attempt to add more than 800 roles via the API or the UI.  If you need to add roles above this limit, please create a support ticket. A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a ROLE_SUBADMIN may not create a Role including an Access Profile if that Access Profile is associated with a Source with which the ROLE_SUBADMIN is not themselves associated. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {Role} role 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRole(role: Role, axiosOptions?: any): AxiosPromise<Role> {
            return localVarFp.createRole(role, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRole(id: string, axiosOptions?: any): AxiosPromise<Role> {
            return localVarFp.getRole(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **aliasName**, **email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignedIdentities(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<RoleIdentity>> {
            return localVarFp.getRoleAssignedIdentities(id, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **name**: *eq, sw* **created, modified**: *gt, lt, ge, le* **owner.id**: *eq, in* **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(forSubadmin?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSegmentIds?: string, includeUnsegmented?: boolean, axiosOptions?: any): AxiosPromise<Array<Role>> {
            return localVarFp.listRoles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates an existing Role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **name**, **description**, **enabled**, **owner**, **accessProfiles**, **membership**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments** A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRole(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<Role> {
            return localVarFp.patchRole(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createRole operation in RolesApi.
 * @export
 * @interface RolesApiCreateRoleRequest
 */
export interface RolesApiCreateRoleRequest {
    /**
     * 
     * @type {Role}
     * @memberof RolesApiCreateRole
     */
    readonly role: Role
}

/**
 * Request parameters for getRole operation in RolesApi.
 * @export
 * @interface RolesApiGetRoleRequest
 */
export interface RolesApiGetRoleRequest {
    /**
     * ID of the Role
     * @type {string}
     * @memberof RolesApiGetRole
     */
    readonly id: string
}

/**
 * Request parameters for getRoleAssignedIdentities operation in RolesApi.
 * @export
 * @interface RolesApiGetRoleAssignedIdentitiesRequest
 */
export interface RolesApiGetRoleAssignedIdentitiesRequest {
    /**
     * ID of the Role for which the assigned Identities are to be listed
     * @type {string}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
     * @type {string}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **aliasName**, **email**
     * @type {string}
     * @memberof RolesApiGetRoleAssignedIdentities
     */
    readonly sorters?: string
}

/**
 * Request parameters for listRoles operation in RolesApi.
 * @export
 * @interface RolesApiListRolesRequest
 */
export interface RolesApiListRolesRequest {
    /**
     * If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly forSubadmin?: string

    /**
     * Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiListRoles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RolesApiListRoles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RolesApiListRoles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **name**: *eq, sw* **created, modified**: *gt, lt, ge, le* **owner.id**: *eq, in* **requestable**: *eq*
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, created, modified**
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly sorters?: string

    /**
     * If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly forSegmentIds?: string

    /**
     * Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
     * @type {boolean}
     * @memberof RolesApiListRoles
     */
    readonly includeUnsegmented?: boolean
}

/**
 * Request parameters for patchRole operation in RolesApi.
 * @export
 * @interface RolesApiPatchRoleRequest
 */
export interface RolesApiPatchRoleRequest {
    /**
     * ID of the Role to patch
     * @type {string}
     * @memberof RolesApiPatchRole
     */
    readonly id: string

    /**
     * 
     * @type {Array<JsonPatchOperation>}
     * @memberof RolesApiPatchRole
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * This API creates a Role. There is a soft limit of 800 roles per org in IdentityNow.  You will receive an error if you attempt to add more than 800 roles via the API or the UI.  If you need to add roles above this limit, please create a support ticket. A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a ROLE_SUBADMIN may not create a Role including an Access Profile if that Access Profile is associated with a Source with which the ROLE_SUBADMIN is not themselves associated. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
     * @summary Create a Role
     * @param {RolesApiCreateRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public createRole(requestParameters: RolesApiCreateRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).createRole(requestParameters.role, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
     * @summary Get a Role
     * @param {RolesApiGetRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRole(requestParameters: RolesApiGetRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRole(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Identities assigned a Role
     * @param {RolesApiGetRoleAssignedIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleAssignedIdentities(requestParameters: RolesApiGetRoleAssignedIdentitiesRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRoleAssignedIdentities(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
     * @summary List Roles
     * @param {RolesApiListRolesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public listRoles(requestParameters: RolesApiListRolesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).listRoles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates an existing Role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable: **name**, **description**, **enabled**, **owner**, **accessProfiles**, **membership**, **requestable**, **accessRequestConfig**, **revokeRequestConfig**, **segments** A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
     * @summary Patch a specified Role
     * @param {RolesApiPatchRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public patchRole(requestParameters: RolesApiPatchRoleRequest, axiosOptions?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).patchRole(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SODPolicyApi - axios parameter creator
 * @export
 */
export const SODPolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSodPolicy: async (sodPolicy: SodPolicy, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sodPolicy' is not null or undefined
            assertParamExists('createSodPolicy', 'sodPolicy', sodPolicy)
            const localVarPath = `/sod-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicy: async (id: string, logical?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (logical !== undefined) {
                localVarQueryParameter['logical'] = logical;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicySchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSodPolicySchedule', 'id', id)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCustomViolationReport: async (reportResultId: string, fileName: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('getCustomViolationReport', 'reportResultId', reportResultId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getCustomViolationReport', 'fileName', fileName)
            const localVarPath = `/sod-violation-report/{reportResultId}/download/{fileName}`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultViolationReport: async (reportResultId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('getDefaultViolationReport', 'reportResultId', reportResultId)
            const localVarPath = `/sod-violation-report/{reportResultId}/download`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodAllReportRunStatus: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-violation-report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the SOD Policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicy: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the SOD policy schedule to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicySchedule: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodPolicySchedule', 'id', id)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportRunStatus: async (reportResultId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportResultId' is not null or undefined
            assertParamExists('getSodViolationReportRunStatus', 'reportResultId', reportResultId)
            const localVarPath = `/sod-policies/sod-violation-report-status/{reportResultId}`
                .replace(`{${"reportResultId"}}`, encodeURIComponent(String(reportResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the violation report to retrieve status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSodViolationReportStatus', 'id', id)
            const localVarPath = `/sod-policies/{id}/violation-report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **state**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSodPolicies: async (limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch SOD policy by ID
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSodPolicy: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchSodPolicy', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchSodPolicy', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicySchedule} sodPolicySchedule 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPolicySchedule: async (id: string, sodPolicySchedule: SodPolicySchedule, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setPolicySchedule', 'id', id)
            // verify required parameter 'sodPolicySchedule' is not null or undefined
            assertParamExists('setPolicySchedule', 'sodPolicySchedule', sodPolicySchedule)
            const localVarPath = `/sod-policies/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicySchedule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setSodPolicy: async (id: string, sodPolicy: SodPolicy, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setSodPolicy', 'id', id)
            // verify required parameter 'sodPolicy' is not null or undefined
            assertParamExists('setSodPolicy', 'sodPolicy', sodPolicy)
            const localVarPath = `/sod-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sodPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startEvaluateSodPolicy: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startEvaluateSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}/evaluate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequest} [multiPolicyRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodAllPoliciesForOrg: async (multiPolicyRequest?: MultiPolicyRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sod-violation-report/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(multiPolicyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodPolicy: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startSodPolicy', 'id', id)
            const localVarPath = `/sod-policies/{id}/violation-report/run`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SODPolicyApi - functional programming interface
 * @export
 */
export const SODPolicyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SODPolicyApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSodPolicy(sodPolicy: SodPolicy, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSodPolicy(sodPolicy, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSodPolicy(id: string, logical?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSodPolicy(id, logical, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSodPolicySchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSodPolicySchedule(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomViolationReport(reportResultId: string, fileName: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomViolationReport(reportResultId, fileName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultViolationReport(reportResultId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultViolationReport(reportResultId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodAllReportRunStatus(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodAllReportRunStatus(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the SOD Policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodPolicy(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodPolicy(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the SOD policy schedule to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodPolicySchedule(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicySchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodPolicySchedule(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodViolationReportRunStatus(reportResultId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodViolationReportRunStatus(reportResultId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the violation report to retrieve status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSodViolationReportStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSodViolationReportStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **state**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSodPolicies(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SodPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSodPolicies(limit, offset, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch SOD policy by ID
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSodPolicy(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSodPolicy(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicySchedule} sodPolicySchedule 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setPolicySchedule(id: string, sodPolicySchedule: SodPolicySchedule, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicySchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPolicySchedule(id, sodPolicySchedule, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setSodPolicy(id: string, sodPolicy: SodPolicy, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSodPolicy(id, sodPolicy, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startEvaluateSodPolicy(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startEvaluateSodPolicy(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequest} [multiPolicyRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startSodAllPoliciesForOrg(multiPolicyRequest?: MultiPolicyRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startSodAllPoliciesForOrg(multiPolicyRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startSodPolicy(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResultReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startSodPolicy(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SODPolicyApi - factory interface
 * @export
 */
export const SODPolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SODPolicyApiFp(configuration)
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSodPolicy(sodPolicy: SodPolicy, axiosOptions?: any): AxiosPromise<SodPolicy> {
            return localVarFp.createSodPolicy(sodPolicy, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicy(id: string, logical?: boolean, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSodPolicy(id, logical, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicySchedule(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSodPolicySchedule(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCustomViolationReport(reportResultId: string, fileName: string, axiosOptions?: any): AxiosPromise<any> {
            return localVarFp.getCustomViolationReport(reportResultId, fileName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultViolationReport(reportResultId: string, axiosOptions?: any): AxiosPromise<any> {
            return localVarFp.getDefaultViolationReport(reportResultId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodAllReportRunStatus(axiosOptions?: any): AxiosPromise<ReportResultReference> {
            return localVarFp.getSodAllReportRunStatus(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the SOD Policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicy(id: string, axiosOptions?: any): AxiosPromise<SodPolicy> {
            return localVarFp.getSodPolicy(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the SOD policy schedule to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicySchedule(id: string, axiosOptions?: any): AxiosPromise<SodPolicySchedule> {
            return localVarFp.getSodPolicySchedule(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportRunStatus(reportResultId: string, axiosOptions?: any): AxiosPromise<ReportResultReference> {
            return localVarFp.getSodViolationReportRunStatus(reportResultId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the violation report to retrieve status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportStatus(id: string, axiosOptions?: any): AxiosPromise<ReportResultReference> {
            return localVarFp.getSodViolationReportStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **state**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSodPolicies(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<SodPolicy>> {
            return localVarFp.listSodPolicies(limit, offset, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
         * @summary Patch SOD policy by ID
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSodPolicy(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<SodPolicy> {
            return localVarFp.patchSodPolicy(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicySchedule} sodPolicySchedule 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPolicySchedule(id: string, sodPolicySchedule: SodPolicySchedule, axiosOptions?: any): AxiosPromise<SodPolicySchedule> {
            return localVarFp.setPolicySchedule(id, sodPolicySchedule, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicy} sodPolicy 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setSodPolicy(id: string, sodPolicy: SodPolicy, axiosOptions?: any): AxiosPromise<SodPolicy> {
            return localVarFp.setSodPolicy(id, sodPolicy, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startEvaluateSodPolicy(id: string, axiosOptions?: any): AxiosPromise<ReportResultReference> {
            return localVarFp.startEvaluateSodPolicy(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequest} [multiPolicyRequest] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodAllPoliciesForOrg(multiPolicyRequest?: MultiPolicyRequest, axiosOptions?: any): AxiosPromise<ReportResultReference> {
            return localVarFp.startSodAllPoliciesForOrg(multiPolicyRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodPolicy(id: string, axiosOptions?: any): AxiosPromise<ReportResultReference> {
            return localVarFp.startSodPolicy(id, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiCreateSodPolicyRequest
 */
export interface SODPolicyApiCreateSodPolicyRequest {
    /**
     * 
     * @type {SodPolicy}
     * @memberof SODPolicyApiCreateSodPolicy
     */
    readonly sodPolicy: SodPolicy
}

/**
 * Request parameters for deleteSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiDeleteSodPolicyRequest
 */
export interface SODPolicyApiDeleteSodPolicyRequest {
    /**
     * The ID of the SOD Policy to delete.
     * @type {string}
     * @memberof SODPolicyApiDeleteSodPolicy
     */
    readonly id: string

    /**
     * Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
     * @type {boolean}
     * @memberof SODPolicyApiDeleteSodPolicy
     */
    readonly logical?: boolean
}

/**
 * Request parameters for deleteSodPolicySchedule operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiDeleteSodPolicyScheduleRequest
 */
export interface SODPolicyApiDeleteSodPolicyScheduleRequest {
    /**
     * The ID of the SOD policy the schedule must be deleted for.
     * @type {string}
     * @memberof SODPolicyApiDeleteSodPolicySchedule
     */
    readonly id: string
}

/**
 * Request parameters for getCustomViolationReport operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiGetCustomViolationReportRequest
 */
export interface SODPolicyApiGetCustomViolationReportRequest {
    /**
     * The ID of the report reference to download.
     * @type {string}
     * @memberof SODPolicyApiGetCustomViolationReport
     */
    readonly reportResultId: string

    /**
     * Custom Name for the  file.
     * @type {string}
     * @memberof SODPolicyApiGetCustomViolationReport
     */
    readonly fileName: string
}

/**
 * Request parameters for getDefaultViolationReport operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiGetDefaultViolationReportRequest
 */
export interface SODPolicyApiGetDefaultViolationReportRequest {
    /**
     * The ID of the report reference to download.
     * @type {string}
     * @memberof SODPolicyApiGetDefaultViolationReport
     */
    readonly reportResultId: string
}

/**
 * Request parameters for getSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiGetSodPolicyRequest
 */
export interface SODPolicyApiGetSodPolicyRequest {
    /**
     * The ID of the SOD Policy to retrieve.
     * @type {string}
     * @memberof SODPolicyApiGetSodPolicy
     */
    readonly id: string
}

/**
 * Request parameters for getSodPolicySchedule operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiGetSodPolicyScheduleRequest
 */
export interface SODPolicyApiGetSodPolicyScheduleRequest {
    /**
     * The ID of the SOD policy schedule to retrieve.
     * @type {string}
     * @memberof SODPolicyApiGetSodPolicySchedule
     */
    readonly id: string
}

/**
 * Request parameters for getSodViolationReportRunStatus operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiGetSodViolationReportRunStatusRequest
 */
export interface SODPolicyApiGetSodViolationReportRunStatusRequest {
    /**
     * The ID of the report reference to retrieve.
     * @type {string}
     * @memberof SODPolicyApiGetSodViolationReportRunStatus
     */
    readonly reportResultId: string
}

/**
 * Request parameters for getSodViolationReportStatus operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiGetSodViolationReportStatusRequest
 */
export interface SODPolicyApiGetSodViolationReportStatusRequest {
    /**
     * The ID of the violation report to retrieve status for.
     * @type {string}
     * @memberof SODPolicyApiGetSodViolationReportStatus
     */
    readonly id: string
}

/**
 * Request parameters for listSodPolicies operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiListSodPoliciesRequest
 */
export interface SODPolicyApiListSodPoliciesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SODPolicyApiListSodPolicies
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SODPolicyApiListSodPolicies
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SODPolicyApiListSodPolicies
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **state**: *eq*
     * @type {string}
     * @memberof SODPolicyApiListSodPolicies
     */
    readonly filters?: string
}

/**
 * Request parameters for patchSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiPatchSodPolicyRequest
 */
export interface SODPolicyApiPatchSodPolicyRequest {
    /**
     * The ID of the SOD policy being modified.
     * @type {string}
     * @memberof SODPolicyApiPatchSodPolicy
     */
    readonly id: string

    /**
     * A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria 
     * @type {Array<JsonPatchOperation>}
     * @memberof SODPolicyApiPatchSodPolicy
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for setPolicySchedule operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiSetPolicyScheduleRequest
 */
export interface SODPolicyApiSetPolicyScheduleRequest {
    /**
     * The ID of the SOD policy to update its schedule.
     * @type {string}
     * @memberof SODPolicyApiSetPolicySchedule
     */
    readonly id: string

    /**
     * 
     * @type {SodPolicySchedule}
     * @memberof SODPolicyApiSetPolicySchedule
     */
    readonly sodPolicySchedule: SodPolicySchedule
}

/**
 * Request parameters for setSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiSetSodPolicyRequest
 */
export interface SODPolicyApiSetSodPolicyRequest {
    /**
     * The ID of the SOD policy to update.
     * @type {string}
     * @memberof SODPolicyApiSetSodPolicy
     */
    readonly id: string

    /**
     * 
     * @type {SodPolicy}
     * @memberof SODPolicyApiSetSodPolicy
     */
    readonly sodPolicy: SodPolicy
}

/**
 * Request parameters for startEvaluateSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiStartEvaluateSodPolicyRequest
 */
export interface SODPolicyApiStartEvaluateSodPolicyRequest {
    /**
     * The SOD policy ID to run.
     * @type {string}
     * @memberof SODPolicyApiStartEvaluateSodPolicy
     */
    readonly id: string
}

/**
 * Request parameters for startSodAllPoliciesForOrg operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiStartSodAllPoliciesForOrgRequest
 */
export interface SODPolicyApiStartSodAllPoliciesForOrgRequest {
    /**
     * 
     * @type {MultiPolicyRequest}
     * @memberof SODPolicyApiStartSodAllPoliciesForOrg
     */
    readonly multiPolicyRequest?: MultiPolicyRequest
}

/**
 * Request parameters for startSodPolicy operation in SODPolicyApi.
 * @export
 * @interface SODPolicyApiStartSodPolicyRequest
 */
export interface SODPolicyApiStartSodPolicyRequest {
    /**
     * The SOD policy ID to run.
     * @type {string}
     * @memberof SODPolicyApiStartSodPolicy
     */
    readonly id: string
}

/**
 * SODPolicyApi - object-oriented interface
 * @export
 * @class SODPolicyApi
 * @extends {BaseAPI}
 */
export class SODPolicyApi extends BaseAPI {
    /**
     * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
     * @summary Create SOD policy
     * @param {SODPolicyApiCreateSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public createSodPolicy(requestParameters: SODPolicyApiCreateSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).createSodPolicy(requestParameters.sodPolicy, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Delete SOD policy by ID
     * @param {SODPolicyApiDeleteSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public deleteSodPolicy(requestParameters: SODPolicyApiDeleteSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).deleteSodPolicy(requestParameters.id, requestParameters.logical, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes schedule for a specified SOD policy by ID.
     * @summary Delete SOD policy schedule
     * @param {SODPolicyApiDeleteSodPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public deleteSodPolicySchedule(requestParameters: SODPolicyApiDeleteSodPolicyScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).deleteSodPolicySchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This allows to download a specified named violation report for a given report reference.
     * @summary Download custom violation report
     * @param {SODPolicyApiGetCustomViolationReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getCustomViolationReport(requestParameters: SODPolicyApiGetCustomViolationReportRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getCustomViolationReport(requestParameters.reportResultId, requestParameters.fileName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This allows to download a violation report for a given report reference.
     * @summary Download violation report
     * @param {SODPolicyApiGetDefaultViolationReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getDefaultViolationReport(requestParameters: SODPolicyApiGetDefaultViolationReportRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getDefaultViolationReport(requestParameters.reportResultId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets the status for a violation report for all policy run.
     * @summary Get multi-report run task status
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getSodAllReportRunStatus(axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getSodAllReportRunStatus(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Get SOD policy by ID
     * @param {SODPolicyApiGetSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getSodPolicy(requestParameters: SODPolicyApiGetSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets a specified SOD policy\'s schedule.
     * @summary Get SOD policy schedule
     * @param {SODPolicyApiGetSodPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getSodPolicySchedule(requestParameters: SODPolicyApiGetSodPolicyScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getSodPolicySchedule(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the status for a violation report run task that has already been invoked.
     * @summary Get violation report run status
     * @param {SODPolicyApiGetSodViolationReportRunStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getSodViolationReportRunStatus(requestParameters: SODPolicyApiGetSodViolationReportRunStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getSodViolationReportRunStatus(requestParameters.reportResultId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the status for a violation report run task that has already been invoked.
     * @summary Get SOD violation report status
     * @param {SODPolicyApiGetSodViolationReportStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public getSodViolationReportStatus(requestParameters: SODPolicyApiGetSodViolationReportStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).getSodViolationReportStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets list of all SOD policies. Requires role of ORG_ADMIN
     * @summary List SOD policies
     * @param {SODPolicyApiListSodPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public listSodPolicies(requestParameters: SODPolicyApiListSodPoliciesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).listSodPolicies(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception. 
     * @summary Patch SOD policy by ID
     * @param {SODPolicyApiPatchSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public patchSodPolicy(requestParameters: SODPolicyApiPatchSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).patchSodPolicy(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates schedule for a specified SOD policy.
     * @summary Update SOD Policy schedule
     * @param {SODPolicyApiSetPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public setPolicySchedule(requestParameters: SODPolicyApiSetPolicyScheduleRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).setPolicySchedule(requestParameters.id, requestParameters.sodPolicySchedule, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Update SOD policy by ID
     * @param {SODPolicyApiSetSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public setSodPolicy(requestParameters: SODPolicyApiSetSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).setSodPolicy(requestParameters.id, requestParameters.sodPolicy, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
     * @summary Evaluate one policy by ID
     * @param {SODPolicyApiStartEvaluateSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public startEvaluateSodPolicy(requestParameters: SODPolicyApiStartEvaluateSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).startEvaluateSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
     * @summary Runs all policies for org
     * @param {SODPolicyApiStartSodAllPoliciesForOrgRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public startSodAllPoliciesForOrg(requestParameters: SODPolicyApiStartSodAllPoliciesForOrgRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).startSodAllPoliciesForOrg(requestParameters.multiPolicyRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
     * @summary Runs SOD policy violation report
     * @param {SODPolicyApiStartSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPolicyApi
     */
    public startSodPolicy(requestParameters: SODPolicyApiStartSodPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SODPolicyApiFp(this.configuration).startSodPolicy(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SODViolationsApi - axios parameter creator
 * @export
 */
export const SODViolationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for identity.
         * @param {IdentityWithNewAccess} identityWithNewAccess 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startPredictSodViolations: async (identityWithNewAccess: IdentityWithNewAccess, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityWithNewAccess' is not null or undefined
            assertParamExists('startPredictSodViolations', 'identityWithNewAccess', identityWithNewAccess)
            const localVarPath = `/sod-violations/predict`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityWithNewAccess, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Check SOD violations
         * @param {IdentityWithNewAccess1} identityWithNewAccess1 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startViolationCheck: async (identityWithNewAccess1: IdentityWithNewAccess1, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityWithNewAccess1' is not null or undefined
            assertParamExists('startViolationCheck', 'identityWithNewAccess1', identityWithNewAccess1)
            const localVarPath = `/sod-violations/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityWithNewAccess1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SODViolationsApi - functional programming interface
 * @export
 */
export const SODViolationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SODViolationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for identity.
         * @param {IdentityWithNewAccess} identityWithNewAccess 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startPredictSodViolations(identityWithNewAccess: IdentityWithNewAccess, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViolationPrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startPredictSodViolations(identityWithNewAccess, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Check SOD violations
         * @param {IdentityWithNewAccess1} identityWithNewAccess1 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startViolationCheck(identityWithNewAccess1: IdentityWithNewAccess1, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SodViolationCheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startViolationCheck(identityWithNewAccess1, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SODViolationsApi - factory interface
 * @export
 */
export const SODViolationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SODViolationsApiFp(configuration)
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for identity.
         * @param {IdentityWithNewAccess} identityWithNewAccess 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startPredictSodViolations(identityWithNewAccess: IdentityWithNewAccess, axiosOptions?: any): AxiosPromise<ViolationPrediction> {
            return localVarFp.startPredictSodViolations(identityWithNewAccess, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Check SOD violations
         * @param {IdentityWithNewAccess1} identityWithNewAccess1 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startViolationCheck(identityWithNewAccess1: IdentityWithNewAccess1, axiosOptions?: any): AxiosPromise<SodViolationCheck> {
            return localVarFp.startViolationCheck(identityWithNewAccess1, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for startPredictSodViolations operation in SODViolationsApi.
 * @export
 * @interface SODViolationsApiStartPredictSodViolationsRequest
 */
export interface SODViolationsApiStartPredictSodViolationsRequest {
    /**
     * 
     * @type {IdentityWithNewAccess}
     * @memberof SODViolationsApiStartPredictSodViolations
     */
    readonly identityWithNewAccess: IdentityWithNewAccess
}

/**
 * Request parameters for startViolationCheck operation in SODViolationsApi.
 * @export
 * @interface SODViolationsApiStartViolationCheckRequest
 */
export interface SODViolationsApiStartViolationCheckRequest {
    /**
     * 
     * @type {IdentityWithNewAccess1}
     * @memberof SODViolationsApiStartViolationCheck
     */
    readonly identityWithNewAccess1: IdentityWithNewAccess1
}

/**
 * SODViolationsApi - object-oriented interface
 * @export
 * @class SODViolationsApi
 * @extends {BaseAPI}
 */
export class SODViolationsApi extends BaseAPI {
    /**
     * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Predict SOD violations for identity.
     * @param {SODViolationsApiStartPredictSodViolationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODViolationsApi
     */
    public startPredictSodViolations(requestParameters: SODViolationsApiStartPredictSodViolationsRequest, axiosOptions?: AxiosRequestConfig) {
        return SODViolationsApiFp(this.configuration).startPredictSodViolations(requestParameters.identityWithNewAccess, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
     * @summary Check SOD violations
     * @param {SODViolationsApiStartViolationCheckRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODViolationsApi
     */
    public startViolationCheck(requestParameters: SODViolationsApiStartViolationCheckRequest, axiosOptions?: AxiosRequestConfig) {
        return SODViolationsApiFp(this.configuration).startViolationCheck(requestParameters.identityWithNewAccess1, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SavedSearchApi - axios parameter creator
 * @export
 */
export const SavedSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {CreateSavedSearchRequest} createSavedSearchRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch: async (createSavedSearchRequest: CreateSavedSearchRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSavedSearchRequest' is not null or undefined
            assertParamExists('createSavedSearch', 'createSavedSearchRequest', createSavedSearchRequest)
            const localVarPath = `/saved-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSavedSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearch: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSavedSearch', 'id', id)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        executeSavedSearch: async (id: string, searchArguments: SearchArguments, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('executeSavedSearch', 'id', id)
            // verify required parameter 'searchArguments' is not null or undefined
            assertParamExists('executeSavedSearch', 'searchArguments', searchArguments)
            const localVarPath = `/saved-searches/{id}/execute`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchArguments, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified saved search. 
         * @summary Return saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearch: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSavedSearch', 'id', id)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of saved searches. 
         * @summary Return a list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *public*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns saved searches for the specified owner ID  &#x60;&#x60;&#x60;public eq true&#x60;&#x60;&#x60; -- returns all public saved searches  &#x60;&#x60;&#x60;owner.id eq me or public eq true&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s saved searches as well as all public saved searches belonging to other users in the current org 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSavedSearches: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saved-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
         * @summary Updates an existing saved search 
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSavedSearch: async (id: string, savedSearch: SavedSearch, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putSavedSearch', 'id', id)
            // verify required parameter 'savedSearch' is not null or undefined
            assertParamExists('putSavedSearch', 'savedSearch', savedSearch)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(savedSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SavedSearchApi - functional programming interface
 * @export
 */
export const SavedSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SavedSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {CreateSavedSearchRequest} createSavedSearchRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSavedSearch(createSavedSearchRequest: CreateSavedSearchRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSavedSearch(createSavedSearchRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSavedSearch(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSavedSearch(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async executeSavedSearch(id: string, searchArguments: SearchArguments, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSavedSearch(id, searchArguments, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the specified saved search. 
         * @summary Return saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedSearch(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedSearch(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of saved searches. 
         * @summary Return a list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *public*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns saved searches for the specified owner ID  &#x60;&#x60;&#x60;public eq true&#x60;&#x60;&#x60; -- returns all public saved searches  &#x60;&#x60;&#x60;owner.id eq me or public eq true&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s saved searches as well as all public saved searches belonging to other users in the current org 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSavedSearches(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SavedSearch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSavedSearches(offset, limit, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
         * @summary Updates an existing saved search 
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSavedSearch(id: string, savedSearch: SavedSearch, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSavedSearch(id, savedSearch, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SavedSearchApi - factory interface
 * @export
 */
export const SavedSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SavedSearchApiFp(configuration)
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {CreateSavedSearchRequest} createSavedSearchRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch(createSavedSearchRequest: CreateSavedSearchRequest, axiosOptions?: any): AxiosPromise<SavedSearch> {
            return localVarFp.createSavedSearch(createSavedSearchRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearch(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSavedSearch(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        executeSavedSearch(id: string, searchArguments: SearchArguments, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.executeSavedSearch(id, searchArguments, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified saved search. 
         * @summary Return saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearch(id: string, axiosOptions?: any): AxiosPromise<SavedSearch> {
            return localVarFp.getSavedSearch(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of saved searches. 
         * @summary Return a list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *public*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns saved searches for the specified owner ID  &#x60;&#x60;&#x60;public eq true&#x60;&#x60;&#x60; -- returns all public saved searches  &#x60;&#x60;&#x60;owner.id eq me or public eq true&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s saved searches as well as all public saved searches belonging to other users in the current org 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSavedSearches(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<SavedSearch>> {
            return localVarFp.listSavedSearches(offset, limit, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
         * @summary Updates an existing saved search 
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSavedSearch(id: string, savedSearch: SavedSearch, axiosOptions?: any): AxiosPromise<SavedSearch> {
            return localVarFp.putSavedSearch(id, savedSearch, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiCreateSavedSearchRequest
 */
export interface SavedSearchApiCreateSavedSearchRequest {
    /**
     * The saved search to persist.
     * @type {CreateSavedSearchRequest}
     * @memberof SavedSearchApiCreateSavedSearch
     */
    readonly createSavedSearchRequest: CreateSavedSearchRequest
}

/**
 * Request parameters for deleteSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiDeleteSavedSearchRequest
 */
export interface SavedSearchApiDeleteSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiDeleteSavedSearch
     */
    readonly id: string
}

/**
 * Request parameters for executeSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiExecuteSavedSearchRequest
 */
export interface SavedSearchApiExecuteSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiExecuteSavedSearch
     */
    readonly id: string

    /**
     * When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
     * @type {SearchArguments}
     * @memberof SavedSearchApiExecuteSavedSearch
     */
    readonly searchArguments: SearchArguments
}

/**
 * Request parameters for getSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiGetSavedSearchRequest
 */
export interface SavedSearchApiGetSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiGetSavedSearch
     */
    readonly id: string
}

/**
 * Request parameters for listSavedSearches operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiListSavedSearchesRequest
 */
export interface SavedSearchApiListSavedSearchesRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly count?: boolean

    /**
     * An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *public*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns saved searches for the specified owner ID  &#x60;&#x60;&#x60;public eq true&#x60;&#x60;&#x60; -- returns all public saved searches  &#x60;&#x60;&#x60;owner.id eq me or public eq true&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s saved searches as well as all public saved searches belonging to other users in the current org 
     * @type {string}
     * @memberof SavedSearchApiListSavedSearches
     */
    readonly filters?: string
}

/**
 * Request parameters for putSavedSearch operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiPutSavedSearchRequest
 */
export interface SavedSearchApiPutSavedSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiPutSavedSearch
     */
    readonly id: string

    /**
     * The saved search to persist.
     * @type {SavedSearch}
     * @memberof SavedSearchApiPutSavedSearch
     */
    readonly savedSearch: SavedSearch
}

/**
 * SavedSearchApi - object-oriented interface
 * @export
 * @class SavedSearchApi
 * @extends {BaseAPI}
 */
export class SavedSearchApi extends BaseAPI {
    /**
     * Creates a new saved search. 
     * @summary Create a saved search
     * @param {SavedSearchApiCreateSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public createSavedSearch(requestParameters: SavedSearchApiCreateSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).createSavedSearch(requestParameters.createSavedSearchRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified saved search. 
     * @summary Delete document by ID
     * @param {SavedSearchApiDeleteSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public deleteSavedSearch(requestParameters: SavedSearchApiDeleteSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).deleteSavedSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Executes the specified saved search. 
     * @summary Execute a saved search by ID
     * @param {SavedSearchApiExecuteSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public executeSavedSearch(requestParameters: SavedSearchApiExecuteSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).executeSavedSearch(requestParameters.id, requestParameters.searchArguments, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified saved search. 
     * @summary Return saved search by ID
     * @param {SavedSearchApiGetSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public getSavedSearch(requestParameters: SavedSearchApiGetSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).getSavedSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of saved searches. 
     * @summary Return a list of Saved Searches
     * @param {SavedSearchApiListSavedSearchesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public listSavedSearches(requestParameters: SavedSearchApiListSavedSearchesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).listSavedSearches(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.** 
     * @summary Updates an existing saved search 
     * @param {SavedSearchApiPutSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public putSavedSearch(requestParameters: SavedSearchApiPutSavedSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).putSavedSearch(requestParameters.id, requestParameters.savedSearch, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduledSearchApi - axios parameter creator
 * @export
 */
export const ScheduledSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {CreateScheduledSearchRequest} createScheduledSearchRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledSearch: async (createScheduledSearchRequest: CreateScheduledSearchRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createScheduledSearchRequest' is not null or undefined
            assertParamExists('createScheduledSearch', 'createScheduledSearchRequest', createScheduledSearchRequest)
            const localVarPath = `/scheduled-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScheduledSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledSearch: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteScheduledSearch', 'id', id)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledSearch: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getScheduledSearch', 'id', id)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *savedSearchId*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches for the specified owner ID  &#x60;&#x60;&#x60;savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches that reference the specified saved search  &#x60;&#x60;&#x60;owner.id eq me or savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s scheduled searches as well as all scheduled searches that reference the specified saved search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledSearch: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scheduled-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeScheduledSearch: async (id: string, typedReference: TypedReference, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unsubscribeScheduledSearch', 'id', id)
            // verify required parameter 'typedReference' is not null or undefined
            assertParamExists('unsubscribeScheduledSearch', 'typedReference', typedReference)
            const localVarPath = `/scheduled-searches/{id}/unsubscribe`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typedReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledSearch: async (id: string, scheduledSearch: ScheduledSearch, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateScheduledSearch', 'id', id)
            // verify required parameter 'scheduledSearch' is not null or undefined
            assertParamExists('updateScheduledSearch', 'scheduledSearch', scheduledSearch)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduledSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledSearchApi - functional programming interface
 * @export
 */
export const ScheduledSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduledSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {CreateScheduledSearchRequest} createScheduledSearchRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createScheduledSearch(createScheduledSearchRequest: CreateScheduledSearchRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScheduledSearch(createScheduledSearchRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScheduledSearch(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScheduledSearch(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduledSearch(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduledSearch(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *savedSearchId*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches for the specified owner ID  &#x60;&#x60;&#x60;savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches that reference the specified saved search  &#x60;&#x60;&#x60;owner.id eq me or savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s scheduled searches as well as all scheduled searches that reference the specified saved search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listScheduledSearch(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduledSearch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScheduledSearch(offset, limit, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribeScheduledSearch(id: string, typedReference: TypedReference, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribeScheduledSearch(id, typedReference, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateScheduledSearch(id: string, scheduledSearch: ScheduledSearch, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScheduledSearch(id, scheduledSearch, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScheduledSearchApi - factory interface
 * @export
 */
export const ScheduledSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduledSearchApiFp(configuration)
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {CreateScheduledSearchRequest} createScheduledSearchRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledSearch(createScheduledSearchRequest: CreateScheduledSearchRequest, axiosOptions?: any): AxiosPromise<ScheduledSearch> {
            return localVarFp.createScheduledSearch(createScheduledSearchRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledSearch(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteScheduledSearch(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledSearch(id: string, axiosOptions?: any): AxiosPromise<ScheduledSearch> {
            return localVarFp.getScheduledSearch(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *savedSearchId*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches for the specified owner ID  &#x60;&#x60;&#x60;savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches that reference the specified saved search  &#x60;&#x60;&#x60;owner.id eq me or savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s scheduled searches as well as all scheduled searches that reference the specified saved search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledSearch(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<ScheduledSearch>> {
            return localVarFp.listScheduledSearch(offset, limit, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeScheduledSearch(id: string, typedReference: TypedReference, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.unsubscribeScheduledSearch(id, typedReference, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledSearch(id: string, scheduledSearch: ScheduledSearch, axiosOptions?: any): AxiosPromise<ScheduledSearch> {
            return localVarFp.updateScheduledSearch(id, scheduledSearch, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiCreateScheduledSearchRequest
 */
export interface ScheduledSearchApiCreateScheduledSearchRequest {
    /**
     * The scheduled search to persist.
     * @type {CreateScheduledSearchRequest}
     * @memberof ScheduledSearchApiCreateScheduledSearch
     */
    readonly createScheduledSearchRequest: CreateScheduledSearchRequest
}

/**
 * Request parameters for deleteScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiDeleteScheduledSearchRequest
 */
export interface ScheduledSearchApiDeleteScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiDeleteScheduledSearch
     */
    readonly id: string
}

/**
 * Request parameters for getScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiGetScheduledSearchRequest
 */
export interface ScheduledSearchApiGetScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiGetScheduledSearch
     */
    readonly id: string
}

/**
 * Request parameters for listScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiListScheduledSearchRequest
 */
export interface ScheduledSearchApiListScheduledSearchRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly count?: boolean

    /**
     * An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *savedSearchId*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches for the specified owner ID  &#x60;&#x60;&#x60;savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches that reference the specified saved search  &#x60;&#x60;&#x60;owner.id eq me or savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s scheduled searches as well as all scheduled searches that reference the specified saved search 
     * @type {string}
     * @memberof ScheduledSearchApiListScheduledSearch
     */
    readonly filters?: string
}

/**
 * Request parameters for unsubscribeScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiUnsubscribeScheduledSearchRequest
 */
export interface ScheduledSearchApiUnsubscribeScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiUnsubscribeScheduledSearch
     */
    readonly id: string

    /**
     * The recipient to be removed from the scheduled search. 
     * @type {TypedReference}
     * @memberof ScheduledSearchApiUnsubscribeScheduledSearch
     */
    readonly typedReference: TypedReference
}

/**
 * Request parameters for updateScheduledSearch operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiUpdateScheduledSearchRequest
 */
export interface ScheduledSearchApiUpdateScheduledSearchRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiUpdateScheduledSearch
     */
    readonly id: string

    /**
     * The scheduled search to persist.
     * @type {ScheduledSearch}
     * @memberof ScheduledSearchApiUpdateScheduledSearch
     */
    readonly scheduledSearch: ScheduledSearch
}

/**
 * ScheduledSearchApi - object-oriented interface
 * @export
 * @class ScheduledSearchApi
 * @extends {BaseAPI}
 */
export class ScheduledSearchApi extends BaseAPI {
    /**
     * Creates a new scheduled search. 
     * @summary Create a new scheduled search
     * @param {ScheduledSearchApiCreateScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public createScheduledSearch(requestParameters: ScheduledSearchApiCreateScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).createScheduledSearch(requestParameters.createScheduledSearchRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified scheduled search. 
     * @summary Delete a Scheduled Search
     * @param {ScheduledSearchApiDeleteScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public deleteScheduledSearch(requestParameters: ScheduledSearchApiDeleteScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).deleteScheduledSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified scheduled search.
     * @summary Get a Scheduled Search
     * @param {ScheduledSearchApiGetScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public getScheduledSearch(requestParameters: ScheduledSearchApiGetScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).getScheduledSearch(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of scheduled searches. 
     * @summary List scheduled searches
     * @param {ScheduledSearchApiListScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public listScheduledSearch(requestParameters: ScheduledSearchApiListScheduledSearchRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).listScheduledSearch(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unsubscribes a recipient from the specified scheduled search. 
     * @summary Unsubscribe a recipient from Scheduled Search
     * @param {ScheduledSearchApiUnsubscribeScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public unsubscribeScheduledSearch(requestParameters: ScheduledSearchApiUnsubscribeScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).unsubscribeScheduledSearch(requestParameters.id, requestParameters.typedReference, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing scheduled search. 
     * @summary Update an existing Scheduled Search
     * @param {ScheduledSearchApiUpdateScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public updateScheduledSearch(requestParameters: ScheduledSearchApiUpdateScheduledSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).updateScheduledSearch(requestParameters.id, requestParameters.scheduledSearch, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchAggregate: async (search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchAggregate', 'search', search)
            const localVarPath = `/search/aggregate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchCount: async (search: Search, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchCount', 'search', search)
            const localVarPath = `/search/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *accounts*, *aggregations*, *entitlements*, *events*, *identities*, and *roles*. 
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchGet: async (index: string, id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('searchGet', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('searchGet', 'id', id)
            const localVarPath = `/search/{index}/{id}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform Search
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPost: async (search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchPost', 'search', search)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchAggregate(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AggregationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAggregate(search, offset, limit, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchCount(search: Search, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCount(search, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *accounts*, *aggregations*, *entitlements*, *events*, *identities*, and *roles*. 
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchGet(index: string, id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGet(index, id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform Search
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchPost(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchDocument>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPost(search, offset, limit, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchAggregate(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: any): AxiosPromise<AggregationResult> {
            return localVarFp.searchAggregate(search, offset, limit, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchCount(search: Search, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.searchCount(search, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *accounts*, *aggregations*, *entitlements*, *events*, *identities*, and *roles*. 
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchGet(index: string, id: string, axiosOptions?: any): AxiosPromise<SearchDocument> {
            return localVarFp.searchGet(index, id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform Search
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPost(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<SearchDocument>> {
            return localVarFp.searchPost(search, offset, limit, count, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for searchAggregate operation in SearchApi.
 * @export
 * @interface SearchApiSearchAggregateRequest
 */
export interface SearchApiSearchAggregateRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchAggregate
     */
    readonly search: Search

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchAggregate
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchAggregate
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SearchApiSearchAggregate
     */
    readonly count?: boolean
}

/**
 * Request parameters for searchCount operation in SearchApi.
 * @export
 * @interface SearchApiSearchCountRequest
 */
export interface SearchApiSearchCountRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchCount
     */
    readonly search: Search
}

/**
 * Request parameters for searchGet operation in SearchApi.
 * @export
 * @interface SearchApiSearchGetRequest
 */
export interface SearchApiSearchGetRequest {
    /**
     * The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *accounts*, *aggregations*, *entitlements*, *events*, *identities*, and *roles*. 
     * @type {string}
     * @memberof SearchApiSearchGet
     */
    readonly index: string

    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SearchApiSearchGet
     */
    readonly id: string
}

/**
 * Request parameters for searchPost operation in SearchApi.
 * @export
 * @interface SearchApiSearchPostRequest
 */
export interface SearchApiSearchPostRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchPost
     */
    readonly search: Search

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchPost
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchPost
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SearchApiSearchPost
     */
    readonly count?: boolean
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
     * @summary Perform a Search Query Aggregation
     * @param {SearchApiSearchAggregateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchAggregate(requestParameters: SearchApiSearchAggregateRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchAggregate(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
     * @summary Count Documents Satisfying a Query
     * @param {SearchApiSearchCountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchCount(requestParameters: SearchApiSearchCountRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchCount(requestParameters.search, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a single document from the specified index, using the specified document ID.
     * @summary Get a Document by ID
     * @param {SearchApiSearchGetRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchGet(requestParameters: SearchApiSearchGetRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchGet(requestParameters.index, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
     * @summary Perform Search
     * @param {SearchApiSearchPostRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchPost(requestParameters: SearchApiSearchPostRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchPost(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SegmentsApi - axios parameter creator
 * @export
 */
export const SegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a segment.  Note that segment definitions may take time to propagate to all identities.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {Segment} segment 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSegment: async (segment: Segment, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segment' is not null or undefined
            assertParamExists('createSegment', 'segment', segment)
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API deletes the segment specified by the given ID.  Note that segment deletion may take some time to become effective.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The ID of the Segment to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSegment', 'id', id)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the segment specified by the given ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get a Segment by ID
         * @param {string} id The ID of the Segment to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSegment', 'id', id)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all segments. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSegments: async (limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Allows updating Segment fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Note that changes to a segment may take some time to propagate to all identities, and that segments will have no effect if segmentation is not enabled for your org.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update a Segment
         * @param {string} id The ID of the Segment being modified.
         * @param {Array<object>} requestBody A list of Segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.   The following fields are patchable: * name * description * owner * visibilityCriteria * active 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment: async (id: string, requestBody: Array<object>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchSegment', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('patchSegment', 'requestBody', requestBody)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a segment.  Note that segment definitions may take time to propagate to all identities.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {Segment} segment 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSegment(segment: Segment, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSegment(segment, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API deletes the segment specified by the given ID.  Note that segment deletion may take some time to become effective.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The ID of the Segment to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSegment(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSegment(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the segment specified by the given ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get a Segment by ID
         * @param {string} id The ID of the Segment to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSegment(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegment(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of all segments. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSegments(limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Segment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSegments(limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows updating Segment fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Note that changes to a segment may take some time to propagate to all identities, and that segments will have no effect if segmentation is not enabled for your org.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update a Segment
         * @param {string} id The ID of the Segment being modified.
         * @param {Array<object>} requestBody A list of Segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.   The following fields are patchable: * name * description * owner * visibilityCriteria * active 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSegment(id: string, requestBody: Array<object>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSegment(id, requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsApiFp(configuration)
    return {
        /**
         * This API creates a segment.  Note that segment definitions may take time to propagate to all identities.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {Segment} segment 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSegment(segment: Segment, axiosOptions?: any): AxiosPromise<Segment> {
            return localVarFp.createSegment(segment, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API deletes the segment specified by the given ID.  Note that segment deletion may take some time to become effective.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The ID of the Segment to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSegment(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the segment specified by the given ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get a Segment by ID
         * @param {string} id The ID of the Segment to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSegment(id: string, axiosOptions?: any): AxiosPromise<Segment> {
            return localVarFp.getSegment(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all segments. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSegments(limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<Segment>> {
            return localVarFp.listSegments(limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating Segment fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Note that changes to a segment may take some time to propagate to all identities, and that segments will have no effect if segmentation is not enabled for your org.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update a Segment
         * @param {string} id The ID of the Segment being modified.
         * @param {Array<object>} requestBody A list of Segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.   The following fields are patchable: * name * description * owner * visibilityCriteria * active 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment(id: string, requestBody: Array<object>, axiosOptions?: any): AxiosPromise<Segment> {
            return localVarFp.patchSegment(id, requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiCreateSegmentRequest
 */
export interface SegmentsApiCreateSegmentRequest {
    /**
     * 
     * @type {Segment}
     * @memberof SegmentsApiCreateSegment
     */
    readonly segment: Segment
}

/**
 * Request parameters for deleteSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiDeleteSegmentRequest
 */
export interface SegmentsApiDeleteSegmentRequest {
    /**
     * The ID of the Segment to delete.
     * @type {string}
     * @memberof SegmentsApiDeleteSegment
     */
    readonly id: string
}

/**
 * Request parameters for getSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiGetSegmentRequest
 */
export interface SegmentsApiGetSegmentRequest {
    /**
     * The ID of the Segment to retrieve.
     * @type {string}
     * @memberof SegmentsApiGetSegment
     */
    readonly id: string
}

/**
 * Request parameters for listSegments operation in SegmentsApi.
 * @export
 * @interface SegmentsApiListSegmentsRequest
 */
export interface SegmentsApiListSegmentsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SegmentsApiListSegments
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SegmentsApiListSegments
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SegmentsApiListSegments
     */
    readonly count?: boolean
}

/**
 * Request parameters for patchSegment operation in SegmentsApi.
 * @export
 * @interface SegmentsApiPatchSegmentRequest
 */
export interface SegmentsApiPatchSegmentRequest {
    /**
     * The ID of the Segment being modified.
     * @type {string}
     * @memberof SegmentsApiPatchSegment
     */
    readonly id: string

    /**
     * A list of Segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.   The following fields are patchable: * name * description * owner * visibilityCriteria * active 
     * @type {Array<object>}
     * @memberof SegmentsApiPatchSegment
     */
    readonly requestBody: Array<object>
}

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
    /**
     * This API creates a segment.  Note that segment definitions may take time to propagate to all identities.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Create Segment
     * @param {SegmentsApiCreateSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public createSegment(requestParameters: SegmentsApiCreateSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).createSegment(requestParameters.segment, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API deletes the segment specified by the given ID.  Note that segment deletion may take some time to become effective.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Delete Segment by ID
     * @param {SegmentsApiDeleteSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public deleteSegment(requestParameters: SegmentsApiDeleteSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).deleteSegment(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the segment specified by the given ID.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Get a Segment by ID
     * @param {SegmentsApiGetSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegment(requestParameters: SegmentsApiGetSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegment(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all segments. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary List Segments
     * @param {SegmentsApiListSegmentsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public listSegments(requestParameters: SegmentsApiListSegmentsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).listSegments(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating Segment fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Note that changes to a segment may take some time to propagate to all identities, and that segments will have no effect if segmentation is not enabled for your org.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Update a Segment
     * @param {SegmentsApiPatchSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public patchSegment(requestParameters: SegmentsApiPatchSegmentRequest, axiosOptions?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).patchSegment(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceDeskIntegrationApi - axios parameter creator
 * @export
 */
export const ServiceDeskIntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration: async (serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceDeskIntegrationDto' is not null or undefined
            assertParamExists('createServiceDeskIntegration', 'serviceDeskIntegrationDto', serviceDeskIntegrationDto)
            const localVarPath = `/service-desk-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceDeskIntegrationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteServiceDeskIntegration', 'id', id)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getServiceDeskIntegration', 'id', id)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate: async (scriptName: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getServiceDeskIntegrationTemplate', 'scriptName', scriptName)
            const localVarPath = `/service-desk-integrations/templates/{scriptName}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrations: async (offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations/status-check-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {JsonPatch} jsonPatch A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   * &#x60;beforeProvisioningRule&#x60;   * &#x60;description&#x60;   * &#x60;ownerRef&#x60;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration: async (id: string, jsonPatch: JsonPatch, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchServiceDeskIntegration', 'id', id)
            // verify required parameter 'jsonPatch' is not null or undefined
            assertParamExists('patchServiceDeskIntegration', 'jsonPatch', jsonPatch)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putServiceDeskIntegration: async (id: string, serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putServiceDeskIntegration', 'id', id)
            // verify required parameter 'serviceDeskIntegrationDto' is not null or undefined
            assertParamExists('putServiceDeskIntegration', 'serviceDeskIntegrationDto', serviceDeskIntegrationDto)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceDeskIntegrationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails: async (queuedCheckConfigDetails: QueuedCheckConfigDetails, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queuedCheckConfigDetails' is not null or undefined
            assertParamExists('updateStatusCheckDetails', 'queuedCheckConfigDetails', queuedCheckConfigDetails)
            const localVarPath = `/service-desk-integrations/status-check-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queuedCheckConfigDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceDeskIntegrationApi - functional programming interface
 * @export
 */
export const ServiceDeskIntegrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceDeskIntegrationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceDeskIntegration(serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceDeskIntegration(serviceDeskIntegrationDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceDeskIntegration(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceDeskIntegration(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegration(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegration(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationTemplate(scriptName: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationTemplate(scriptName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationTypes(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDeskIntegrationTemplateType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationTypes(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrations(offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDeskIntegrationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrations(offset, limit, sorters, filters, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusCheckDetails(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedCheckConfigDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusCheckDetails(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {JsonPatch} jsonPatch A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   * &#x60;beforeProvisioningRule&#x60;   * &#x60;description&#x60;   * &#x60;ownerRef&#x60;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchServiceDeskIntegration(id: string, jsonPatch: JsonPatch, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchServiceDeskIntegration(id, jsonPatch, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putServiceDeskIntegration(id: string, serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putServiceDeskIntegration(id, serviceDeskIntegrationDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatusCheckDetails(queuedCheckConfigDetails: QueuedCheckConfigDetails, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedCheckConfigDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatusCheckDetails(queuedCheckConfigDetails, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceDeskIntegrationApi - factory interface
 * @export
 */
export const ServiceDeskIntegrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceDeskIntegrationApiFp(configuration)
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration(serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.createServiceDeskIntegration(serviceDeskIntegrationDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteServiceDeskIntegration(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration(id: string, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.getServiceDeskIntegration(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate(scriptName: string, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationTemplateDto> {
            return localVarFp.getServiceDeskIntegrationTemplate(scriptName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes(axiosOptions?: any): AxiosPromise<Array<ServiceDeskIntegrationTemplateType>> {
            return localVarFp.getServiceDeskIntegrationTypes(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrations(offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions?: any): AxiosPromise<Array<ServiceDeskIntegrationDto>> {
            return localVarFp.getServiceDeskIntegrations(offset, limit, sorters, filters, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails(axiosOptions?: any): AxiosPromise<QueuedCheckConfigDetails> {
            return localVarFp.getStatusCheckDetails(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {JsonPatch} jsonPatch A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   * &#x60;beforeProvisioningRule&#x60;   * &#x60;description&#x60;   * &#x60;ownerRef&#x60;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration(id: string, jsonPatch: JsonPatch, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.patchServiceDeskIntegration(id, jsonPatch, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putServiceDeskIntegration(id: string, serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.putServiceDeskIntegration(id, serviceDeskIntegrationDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails(queuedCheckConfigDetails: QueuedCheckConfigDetails, axiosOptions?: any): AxiosPromise<QueuedCheckConfigDetails> {
            return localVarFp.updateStatusCheckDetails(queuedCheckConfigDetails, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest {
    /**
     * The specifics of a new integration to create
     * @type {ServiceDeskIntegrationDto}
     * @memberof ServiceDeskIntegrationApiCreateServiceDeskIntegration
     */
    readonly serviceDeskIntegrationDto: ServiceDeskIntegrationDto
}

/**
 * Request parameters for deleteServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest {
    /**
     * ID of Service Desk integration to delete
     * @type {string}
     * @memberof ServiceDeskIntegrationApiDeleteServiceDeskIntegration
     */
    readonly id: string
}

/**
 * Request parameters for getServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to get
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegration
     */
    readonly id: string
}

/**
 * Request parameters for getServiceDeskIntegrationTemplate operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest {
    /**
     * The scriptName value of the Service Desk integration template to get
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplate
     */
    readonly scriptName: string
}

/**
 * Request parameters for getServiceDeskIntegrations operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly limit?: number

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly filters?: string

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrations
     */
    readonly count?: boolean
}

/**
 * Request parameters for patchServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to update
     * @type {string}
     * @memberof ServiceDeskIntegrationApiPatchServiceDeskIntegration
     */
    readonly id: string

    /**
     * A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   * &#x60;beforeProvisioningRule&#x60;   * &#x60;description&#x60;   * &#x60;ownerRef&#x60;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
     * @type {JsonPatch}
     * @memberof ServiceDeskIntegrationApiPatchServiceDeskIntegration
     */
    readonly jsonPatch: JsonPatch
}

/**
 * Request parameters for putServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to update
     * @type {string}
     * @memberof ServiceDeskIntegrationApiPutServiceDeskIntegration
     */
    readonly id: string

    /**
     * The specifics of the integration to update
     * @type {ServiceDeskIntegrationDto}
     * @memberof ServiceDeskIntegrationApiPutServiceDeskIntegration
     */
    readonly serviceDeskIntegrationDto: ServiceDeskIntegrationDto
}

/**
 * Request parameters for updateStatusCheckDetails operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest
 */
export interface ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest {
    /**
     * the modified time check configuration
     * @type {QueuedCheckConfigDetails}
     * @memberof ServiceDeskIntegrationApiUpdateStatusCheckDetails
     */
    readonly queuedCheckConfigDetails: QueuedCheckConfigDetails
}

/**
 * ServiceDeskIntegrationApi - object-oriented interface
 * @export
 * @class ServiceDeskIntegrationApi
 * @extends {BaseAPI}
 */
export class ServiceDeskIntegrationApi extends BaseAPI {
    /**
     * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Create new Service Desk integration
     * @param {ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public createServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).createServiceDeskIntegration(requestParameters.serviceDeskIntegrationDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Delete a Service Desk integration
     * @param {ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public deleteServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).deleteServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Get a Service Desk integration
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Service Desk integration template by scriptName.
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrationTemplate(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrationTemplate(requestParameters.scriptName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Service Desk Integration Types List.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrationTypes(axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrationTypes(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary List existing Service Desk Integrations
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrations(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrations(requestParameters.offset, requestParameters.limit, requestParameters.sorters, requestParameters.filters, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Get the time check configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getStatusCheckDetails(axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getStatusCheckDetails(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing ServiceDeskIntegration by ID with a PATCH request.
     * @summary Service Desk Integration Update PATCH
     * @param {ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public patchServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).patchServiceDeskIntegration(requestParameters.id, requestParameters.jsonPatch, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Update a Service Desk integration
     * @param {ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public putServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).putServiceDeskIntegration(requestParameters.id, requestParameters.serviceDeskIntegrationDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Update the time check configuration
     * @param {ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public updateStatusCheckDetails(requestParameters: ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).updateStatusCheckDetails(requestParameters.queuedCheckConfigDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SourcesApi - axios parameter creator
 * @export
 */
export const SourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy: async (sourceId: string, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('createProvisioningPolicy', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source 
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource: async (source: Source, provisionAsCsv?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('createSource', 'source', source)
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (provisionAsCsv !== undefined) {
                localVarQueryParameter['provisionAsCsv'] = provisionAsCsv;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(source, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Schema on the specified Source in IdentityNow. 
         * @summary Create Schema on a Source
         * @param {string} sourceId The Source id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSourceSchema: async (sourceId: string, schema: Schema, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schema' is not null or undefined
            assertParamExists('createSourceSchema', 'schema', schema)
            const localVarPath = `/sources/{sourceId}/schemas`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy: async (sourceId: string, usageType: UsageType, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('deleteProvisioningPolicy', 'usageType', usageType)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSource', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceSchema: async (sourceId: string, schemaId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('deleteSourceSchema', 'schemaId', schemaId)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsSchema: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementsSchema: async (id: string, schemaName?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEntitlementsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (schemaName !== undefined) {
                localVarQueryParameter['schemaName'] = schemaName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy: async (sourceId: string, usageType: UsageType, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('getProvisioningPolicy', 'usageType', usageType)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSource', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceHealth: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceHealth', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/source-health`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchema: async (sourceId: string, schemaId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('getSourceSchema', 'schemaId', schemaId)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importAccountsSchema: async (id: string, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importAccountsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importConnectorFile: async (sourceId: string, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('importConnectorFile', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/upload-connector-file`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importEntitlementsSchema: async (id: string, schemaName?: string, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importEntitlementsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (schemaName !== undefined) {
                localVarQueryParameter['schemaName'] = schemaName;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('listProvisioningPolicies', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/provisioning-policies`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Lists the Schemas that exist on the specified Source in IdentityNow. 
         * @summary List Schemas on a Source
         * @param {string} sourceId The Source ID.
         * @param {string} [includeTypes] If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSourceSchemas: async (sourceId: string, includeTypes?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('listSourceSchemas', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/schemas`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (includeTypes !== undefined) {
                localVarQueryParameter['include-types'] = includeTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:   **id**: *eq, in*   **name**: *co, eq, in, sw*   **type**: *eq, in*   **owner.id**: *eq, in*   **features**: *ca, co*   **created**: *eq*   **modified**: *eq*   **managementWorkgroup.id**: *eq*   **description**: *eq*   **authoritative**: *eq*   **healthy**: *eq*   **status**: *eq, in*   **connectionType**: *eq*   **connectorName**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putProvisioningPolicy: async (sourceId: string, usageType: UsageType, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'usageType', usageType)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('putProvisioningPolicy', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id The Source id
         * @param {Source} source 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSource: async (id: string, source: Source, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putSource', 'id', id)
            // verify required parameter 'source' is not null or undefined
            assertParamExists('putSource', 'source', source)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(source, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceSchema: async (sourceId: string, schemaId: string, schema: Schema, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('putSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('putSourceSchema', 'schemaId', schemaId)
            // verify required parameter 'schema' is not null or undefined
            assertParamExists('putSourceSchema', 'schema', schema)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPoliciesInBulk: async (sourceId: string, provisioningPolicyDto: Array<ProvisioningPolicyDto>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateProvisioningPoliciesInBulk', 'sourceId', sourceId)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('updateProvisioningPoliciesInBulk', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/bulk-update`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy: async (sourceId: string, usageType: UsageType, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'usageType', usageType)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSource', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateSource', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceSchema: async (sourceId: string, schemaId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateSourceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('updateSourceSchema', 'schemaId', schemaId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateSourceSchema', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesApi - functional programming interface
 * @export
 */
export const SourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createProvisioningPolicy(sourceId: string, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProvisioningPolicy(sourceId, provisioningPolicyDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source 
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSource(source: Source, provisionAsCsv?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSource(source, provisionAsCsv, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Schema on the specified Source in IdentityNow. 
         * @summary Create Schema on a Source
         * @param {string} sourceId The Source id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSourceSchema(sourceId: string, schema: Schema, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSourceSchema(sourceId, schema, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProvisioningPolicy(sourceId, usageType, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteSource202Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSourceSchema(sourceId: string, schemaId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSourceSchema(sourceId, schemaId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsSchema(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsSchema(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitlementsSchema(id: string, schemaName?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitlementsSchema(id, schemaName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProvisioningPolicy(sourceId, usageType, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSource(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSource(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceHealth(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceHealthDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceHealth(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceSchema(sourceId: string, schemaId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceSchema(sourceId, schemaId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importAccountsSchema(id: string, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importAccountsSchema(id, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importConnectorFile(sourceId: string, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importConnectorFile(sourceId, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importEntitlementsSchema(id: string, schemaName?: string, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importEntitlementsSchema(id, schemaName, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listProvisioningPolicies(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProvisioningPolicyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProvisioningPolicies(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the Schemas that exist on the specified Source in IdentityNow. 
         * @summary List Schemas on a Source
         * @param {string} sourceId The Source ID.
         * @param {string} [includeTypes] If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceSchemas(sourceId: string, includeTypes?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSourceSchemas(sourceId, includeTypes, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:   **id**: *eq, in*   **name**: *co, eq, in, sw*   **type**: *eq, in*   **owner.id**: *eq, in*   **features**: *ca, co*   **created**: *eq*   **modified**: *eq*   **managementWorkgroup.id**: *eq*   **description**: *eq*   **authoritative**: *eq*   **healthy**: *eq*   **status**: *eq, in*   **connectionType**: *eq*   **connectorName**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSources(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Source>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSources(limit, offset, count, filters, sorters, forSubadmin, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putProvisioningPolicy(sourceId: string, usageType: UsageType, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProvisioningPolicy(sourceId, usageType, provisioningPolicyDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id The Source id
         * @param {Source} source 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSource(id: string, source: Source, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSource(id, source, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putSourceSchema(sourceId: string, schemaId: string, schema: Schema, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSourceSchema(sourceId, schemaId, schema, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateProvisioningPoliciesInBulk(sourceId: string, provisioningPolicyDto: Array<ProvisioningPolicyDto>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProvisioningPolicyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProvisioningPoliciesInBulk(sourceId, provisioningPolicyDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateProvisioningPolicy(sourceId: string, usageType: UsageType, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProvisioningPolicy(sourceId, usageType, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSource(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSource(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSourceSchema(sourceId: string, schemaId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSourceSchema(sourceId, schemaId, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SourcesApi - factory interface
 * @export
 */
export const SourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourcesApiFp(configuration)
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy(sourceId: string, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.createProvisioningPolicy(sourceId, provisioningPolicyDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source 
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource(source: Source, provisionAsCsv?: boolean, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.createSource(source, provisionAsCsv, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Schema on the specified Source in IdentityNow. 
         * @summary Create Schema on a Source
         * @param {string} sourceId The Source id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSourceSchema(sourceId: string, schema: Schema, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.createSourceSchema(sourceId, schema, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteProvisioningPolicy(sourceId, usageType, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(id: string, axiosOptions?: any): AxiosPromise<DeleteSource202Response> {
            return localVarFp.deleteSource(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceSchema(sourceId: string, schemaId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSourceSchema(sourceId, schemaId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsSchema(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getAccountsSchema(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementsSchema(id: string, schemaName?: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getEntitlementsSchema(id, schemaName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.getProvisioningPolicy(sourceId, usageType, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource(id: string, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.getSource(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceHealth(sourceId: string, axiosOptions?: any): AxiosPromise<SourceHealthDto> {
            return localVarFp.getSourceHealth(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchema(sourceId: string, schemaId: string, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.getSourceSchema(sourceId, schemaId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importAccountsSchema(id: string, file?: any, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.importAccountsSchema(id, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importConnectorFile(sourceId: string, file?: any, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.importConnectorFile(sourceId, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importEntitlementsSchema(id: string, schemaName?: string, file?: any, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.importEntitlementsSchema(id, schemaName, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies(sourceId: string, axiosOptions?: any): AxiosPromise<Array<ProvisioningPolicyDto>> {
            return localVarFp.listProvisioningPolicies(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Lists the Schemas that exist on the specified Source in IdentityNow. 
         * @summary List Schemas on a Source
         * @param {string} sourceId The Source ID.
         * @param {string} [includeTypes] If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSourceSchemas(sourceId: string, includeTypes?: string, axiosOptions?: any): AxiosPromise<Array<Schema>> {
            return localVarFp.listSourceSchemas(sourceId, includeTypes, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:   **id**: *eq, in*   **name**: *co, eq, in, sw*   **type**: *eq, in*   **owner.id**: *eq, in*   **features**: *ca, co*   **created**: *eq*   **modified**: *eq*   **managementWorkgroup.id**: *eq*   **description**: *eq*   **authoritative**: *eq*   **healthy**: *eq*   **status**: *eq, in*   **connectionType**: *eq*   **connectorName**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions?: any): AxiosPromise<Array<Source>> {
            return localVarFp.listSources(limit, offset, count, filters, sorters, forSubadmin, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putProvisioningPolicy(sourceId: string, usageType: UsageType, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.putProvisioningPolicy(sourceId, usageType, provisioningPolicyDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id The Source id
         * @param {Source} source 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSource(id: string, source: Source, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.putSource(id, source, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceSchema(sourceId: string, schemaId: string, schema: Schema, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.putSourceSchema(sourceId, schemaId, schema, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPoliciesInBulk(sourceId: string, provisioningPolicyDto: Array<ProvisioningPolicyDto>, axiosOptions?: any): AxiosPromise<Array<ProvisioningPolicyDto>> {
            return localVarFp.updateProvisioningPoliciesInBulk(sourceId, provisioningPolicyDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy(sourceId: string, usageType: UsageType, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.updateProvisioningPolicy(sourceId, usageType, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.updateSource(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceSchema(sourceId: string, schemaId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.updateSourceSchema(sourceId, schemaId, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateProvisioningPolicyRequest
 */
export interface SourcesApiCreateProvisioningPolicyRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiCreateProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * 
     * @type {ProvisioningPolicyDto}
     * @memberof SourcesApiCreateProvisioningPolicy
     */
    readonly provisioningPolicyDto: ProvisioningPolicyDto
}

/**
 * Request parameters for createSource operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateSourceRequest
 */
export interface SourcesApiCreateSourceRequest {
    /**
     * 
     * @type {Source}
     * @memberof SourcesApiCreateSource
     */
    readonly source: Source

    /**
     * If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.  
     * @type {boolean}
     * @memberof SourcesApiCreateSource
     */
    readonly provisionAsCsv?: boolean
}

/**
 * Request parameters for createSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateSourceSchemaRequest
 */
export interface SourcesApiCreateSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiCreateSourceSchema
     */
    readonly sourceId: string

    /**
     * 
     * @type {Schema}
     * @memberof SourcesApiCreateSourceSchema
     */
    readonly schema: Schema
}

/**
 * Request parameters for deleteProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteProvisioningPolicyRequest
 */
export interface SourcesApiDeleteProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiDeleteProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of ProvisioningPolicy usage.
     * @type {UsageType}
     * @memberof SourcesApiDeleteProvisioningPolicy
     */
    readonly usageType: UsageType
}

/**
 * Request parameters for deleteSource operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteSourceRequest
 */
export interface SourcesApiDeleteSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiDeleteSource
     */
    readonly id: string
}

/**
 * Request parameters for deleteSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteSourceSchemaRequest
 */
export interface SourcesApiDeleteSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiDeleteSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiDeleteSourceSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for getAccountsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiGetAccountsSchemaRequest
 */
export interface SourcesApiGetAccountsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiGetAccountsSchema
     */
    readonly id: string
}

/**
 * Request parameters for getEntitlementsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiGetEntitlementsSchemaRequest
 */
export interface SourcesApiGetEntitlementsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiGetEntitlementsSchema
     */
    readonly id: string

    /**
     * Name of entitlement schema
     * @type {string}
     * @memberof SourcesApiGetEntitlementsSchema
     */
    readonly schemaName?: string
}

/**
 * Request parameters for getProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiGetProvisioningPolicyRequest
 */
export interface SourcesApiGetProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiGetProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of ProvisioningPolicy usage.
     * @type {UsageType}
     * @memberof SourcesApiGetProvisioningPolicy
     */
    readonly usageType: UsageType
}

/**
 * Request parameters for getSource operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceRequest
 */
export interface SourcesApiGetSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiGetSource
     */
    readonly id: string
}

/**
 * Request parameters for getSourceHealth operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceHealthRequest
 */
export interface SourcesApiGetSourceHealthRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiGetSourceHealth
     */
    readonly sourceId: string
}

/**
 * Request parameters for getSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceSchemaRequest
 */
export interface SourcesApiGetSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiGetSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiGetSourceSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for importAccountsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiImportAccountsSchemaRequest
 */
export interface SourcesApiImportAccountsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiImportAccountsSchema
     */
    readonly id: string

    /**
     * 
     * @type {any}
     * @memberof SourcesApiImportAccountsSchema
     */
    readonly file?: any
}

/**
 * Request parameters for importConnectorFile operation in SourcesApi.
 * @export
 * @interface SourcesApiImportConnectorFileRequest
 */
export interface SourcesApiImportConnectorFileRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiImportConnectorFile
     */
    readonly sourceId: string

    /**
     * 
     * @type {any}
     * @memberof SourcesApiImportConnectorFile
     */
    readonly file?: any
}

/**
 * Request parameters for importEntitlementsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiImportEntitlementsSchemaRequest
 */
export interface SourcesApiImportEntitlementsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiImportEntitlementsSchema
     */
    readonly id: string

    /**
     * Name of entitlement schema
     * @type {string}
     * @memberof SourcesApiImportEntitlementsSchema
     */
    readonly schemaName?: string

    /**
     * 
     * @type {any}
     * @memberof SourcesApiImportEntitlementsSchema
     */
    readonly file?: any
}

/**
 * Request parameters for listProvisioningPolicies operation in SourcesApi.
 * @export
 * @interface SourcesApiListProvisioningPoliciesRequest
 */
export interface SourcesApiListProvisioningPoliciesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiListProvisioningPolicies
     */
    readonly sourceId: string
}

/**
 * Request parameters for listSourceSchemas operation in SourcesApi.
 * @export
 * @interface SourcesApiListSourceSchemasRequest
 */
export interface SourcesApiListSourceSchemasRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiListSourceSchemas
     */
    readonly sourceId: string

    /**
     * If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
     * @type {string}
     * @memberof SourcesApiListSourceSchemas
     */
    readonly includeTypes?: string
}

/**
 * Request parameters for listSources operation in SourcesApi.
 * @export
 * @interface SourcesApiListSourcesRequest
 */
export interface SourcesApiListSourcesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourcesApiListSources
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourcesApiListSources
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SourcesApiListSources
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators:   **id**: *eq, in*   **name**: *co, eq, in, sw*   **type**: *eq, in*   **owner.id**: *eq, in*   **features**: *ca, co*   **created**: *eq*   **modified**: *eq*   **managementWorkgroup.id**: *eq*   **description**: *eq*   **authoritative**: *eq*   **healthy**: *eq*   **status**: *eq, in*   **connectionType**: *eq*   **connectorName**: *eq*
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status**
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly sorters?: string

    /**
     * Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly forSubadmin?: string
}

/**
 * Request parameters for putProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiPutProvisioningPolicyRequest
 */
export interface SourcesApiPutProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiPutProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of ProvisioningPolicy usage.
     * @type {UsageType}
     * @memberof SourcesApiPutProvisioningPolicy
     */
    readonly usageType: UsageType

    /**
     * 
     * @type {ProvisioningPolicyDto}
     * @memberof SourcesApiPutProvisioningPolicy
     */
    readonly provisioningPolicyDto: ProvisioningPolicyDto
}

/**
 * Request parameters for putSource operation in SourcesApi.
 * @export
 * @interface SourcesApiPutSourceRequest
 */
export interface SourcesApiPutSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiPutSource
     */
    readonly id: string

    /**
     * 
     * @type {Source}
     * @memberof SourcesApiPutSource
     */
    readonly source: Source
}

/**
 * Request parameters for putSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiPutSourceSchemaRequest
 */
export interface SourcesApiPutSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiPutSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiPutSourceSchema
     */
    readonly schemaId: string

    /**
     * 
     * @type {Schema}
     * @memberof SourcesApiPutSourceSchema
     */
    readonly schema: Schema
}

/**
 * Request parameters for updateProvisioningPoliciesInBulk operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateProvisioningPoliciesInBulkRequest
 */
export interface SourcesApiUpdateProvisioningPoliciesInBulkRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateProvisioningPoliciesInBulk
     */
    readonly sourceId: string

    /**
     * 
     * @type {Array<ProvisioningPolicyDto>}
     * @memberof SourcesApiUpdateProvisioningPoliciesInBulk
     */
    readonly provisioningPolicyDto: Array<ProvisioningPolicyDto>
}

/**
 * Request parameters for updateProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateProvisioningPolicyRequest
 */
export interface SourcesApiUpdateProvisioningPolicyRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of ProvisioningPolicy usage.
     * @type {UsageType}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly usageType: UsageType

    /**
     * The JSONPatch payload used to update the schema.
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for updateSource operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateSourceRequest
 */
export interface SourcesApiUpdateSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiUpdateSource
     */
    readonly id: string

    /**
     * A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateSource
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for updateSourceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateSourceSchemaRequest
 */
export interface SourcesApiUpdateSourceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateSourceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiUpdateSourceSchema
     */
    readonly schemaId: string

    /**
     * The JSONPatch payload used to update the schema.
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateSourceSchema
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * SourcesApi - object-oriented interface
 * @export
 * @class SourcesApi
 * @extends {BaseAPI}
 */
export class SourcesApi extends BaseAPI {
    /**
     * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Provisioning Policy
     * @param {SourcesApiCreateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createProvisioningPolicy(requestParameters: SourcesApiCreateProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createProvisioningPolicy(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Creates a source in IdentityNow.
     * @param {SourcesApiCreateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createSource(requestParameters: SourcesApiCreateSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createSource(requestParameters.source, requestParameters.provisionAsCsv, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Schema on the specified Source in IdentityNow. 
     * @summary Create Schema on a Source
     * @param {SourcesApiCreateSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createSourceSchema(requestParameters: SourcesApiCreateSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createSourceSchema(requestParameters.sourceId, requestParameters.schema, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Delete Provisioning Policy by UsageType
     * @param {SourcesApiDeleteProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteProvisioningPolicy(requestParameters: SourcesApiDeleteProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
     * @summary Delete Source by ID
     * @param {SourcesApiDeleteSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteSource(requestParameters: SourcesApiDeleteSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteSource(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Source Schema by ID
     * @param {SourcesApiDeleteSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteSourceSchema(requestParameters: SourcesApiDeleteSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Downloads source accounts schema template
     * @param {SourcesApiGetAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getAccountsSchema(requestParameters: SourcesApiGetAccountsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getAccountsSchema(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Downloads source entitlements schema template
     * @param {SourcesApiGetEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getEntitlementsSchema(requestParameters: SourcesApiGetEntitlementsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getEntitlementsSchema(requestParameters.id, requestParameters.schemaName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get Provisioning Policy by UsageType
     * @param {SourcesApiGetProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getProvisioningPolicy(requestParameters: SourcesApiGetProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get Source by ID
     * @param {SourcesApiGetSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSource(requestParameters: SourcesApiGetSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSource(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint fetches source health by source\'s id
     * @summary Fetches source health by id
     * @param {SourcesApiGetSourceHealthRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourceHealth(requestParameters: SourcesApiGetSourceHealthRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSourceHealth(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Source Schema by ID in IdentityNow. 
     * @summary Get Source Schema by ID
     * @param {SourcesApiGetSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourceSchema(requestParameters: SourcesApiGetSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Uploads source accounts schema template
     * @param {SourcesApiImportAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public importAccountsSchema(requestParameters: SourcesApiImportAccountsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).importAccountsSchema(requestParameters.id, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
     * @summary Upload connector file to source
     * @param {SourcesApiImportConnectorFileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public importConnectorFile(requestParameters: SourcesApiImportConnectorFileRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).importConnectorFile(requestParameters.sourceId, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Uploads source entitlements schema template
     * @param {SourcesApiImportEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public importEntitlementsSchema(requestParameters: SourcesApiImportEntitlementsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).importEntitlementsSchema(requestParameters.id, requestParameters.schemaName, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Lists ProvisioningPolicies
     * @param {SourcesApiListProvisioningPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listProvisioningPolicies(requestParameters: SourcesApiListProvisioningPoliciesRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).listProvisioningPolicies(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the Schemas that exist on the specified Source in IdentityNow. 
     * @summary List Schemas on a Source
     * @param {SourcesApiListSourceSchemasRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listSourceSchemas(requestParameters: SourcesApiListSourceSchemasRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).listSourceSchemas(requestParameters.sourceId, requestParameters.includeTypes, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
     * @summary Lists all sources in IdentityNow.
     * @param {SourcesApiListSourcesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listSources(requestParameters: SourcesApiListSourcesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).listSources(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSubadmin, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Update Provisioning Policy by UsageType
     * @param {SourcesApiPutProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public putProvisioningPolicy(requestParameters: SourcesApiPutProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).putProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
     * @summary Update Source (Full)
     * @param {SourcesApiPutSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public putSource(requestParameters: SourcesApiPutSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).putSource(requestParameters.id, requestParameters.source, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
     * @summary Update Source Schema (Full)
     * @param {SourcesApiPutSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public putSourceSchema(requestParameters: SourcesApiPutSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).putSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.schema, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Bulk Update Provisioning Policies
     * @param {SourcesApiUpdateProvisioningPoliciesInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateProvisioningPoliciesInBulk(requestParameters: SourcesApiUpdateProvisioningPoliciesInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateProvisioningPoliciesInBulk(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Partial update of Provisioning Policy
     * @param {SourcesApiUpdateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateProvisioningPolicy(requestParameters: SourcesApiUpdateProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
     * @summary Update Source (Partial)
     * @param {SourcesApiUpdateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateSource(requestParameters: SourcesApiUpdateSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateSource(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
     * @summary Update Source Schema (Partial)
     * @param {SourcesApiUpdateSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateSourceSchema(requestParameters: SourcesApiUpdateSourceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaggedObjectsApi - axios parameter creator
 * @export
 */
export const TaggedObjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaggedObject: async (type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTaggedObject', 'id', id)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ROLE, IDENTITY and SOD_POLICY.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsToManyObject: async (bulkTaggedObject: BulkTaggedObject, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkTaggedObject' is not null or undefined
            assertParamExists('deleteTagsToManyObject', 'bulkTaggedObject', bulkTaggedObject)
            const localVarPath = `/tagged-objects/bulk-remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkTaggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTaggedObject: async (type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaggedObject', 'id', id)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjects: async (limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tagged-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjectsByType: async (type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('listTaggedObjectsByType', 'type', type)
            const localVarPath = `/tagged-objects/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTaggedObject: async (type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, taggedObject: TaggedObject, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('putTaggedObject', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putTaggedObject', 'id', id)
            // verify required parameter 'taggedObject' is not null or undefined
            assertParamExists('putTaggedObject', 'taggedObject', taggedObject)
            const localVarPath = `/tagged-objects/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagToObject: async (taggedObject: TaggedObject, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taggedObject' is not null or undefined
            assertParamExists('setTagToObject', 'taggedObject', taggedObject)
            const localVarPath = `/tagged-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ROLE, IDENTITY and SOD_POLICY.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagsToManyObjects: async (bulkTaggedObject: BulkTaggedObject, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkTaggedObject' is not null or undefined
            assertParamExists('setTagsToManyObjects', 'bulkTaggedObject', bulkTaggedObject)
            const localVarPath = `/tagged-objects/bulk-add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkTaggedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaggedObjectsApi - functional programming interface
 * @export
 */
export const TaggedObjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaggedObjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaggedObject(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaggedObject(type, id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ROLE, IDENTITY and SOD_POLICY.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTagsToManyObject(bulkTaggedObject: BulkTaggedObject, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTagsToManyObject(bulkTaggedObject, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTaggedObject(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggedObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaggedObject(type, id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTaggedObjects(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaggedObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTaggedObjects(limit, offset, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTaggedObjectsByType(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaggedObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTaggedObjectsByType(type, limit, offset, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putTaggedObject(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, taggedObject: TaggedObject, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggedObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTaggedObject(type, id, taggedObject, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setTagToObject(taggedObject: TaggedObject, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTagToObject(taggedObject, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ROLE, IDENTITY and SOD_POLICY.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setTagsToManyObjects(bulkTaggedObject: BulkTaggedObject, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkTaggedObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTagsToManyObjects(bulkTaggedObject, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaggedObjectsApi - factory interface
 * @export
 */
export const TaggedObjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaggedObjectsApiFp(configuration)
    return {
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaggedObject(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteTaggedObject(type, id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ROLE, IDENTITY and SOD_POLICY.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsToManyObject(bulkTaggedObject: BulkTaggedObject, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteTagsToManyObject(bulkTaggedObject, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTaggedObject(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, axiosOptions?: any): AxiosPromise<TaggedObject> {
            return localVarFp.getTaggedObject(type, id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjects(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<TaggedObject>> {
            return localVarFp.listTaggedObjects(limit, offset, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjectsByType(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<TaggedObject>> {
            return localVarFp.listTaggedObjectsByType(type, limit, offset, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {'ROLE' | 'IDENTITY' | 'SOD_POLICY'} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTaggedObject(type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY', id: string, taggedObject: TaggedObject, axiosOptions?: any): AxiosPromise<TaggedObject> {
            return localVarFp.putTaggedObject(type, id, taggedObject, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObject} taggedObject 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagToObject(taggedObject: TaggedObject, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.setTagToObject(taggedObject, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkTaggedObject} bulkTaggedObject Supported object types are ROLE, IDENTITY and SOD_POLICY.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagsToManyObjects(bulkTaggedObject: BulkTaggedObject, axiosOptions?: any): AxiosPromise<BulkTaggedObject> {
            return localVarFp.setTagsToManyObjects(bulkTaggedObject, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteTaggedObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiDeleteTaggedObjectRequest
 */
export interface TaggedObjectsApiDeleteTaggedObjectRequest {
    /**
     * The type of tagged object to delete.
     * @type {'ROLE' | 'IDENTITY' | 'SOD_POLICY'}
     * @memberof TaggedObjectsApiDeleteTaggedObject
     */
    readonly type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY'

    /**
     * The ID of the object reference to delete.
     * @type {string}
     * @memberof TaggedObjectsApiDeleteTaggedObject
     */
    readonly id: string
}

/**
 * Request parameters for deleteTagsToManyObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiDeleteTagsToManyObjectRequest
 */
export interface TaggedObjectsApiDeleteTagsToManyObjectRequest {
    /**
     * Supported object types are ROLE, IDENTITY and SOD_POLICY.
     * @type {BulkTaggedObject}
     * @memberof TaggedObjectsApiDeleteTagsToManyObject
     */
    readonly bulkTaggedObject: BulkTaggedObject
}

/**
 * Request parameters for getTaggedObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiGetTaggedObjectRequest
 */
export interface TaggedObjectsApiGetTaggedObjectRequest {
    /**
     * The type of tagged object to retrieve.
     * @type {'ROLE' | 'IDENTITY' | 'SOD_POLICY'}
     * @memberof TaggedObjectsApiGetTaggedObject
     */
    readonly type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY'

    /**
     * The ID of the object reference to retrieve.
     * @type {string}
     * @memberof TaggedObjectsApiGetTaggedObject
     */
    readonly id: string
}

/**
 * Request parameters for listTaggedObjects operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiListTaggedObjectsRequest
 */
export interface TaggedObjectsApiListTaggedObjectsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
     * @type {string}
     * @memberof TaggedObjectsApiListTaggedObjects
     */
    readonly filters?: string
}

/**
 * Request parameters for listTaggedObjectsByType operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiListTaggedObjectsByTypeRequest
 */
export interface TaggedObjectsApiListTaggedObjectsByTypeRequest {
    /**
     * The type of tagged object to retrieve.
     * @type {'ROLE' | 'IDENTITY' | 'SOD_POLICY'}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY'

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
     * @type {string}
     * @memberof TaggedObjectsApiListTaggedObjectsByType
     */
    readonly filters?: string
}

/**
 * Request parameters for putTaggedObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiPutTaggedObjectRequest
 */
export interface TaggedObjectsApiPutTaggedObjectRequest {
    /**
     * The type of tagged object to update.
     * @type {'ROLE' | 'IDENTITY' | 'SOD_POLICY'}
     * @memberof TaggedObjectsApiPutTaggedObject
     */
    readonly type: 'ROLE' | 'IDENTITY' | 'SOD_POLICY'

    /**
     * The ID of the object reference to update.
     * @type {string}
     * @memberof TaggedObjectsApiPutTaggedObject
     */
    readonly id: string

    /**
     * 
     * @type {TaggedObject}
     * @memberof TaggedObjectsApiPutTaggedObject
     */
    readonly taggedObject: TaggedObject
}

/**
 * Request parameters for setTagToObject operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiSetTagToObjectRequest
 */
export interface TaggedObjectsApiSetTagToObjectRequest {
    /**
     * 
     * @type {TaggedObject}
     * @memberof TaggedObjectsApiSetTagToObject
     */
    readonly taggedObject: TaggedObject
}

/**
 * Request parameters for setTagsToManyObjects operation in TaggedObjectsApi.
 * @export
 * @interface TaggedObjectsApiSetTagsToManyObjectsRequest
 */
export interface TaggedObjectsApiSetTagsToManyObjectsRequest {
    /**
     * Supported object types are ROLE, IDENTITY and SOD_POLICY.
     * @type {BulkTaggedObject}
     * @memberof TaggedObjectsApiSetTagsToManyObjects
     */
    readonly bulkTaggedObject: BulkTaggedObject
}

/**
 * TaggedObjectsApi - object-oriented interface
 * @export
 * @class TaggedObjectsApi
 * @extends {BaseAPI}
 */
export class TaggedObjectsApi extends BaseAPI {
    /**
     * This deletes a tagged object for the specified type.
     * @summary Delete Tagged Object
     * @param {TaggedObjectsApiDeleteTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public deleteTaggedObject(requestParameters: TaggedObjectsApiDeleteTaggedObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).deleteTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Remove Tags from Multiple Objects
     * @param {TaggedObjectsApiDeleteTagsToManyObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public deleteTagsToManyObject(requestParameters: TaggedObjectsApiDeleteTagsToManyObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).deleteTagsToManyObject(requestParameters.bulkTaggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a tagged object for the specified type.
     * @summary Get Tagged Object
     * @param {TaggedObjectsApiGetTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public getTaggedObject(requestParameters: TaggedObjectsApiGetTaggedObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).getTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
     * @summary List Tagged Objects
     * @param {TaggedObjectsApiListTaggedObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public listTaggedObjects(requestParameters: TaggedObjectsApiListTaggedObjectsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).listTaggedObjects(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
     * @summary List Tagged Objects
     * @param {TaggedObjectsApiListTaggedObjectsByTypeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public listTaggedObjectsByType(requestParameters: TaggedObjectsApiListTaggedObjectsByTypeRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).listTaggedObjectsByType(requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This updates a tagged object for the specified type.
     * @summary Update Tagged Object
     * @param {TaggedObjectsApiPutTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public putTaggedObject(requestParameters: TaggedObjectsApiPutTaggedObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).putTaggedObject(requestParameters.type, requestParameters.id, requestParameters.taggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This adds a tag to an object.  Any authenticated token may be used to call this API.
     * @summary Add Tag to Object
     * @param {TaggedObjectsApiSetTagToObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public setTagToObject(requestParameters: TaggedObjectsApiSetTagToObjectRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).setTagToObject(requestParameters.taggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Tag Multiple Objects
     * @param {TaggedObjectsApiSetTagsToManyObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    public setTagsToManyObjects(requestParameters: TaggedObjectsApiSetTagsToManyObjectsRequest, axiosOptions?: AxiosRequestConfig) {
        return TaggedObjectsApiFp(this.configuration).setTagsToManyObjects(requestParameters.bulkTaggedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransformsApi - axios parameter creator
 * @export
 */
export const TransformsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform: async (transform: Transform, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transform' is not null or undefined
            assertParamExists('createTransform', 'transform', transform)
            const localVarPath = `/transforms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transform, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **internal**: *eq* **name**: *eq*, *sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTransforms: async (offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transforms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object (must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform: async (id: string, transform?: Transform, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transform, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransformsApi - functional programming interface
 * @export
 */
export const TransformsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransformsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createTransform(transform: Transform, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransform(transform, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransform(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransform(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTransform(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransform(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **internal**: *eq* **name**: *eq*, *sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listTransforms(offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transform>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransforms(offset, limit, count, name, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object (must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransform(id: string, transform?: Transform, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransform(id, transform, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransformsApi - factory interface
 * @export
 */
export const TransformsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransformsApiFp(configuration)
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform(transform: Transform, axiosOptions?: any): AxiosPromise<Transform> {
            return localVarFp.createTransform(transform, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteTransform(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform(id: string, axiosOptions?: any): AxiosPromise<Transform> {
            return localVarFp.getTransform(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **internal**: *eq* **name**: *eq*, *sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTransforms(offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<Transform>> {
            return localVarFp.listTransforms(offset, limit, count, name, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object (must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform(id: string, transform?: Transform, axiosOptions?: any): AxiosPromise<Transform> {
            return localVarFp.updateTransform(id, transform, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiCreateTransformRequest
 */
export interface TransformsApiCreateTransformRequest {
    /**
     * The transform to be created.
     * @type {Transform}
     * @memberof TransformsApiCreateTransform
     */
    readonly transform: Transform
}

/**
 * Request parameters for deleteTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiDeleteTransformRequest
 */
export interface TransformsApiDeleteTransformRequest {
    /**
     * ID of the transform to delete
     * @type {string}
     * @memberof TransformsApiDeleteTransform
     */
    readonly id: string
}

/**
 * Request parameters for getTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiGetTransformRequest
 */
export interface TransformsApiGetTransformRequest {
    /**
     * ID of the transform to retrieve
     * @type {string}
     * @memberof TransformsApiGetTransform
     */
    readonly id: string
}

/**
 * Request parameters for listTransforms operation in TransformsApi.
 * @export
 * @interface TransformsApiListTransformsRequest
 */
export interface TransformsApiListTransformsRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TransformsApiListTransforms
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TransformsApiListTransforms
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TransformsApiListTransforms
     */
    readonly count?: boolean

    /**
     * Name of the transform to retrieve from the list.
     * @type {string}
     * @memberof TransformsApiListTransforms
     */
    readonly name?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **internal**: *eq* **name**: *eq*, *sw*
     * @type {string}
     * @memberof TransformsApiListTransforms
     */
    readonly filters?: string
}

/**
 * Request parameters for updateTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiUpdateTransformRequest
 */
export interface TransformsApiUpdateTransformRequest {
    /**
     * ID of the transform to update
     * @type {string}
     * @memberof TransformsApiUpdateTransform
     */
    readonly id: string

    /**
     * The updated transform object (must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields).
     * @type {Transform}
     * @memberof TransformsApiUpdateTransform
     */
    readonly transform?: Transform
}

/**
 * TransformsApi - object-oriented interface
 * @export
 * @class TransformsApi
 * @extends {BaseAPI}
 */
export class TransformsApi extends BaseAPI {
    /**
     * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
     * @summary Create transform
     * @param {TransformsApiCreateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public createTransform(requestParameters: TransformsApiCreateTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).createTransform(requestParameters.transform, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
     * @summary Delete a transform
     * @param {TransformsApiDeleteTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public deleteTransform(requestParameters: TransformsApiDeleteTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).deleteTransform(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
     * @summary Transform by ID
     * @param {TransformsApiGetTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public getTransform(requestParameters: TransformsApiGetTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).getTransform(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
     * @summary List transforms
     * @param {TransformsApiListTransformsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public listTransforms(requestParameters: TransformsApiListTransformsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).listTransforms(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.name, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
     * @summary Update a transform
     * @param {TransformsApiUpdateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public updateTransform(requestParameters: TransformsApiUpdateTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).updateTransform(requestParameters.id, requestParameters.transform, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkItemsApi - axios parameter creator
 * @export
 */
export const WorkItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem: async (id: string, approvalItemId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveApprovalItem', 'id', id)
            // verify required parameter 'approvalItemId' is not null or undefined
            assertParamExists('approveApprovalItem', 'approvalItemId', approvalItemId)
            const localVarPath = `/work-items/{id}/approve/{approvalItemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"approvalItemId"}}`, encodeURIComponent(String(approvalItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItemsInBulk: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveApprovalItemsInBulk', 'id', id)
            const localVarPath = `/work-items/bulk-approve/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeWorkItem', 'id', id)
            const localVarPath = `/work-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCompletedWorkItems: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountCompletedWorkItems: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/completed/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountWorkItems: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItem: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkItem', 'id', id)
            const localVarPath = `/work-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsSummary: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems: async (limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem: async (id: string, approvalItemId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectApprovalItem', 'id', id)
            // verify required parameter 'approvalItemId' is not null or undefined
            assertParamExists('rejectApprovalItem', 'approvalItemId', approvalItemId)
            const localVarPath = `/work-items/{id}/reject/{approvalItemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"approvalItemId"}}`, encodeURIComponent(String(approvalItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItemsInBulk: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectApprovalItemsInBulk', 'id', id)
            const localVarPath = `/work-items/bulk-reject/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection: async (id: string, requestBody: { [key: string]: any; }, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitAccountSelection', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('submitAccountSelection', 'requestBody', requestBody)
            const localVarPath = `/work-items/{id}/submit-account-selection`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkItemsApi - functional programming interface
 * @export
 */
export const WorkItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveApprovalItem(id: string, approvalItemId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveApprovalItem(id, approvalItemId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveApprovalItemsInBulk(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveApprovalItemsInBulk(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async completeWorkItem(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeWorkItem(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCompletedWorkItems(ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItems>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompletedWorkItems(ownerId, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCountCompletedWorkItems(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountCompletedWorkItems(ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCountWorkItems(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountWorkItems(ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItem(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItem(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItemsSummary(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItemsSummary(ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkItems(limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItems>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkItems(limit, offset, count, ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectApprovalItem(id: string, approvalItemId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectApprovalItem(id, approvalItemId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectApprovalItemsInBulk(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectApprovalItemsInBulk(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async submitAccountSelection(id: string, requestBody: { [key: string]: any; }, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitAccountSelection(id, requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkItemsApi - factory interface
 * @export
 */
export const WorkItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkItemsApiFp(configuration)
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem(id: string, approvalItemId: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.approveApprovalItem(id, approvalItemId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItemsInBulk(id: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.approveApprovalItemsInBulk(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem(id: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.completeWorkItem(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCompletedWorkItems(ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<WorkItems>> {
            return localVarFp.getCompletedWorkItems(ownerId, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountCompletedWorkItems(ownerId?: string, axiosOptions?: any): AxiosPromise<WorkItemsCount> {
            return localVarFp.getCountCompletedWorkItems(ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountWorkItems(ownerId?: string, axiosOptions?: any): AxiosPromise<WorkItemsCount> {
            return localVarFp.getCountWorkItems(ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItem(id: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.getWorkItem(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsSummary(ownerId?: string, axiosOptions?: any): AxiosPromise<WorkItemsSummary> {
            return localVarFp.getWorkItemsSummary(ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems(limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions?: any): AxiosPromise<Array<WorkItems>> {
            return localVarFp.listWorkItems(limit, offset, count, ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem(id: string, approvalItemId: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.rejectApprovalItem(id, approvalItemId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItemsInBulk(id: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.rejectApprovalItemsInBulk(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection(id: string, requestBody: { [key: string]: any; }, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.submitAccountSelection(id, requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveApprovalItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiApproveApprovalItemRequest
 */
export interface WorkItemsApiApproveApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItem
     */
    readonly id: string

    /**
     * The ID of the approval item.
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItem
     */
    readonly approvalItemId: string
}

/**
 * Request parameters for approveApprovalItemsInBulk operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiApproveApprovalItemsInBulkRequest
 */
export interface WorkItemsApiApproveApprovalItemsInBulkRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItemsInBulk
     */
    readonly id: string
}

/**
 * Request parameters for completeWorkItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiCompleteWorkItemRequest
 */
export interface WorkItemsApiCompleteWorkItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiCompleteWorkItem
     */
    readonly id: string
}

/**
 * Request parameters for getCompletedWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetCompletedWorkItemsRequest
 */
export interface WorkItemsApiGetCompletedWorkItemsRequest {
    /**
     * The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
     * @type {string}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkItemsApiGetCompletedWorkItems
     */
    readonly count?: boolean
}

/**
 * Request parameters for getCountCompletedWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetCountCompletedWorkItemsRequest
 */
export interface WorkItemsApiGetCountCompletedWorkItemsRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiGetCountCompletedWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for getCountWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetCountWorkItemsRequest
 */
export interface WorkItemsApiGetCountWorkItemsRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiGetCountWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for getWorkItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetWorkItemRequest
 */
export interface WorkItemsApiGetWorkItemRequest {
    /**
     * ID of the work item.
     * @type {string}
     * @memberof WorkItemsApiGetWorkItem
     */
    readonly id: string
}

/**
 * Request parameters for getWorkItemsSummary operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetWorkItemsSummaryRequest
 */
export interface WorkItemsApiGetWorkItemsSummaryRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiGetWorkItemsSummary
     */
    readonly ownerId?: string
}

/**
 * Request parameters for listWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiListWorkItemsRequest
 */
export interface WorkItemsApiListWorkItemsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly count?: boolean

    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for rejectApprovalItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiRejectApprovalItemRequest
 */
export interface WorkItemsApiRejectApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItem
     */
    readonly id: string

    /**
     * The ID of the approval item.
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItem
     */
    readonly approvalItemId: string
}

/**
 * Request parameters for rejectApprovalItemsInBulk operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiRejectApprovalItemsInBulkRequest
 */
export interface WorkItemsApiRejectApprovalItemsInBulkRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItemsInBulk
     */
    readonly id: string
}

/**
 * Request parameters for submitAccountSelection operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiSubmitAccountSelectionRequest
 */
export interface WorkItemsApiSubmitAccountSelectionRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiSubmitAccountSelection
     */
    readonly id: string

    /**
     * Account Selection Data map, keyed on fieldName
     * @type {{ [key: string]: any; }}
     * @memberof WorkItemsApiSubmitAccountSelection
     */
    readonly requestBody: { [key: string]: any; }
}

/**
 * WorkItemsApi - object-oriented interface
 * @export
 * @class WorkItemsApi
 * @extends {BaseAPI}
 */
export class WorkItemsApi extends BaseAPI {
    /**
     * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Approve an Approval Item
     * @param {WorkItemsApiApproveApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public approveApprovalItem(requestParameters: WorkItemsApiApproveApprovalItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).approveApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk approve Approval Items
     * @param {WorkItemsApiApproveApprovalItemsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public approveApprovalItemsInBulk(requestParameters: WorkItemsApiApproveApprovalItemsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).approveApprovalItemsInBulk(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API completes a work item. Either an admin, or the owning/current user must make this request.
     * @summary Complete a Work Item
     * @param {WorkItemsApiCompleteWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public completeWorkItem(requestParameters: WorkItemsApiCompleteWorkItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).completeWorkItem(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Completed Work Items
     * @param {WorkItemsApiGetCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getCompletedWorkItems(requestParameters: WorkItemsApiGetCompletedWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getCompletedWorkItems(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Completed Work Items
     * @param {WorkItemsApiGetCountCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getCountCompletedWorkItems(requestParameters: WorkItemsApiGetCountCompletedWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getCountCompletedWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a count of work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Work Items
     * @param {WorkItemsApiGetCountWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getCountWorkItems(requestParameters: WorkItemsApiGetCountWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getCountWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
     * @summary Get a Work Item
     * @param {WorkItemsApiGetWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getWorkItem(requestParameters: WorkItemsApiGetWorkItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getWorkItem(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
     * @summary Work Items Summary
     * @param {WorkItemsApiGetWorkItemsSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getWorkItemsSummary(requestParameters: WorkItemsApiGetWorkItemsSummaryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getWorkItemsSummary(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
     * @summary List Work Items
     * @param {WorkItemsApiListWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public listWorkItems(requestParameters: WorkItemsApiListWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).listWorkItems(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Reject an Approval Item
     * @param {WorkItemsApiRejectApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public rejectApprovalItem(requestParameters: WorkItemsApiRejectApprovalItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).rejectApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk reject Approval Items
     * @param {WorkItemsApiRejectApprovalItemsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public rejectApprovalItemsInBulk(requestParameters: WorkItemsApiRejectApprovalItemsInBulkRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).rejectApprovalItemsInBulk(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits account selections. Either an admin, or the owning/current user must make this request.
     * @summary Submit Account Selections
     * @param {WorkItemsApiSubmitAccountSelectionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public submitAccountSelection(requestParameters: WorkItemsApiSubmitAccountSelectionRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).submitAccountSelection(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


